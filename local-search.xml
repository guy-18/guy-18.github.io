<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用kubebuilder实现一个operator</title>
    <link href="/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/"/>
    <url>/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://qingwave.github.io/how-to-write-a-k8s-operator/">https://qingwave.github.io/how-to-write-a-k8s-operator/</a></p><p>Kubernetes 提供了众多的扩展功能，比如 CRD、CRI、CSI 等等，强大的扩展功能让 k8s 迅速占领市场。<a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/">Operator</a>模式可以实现 CRD 并管理自定义资源的生命周期，本文基于<a href="https://kubebuilder.io/">kubebuilder</a>快速实现一个 Operator，示例源码见<a href="https://github.com/qingwave/mygame">mygame</a>。</p><h2 id="Kubebuilder"><a href="#Kubebuilder" class="headerlink" title="Kubebuilder"></a>Kubebuilder</h2><p><code>kubebuilder</code>是一个官方提供快速实现 Operator 的工具包，可快速生成 k8s 的 CRD、Controller、Webhook，用户只需要实现业务逻辑。</p><blockquote><p>类似工具还有<a href="https://sdk.operatorframework.io/">operader-sdk</a>，目前正在与<code>Kubebuilder</code>融合</p></blockquote><p>kubebuilder 封装了<code>controller-runtime</code>与<code>controller-tools</code>，通过<code>controller-gen</code>来生产代码，简化了用户创建 Operator 的步骤。</p><p>一般创建 Operator 流程如下：</p><ol><li>创建工作目录，初始化项目</li><li>创建 API，填充字段</li><li>创建 Controller，编写核心协调逻辑(Reconcile)</li><li>创建 Webhook，实现接口，可选</li><li>验证测试</li><li>发布到集群中</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们准备创建一个 2048 的游戏，对外可以提供服务，也能方便地扩缩容。</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>首先你需要有 Kubernetes、Docker、Golang 相关环境。 Linux 下安装 kubebuilder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/$(go <span class="hljs-built_in">env</span> GOOS)/$(go <span class="hljs-built_in">env</span> GOARCH)<br><span class="hljs-built_in">chmod</span> +x kubebuilder &amp;&amp; <span class="hljs-built_in">mv</span> kubebuilder /usr/local/bin/<br></code></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mkdir -<span class="hljs-selector-tag">p</span> ~/work/mygame &amp;&amp; cd $_<br>kubebuilder init <span class="hljs-attr">--domain</span> qingwave<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span> <span class="hljs-attr">--repo</span> qingwave<span class="hljs-selector-class">.github</span>.io/mygame<br></code></pre></td></tr></table></figure><h3 id="创建-API"><a href="#创建-API" class="headerlink" title="创建 API"></a>创建 API</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">kubebuilder create api <span class="hljs-attr">--group</span> myapp <span class="hljs-attr">--version</span> v1 <span class="hljs-attr">--kind</span> Game<br><br>Create Resource <span class="hljs-selector-attr">[y/n]</span><br><span class="hljs-attribute">y</span> #生成CR<br>Create Controller <span class="hljs-selector-attr">[y/n]</span><br><span class="hljs-attribute">y</span> #生成Controller<br></code></pre></td></tr></table></figure><p>目录结构如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">├── api<br>│   └── <span class="hljs-built_in">v1</span> <span class="hljs-comment"># CRD定义</span><br>├── <span class="hljs-keyword">bin</span><br><span class="hljs-keyword"></span>│   └── controller-gen<br>├── <span class="hljs-built_in">config</span><br>│   ├── crd <span class="hljs-comment"># crd配置</span><br>│   ├── default<br>│   ├── manager <span class="hljs-comment"># operator部署文件</span><br>│   ├── prometheus<br>│   ├── rbac<br>│   └── samples <span class="hljs-comment"># cr示例</span><br>├── controllers<br>│   ├── game_controller.go <span class="hljs-comment"># controller逻辑</span><br>│   └── suite_test.go<br>├── Dockerfile<br>├── go.mod<br>├── go.sum<br>├── hack<br>│   └── <span class="hljs-keyword">boilerplate.go.txt </span><span class="hljs-comment"># 头文件模板</span><br>├── main.go <span class="hljs-comment"># 项目主函数</span><br>├── Makefile<br>└── PROJECT <span class="hljs-comment">#项目元数据</span><br></code></pre></td></tr></table></figure><h3 id="编写-API"><a href="#编写-API" class="headerlink" title="编写 API"></a>编写 API</h3><p>在<code>mygame/api/v1/game_types.go</code>定义我们需要的字段</p><p><code>Spec</code>配置如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> <span class="hljs-type">GameSpec</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Number of desired pods. This is a pointer to distinguish between explicit</span><br><span class="hljs-comment">// zero and not specified. Defaults to 1.</span><br><span class="hljs-comment">// +optional</span><br><span class="hljs-comment">//+kubebuilder:default:=1</span><br><span class="hljs-comment">//+kubebuilder:validation:Minimum:=1</span><br><span class="hljs-type">Replicas</span> *<span class="hljs-built_in">int32</span> `json:<span class="hljs-string">&quot;replicas,omitempty&quot;</span> protobuf:<span class="hljs-string">&quot;varint,1,opt,name=replicas&quot;</span>`<br><br><span class="hljs-comment">// Docker image name</span><br><span class="hljs-comment">// +optional</span><br><span class="hljs-type">Image</span> <span class="hljs-built_in">string</span> `json:<span class="hljs-string">&quot;image,omitempty&quot;</span>`<br><br><span class="hljs-comment">// Ingress Host name</span><br><span class="hljs-type">Host</span> <span class="hljs-built_in">string</span> `json:<span class="hljs-string">&quot;host,omitempty&quot;</span>`<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>kubebuilder:default</code>可以设置默认值</p></blockquote><p><code>Status</code>定义如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const (<br>Running  = &quot;Running&quot;<br>Pending  = &quot;Pending&quot;<br>NotReady = &quot;NotReady&quot;<br>Failed   = &quot;Failed&quot;<br>)<br><br><span class="hljs-keyword">type</span> GameStatus struct &#123;<br>// Phase <span class="hljs-keyword">is</span> the phase <span class="hljs-keyword">of</span> guestbook<br>Phase string `<span class="hljs-type">json</span>:&quot;phase,omitempty&quot;`<br><br>// replicas <span class="hljs-keyword">is</span> the number <span class="hljs-keyword">of</span> Pods created <span class="hljs-keyword">by</span> the StatefulSet controller.<br>Replicas int32 `<span class="hljs-type">json</span>:&quot;replicas&quot;`<br><br>// readyReplicas <span class="hljs-keyword">is</span> the number <span class="hljs-keyword">of</span> Pods created <span class="hljs-keyword">by</span> the StatefulSet controller that have a Ready Condition.<br>ReadyReplicas int32 `<span class="hljs-type">json</span>:&quot;readyReplicas&quot;`<br><br>// LabelSelector <span class="hljs-keyword">is</span> label selectors <span class="hljs-keyword">for</span> query <span class="hljs-keyword">over</span> pods that should match the <span class="hljs-keyword">replica</span> count used <span class="hljs-keyword">by</span> HPA.<br>LabelSelector string `<span class="hljs-type">json</span>:&quot;labelSelector,omitempty&quot;`<br>&#125;<br></code></pre></td></tr></table></figure><p>另外需要添加<code>scale</code>接口</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>+kubebuilder<span class="hljs-function">:subresource</span><span class="hljs-function">:scale</span><span class="hljs-function">:specpath</span>=<span class="hljs-string">.spec.replicas</span>,statuspath=<span class="hljs-string">.status.replicas</span>,selectorpath=<span class="hljs-string">.status.labelSelector</span><br></code></pre></td></tr></table></figure><p>添加<code>kubectl</code>展示参数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;Phase&quot;,<span class="hljs-keyword">type</span>=&quot;string&quot;,JSONPath=&quot;.status.phase&quot;,description=&quot;The phase of game.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;Host&quot;,<span class="hljs-keyword">type</span>=&quot;string&quot;,JSONPath=&quot;.spec.host&quot;,description=&quot;The Host Address.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;DESIRED&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.spec.replicas&quot;,description=&quot;The desired number of pods.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;CURRENT&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.status.replicas&quot;,description=&quot;The number of currently all pods.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;READY&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.status.readyReplicas&quot;,description=&quot;The number of pods ready.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;AGE&quot;,<span class="hljs-keyword">type</span>=&quot;date&quot;,JSONPath=&quot;.metadata.creationTimestamp&quot;,description=&quot;CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.&quot;<br></code></pre></td></tr></table></figure><h3 id="编写-Controller-逻辑"><a href="#编写-Controller-逻辑" class="headerlink" title="编写 Controller 逻辑"></a>编写 Controller 逻辑</h3><p>Controller 的核心逻辑在<code>Reconcile</code>中，我们只需要填充自己的业务逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GameReconciler)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="hljs-type">error</span>) &#123;<br>logger := log.FromContext(ctx)<br>logger.Info(<span class="hljs-string">&quot;revice reconcile event&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><br><span class="hljs-comment">// 获取game对象</span><br>game := &amp;myappv1.Game&#123;&#125;<br><span class="hljs-keyword">if</span> err := r.Get(ctx, req.NamespacedName, game); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)<br>&#125;<br><br>  <span class="hljs-comment">// 如果处在删除中直接跳过</span><br><span class="hljs-keyword">if</span> game.DeletionTimestamp != <span class="hljs-literal">nil</span> &#123;<br>logger.Info(<span class="hljs-string">&quot;game in deleting&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br>  <span class="hljs-comment">// 同步资源，如果资源不存在创建deployment、ingress、service，并更新status</span><br><span class="hljs-keyword">if</span> err := r.syncGame(ctx, game); err != <span class="hljs-literal">nil</span> &#123;<br>logger.Error(err, <span class="hljs-string">&quot;failed to sync game&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>添加 rbac 配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>apps,resources<span class="hljs-operator">=</span>deployments,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>apps,resources<span class="hljs-operator">=</span>deployments<span class="hljs-operator">/</span>status,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;<span class="hljs-keyword">update</span>;patch<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>core,resources<span class="hljs-operator">=</span>services,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>networking,resources<span class="hljs-operator">=</span>ingresses,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><p>具体<code>syncGame</code>逻辑如下</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">func (r *GameReconciler) syncGame(ctx context.Context, obj *myappv1.Game) error &#123;<br><span class="hljs-attribute">logger</span> := log<span class="hljs-variable">.FromContext</span>(ctx)<br><br>game := obj<span class="hljs-variable">.DeepCopy</span>()<br>name := types<span class="hljs-variable">.NamespacedName</span>&#123;<br>Namespace: game<span class="hljs-variable">.Namespace</span>,<br>Name:      game<span class="hljs-variable">.Name</span>,<br>&#125;<br><br>  // 构造owner<br>owner := []metav1<span class="hljs-variable">.OwnerReference</span>&#123;<br>&#123;<br>APIVersion:         game<span class="hljs-variable">.APIVersion</span>,<br>Kind:               game<span class="hljs-variable">.Kind</span>,<br>Name:               game<span class="hljs-variable">.Name</span>,<br>Controller:         pointer<span class="hljs-variable">.BoolPtr</span>(true),<br>BlockOwnerDeletion: pointer<span class="hljs-variable">.BoolPtr</span>(true),<br>UID:                game<span class="hljs-variable">.UID</span>,<br>&#125;,<br>&#125;<br><br>labels := game<span class="hljs-variable">.Labels</span><br>labels[gameLabelName] = game<span class="hljs-variable">.Name</span><br>meta := metav1<span class="hljs-variable">.ObjectMeta</span>&#123;<br>Name:            game<span class="hljs-variable">.Name</span>,<br>Namespace:       game<span class="hljs-variable">.Namespace</span>,<br>Labels:          labels,<br>OwnerReferences: owner,<br>&#125;<br><br>  // 获取对应deployment, 如不存在则创建<br>deploy := &amp;appsv1<span class="hljs-variable">.Deployment</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">if !errors.IsNotFound(err) &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">deploy = &amp;appsv1.Deployment&#123;</span><br><span class="hljs-attribute">ObjectMeta</span>: meta,<br>Spec:       getDeploymentSpec(game, labels),<br>&#125;<br>if err := r<span class="hljs-variable">.Create</span>(ctx, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">logger.Info(&quot;create deployment success&quot;, &quot;name&quot;, name.String())</span><br><span class="hljs-attribute">&#125; else &#123;</span><br><span class="hljs-attribute">    // 如果存在对比和game生成的deployment是否一致，不一致则更新</span><br><span class="hljs-attribute">want</span> := getDeploymentSpec(game, labels)<br>get := getSpecFromDeployment(deploy)<br>if !reflect<span class="hljs-variable">.DeepEqual</span>(want, get) &#123;<br>deploy = &amp;appsv1<span class="hljs-variable">.Deployment</span>&#123;<br>ObjectMeta: meta,<br>Spec:       want,<br>&#125;<br>if err := r<span class="hljs-variable">.Update</span>(ctx, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">logger.Info(&quot;update deployment success&quot;, &quot;name&quot;, name.String())</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  //service创建</span><br><span class="hljs-attribute">svc</span> := &amp;corev1<span class="hljs-variable">.Service</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, svc); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">  ...</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  // ingress创建</span><br><span class="hljs-attribute">ing</span> := &amp;networkingv1<span class="hljs-variable">.Ingress</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, ing); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">...</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">newStatus</span> := myappv1<span class="hljs-variable">.GameStatus</span>&#123;<br>Replicas:      *game<span class="hljs-variable">.Spec</span><span class="hljs-variable">.Replicas</span>,<br>ReadyReplicas: deploy<span class="hljs-variable">.Status</span><span class="hljs-variable">.ReadyReplicas</span>,<br>&#125;<br><br>if newStatus<span class="hljs-variable">.Replicas</span> == newStatus<span class="hljs-variable">.ReadyReplicas</span> &#123;<br>newStatus<span class="hljs-variable">.Phase</span> = myappv1<span class="hljs-variable">.Running</span><br>&#125; else &#123;<br>newStatus<span class="hljs-variable">.Phase</span> = myappv1<span class="hljs-variable">.NotReady</span><br>&#125;<br><br>  // 更新状态<br>if !reflect<span class="hljs-variable">.DeepEqual</span>(game<span class="hljs-variable">.Status</span>, newStatus) &#123;<br>game<span class="hljs-variable">.Status</span> = newStatus<br>logger<span class="hljs-variable">.Info</span>(&quot;update game status&quot;, &quot;name&quot;, name<span class="hljs-variable">.String</span>())<br>return r<span class="hljs-variable">.Client</span><span class="hljs-variable">.Status</span>()<span class="hljs-variable">.Update</span>(ctx, game)<br>&#125;<br><br>return nil<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下生成的 controller 只监听自定义资源，在示例中我们也需要监听<code>game</code>的子资源，如监听<code>deployment</code>是否符合预期</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SetupWithManager sets up the controller with the Manager.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GameReconciler)</span></span> SetupWithManager(mgr ctrl.Manager) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 创建controller</span><br>c, err := controller.New(<span class="hljs-string">&quot;game-controller&quot;</span>, mgr, controller.Options&#123;<br>Reconciler:              r,<br>MaxConcurrentReconciles: <span class="hljs-number">3</span>, <span class="hljs-comment">//controller运行的worker数</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">//监听自定义资源</span><br><span class="hljs-keyword">if</span> err := c.Watch(&amp;source.Kind&#123;Type: &amp;myappv1.Game&#123;&#125;&#125;, &amp;handler.EnqueueRequestForObject&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">//监听deployment,将owner信息即game namespace/name添加到队列</span><br><span class="hljs-keyword">if</span> err := c.Watch(&amp;source.Kind&#123;Type: &amp;appsv1.Deployment&#123;&#125;&#125;, &amp;handler.EnqueueRequestForOwner&#123;<br>OwnerType:    &amp;myappv1.Game&#123;&#125;,<br>IsController: <span class="hljs-literal">true</span>,<br>&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h3><p>安装 CRD</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">make <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>本地运行 operator</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> <span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><p>修改 sample 文件<code>config/samples/myapp_v1_game.yaml</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> myapp.qingwave.github.io/v1<br><span class="hljs-symbol">kind:</span> Game<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> game-sample<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  replicas:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">  image:</span> alexwhen/docker<span class="hljs-number">-2048</span><br><span class="hljs-symbol">  host:</span> mygame.io<br></code></pre></td></tr></table></figure><p>部署<code>game-sample</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">kubectl apply -f config/samples/myapp_v1_game.yaml<br></code></pre></td></tr></table></figure><p>查看<code>game</code>自定义资源状态</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 查看game</span><br><span class="hljs-attribute">kubectl</span> get game<br><span class="hljs-attribute">NAME</span>          PHASE     HOST        DESIRED   CURRENT   READY   AGE<br><span class="hljs-attribute">game</span>-sample   Running   mygame.io   <span class="hljs-number">1</span>         <span class="hljs-number">1</span>         <span class="hljs-number">1</span>       <span class="hljs-number">6</span>m<br><br><span class="hljs-comment"># 查看deploy</span><br><span class="hljs-attribute">kubectl</span> get deploy game-sample<br><span class="hljs-attribute">NAME</span>          READY   UP-TO-DATE   AVAILABLE   AGE<br><span class="hljs-attribute">game</span>-sample   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     <span class="hljs-number">1</span>            <span class="hljs-number">1</span>           <span class="hljs-number">6</span>m<br><br><span class="hljs-comment"># 查看ingress</span><br><span class="hljs-attribute">kubectl</span> get ing game-sample<br><span class="hljs-attribute">NAME</span>          CLASS    HOSTS       ADDRESS        PORTS   AGE<br><span class="hljs-attribute">game</span>-sample   &lt;none&gt;   mygame.io   <span class="hljs-number">192.168.49.2</span>   <span class="hljs-number">80</span>      <span class="hljs-number">7</span>m<br></code></pre></td></tr></table></figure><p>验证应用，在<code>/etc/hosts</code>中添加<code>&lt;Ingress ADDRESS Ip&gt; mygame.io</code>，访问浏览器如下图所示<img src="/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/crd_mygame.png" alt="2048"></p><p>验证扩容</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kubectl</span> scale games.myapp.qingwave.github.io game-sample --replicas <span class="hljs-number">2</span><br><span class="hljs-attribute">game</span>.myapp.qingwave.github.io/game-sample scaled<br><br><span class="hljs-comment"># 扩容后</span><br><span class="hljs-attribute">kubectl</span> get games.myapp.qingwave.github.io<br><span class="hljs-attribute">NAME</span>          PHASE     HOST        DESIRED   CURRENT   READY   AGE<br><span class="hljs-attribute">game</span>-sample   Running   mygame.io   <span class="hljs-number">2</span>         <span class="hljs-number">2</span>         <span class="hljs-number">2</span>       <span class="hljs-number">7</span>m<br></code></pre></td></tr></table></figure><p>如需部署<code>Operator</code>到集群中，可参考官方文档，制作镜像并上传，运行<code>make deploy</code></p><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p>通常我们需要与 CR 自定义资源设置部分字段的默认值，或者验证字段是否合法，这就需要自己实现<code>Webhook</code>，<code>Kubebuilder</code>也提供了<code>Webhook</code>的功能。</p><p>通过设置<code>--defaulting</code>可创建<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">mutatingadmissionwebhook</a>类型准入控制器，用来修改传入资源；参数<code>--programmatic-validation</code>可创建<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">validatingadmissionwebhook</a>，用来验证传入资源</p><blockquote><p>在资源创建、修改时<code>apiserver</code>会通过 http 调用<code>webhook</code>提供的接口，所以会带来额外开销，简单的验证工作可通过<code>//+kubebuilder:validation</code>注解，直接通过<code>openapi</code>验证，性能更好</p></blockquote><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">kubebuilder create webhook</span> <span class="hljs-literal">--</span><span class="hljs-comment">group myapp</span> <span class="hljs-literal">--</span><span class="hljs-comment">version v1</span> <span class="hljs-literal">--</span><span class="hljs-comment">kind Game</span> <span class="hljs-literal">--</span><span class="hljs-comment">defaulting</span> <span class="hljs-literal">--</span><span class="hljs-comment">programmatic</span><span class="hljs-literal">-</span><span class="hljs-comment">validation</span><br></code></pre></td></tr></table></figure><p>生成文件在<code>api/v1/game_webhook.go</code></p><p><code>Default</code>接口可实现修改资源，根据 kubebuilder 注释,当<code>game</code>资源<code>create</code>与<code>update</code>时，调用这个接口</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//+kubebuilder:webhook:<span class="hljs-type">path</span>=/mutate-myapp-qingwave-github-io-v1-game,mutating=<span class="hljs-keyword">true</span>,failurePolicy=fail,sideEffects=<span class="hljs-keyword">None</span>,<span class="hljs-keyword">groups</span>=myapp.qingwave.github.io,resources=games,verbs=<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>,versions=v1,<span class="hljs-type">name</span>=mgame.kb.io,admissionReviewVersions=&#123;v1,v1beta1&#125;<br>const (<br>defaultImage = `alexwhen/docker<span class="hljs-number">-2048</span>`<br>)<br><br>// <span class="hljs-keyword">Default</span> implements webhook.Defaulter so a webhook will be registered <span class="hljs-keyword">for</span> the <span class="hljs-keyword">type</span><br>func (r *Game) <span class="hljs-keyword">Default</span>() &#123;<br>gamelog.<span class="hljs-keyword">Info</span>(&quot;default&quot;, &quot;name&quot;, r.Name)<br><br>// 设置默认镜像<br><span class="hljs-keyword">if</span> r.Spec.Image == &quot;&quot; &#123;<br>r.Spec.Image = defaultImage<br>&#125;<br><br>// 设置默认Host<br><span class="hljs-keyword">if</span> r.Spec.Host == &quot;&quot; &#123;<br>r.Spec.Host = fmt.Sprintf(&quot;%s.%s.mygame.io&quot;, r.Name, r.Namespace)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的通过<code>ValidateCreate</code>、<code>ValidateUpdate</code>可实现<code>validating webhook</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Game)</span></span> ValidateCreate() <span class="hljs-type">error</span> &#123;<br>gamelog.Info(<span class="hljs-string">&quot;validate create&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, r.Name)<br><br><span class="hljs-comment">// Host不能包括通配符</span><br><span class="hljs-keyword">if</span> strings.Contains(r.Spec.Host, <span class="hljs-string">&quot;*&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;host should not contain *&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>本地验证 webhook 需要配置证书，在集群中测试更方便点，可参考官方文档。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经实现了一个功能完全的<code>game-operator</code>，可以管理<code>game</code>资源的生命周期，创建&#x2F;更新 game 时会自动创建<code>deployment、service、ingress</code>等资源，当<code>deployment</code>被误删或者误修改时也可以自动回复到期望状态，也实现了<code>scale</code>接口。</p><p>通过<code>kubebuiler</code>大大简化了开发<code>operator</code>的成本，我们只需要关心业务逻辑即可，不需要再手动去创建<code>client/controller</code>等，但同时<code>kubebuilder</code>生成的代码中屏蔽了很多细节，比如<code>controller</code>的最大 worker 数、同步时间、队列类型等参数设置，只有了解<code>operator</code>的原理才更好应用于生产。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://book.kubebuilder.io/">https://book.kubebuilder.io/</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s证书</title>
    <link href="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/"/>
    <url>/2025/03/30/k8s%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.zhaohuabing.com/post/2020-05-19-k8s-certificate/">https://www.zhaohuabing.com/post/2020-05-19-k8s-certificate/</a></p><p>接触 Kubernetes 以来，我经常看到 Kubernetes 在不同的地方使用了证书（Certificate），在 Kubernetes 安装和组件启动参数中也需要配置大量证书相关的参数。但是 Kubernetes 的文档在解释这些证书的工作机制方面做得并不是太好。经过大量的相关阅读和分析工作后，我基本弄清楚了 Kubernetes 中证书的使用方式。在本文中，我将试图以一种比官方文档更容易理解的方式来说明 Kubernetes 中证书相关的工作机制，如果你也存在这方面的疑惑，希望这篇文章对你有所帮助。</p><h1 id="Kubernetes-组件的认证方式"><a href="#Kubernetes-组件的认证方式" class="headerlink" title="Kubernetes 组件的认证方式"></a>Kubernetes 组件的认证方式</h1><p>首先让我们来看一下 Kubernetes 中的组件：在 Kubernetes 中包含多个以独立进程形式运行的组件，这些组件之间通过 HTTP&#x2F;GRPC 相互通信，以协同完成集群中应用的部署和管理工作。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/components-of-kubernetes.png" alt="img">kubernetes 组件，图片来源<a href="https://kubernetes.io/zh/docs/concepts/overview/components/">kubernetes.io</a></p><p>从图中可以看到，Kubernetes 控制平面中包含了 etctd，kube-api-server，kube-scheduler，kube-controller-manager 等组件，这些组件会相互进行远程调用，例如 kube-api-server 会调用 etcd 接口存储数据，kube-controller-manager 会调用 kube-api-server 接口查询集群中的对象状态；同时，kube-api-server 也会和在工作节点上的 kubelet 和 kube-proxy 进行通信，以在工作节点上部署和管理应用。</p><p>以上这些组件之间的相互调用都是通过网络进行的。在进行网络通信时，通信双方需要验证对方的身份，以避免恶意第三方伪造身份窃取信息或者对系统进行攻击。为了相互验证对方的身份，通信双方中的任何一方都需要做下面两件事情：</p><ul><li>向对方提供标明自己身份的一个证书</li><li>验证对方提供的身份证书是否合法，是否伪造的？</li></ul><p>在 Kubernetes 中使用了数字证书来提供身份证明，我们可以把数字证书简单理解为我们在日常生活中使用的“身份证”，上面标注了证书拥有者的身份信息，例如名称，所属组织机构等。为了保证证书的权威性，会采用一个通信双方都信任的 CA（证书机构，Certificate Authority）来颁发证书。这就类似于现实生活中颁发“身份证”的政府机构。数字证书中最重要的内容实际上是证书拥有者的公钥，该公钥代表了用户的身份。本文假设读者已经了解数字证书和 CA 的基本原理，如果你对此不太清楚，或者希望重新温习一下相关知识，可以先阅读一下这篇文章<a href="https://zhaohuabing.com/post/2020-03-19-pki">《数字证书原理》</a>。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/ca.png" alt="img"></p><p>CA （证书机构），图片来源<a href="https://www.trustauth.cn/ca-question/1791.html">www.trustauth.cn</a></p><p>在 Kubernetes 的组件之间进行通信时，数字证书的验证是在协议层面通过 TLS 完成的，除了需要在建立通信时提供相关的证书和密钥外，在应用层面并不需要进行特殊处理。采用 TLS 进行验证有两种方式：</p><ul><li>服务器单向认证：只需要服务器端提供证书，客户端通过服务器端证书验证服务的身份，但服务器并不验证客户端的身份。这种情况一般适用于对 Internet 开放的服务，例如搜索引擎网站，任何客户端都可以连接到服务器上进行访问，但客户端需要验证服务器的身份，以避免连接到伪造的恶意服务器。</li><li>双向 TLS 认证：除了客户端需要验证服务器的证书，服务器也要通过客户端证书验证客户端的身份。这种情况下服务器提供的是敏感信息，只允许特定身份的客户端访问。</li></ul><p>在 Kubernetes 中，各个组件提供的接口中包含了集群的内部信息。如果这些接口被非法访问，将影响集群的安全，因此组件之间的通信需要采用双向 TLS 认证。即客户端和服务器端都需要验证对方的身份信息。在两个组件进行双向认证时，会涉及到下面这些证书相关的文件：</p><ul><li>服务器端证书：服务器用于证明自身身份的数字证书，里面主要包含了服务器端的公钥以及服务器的身份信息。</li><li>服务器端私钥：服务器端证书中包含的公钥所对应的私钥。公钥和私钥是成对使用的，在进行 TLS 验证时，服务器使用该私钥来向客户端证明自己是服务器端证书的拥有者。</li><li>客户端证书：客户端用于证明自身身份的数字证书，里面主要包含了客户端的公钥以及客户端的身份信息。</li><li>客户端私钥：客户端证书中包含的公钥所对应的私钥，同理，客户端使用该私钥来向服务器端证明自己是客户端证书的拥有者。</li><li>服务器端 CA 根证书：签发服务器端证书的 CA 根证书，客户端使用该 CA 根证书来验证服务器端证书的合法性。</li><li>客户端端 CA 根证书：签发客户端证书的 CA 根证书，服务器端使用该 CA 根证书来验证客户端证书的合法性。</li></ul><p>下面这张来自<a href="https://medium.com/sitewards/the-magic-of-tls-x509-and-mutual-authentication-explained-b2162dec4401">The magic of TLS, X509 and mutual authentication explained</a> 文章中的图形象地解释了双向 TLS 认证的原理。如果你需要了解更多关于 TLS 认证的原理，可以阅读一下 medium 上的原文。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/mutual-tls.png" alt="img"></p><p>图片来源<a href="https://medium.com/sitewards/the-magic-of-tls-x509-and-mutual-authentication-explained-b2162dec4401">The magic of TLS, X509 and mutual authentication explained</a></p><h1 id="Kubernetes-中使用到的CA和证书"><a href="#Kubernetes-中使用到的CA和证书" class="headerlink" title="Kubernetes 中使用到的CA和证书"></a>Kubernetes 中使用到的CA和证书</h1><p>Kubernetes 中使用了大量的证书，本文不会试图覆盖到所有可能使用到的证书，但会讨论到主要的证书。理解了这些证书的使用方法和原理后，也能很快理解其他可能遇到的证书文件。下图标识出了在 kubernetes 中主要使用到的证书和其使用的位置：</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/kubernetes-certificate-usage.png" alt="img"></p><p>Kubernetes 中使用到的主要证书</p><p>上图中使用序号对证书进行了标注。图中的箭头表明了组件的调用方向，箭头所指方向为服务提供方，另一头为服务调用方。为了实现 TLS 双向认证，服务提供方需要使用一个服务器证书，服务调用方则需要提供一个客户端证书，并且双方都需要使用一个 CA 证书来验证对方提供的证书。为了简明起见，上图中只标注了证书使用方提供的证书，并没有标注证书的验证方验证使用的 CA 证书。图中标注的这些证书的作用分别如下：</p><ol><li>etcd 集群中各个节点之间相互通信使用的证书。由于一个 etctd 节点既为其他节点提供服务，又需要作为客户端访问其他节点，因此该证书同时用作服务器证书和客户端证书。</li><li>etcd 集群向外提供服务使用的证书。该证书是服务器证书。</li><li>kube-apiserver 作为客户端访问 etcd 使用的证书。该证书是客户端证书。</li><li>kube-apiserver 对外提供服务使用的证书。该证书是服务器证书。</li><li>kube-controller-manager 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kube-scheduler 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kube-proxy 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kubelet 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>管理员用户通过 kubectl 访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kubelet 对外提供服务使用的证书。该证书是服务器证书。</li><li>kube-apiserver 作为客户端访问 kubelet 采用的证书。该证书是客户端证书。</li><li>kube-controller-manager 用于生成和验证 service-account token 的证书。该证书并不会像其他证书一样用于身份认证，而是将证书中的公钥&#x2F;私钥对用于 service account token 的生成和验证。kube-controller-manager 会用该证书的私钥来生成 service account token，然后以 secret 的方式加载到 pod 中。pod 中的应用可以使用该 token 来访问 kube-apiserver， kube-apiserver 会使用该证书中的公钥来验证请求中的 token。我们将在文中稍后部分详细介绍该证书的使用方法。</li></ol><p>通过这张图，对证书机制比较了解的读者可能已经看出，我们其实可以使用多个不同的 CA 来颁发这些证书。只要在通信的组件中正确配置用于验证对方证书的 CA 根证书，就可以使用不同的 CA 来颁发不同用途的证书。但我们一般建议采用统一的 CA 来颁发 kubernetes 集群中的所有证书，这是因为采用一个集群根 CA 的方式比采用多个 CA 的方式更容易管理，可以避免多个CA 导致的复杂的证书配置、更新等问题，减少由于证书配置错误导致的集群故障。</p><h1 id="Kubernetes-中的证书配置"><a href="#Kubernetes-中的证书配置" class="headerlink" title="Kubernetes 中的证书配置"></a>Kubernetes 中的证书配置</h1><p>前面我们介绍了 Kubernetes 集群中主要使用到的证书。下面我们分别看一下如何将这些证书及其对应的私钥和 CA 根证书需要配置到 Kubernetes 中各个组件中，以供各个组件进行使用。这里假设使用一个集群根 CA 来颁发所有相关证书，因此涉及到 CA 的配置对应的证书文件名都是相同的。</p><h2 id="etcd-证书配置"><a href="#etcd-证书配置" class="headerlink" title="etcd 证书配置"></a>etcd 证书配置</h2><p>需要在 etcd 的启动命令行中配置以下证书相关参数：</p><ul><li>etcd 对外提供服务的服务器证书及私钥。</li><li>etcd 节点之间相互进行认证的 peer 证书、私钥以及验证 peer 的 CA。</li><li>etcd 验证访问其服务的客户端的 CA。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/etcd \\<br>  --cert-file=/etc/etcd/kube-etcd.pem \\                   <span class="hljs-comment"># 对外提供服务的服务器证书</span><br>  --key-file=/etc/etcd/kube-etcd-key.pem \\                <span class="hljs-comment"># 服务器证书对应的私钥</span><br>  --peer-cert-file=/etc/etcd/kube-etcd-peer.pem \\         <span class="hljs-comment"># peer 证书，用于 etcd 节点之间的相互访问</span><br>  --peer-key-file=/etc/etcd/kube-etcd-peer-key.pem \\      <span class="hljs-comment"># peer 证书对应的私钥</span><br>  --trusted-ca-file=/etc/etcd/cluster-root-ca.pem \\       <span class="hljs-comment"># 用于验证访问 etcd 服务器的客户端证书的 CA 根证书</span><br>  --peer-trusted-ca-file=/etc/etcd/cluster-root-ca.pem\\   <span class="hljs-comment"># 用于验证 peer 证书的 CA 根证书</span><br>  ...<br></code></pre></td></tr></table></figure><h2 id="kube-apiserver-证书配置"><a href="#kube-apiserver-证书配置" class="headerlink" title="kube-apiserver 证书配置"></a>kube-apiserver 证书配置</h2><p>需要在 kube-apiserver 中配置以下证书相关参数：</p><ul><li>kube-apiserver 对外提供服务的服务器证书及私钥。</li><li>kube-apiserver 访问 etcd 所需的客户端证书及私钥。</li><li>kube-apiserver 访问 kubelet 所需的客户端证书及私钥。</li><li>验证访问其服务的客户端的 CA。</li><li>验证 etcd 服务器证书的 CA 根证书。</li><li>验证 service account token 的公钥。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-apiserver \\ <br>  --tls-cert-file=/var/lib/kubernetes/kube-apiserver.pem \\                             <span class="hljs-comment"># 用于对外提供服务的服务器证书</span><br>  --tls-private-key-file=/var/lib/kubernetes/kube-apiserver-key.pem \\                  <span class="hljs-comment"># 服务器证书对应的私钥</span><br>  --etcd-certfile=/var/lib/kubernetes/kube-apiserver-etcd-client.pem \\                 <span class="hljs-comment"># 用于访问 etcd 的客户端证书</span><br>  --etcd-keyfile=/var/lib/kubernetes/kube-apiserver-etcd-client-key.pem \\              <span class="hljs-comment"># 用于访问 etcd 的客户端证书的私钥</span><br>  --kubelet-client-certificate=/var/lib/kubernetes/kube-apiserver-kubelet-client.pem \\ <span class="hljs-comment"># 用于访问 kubelet 的客户端证书</span><br>  --kubelet-client-key=/var/lib/kubernetes/kube-apiserver-kubelet-client-key.pem \\     <span class="hljs-comment"># 用于访问 kubelet 的客户端证书的私钥</span><br>  --client-ca-file=/var/lib/kubernetes/cluster-root-ca.pem \\                           <span class="hljs-comment"># 用于验证访问 kube-apiserver 的客户端的证书的 CA 根证书</span><br>  --etcd-cafile=/var/lib/kubernetes/cluster-root-ca.pem \\                              <span class="hljs-comment"># 用于验证 etcd 服务器证书的 CA 根证书  </span><br>  --kubelet-certificate-authority=/var/lib/kubernetes/cluster-root-ca.pem \\            <span class="hljs-comment"># 用于验证 kubelet 服务器证书的 CA 根证书</span><br>  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\                 <span class="hljs-comment"># 用于验证 service account token 的公钥</span><br>  ...<br></code></pre></td></tr></table></figure><h2 id="采用-kubeconfig-访问-kube-apiserver"><a href="#采用-kubeconfig-访问-kube-apiserver" class="headerlink" title="采用 kubeconfig 访问 kube-apiserver"></a>采用 kubeconfig 访问 kube-apiserver</h2><p>Kubernetes 中的各个组件，包括kube-controller-mananger、kube-scheduler、kube-proxy、kubelet等，采用一个kubeconfig 文件中配置的信息来访问 kube-apiserver。该文件中包含了 kube-apiserver 的地址，验证 kube-apiserver 服务器证书的 CA 证书，自己的客户端证书和私钥等访问信息。</p><p>在一个使用 minikube 安装的集群中，生成的 kubeconfig 配置文件如下所示，这四个文件分别为 admin 用户， kube-controller-mananger、kubelet 和 kube-scheduler 的kubeconfig配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /etc/kubernetes/<br>admin.conf  controller-manager.conf  kubelet.conf  scheduler.conf<br></code></pre></td></tr></table></figure><p>我们打开 controller-manager.conf 来看一下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">cluster:</span> <br>    <span class="hljs-comment"># 用于验证 kube-apiserver 服务器证书的 CA 根证书 </span><br>    <span class="hljs-attr">certificate-authority-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQVRBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwdGFXNXAKYTNWaVpVTkJNQjRYRFRJd01ETXdOekF3TXpjeE1Wb1hEVE13TURNd05qQXdNemN4TVZvd0ZURVRNQkVHQTFVRQpBeE1LYldsdWFXdDFZbVZEUVRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTTczCkdIMWxqNkxEUm1FLy9hQ2cvNUlmampKYy8zOGcyMVpITXJDMkx5RGVqZWhrdWUwZFB1WTJ0L2JjTjJYM1dGNEsKaWNzNmhhWnBDbFVxL3pteVRITWhhZnlmVVF5MDFJZmhDV2I5NXI4akpHZ2NyU3U3UUtXM3ZOd1Z1TmhJNmd6SApSWW45Ry82VHJKTjdOMWRjejNmMlU1OFRjUHVCQzZOUzVTc1JmemFSczVDZnd0UTNaa2czQUFVYTlQSDZFVmtDCkIvRGR1bXBialZGakMwSllOWlFVNTlGNUxDeHJ0bEYvOUJsSVhnZGw0ZlNCNzQ0ZW1UelcySEZQek9lTklYYnUKYTJPa0FFTDdJc3hSRTFBaEFKZ1h6cFNmdi9paDBuMEJpQ1VaV1hLZjg2UjZJL2xlK2docG51c21kTXUwbkNEUApHMm9laXhRTit5NzFQU2tGcGdzQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUIwR0ExVWRKUVFXCk1CUUdDQ3NHQVFVRkJ3TUNCZ2dyQmdFRkJRY0RBVEFQQmdOVkhSTUJBZjhFQlRBREFRSC9NQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFCaWpXYlpPNU9uaU9lNHRHUlQvRGFXaFBkY2ZwbE8vcVQ5WkFqU1hXZU41TStubExQZQpGV1NLRGRWU1NzajJ6UVdMU3A1Vjc3MkFoa2NYQlM0a2ZiY2ZCTUl2ejVsYXJZeHgxcnduTzZLbVZSTHdkNUNkCnRER2RjUjF0UzdqeTRSV05ISlAyNWZhZHB5TE9KVzJlZkdLRmRiSnZyRjljekV1ODR5a1drdThtVnNNa0RzTXkKbnVFNGtXblNvODgweFpxVG9QN01qM3hkRlNYYWdoNytwK3FMazk1VjhBNTRUNmRKa2VjSGg4SzdNYVRxdWVOVgpzOVhuZDA2WEJGQWFCVXRsSGZybmRXUzhmaTQ5dTY0NEFWOWJHclNYRnR1Q0lydnIxVkY2d0R3dEJYZi9UUStrCkx3Zk1oNVZDVWt1bEJqWEpqK1ZvRnBLZm5Qck9nbEExZzRtUgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://localhost:8443</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes</span><br><span class="hljs-attr">contexts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">kubernetes</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">system:kube-controller-manager</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-controller-manager@kubernetes</span><br><span class="hljs-attr">current-context:</span> <span class="hljs-string">system:kube-controller-manager@kubernetes</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Config</span><br><span class="hljs-attr">preferences:</span> &#123;&#125;<br><span class="hljs-attr">users:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-controller-manager</span><br>  <span class="hljs-attr">user:</span><br>    <span class="hljs-comment"># 用于访问 kube-apiserver 的客户端证书</span><br>    <span class="hljs-attr">client-certificate-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lJZVE4aDNXSlNmZEF3RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2JXbHVhV3QxWW1WRFFUQWVGdzB5TURBek1EY3dNRE0zTVRGYUZ3MHlNVEExTVRrd05qVTNNemxhTUNreApKekFsQmdOVkJBTVRIbk41YzNSbGJUcHJkV0psTFdOdmJuUnliMnhzWlhJdGJXRnVZV2RsY2pDQ0FTSXdEUVlKCktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU5DTzJpTEZzNGRTTW9sR2plN2tjY1VFbURDVjEvbWQKV1p1cS9DT0RvV1p2Uy80clNrOXNsaFQvektIVTVkVmg3SFV4TGNWU1RkQXZScGEwN3dXK3h2eWlDR3Y5UmMyVAp0bkFnUFFhQ2VkOC8zZlFpMzI1QmZCZVl4UjRTTm8raEM1b0ZYYkhpdC9OWWlQTVMvM1hFOGVCc0dEZCtjd1pzCnhNTDZzc0pJNzVOSmNXckV3eXlMbzIrb1JSRmJ2TlpJWFRZekJpRGd3QkZxNUkzZVA5QTl2d29rUG5STFBSdlYKQU9SV3hUZDMyblJLOTY1SU9uV25mNzY0bHhSeEV6bHIyS09rSzc5NlVJWTlyL0lYOWdGQjNqbGZFK1lBOE5VLwpuV2x3cElNL0ZpMk9hL1hjNnQzNUJHSnNXcTR4bHQ5RDdqS3V2bTNONmJlanJPOFZNODU5QU44Q0F3RUFBYU1uCk1DVXdEZ1lEVlIwUEFRSC9CQVFEQWdXZ01CTUdBMVVkSlFRTU1Bb0dDQ3NHQVFVRkJ3TUNNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFCZVg4QmVuTlJoUTVWaVpMMjRxcWxIMjRlMDVyYWVVTFZJQlQzWE90cmdQcXF1WXRGWgptRG9naEpuSW05aVVMcHFTTUxHMlJrQ0RBMEk2Rit0SGVFVHRMRDlNdjA2N1huQ2VCclhkTFVTYzkwaHNZWm1KClNsVG11c21TZGUxUXJsRnFxQVRZY2VCVWgwM0lSbXZIL1BtS21va1FUZDZER0paVVVhM3ducEN6Nko4aGcySGwKWlZFaURKcHNoeXNBaVdCUWZBN01TRlFlb0poSjhUdHgzdEhNZDlaaHlmcVVHOVByUGJkMUlBQTIrRlVudXRsNwpoRmdZdTBxbG5aZFZCWE9JM1dvZndWZ2dDTEQrbFVCeGgzNVhLNStxYXhWNVlDTit0ZTNFeDJERHVmRW1UV0FoCkwwUVNTc0RTZGd0Vi9TNFhvV2xQcXU0Q2lRVnZydUg3WHkxMwotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br>    <span class="hljs-comment"># 客户端证书对应的私钥</span><br>    <span class="hljs-attr">client-key-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBMEk3YUlzV3poMUl5aVVhTjd1Unh4UVNZTUpYWCtaMVptNnI4STRPaFptOUwvaXRLClQyeVdGUC9Nb2RUbDFXSHNkVEV0eFZKTjBDOUdsclR2QmI3Ry9LSUlhLzFGelpPMmNDQTlCb0o1M3ovZDlDTGYKYmtGOEY1akZIaEkyajZFTG1nVmRzZUszODFpSTh4TC9kY1R4NEd3WU4zNXpCbXpFd3ZxeXdranZrMGx4YXNURApMSXVqYjZoRkVWdTgxa2hkTmpNR0lPREFFV3JramQ0LzBEMi9DaVErZEVzOUc5VUE1RmJGTjNmYWRFcjNya2c2CmRhZC92cmlYRkhFVE9XdllvNlFydjNwUWhqMnY4aGYyQVVIZU9WOFQ1Z0R3MVQrZGFYQ2tnejhXTFk1cjlkenEKM2ZrRVlteGFyakdXMzBQdU1xNitiYzNwdDZPczd4VXp6bjBBM3dJREFRQUJBb0lCQVFDRDVMT2pKZkJoZGVRcgoySWpPT1g2Um9GUTI5YXgrV2JwZnJnU0MyUzNyUUJ1SkJBdWNxd2xIQW5hQktjaW41NlBJZ1c5MnlKUVpRcXliCmhwVmF4c25FM3h3QVgwNFRzb1MvNkVOdnFIZzJiWWVLYTd0dFdOQ0hnNysxUXNOcWxlaG1ZVnBkc3dtdVJhRm0KUis5eXBUaHFPeklkZGtSOEhiRlp0WDN6VEhqbVpYaUhGdlIvMFhYK1BVbDR6SllSWjlCbVBnY2Ric2tSTldScgo0Qk8wUmlQQWRKVEo2VHZLMGhxT1g1UHo4ekl3S1ZzYjdyYndUdXArTGs4eWNCVUd3Q1N3RzEyanVNQW1kYkJJClZmdmlFK1VYRHRIQXdLWXlnMEhCVitJVlEvcVNwSVJ1WXQ4SmY1MWVKN1VEbHhiN3ZRTStEYVNsNjVaMVNyWUcKQU9UTGpPVkJBb0dCQU5PYzB0OG5ybmhUR3V0MGhMdVp6SWs4ekFranhYYWtiSURlZi9XeXlQdW94Z3J2ZGMzcwpsbHV0U3hSOFV4WGVuQjBLZFpnYnNoc1ozeW9GbEI0YThTMzI1UFRsYm9xOVB0TDRaOFBzczQ3L0l1bHYxTk10CnZzZjdKZ1FuaFRCVndkdjN6OXFpdml6bjB4Mk9CdURxdzNSYXcvWEhwRy9RczJ5WmF4S29GNW9SQW9HQkFQeE8KQVBDUXQ2Q2swOFF2WTE4VjFLQXA0d2h1YWEyMS9MeC9rZUZJSURRd0tZZnFHRGdBWUYvQzJUbC9xc29TMXAvTwpFcFVkVkRBNHVpblFVbnFhNGg0a0JOYjRXTFhrSXhRdXdjWHdJNjRMNWR3ZWJHalhxUWUwbnkxQkhkTmU2Z0dqClorbit4OUJLWnJmcEliYkQ2blpYUUREbS9jZWYyWU5NVWRqVWpudnZBb0dBQnlIMUZhSi94ZngvSHNxWm9yMG4KWU1UVTE4WUY1TjdiN1dnU2hoU1ZvNjNucHZ5MVN0Q2JyTkZsZzNaQlVxNWpNck5ralZENXF1SXZYSG85cU5vZApvUC8rYmFiQ0dCa1M0Z2VQYjlJdHB6ZEFWUC80KzNsQ1FmbGNLYTJ2VnBhOVp3MnVTdDlMYTdZUXJxRlg2QUxoCnZhMUZoNlpJQzZETU8yL2NaUStYWkJFQ2dZQnNGMHNGeFNvMlU0YzZISWM1SEZRc2plVnJIa3ArRm1LQnF6R24KVDB3a3I2R0xUZm8wTzgwT0daOFFxQ1pXVGozTzF1MVZIdXlMZ0RJWmFkdDhGVkRjVXRnVDlPK2tkV21sNHVZMwpVOHNsYklsOGhUZ3lybm9IQ0JYTndJRHpwazBnaUk0alRIajBQbnZGUE1hcDAwTm1rYmk1ZXF5czBrblFtMmpSCk9UY1Yxd0tCZ0RNUWZSVlNNNXlGcjVIalJ4UXcwRDdrUWhONDlLbngrMWs2bWRORWJ6VG9rQ1RRcWlSeUJQdGgKcjlqZk0rRXFZcnZ1elRmRVpiS1VBMEZac09yeStxMHpXb29mTURLajFGV3BaTXJBSmdxdDFlcWtFbVFrVi8vSApQMzF3ejZDa1RneDdJby9iZ09PbmhsbUplU3NHaXpqenV2TjFEcWtjNVR3M3oxUSs1dmxmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==</span><br></code></pre></td></tr></table></figure><p>可以看到，访问 kube-apiserver 所需要的相关证书内容已经被采用 base64 编码写入了文件中。其他几个文件中的内容也是类似的，只是配置的用户名和客户端证书有所不同。</p><p>在启动这些组件时，需要在参数中指出 kubeconfig 文件的路径，例如 kube-controller-manager 的启动命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-controller-manager \\<br>--kubeconfig=/etc/kubernetes/controller-manager.conf <br><span class="hljs-comment"># 下面几个证书和访问 kube-apiserver 无关，我们会在后面介绍到</span><br>--cluster-signing-cert-file=/var/lib/kubernetes/cluster-root-ca.pem             <span class="hljs-comment"># 用于签发证书的 CA 根证书</span><br>--cluster-signing-key-file=/var/lib/kubernetes/cluster-root-ca-key.pem          <span class="hljs-comment"># 用于签发证书的 CA 根证书的私钥  </span><br>--service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem  <span class="hljs-comment"># 用于对 service account token 进行签名的私钥</span><br>... <br></code></pre></td></tr></table></figure><h2 id="Service-Account-证书"><a href="#Service-Account-证书" class="headerlink" title="Service Account 证书"></a>Service Account 证书</h2><p>Kubernetes 中有两类用户，一类为 user account，一类为 service account。 service account 主要被 pod 用于访问 kube-apiserver。 在为一个 pod 指定了 service account 后，kubernetes 会为该 service account 生成一个 JWT token，并使用 secret 将该 service account token 加载到 pod 上。pod 中的应用可以使用 service account token 来访问 api server。service account 证书被用于生成和验证 service account token。该证书的用法和前面介绍的其他证书不同，因为实际上使用的是其公钥和私钥，而并不需要对证书进行验证。</p><p>我们可以看到 service account 证书的公钥和私钥分别被配置到了 kube-apiserver 和 kube-controller-manager 的命令行参数中，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-apiserver \\ <br>  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\          <span class="hljs-comment"># 用于验证 service account token 的公钥</span><br>  ...<br>  <br> /usr/local/bin/kube-controller-manager \\<br> --service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem  <span class="hljs-comment"># 用于对 service account token 进行签名的私钥</span><br> ... <br></code></pre></td></tr></table></figure><p>下图展示了 kubernetes 中生成、使用和验证 service account token 的过程。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/service-account-token.png" alt="img"></p><h3 id="认证方法：客户端证书还是-token-？"><a href="#认证方法：客户端证书还是-token-？" class="headerlink" title="认证方法：客户端证书还是 token ？"></a>认证方法：客户端证书还是 token ？</h3><p>我们可以看到，Kubernetes 提供了两种客户端认证的方法，控制面组件采用的是客户端数字证书;而在集群中部署的应用则采用了 service account token 的方式。为什么 Kubernetes 不为 service account 也生成一个证书，并采用该证书进行身份认证呢？ 实际上 Istio 就是这样做的，Istio 会自动为每个 service account 生成一个证书，并使用该证书来在 pod 中的应用之间建立双向 tls 认证。我没有找到 Kubernetes 这个设计决策的相关说明，如果你知道原因或对此有自己的见解，欢迎联系我进行探讨。</p><h2 id="Kubernetes-证书签发"><a href="#Kubernetes-证书签发" class="headerlink" title="Kubernetes 证书签发"></a>Kubernetes 证书签发</h2><p>Kubernetes 提供了一个 <code>certificates.k8s.io</code> API，可以使用配置的 CA 根证书来签发用户证书。该 API 由 kube-controller-manager 实现，其签发证书使用的根证书在下面的命令行中进行配置。我们希望 Kubernetes 采用集群根 CA 来签发用户证书，因此在 kube-controller-manager 的命令行参数中将相关参数配置为了集群根 CA。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-controller-manager \\<br>--cluster-signing-cert-file=/var/lib/kubernetes/cluster-root-ca.pem             <span class="hljs-comment"># 用于签发证书的 CA 根证书</span><br>--cluster-signing-key-file=/var/lib/kubernetes/cluster-root-ca-key.pem          <span class="hljs-comment"># 用于签发证书的 CA 根证书的私钥  </span><br>... <br></code></pre></td></tr></table></figure><p>关于更多 Kubernetes 证书签发 API 的内容，可以参见 <a href="https://kubernetes.io/zh/docs/tasks/tls/managing-tls-in-a-cluster/">管理集群中的 TLS 认证</a>。</p><h2 id="使用-TLS-bootstrapping-简化-Kubelet-证书制作"><a href="#使用-TLS-bootstrapping-简化-Kubelet-证书制作" class="headerlink" title="使用 TLS bootstrapping 简化 Kubelet 证书制作"></a>使用 TLS bootstrapping 简化 Kubelet 证书制作</h2><p>在安装 Kubernetes 时，我们需要为每一个工作节点上的 Kubelet 分别生成一个证书。由于工作节点可能很多，手动生成 Kubelet 证书的过程会比较繁琐。为了解决这个问题，Kubernetes 提供了 <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS bootstrapping </a>的方式来简化 Kubelet 证书的生成过程。其原理是预先提供一个 bootstrapping token，kubelet 采用该 bootstrapping token 进行客户端验证，调用 kube-apiserver 的证书签发 API 来生成 自己需要的证书。要启用该功能，需要在 kube-apiserver 中启用 <code>--enable-bootstrap-token-auth</code> ，并创建一个 kubelet 访问 kube-apiserver 使用的 bootstrap token secret。如果使用 kubeadmin 安装，可以使用 <code>kubeadm token create</code>命令来创建 token。</p><p>采用TLS bootstrapping 生成证书的流程如下：</p><ol><li>调用 kube-apiserver 生成一个 bootstrap token。</li><li>将该 bootstrap token 写入到一个 kubeconfig 文件中，作为 kubelet 调用 kube-apiserver 的客户端验证方式。</li><li>通过 <code>--bootstrap-kubeconfig</code> 启动参数将 bootstrap token 传递给 kubelet 进程。</li><li>Kubelet 采用bootstrap token 调用 kube-apiserver API，生成自己所需的服务器和客户端证书。</li><li>证书生成后，Kubelet 采用生成的证书和 kube-apiserver 进行通信，并删除本地的 kubeconfig 文件，以避免 bootstrap token 泄漏风险。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Kubernetes 中使用了大量的证书来确保集群的安全，弄清楚这些证书的用途和配置方法将有助于我们深入理解 kubernetes 的安装过程和组件的配置。本文是笔者在学习 过程中整理的 Kubernetes 集群中主要使用到的证书，由于笔者对 Kubernetes 的理解有限，文章中难免存在部分错误，欢迎指正。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://kubernetes.io/zh/docs/setup/best-practices/certificates/">Kubernetes PKI 证书和要求</a></li><li><a href="https://github.com/kelseyhightower/kubernetes-the-hard-wa">kubernetes the hard way</a></li><li><a href="https://blog.51cto.com/13210651/2361208">Kubernetes 之 二进制安装(二) 证书详解</a></li><li><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS bootstrapping</a></li><li><a href="https://zhaohuabing.com/post/2020-03-19-pki/">数字证书原理</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s-选主-实战验证</title>
    <link href="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/"/>
    <url>/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s-选主-实战验证"><a href="#k8s-选主-实战验证" class="headerlink" title="k8s-选主-实战验证"></a>k8s-选主-实战验证</h1><p>转自：<a href="https://blog.csdn.net/boling_cavalry/article/details/132129123">https://blog.csdn.net/boling_cavalry/article/details/132129123</a></p><h4 id="本篇概览"><a href="#本篇概览" class="headerlink" title="本篇概览"></a>本篇概览</h4><p>•本文是《client-go实战》系列的第十二篇，又有一个精彩的知识点在本章呈现：选主(leader-election)•在解释什么是选主之前，咱们先来看一个场景（有真实适用场景的技术，学起来才有动力），如下图所示（稍后有详细说明）</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/230a3f9ae9a956d7d112c28c02a38ff4.png" alt="Image 32: 在这里插入图片描述"></p><p>上图所描述的业务场景是个普通的controller应用：</p><p>1.右侧是人工操作，通过kubectl命令修改了service资源2.左侧的业务应用订阅了service的变化，在收到service变更的事件后，对pod进行写操作（例如将收到事件的时间写入pod的label）</p><p>•以上的业务应用就是个很普通的controller，很简单，运行起来也没啥问题，但是，如果这个业务应用有多个实例呢？</p><h4 id="多实例的问题"><a href="#多实例的问题" class="headerlink" title="多实例的问题"></a>多实例的问题</h4><p>•所谓多个实例，就是同样的业务应用我们运行了多个进程（例如三个），为什么多个进程？同一个应用运行多个进程不是很正常么？横向扩容不就是多进程嘛•多个进程运行的时候，如果service发生变化，那么每个进程都会去修改pod的label，这不是我们想要的（只要修改一次就行了）•所以，如何解决这个问题呢？三个进程都是同一套代码，都会订阅service的变化，但是最终只修改一次pod•经验丰富的您应该会想到分布式锁，三个进程去抢分布式锁，抢到的负责更新，没错，这是一个正确的解法•但是，分布式锁需要引入相关组件吧，redis的setnx，或者mysql的乐观锁，这样就需要维护新的组件了•其实这在kubernetes是个很典型的问题，毕竟pod多实例在kubernetes是常态了，所以当然也有官方的解法，页就是本文的主题：选主(leader-election)</p><h4 id="选主-leader-election"><a href="#选主-leader-election" class="headerlink" title="选主(leader-election)"></a>选主(leader-election)</h4><p>•说到这里您应该能理解选主的含义了：多个进程竞争某个key的leader，咱们可以把特定的代码放在竞争成功后再执行，由于同一时刻只有一个进程可以竞争成功，这就相当于在不引入额外组件的情况下，只用client-go就实现了分布式锁•由于选主只是个特定的小知识点，本篇就没什么多余的理论要研究了，接下来直接开始实战，编码实现一个功能来说明选主的用法•实战的业务需求如下</p><p>1.开发一个应用，该应用同时运行多个进程2.当kubernetes的指定namespace下的service发生变化时，在pod的label中记录这个service的变化时间3.每次serivce变化，pod的label只能修改一次（尽管此时有多个进程）</p><p>•让我们少些套路，多一点真诚，不说废话，直接开始动手实战吧</p><h4 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h4><p>•如果您不想编写代码，也可以从GitHub上直接下载，地址和链接信息如下表所示(<a href="https://github.com/zq2599/blog/_demos)%EF%BC%9A">https://github.com/zq2599/blog\_demos)：</a></p><table><thead><tr><th>名称</th><th>链接</th><th>备注</th></tr></thead><tbody><tr><td>项目主页</td><td><a href="https://github.com/zq2599/blog/_demos">https://github.com/zq2599/blog\_demos</a></td><td>该项目在GitHub上的主页</td></tr><tr><td>git仓库地址(https)</td><td><a href="https://github.com/zq2599/blog/_demos.git">https://github.com/zq2599/blog\_demos.git</a></td><td>该项目源码的仓库地址，https协议</td></tr><tr><td>git仓库地址(ssh)</td><td><a href="mailto:&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#98;&#46;&#99;&#x6f;&#x6d;</a>:zq2599&#x2F;blog_demos.git</td><td>该项目源码的仓库地址，ssh协议</td></tr></tbody></table><p>•这个git项目中有多个文件夹，本篇的源码在leader-tutorials文件夹下，如下图黄框所示：</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/fc33e0f2da6fec4b7043fc97415dd155.png" alt="Image 33: 在这里插入图片描述"></p><h4 id="提前了解选主的代码"><a href="#提前了解选主的代码" class="headerlink" title="提前了解选主的代码"></a>提前了解选主的代码</h4><p>•接下来会开发一个完整的controller应用，以此来说明选主功能•如果您觉得完整应用的代码太多，懒得看，只想了解选主部分，那就在此提前将整个工程中选主相关的代码贴出来•核心代码如下所示，先创建锁对象，就像分布式锁一样，总要有个key，然后执行leaderelection.RunOrDie方法参与选主，一旦有了结果，OnNewLeader方法会被回调，这时候通过自身id和leader的id比较就知道是不是自己了，另外，当OnStartedLeading被执行的时候，就意味着当前进程就是leader，并且可以立即开始执行只有leader才能做的事情了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// startLeaderElection 选主的核心逻辑代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startLeaderElection</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, stop <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]创建选主所需的锁对象&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 创建锁对象</span><br>    lock := &amp;resourcelock.LeaseLock&#123;<br>        LeaseMeta: metav1.ObjectMeta&#123;<br>            Name:      <span class="hljs-string">&quot;leader-tutorials&quot;</span>,<br>            Namespace: NAMESPACE,<br>        &#125;,<br>        Client: clientset.CoordinationV1(),<br>        LockConfig: resourcelock.ResourceLockConfig&#123;<br>            Identity: processIndentify,<br>        &#125;,<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始选主&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 启动选主操作</span><br>    leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;<br>        Lock:            lock,<br>        ReleaseOnCancel: <span class="hljs-literal">true</span>,<br>        LeaseDuration:   <span class="hljs-number">10</span> * time.Second,<br>        RenewDeadline:   <span class="hljs-number">5</span> * time.Second,<br>        RetryPeriod:     <span class="hljs-number">2</span> * time.Second,<br>        Callbacks: leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]当前进程是leader，只有leader才能执行的业务逻辑立即开始&quot;</span>, processIndentify)<br>                <span class="hljs-comment">// 在这里写入选主成功的代码，</span><br>                <span class="hljs-comment">// 就像抢分布式锁一样，当前进程选举成功的时候，这的代码就会被执行，</span><br>                <span class="hljs-comment">// 所以，在这里填写抢锁成功的业务逻辑吧，本例中就是监听service变化，然后修改pod的label</span><br>                CreateAndStartController(ctx, clientset, &amp;v1.Service&#123;&#125;, <span class="hljs-string">&quot;services&quot;</span>, NAMESPACE, stop)<br>            &#125;,<br>            OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-comment">// 失去了leader时的逻辑</span><br>                klog.Infof(<span class="hljs-string">&quot;[%s]失去leader身份，不再是leader了&quot;</span>, processIndentify)<br>                os.Exit(<span class="hljs-number">0</span>)<br>            &#125;,<br>            OnNewLeader: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span> &#123;<br>                <span class="hljs-comment">// 收到通知，知道最终的选举结果</span><br>                <span class="hljs-keyword">if</span> identity == processIndentify &#123;<br>                    klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，当前进程就是leader&quot;</span>, processIndentify)<br>                    <span class="hljs-comment">// I just got the lock</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，leader是 : [%s]&quot;</span>, processIndentify, identity)<br>            &#125;,<br>        &#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实战：部署service和deployment"><a href="#实战：部署service和deployment" class="headerlink" title="实战：部署service和deployment"></a>实战：部署service和deployment</h4><p>•首先请准备好k8s环境，这在《client-go实战之六:时隔两年，刷新版本继续实战》里面已有详细说明•然后把本次实战所需的service和deployment部署好，- 所有要部署的内容我都集中在这个名为nginx-deployment-service.yaml脚本中了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">client-go-tutorials</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>        <span class="hljs-comment"># 这是第一个业务自定义label，指定了mysql的语言类型是c语言</span><br>        <span class="hljs-attr">language:</span> <span class="hljs-string">c</span><br>        <span class="hljs-comment"># 这是第二个业务自定义label，指定了这个pod属于哪一类服务，nginx属于web类</span><br>        <span class="hljs-attr">business-service-type:</span> <span class="hljs-string">web</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>          <span class="hljs-attr">resources:</span><br>            <span class="hljs-attr">limits:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span><br>            <span class="hljs-attr">requests:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.1&quot;</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">64Mi</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">client-go-tutorials</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30011</span><br></code></pre></td></tr></table></figure><p>•先执行以下命令创建namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create namespace client-go-tutorials<br></code></pre></td></tr></table></figure><p>•再执行以下命令即可完成资源的创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f nginx-deployment-service.yaml<br></code></pre></td></tr></table></figure><p>•来查看一下资源情况，如下图，service和pod都创建好了，准备工作完成，可以开始编码了</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/73fa79a5cf8315f15417361895009780.png" alt="Image 36: 在这里插入图片描述"></p><h4 id="编码：准备工程"><a href="#编码：准备工程" class="headerlink" title="编码：准备工程"></a>编码：准备工程</h4><p>•执行命令名为go mod init leader-tutorials，新建module•确保您的goproxy是正常的•执行命令go get k8s.io&#x2F;<a href="mailto:&#99;&#x6c;&#105;&#101;&#x6e;&#x74;&#x2d;&#x67;&#111;&#x40;&#118;&#x30;&#x2e;&#50;&#50;&#x2e;&#x38;">&#99;&#x6c;&#105;&#101;&#x6e;&#x74;&#x2d;&#x67;&#111;&#x40;&#118;&#x30;&#x2e;&#50;&#50;&#x2e;&#x38;</a>，下载client-go的指定版本•现在工程已经准备好了，接着就是具体的编码</p><h4 id="编码：梳理"><a href="#编码：梳理" class="headerlink" title="编码：梳理"></a>编码：梳理</h4><p>•咱们按照开发顺序开始写代码，如果您看过欣宸的《client-go实战》系列，此刻对使用client-go开发简易版controller应该很熟悉了，这里再简单提一下开发的流程</p><p>1.将controller完整的写出来，功能是监听service，一旦有变化就更新pod的label2.在主控逻辑中，根据选主结果决定是否启动步骤1中的controller</p><p>•下面开始写代码</p><h4 id="编码：controller"><a href="#编码：controller" class="headerlink" title="编码：controller"></a>编码：controller</h4><p>•新建controller.go文件•在controller.go中增加常量和数据结构的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br><br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/fields&quot;</span><br>    objectruntime <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/types&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/util/runtime&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/util/wait&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/cache&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/util/workqueue&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    LABLE_SERVICE_UPDATE_TIME = <span class="hljs-string">&quot;service-update-time&quot;</span> <span class="hljs-comment">// 这个label用来记录service的更新时间</span><br>)<br><br><span class="hljs-comment">// 自定义controller数据结构，嵌入了真实的控制器</span><br><span class="hljs-keyword">type</span> Controller <span class="hljs-keyword">struct</span> &#123;<br>    ctx       context.Context<br>    clientset *kubernetes.Clientset<br>    <span class="hljs-comment">// 本地缓存，关注的对象都会同步到这里</span><br>    indexer cache.Indexer<br>    <span class="hljs-comment">// 消息队列，用来触发对真实对象的处理事件</span><br>    queue workqueue.RateLimitingInterface<br>    <span class="hljs-comment">// 实际运行运行的控制器</span><br>    informer cache.Controller<br>&#125;<br></code></pre></td></tr></table></figure><p>•然后是controller的套路代码，主要是从队列中不断获取数据并处理的逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// processNextItem 不间断从队列中取得数据并处理</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> processNextItem() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 注意，队列里面不是对象，而是key，这是个阻塞队列，会一直等待</span><br>    key, quit := c.queue.Get()<br>    <span class="hljs-keyword">if</span> quit &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// Tell the queue that we are done with processing this key. This unblocks the key for other workers</span><br>    <span class="hljs-comment">// This allows safe parallel processing because two pods with the same key are never processed in</span><br>    <span class="hljs-comment">// parallel.</span><br>    <span class="hljs-keyword">defer</span> c.queue.Done(key)<br><br>    <span class="hljs-comment">// 注意，这里的syncToStdout应该是业务代码，处理对象变化的事件</span><br>    err := c.updatePodsLabel(key.(<span class="hljs-type">string</span>))<br><br>    <span class="hljs-comment">// 如果前面的业务逻辑遇到了错误，就在此处理</span><br>    c.handleErr(err, key)<br><br>    <span class="hljs-comment">// 外面的调用逻辑是：返回true就继续调用processNextItem方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// runWorker 这是个无限循环，不断地从队列取出数据处理</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> runWorker() &#123;<br>    <span class="hljs-keyword">for</span> c.processNextItem() &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// handleErr 如果前面的业务逻辑执行出现错误，就在此集中处理错误，本例中主要是重试次数的控制</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> handleErr(err <span class="hljs-type">error</span>, key <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// Forget about the #AddRateLimited history of the key on every successful synchronization.</span><br>        <span class="hljs-comment">// This ensures that future processing of updates for this key is not delayed because of</span><br>        <span class="hljs-comment">// an outdated error history.</span><br>        c.queue.Forget(key)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果重试次数未超过5次，就继续重试</span><br>    <span class="hljs-keyword">if</span> c.queue.NumRequeues(key) &lt; <span class="hljs-number">5</span> &#123;<br>        klog.Infof(<span class="hljs-string">&quot;Error syncing pod %v: %v&quot;</span>, key, err)<br><br>        <span class="hljs-comment">// Re-enqueue the key rate limited. Based on the rate limiter on the</span><br>        <span class="hljs-comment">// queue and the re-enqueue history, the key will be processed later again.</span><br>        c.queue.AddRateLimited(key)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 代码走到这里，意味着有错误并且重试超过了5次，应该立即丢弃</span><br>    c.queue.Forget(key)<br>    <span class="hljs-comment">// 这种连续五次重试还未成功的错误，交给全局处理逻辑</span><br>    runtime.HandleError(err)<br>    klog.Infof(<span class="hljs-string">&quot;Dropping pod %q out of the queue: %v&quot;</span>, key, err)<br>&#125;<br><br><span class="hljs-comment">// Run 开始常规的控制器模式（持续响应资源变化事件）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> Run(threadiness <span class="hljs-type">int</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    <span class="hljs-keyword">defer</span> runtime.HandleCrash()<br><br>    <span class="hljs-comment">// Let the workers stop when we are done</span><br>    <span class="hljs-keyword">defer</span> c.queue.ShutDown()<br>    klog.Info(<span class="hljs-string">&quot;Starting Pod controller&quot;</span>)<br><br>    <span class="hljs-keyword">go</span> c.informer.Run(stopCh)<br><br>    <span class="hljs-comment">// Wait for all involved caches to be synced, before processing items from the queue is started</span><br>    <span class="hljs-comment">// 刚开始启动，从api-server一次性全量同步所有数据</span><br>    <span class="hljs-keyword">if</span> !cache.WaitForCacheSync(stopCh, c.informer.HasSynced) &#123;<br>        runtime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;timed out waiting for caches to sync&quot;</span>))<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 支持多个线程并行从队列中取得数据进行处理</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadiness; i++ &#123;<br>        <span class="hljs-keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)<br>    &#125;<br><br>    &lt;-stopCh<br>    klog.Info(<span class="hljs-string">&quot;Stopping Pod controller&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>•从上述代码可见，监听的资源发生变化时，调用的是updatePodsLabel方法，此方法的作用就是查找该namespace下的所有pod，依次用patch的方式更新pod的label</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// updatePodsLabel 这是业务逻辑代码，一旦service发生变化，就修改pod的label，将service的变化事件记录进去</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> updatePodsLabel(key <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 开始进入controller的业务逻辑</span><br>    klog.Infof(<span class="hljs-string">&quot;[%s]这里是controller的业务逻辑，key [%s]&quot;</span>, processIndentify, key)<br>    <span class="hljs-comment">// 从本地缓存中取出完整的对象</span><br>    _, exists, err := c.indexer.GetByKey(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Errorf(<span class="hljs-string">&quot;[%s]根据key[%s]从本地缓存获取对象失败 : %v&quot;</span>, processIndentify, key, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> !exists &#123;<br>        klog.Infof(<span class="hljs-string">&quot;[%s]对象不存在，key [%s]，这是个删除事件&quot;</span>, processIndentify, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        klog.Infof(<span class="hljs-string">&quot;[%s]对象存在，key [%s]，这是个新增或修改事件&quot;</span>, processIndentify, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 代码走到这里，表示监听的对象发生了变化，</span><br>    <span class="hljs-comment">// 按照业务设定，需要修改pod的指定label,</span><br>    <span class="hljs-comment">// 准备好操作pod的接口</span><br>    podInterface := c.clientset.CoreV1().Pods(NAMESPACE)<br><br>    <span class="hljs-comment">// 远程取得最新的pod列表</span><br>    pods, err := podInterface.List(c.ctx, metav1.ListOptions&#123;&#125;)<br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Errorf(<span class="hljs-string">&quot;[%s]远程获取pod列表失败 : %v&quot;</span>, processIndentify, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 将service的变化时间写入pod的指定label，这里先获取当前时间</span><br>    updateTime := time.Now().Format(<span class="hljs-string">&quot;20060102150405&quot;</span>)<br>    <span class="hljs-comment">// 准备patch对象</span><br>    patchData := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>        <span class="hljs-string">&quot;metadata&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>            <span class="hljs-string">&quot;labels&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>                LABLE_SERVICE_UPDATE_TIME: updateTime,<br>            &#125;,<br>        &#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 转为byte数组，稍后更新pod的时候，就用这个数组进行patch更新</span><br>    patchByte, _ := json.Marshal(patchData)<br><br>    <span class="hljs-comment">// 遍历所有pod，逐个更新label</span><br>    <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods.Items &#123;<br>        podName := pod.Name<br>        klog.Infof(<span class="hljs-string">&quot;[%s]正在更新pod [%s]&quot;</span>, processIndentify, podName)<br><br>        _, err := podInterface.Patch(c.ctx, podName, types.MergePatchType, patchByte, metav1.PatchOptions&#123;&#125;)<br><br>        <span class="hljs-comment">// 失败就返回，会导致整体重试</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            klog.Infof(<span class="hljs-string">&quot;[%s]更新pod [%s]失败, %v&quot;</span>, processIndentify, podName, err)<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br><br>        klog.Infof(<span class="hljs-string">&quot;[%s]更新pod [%s]成功&quot;</span>, processIndentify, podName)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>•到这里，controller的代码已经写得七七八八了，还剩创建controller对象以及运行informer的代码，这里将它们集中封装在一个方法中，一旦这个方法被调用，就意味着controller会被创建，然后监听service变化再更新pod的label的逻辑就会被执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateAndStartController 为了便于外部使用，这里将controller的创建和启动封装在一起</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateAndStartController</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, objType objectruntime.Object, resource <span class="hljs-type">string</span>, namespace <span class="hljs-type">string</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-comment">// ListWatcher用于获取数据并监听资源的事件</span><br>    podListWatcher := cache.NewListWatchFromClient(clientset.CoreV1().RESTClient(), resource, NAMESPACE, fields.Everything())<br><br>    <span class="hljs-comment">// 限速队列，里面存的是有事件发生的对象的身份信息，而非对象本身</span><br>    queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())<br><br>    <span class="hljs-comment">// 创建本地缓存并对指定类型的资源开始监听</span><br>    <span class="hljs-comment">// 注意，如果业务上有必要，其实可以将新增、修改、删除等事件放入不同队列，然后分别做针对性处理，</span><br>    <span class="hljs-comment">// 但是，controller对应的模式，主要是让status与spec达成一致，也就是说增删改等事件，对应的都是查到实际情况，令其与期望情况保持一致，</span><br>    <span class="hljs-comment">// 因此，多数情况下增删改用一个队列即可，里面放入变化的对象的身份，至于处理方式只有一种：查到实际情况，令其与期望情况保持一致</span><br>    indexer, informer := cache.NewIndexerInformer(podListWatcher, objType, <span class="hljs-number">0</span>, cache.ResourceEventHandlerFuncs&#123;<br>        AddFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 再次注意：这里放入队列的并非对象，而是对象的身份，作用是仅仅告知消费方，该对象有变化，</span><br>                <span class="hljs-comment">// 至于有什么变化，需要消费方自行判断，然后再做针对性处理</span><br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        UpdateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(old <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(<span class="hljs-built_in">new</span>)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        DeleteFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>    &#125;, cache.Indexers&#123;&#125;)<br><br>    controller := &amp;Controller&#123;<br>        ctx:       ctx,<br>        clientset: clientset,<br>        informer:  informer,<br>        indexer:   indexer,<br>        queue:     queue,<br>    &#125;<br><br>    <span class="hljs-keyword">go</span> controller.Run(<span class="hljs-number">1</span>, stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编码：主控程序（选主逻辑也在里面）"><a href="#编码：主控程序（选主逻辑也在里面）" class="headerlink" title="编码：主控程序（选主逻辑也在里面）"></a>编码：主控程序（选主逻辑也在里面）</h4><p>•本文是讲选主(leader-election)的，前面做了这么多铺垫，主角该上场了，新建main.go文件•定义常量，以及全局变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;flag&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;path/filepath&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/google/uuid&quot;</span><br>    v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/leaderelection&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/leaderelection/resourcelock&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/util/homedir&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    NAMESPACE = <span class="hljs-string">&quot;client-go-tutorials&quot;</span><br>)<br><br><span class="hljs-comment">// 用于表明当前进程身份的全局变量，目前用的是uuid</span><br><span class="hljs-keyword">var</span> processIndentify <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>•先把套路的代码写了，就是client-go初始化的那部分，以及main方法，里面是整个程序的启动和业务调用流程，可见选主有关的代码都放在名为startLeaderElection的方法中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// initOrDie client有关的初始化操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initOrDie</span><span class="hljs-params">()</span></span> *kubernetes.Clientset &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始初始化kubernetes客户端相关对象&quot;</span>, processIndentify)<br>    <span class="hljs-keyword">var</span> kubeconfig *<span class="hljs-type">string</span><br>    <span class="hljs-keyword">var</span> master <span class="hljs-type">string</span><br><br>    <span class="hljs-comment">// 试图取到当前账号的家目录</span><br>    <span class="hljs-keyword">if</span> home := homedir.HomeDir(); home != <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-comment">// 如果能取到，就把家目录下的.kube/config作为默认配置文件</span><br>        kubeconfig = flag.String(<span class="hljs-string">&quot;kubeconfig&quot;</span>, filepath.Join(home, <span class="hljs-string">&quot;.kube&quot;</span>, <span class="hljs-string">&quot;config&quot;</span>), <span class="hljs-string">&quot;(optional) absolute path to the kubeconfig file&quot;</span>)<br>        master = <span class="hljs-string">&quot;&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果取不到，就没有默认配置文件，必须通过kubeconfig参数来指定</span><br>        flag.StringVar(kubeconfig, <span class="hljs-string">&quot;kubeconfig&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;absolute path to the kubeconfig file&quot;</span>)<br>        flag.StringVar(&amp;master, <span class="hljs-string">&quot;master&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;master url&quot;</span>)<br>        flag.Parse()<br>    &#125;<br><br>    config, err := clientcmd.BuildConfigFromFlags(master, *kubeconfig)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Fatal(err)<br>    &#125;<br><br>    clientset, err := kubernetes.NewForConfig(config)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Fatal(err)<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]kubernetes客户端相关对象创建成功&quot;</span>, processIndentify)<br>    <span class="hljs-keyword">return</span> clientset<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 一次性确定当前进程身份</span><br>    processIndentify = uuid.New().String()<br><br>    <span class="hljs-comment">// 准备一个带cancel的context，这样在主程序退出的时候，可以将停止的信号传递给业务</span><br>    ctx, cancel := context.WithCancel(context.Background())<br>    <span class="hljs-comment">// 这个是用来停止controller的</span><br>    stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br>    <span class="hljs-comment">// 主程序结束的时候，下面的操作可以将业务逻辑都停掉</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">close</span>(stop)<br>        cancel()<br>    &#125;()<br><br>    <span class="hljs-comment">// 初始化clientSet配置，因为是启动阶段，所以必须初始化成功，否则进程退出</span><br>    clientset := initOrDie()<br><br>    <span class="hljs-comment">// 在一个新的协程中执行选主逻辑，以及选主成功的后的逻辑</span><br>    <span class="hljs-keyword">go</span> startLeaderElection(ctx, clientset, stop)<br><br>    <span class="hljs-comment">// 这里可以继续做其他事情</span><br>    klog.Infof(<span class="hljs-string">&quot;选主的协程已经在运行，接下来可以执行其他业务 [%s]&quot;</span>, processIndentify)<br><br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>•最后是选主的代码，如下所示，先创建锁对象，就像分布式锁一样，总要有个key，然后执行leaderelection.RunOrDie方法参与选主，一旦有了结果，OnNewLeader方法会被回调，这时候通过自身id和leader的id比较就知道是不是自己了，另外，当OnStartedLeading被执行的时候，就意味着当前进程就是leader，并且可以立即开始执行只有leader才能做的事情了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// startLeaderElection 选主的核心逻辑代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startLeaderElection</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, stop <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]创建选主所需的锁对象&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 创建锁对象</span><br>    lock := &amp;resourcelock.LeaseLock&#123;<br>        LeaseMeta: metav1.ObjectMeta&#123;<br>            Name:      <span class="hljs-string">&quot;leader-tutorials&quot;</span>,<br>            Namespace: NAMESPACE,<br>        &#125;,<br>        Client: clientset.CoordinationV1(),<br>        LockConfig: resourcelock.ResourceLockConfig&#123;<br>            Identity: processIndentify,<br>        &#125;,<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始选主&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 启动选主操作</span><br>    leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;<br>        Lock:            lock,<br>        ReleaseOnCancel: <span class="hljs-literal">true</span>,<br>        LeaseDuration:   <span class="hljs-number">10</span> * time.Second,<br>        RenewDeadline:   <span class="hljs-number">5</span> * time.Second,<br>        RetryPeriod:     <span class="hljs-number">2</span> * time.Second,<br>        Callbacks: leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]当前进程是leader，只有leader才能执行的业务逻辑立即开始&quot;</span>, processIndentify)<br>                <span class="hljs-comment">// 在这里写入选主成功的代码，</span><br>                <span class="hljs-comment">// 就像抢分布式锁一样，当前进程选举成功的时候，这的代码就会被执行，</span><br>                <span class="hljs-comment">// 所以，在这里填写抢锁成功的业务逻辑吧，本例中就是监听service变化，然后修改pod的label</span><br>                CreateAndStartController(ctx, clientset, &amp;v1.Service&#123;&#125;, <span class="hljs-string">&quot;services&quot;</span>, NAMESPACE, stop)<br>            &#125;,<br>            OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-comment">// 失去了leader时的逻辑</span><br>                klog.Infof(<span class="hljs-string">&quot;[%s]失去leader身份，不再是leader了&quot;</span>, processIndentify)<br>                os.Exit(<span class="hljs-number">0</span>)<br>            &#125;,<br>            OnNewLeader: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span> &#123;<br>                <span class="hljs-comment">// 收到通知，知道最终的选举结果</span><br>                <span class="hljs-keyword">if</span> identity == processIndentify &#123;<br>                    klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，当前进程就是leader&quot;</span>, processIndentify)<br>                    <span class="hljs-comment">// I just got the lock</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，leader是 : [%s]&quot;</span>, processIndentify, identity)<br>            &#125;,<br>        &#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>•上述代码中，请注意LeaderElectionConfig对象的几个重要字段，例如LeaseDuration、RenewDeadline、RetryPeriod这些，是和选主时候的续租、超时、重试相关，需要按照您的实际网络情况进行调整•现在代码写完了，可以开始验证了</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>•这里捋一下验证的步骤</p><p>1.构建项目，生产二进制文件2.执行此二进制文件，启动三个进程3.观察日志，应该有一个进程选举成功，另外两个只会在日志输出选主结果4.修改service资源，再去观察日志，发现leader进程会输出日志，再检查pod的label，发现已经修改5.用ctrl+C命令将leader进程退出，可见另外两个进程会有一个成为新的leader6.再次修改service资源，新的leader会负责更新pod的label</p><p>•接下来开始操作</p><p>1.执行命令go build，对当前工程进行编译构建，得到二进制文件leader-tutorials2.打开三个终端窗口，输入同样的命令.&#x2F;leader-tutorials，选主成功的进程日志如下，之前操作过的残留，所以没有一开始就选主成功，而是等了几秒后才成为leader，一旦成为leader，全量同步service会触发一次pod的更新操作</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/cf656b2b31af8deecf6f3006945138e9.png" alt="Image 44: 在这里插入图片描述"></p><p>•再去看另外两个进程的日志，可见已经识别到leader的身份，于是就没有执行controller的逻辑</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/aca4a7a4b411ea9367898a8bf8243fe0.png" alt="Image 45: 在这里插入图片描述"></p><p>•现在去修改service，用命令kubectl edit service nginx-service -n client-go-tutorials编辑，我这里是给service增加了一个label，如下图所示<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/baf02a2ee6822724c9eef9c0afad8fc9.png" alt="Image 46: 在这里插入图片描述"></p><p>•此刻，leader进程会监听到service变化，下图黄色箭头以下的内容就是处理pod的日志<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/c9616846888ce5759fb84403e098f77f.png" alt="Image 47: 在这里插入图片描述"></p><p>•去看另外两个进程的日志，不会有任何变化，因为controller都没有•执行以下命令查看pod的修改情况(注意pod的名字要从您自己的环境复制)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl describe pod nginx-deployment-78f6b696d9-cr47w -n client-go-tutorials<br></code></pre></td></tr></table></figure><p>•可以看到pod的label有变化，如下图黄色箭头所示，这和上面的leader日志的时间是一致的</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/818ef75c8437ca25ac96894630b5b080.png" alt="Image 48: 在这里插入图片描述"></p><p>•目前leader进程工作正常，再来试试leader进程退出后的情况，用ctrl+C终止leader进程•再去看另外两个进程的日志，发现其中一个成功成为新的leader<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/56e49cc164c374ce25a764dc04a04f50.png" alt="Image 49: 在这里插入图片描述"></p><p>•验证完成，都符合预期•至此，client-go的选主功能实战就完成了，如果您在寻找kubernetes原生的分布式锁方案，希望本篇能给您一些参考</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s-选主</title>
    <link href="/2025/03/27/k8s-%E9%80%89%E4%B8%BB/"/>
    <url>/2025/03/27/k8s-%E9%80%89%E4%B8%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s-选主"><a href="#k8s-选主" class="headerlink" title="k8s-选主"></a>k8s-选主</h1><p>选主是为了在多副本的情况下，避免同一个操作被所有副本分别执行一次（实际只需要执行一次）。</p><p>所以将只需要执行一次的逻辑封装进一个函数，在执行这个函数之前，先进行选主，只有成为leader的副本才会执行该函数。</p><p>实际应用中，可以将自定义的controller逻辑封装起来，只在选主成功的副本里运行controller。其余的副本什么也不做，只是待命而已。这样在leader挂了之后，能快速的切换leader，保证业务逻辑快速恢复。</p><p>转自：<a href="https://qiankunli.github.io/2021/01/13/kubernetes_leader_election.html">https://qiankunli.github.io/2021/01/13/kubernetes_leader_election.html</a></p><p>假设run 是真正的业务逻辑，加入选主逻辑之后，将run挂在 <code>election.RunOrDie</code> 的 OnStartedLeading 回调上。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts">election.RunOrDie(election.LeaderElectionConfig<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">Lock:</span>          rl,<br><span class="hljs-symbol">LeaseDuration:</span> leaseDuration,<br><span class="hljs-symbol">RenewDeadline:</span> renewDuration,<br><span class="hljs-symbol">RetryPeriod:</span>   retryPeriod,<br><span class="hljs-symbol">Callbacks:</span> election.LeaderCallbacks<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">OnStartedLeading:</span> run,<span class="hljs-comment">// 业务逻辑</span><br><span class="hljs-symbol">OnStoppedLeading:</span> func() <span class="hljs-punctuation">&#123;</span><br>log.Fatalf(<span class="hljs-string">&quot;leader election lost&quot;</span>)<br><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;</span>)<br><span class="hljs-comment">// 笔者觉得应该函数封装下，直接 election.RunOrDie(rl,leaseDuration,renewDuration,retryPeriod,run)</span><br></code></pre></td></tr></table></figure><h2 id="选主原理"><a href="#选主原理" class="headerlink" title="选主原理"></a>选主原理</h2><p><strong>leaderelection 主要是利用了k8s API操作的原子性实现了一个分布式锁</strong>，在不断的竞争中进行选举。选中为leader的实体才会执行具体的业务代码。</p><p>代码结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">k8s.io/client-<span class="hljs-keyword">go</span>/tools/leaderelection<br>    /resourcelock<br>        /configmaplock.<span class="hljs-keyword">go</span><br>        /endpointslock.<span class="hljs-keyword">go</span><br>        /<span class="hljs-keyword">interface</span>.<span class="hljs-keyword">go</span>  <span class="hljs-comment">// 定义了锁的操作接口</span><br>        /leaselock.<span class="hljs-keyword">go</span><br>    /leaderelection.<span class="hljs-keyword">go</span><br>    /metrics.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB/leader_election.png" alt="img"></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><a href="http://www.xuyasong.com/?p=2037">K8S 中 scheduler 组件的选主逻辑</a>锁的存在形式：configmap&#x2F;endpoint 的annotation 上，key &#x3D; <code>control-plane.alpha.kubernetes.io/leader</code>， 值对应了 LeaderElectionRecord struct，记录了当前leader 的Identity 以及renewTime</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Endpoints<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">annotations</span>:<br>    <span class="hljs-attribute">control</span>-plane.alpha.kubernetes.io/leader: &#x27;&#123;<span class="hljs-string">&quot;holderIdentity&quot;</span>:<span class="hljs-string">&quot;instance-o24xykos-3_1ad55d32-2abe-49f7-9d68-33ec5eadb906&quot;</span>,<span class="hljs-string">&quot;leaseDurationSeconds&quot;</span>:<span class="hljs-number">15</span>,<span class="hljs-string">&quot;acquireTime&quot;</span>:<span class="hljs-string">&quot;2020-04-23T06:45:07Z&quot;</span>,<span class="hljs-string">&quot;renewTime&quot;</span>:<span class="hljs-string">&quot;2020-04-25T07:55:58Z&quot;</span>,<span class="hljs-string">&quot;leaderTransitions&quot;</span>:<span class="hljs-number">1</span>&#125;&#x27;<br>  <span class="hljs-attribute">creationTimestamp</span>: <span class="hljs-string">&quot;2020-04-22T12:05:29Z&quot;</span><br>  <span class="hljs-attribute">name</span>: kube-scheduler<br>  <span class="hljs-attribute">namespace</span>: kube-system<br>  <span class="hljs-attribute">resourceVersion</span>: <span class="hljs-string">&quot;467853&quot;</span><br>  <span class="hljs-attribute">selfLink</span>: /api/v1/namespaces/kube-system/endpoints/kube-scheduler<br>  <span class="hljs-attribute">uid</span>: f3535807-<span class="hljs-number">0575</span>-<span class="hljs-number">483</span>f-<span class="hljs-number">8471</span>-f8d4fd9eeac6<br></code></pre></td></tr></table></figure><p>“锁”即annotation value 记录了 leader 的一些信息</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&#123;<br>    &quot;holderIdentity&quot;: &quot;instance-o24xykos<span class="hljs-string">-3</span>_1ad55d32<span class="hljs-string">-2</span>abe<span class="hljs-string">-49</span>f7<span class="hljs-string">-9</span>d68<span class="hljs-string">-33</span>ec5eadb906&quot;, <br>    &quot;leaseDurationSeconds&quot;: 15, <br>    &quot;acquireTime&quot;: &quot;2020<span class="hljs-string">-04</span><span class="hljs-string">-23</span>T06:45:07Z&quot;, <br>    &quot;renewTime&quot;: &quot;2020<span class="hljs-string">-04</span><span class="hljs-string">-25</span>T07:55:58Z&quot;, <br>    &quot;leaderTransitions&quot;: 1<br>&#125;<br></code></pre></td></tr></table></figure><p>代码体现</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elm">// k8s.io/client-go/tools/leaderelection/resourcelock/interface.go<br><span class="hljs-keyword">type</span> <span class="hljs-type">Interface</span> interface &#123;<br>// <span class="hljs-type">Get</span> returns the <span class="hljs-type">LeaderElectionRecord</span><br><span class="hljs-type">Get</span>() (*<span class="hljs-type">LeaderElectionRecord</span>, error)<br>// <span class="hljs-type">Create</span> attempts to create a <span class="hljs-type">LeaderElectionRecord</span><br><span class="hljs-type">Create</span>(ler <span class="hljs-type">LeaderElectionRecord</span>) error<br>// <span class="hljs-type">Update</span> will update and existing <span class="hljs-type">LeaderElectionRecord</span><br>    <span class="hljs-type">Update</span>(ler <span class="hljs-type">LeaderElectionRecord</span>) error<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>kubernetes 的 update 是原子的、安全的</strong>：Kubernetes 通过定义资源版本字段实现了乐观并发控制，资源版本 (ResourceVersion)字段包含在 Kubernetes 对象的元数据 (Metadata)中。这个字符串格式的字段标识了对象的内部版本号，其取值来自 etcd 的 modifiedindex，且当对象被修改时，该字段将随之被修改。值得注意的是该字段由服务端维护</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> ObjectMeta <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a   resource or set of resources.Clients must treat these values as opaque and passed unmodified   back to the server.They may only be valid for a particular resource or set of resources.</span><br>    <span class="hljs-comment">// Populated by the system.Read-only.</span><br>    ResourceVersion <span class="hljs-keyword">string</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>所谓的选主，就是看哪个follower能将自己的信息更新到 object 的annotation 上</strong>。</p><h3 id="选主逻辑"><a href="#选主逻辑" class="headerlink" title="选主逻辑"></a>选主逻辑</h3><ol><li>leader 每隔RetryPeriod时间会通过tryAcquireOrRenew续约, 如果续约失败, 还会进行再次尝试. 一直到尝试的总时间超过RenewDeadline后该client就会失去leadership.</li><li>follower 获得leadership需要的等待LeaseDuration 时间.</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// client-go/tools/leaderelection/leaderelection.go</span><br>func <span class="hljs-built_in">RunOrDie</span>(ctx context<span class="hljs-selector-class">.Context</span>, lec LeaderElectionConfig) &#123;<br>le, err := <span class="hljs-built_in">NewLeaderElector</span>(lec)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">if</span> lec<span class="hljs-selector-class">.WatchDog</span> != nil &#123;<br>lec<span class="hljs-selector-class">.WatchDog</span><span class="hljs-selector-class">.SetLeaderElection</span>(le)<br>&#125;<br>le<span class="hljs-selector-class">.Run</span>(ctx)<br>&#125;<br><span class="hljs-comment">// 等待，直到ctx 取消/成为leader再失去leader 后返回</span><br>func (le *LeaderElector) <span class="hljs-built_in">Run</span>(ctx context.Context) &#123;<br>defer <span class="hljs-built_in">func</span>() &#123;<br>runtime<span class="hljs-selector-class">.HandleCrash</span>()<br>le<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.Callbacks</span><span class="hljs-selector-class">.OnStoppedLeading</span>()<br>    &#125;()<br>    <span class="hljs-comment">// 等待，除非成为leader（返回true） 或者ctx 取消（返回false）</span><br><span class="hljs-keyword">if</span> !le<span class="hljs-selector-class">.acquire</span>(ctx) &#123;<br>return <br>&#125;<br>ctx, cancel := context<span class="hljs-selector-class">.WithCancel</span>(ctx)<br>defer <span class="hljs-built_in">cancel</span>()<br>    go le<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.Callbacks</span><span class="hljs-selector-class">.OnStartedLeading</span>(ctx)<span class="hljs-comment">// 执行业务方法</span><br>    <span class="hljs-comment">// 成为leader后周期性续期，如果ctx 取消或失去leader 则立即返回</span><br>le<span class="hljs-selector-class">.renew</span>(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>选主核心逻辑</p><ol><li>没有lock，抢占&#x2F;Create</li><li>已有lock，但是别人的，租约没过期则退出 再试，过期则抢占&#x2F;Update</li><li>已有lock，自己的，续期&#x2F;Update</li></ol><p>函数返回 True 说明本 goroutine 已成功抢占到锁，获得租约合同，成为 leader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> tryAcquireOrRenew() <span class="hljs-type">bool</span> &#123;<br>now := metav1.Now()<br>leaderElectionRecord := rl.LeaderElectionRecord&#123;...&#125;<br><span class="hljs-comment">// 1. obtain or create the ElectionRecord</span><br>oldLeaderElectionRecord, err := le.config.Lock.Get()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 获取锁信息失败则直接返回</span><br><span class="hljs-keyword">if</span> !errors.IsNotFound(err) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        <span class="hljs-comment">// 锁不存在则创建，创建失败则返回</span><br><span class="hljs-keyword">if</span> err = le.config.Lock.Create(leaderElectionRecord); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        <span class="hljs-comment">// 创建lock成功 即第一次选主抢占leader 成功，则返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">// 2. Record obtained, check the Identity &amp; Time</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(oldLeaderElectionRecord.HolderIdentity) &gt; <span class="hljs-number">0</span> &amp;&amp; le.observedTime.Add(le.config.LeaseDuration).After(now.Time) &amp;&amp;!le.IsLeader() &#123; <span class="hljs-comment">// 其他leader 未过期</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 3. We&#x27;re going to try to update. The leaderElectionRecord is set to it&#x27;s default</span><br><span class="hljs-comment">// here. Let&#x27;s correct it before updating.</span><br><span class="hljs-keyword">if</span> le.IsLeader() &#123;<br>leaderElectionRecord.AcquireTime = oldLeaderElectionRecord.AcquireTime<br>leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-comment">// update the lock itself</span><br><span class="hljs-keyword">if</span> err = le.config.Lock.Update(leaderElectionRecord); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过LeaderCallbacks 感知leader 状态变化。回调OnStartedLeading 和 OnNewLeader 都会另起协程执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LeaderCallbacks <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// OnStartedLeading is called when a LeaderElector client starts leading</span><br>    <span class="hljs-comment">// 当选主逻辑退出时，会通过 context 传给OnStartedLeading</span><br>OnStartedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context.Context)</span></span><br><span class="hljs-comment">// OnStoppedLeading is called when a LeaderElector client stops leading</span><br>OnStoppedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// OnNewLeader is called when the client observes a leader that is not the previously observed leader. This includes the first observed leader when the client starts.</span><br>OnNewLeader <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>k8s scheduler 调度器的执行入口是 <code>sched.Run</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// k8s.io/kubernetes/cmd/kube-scheduler/app/server.go</span><br>func <span class="hljs-keyword">Run</span>(ctx context.Context, <span class="hljs-keyword">cc</span> schedulerserverconfig.CompletedConfig, outOfTreeRegistryOptions ...Option) <span class="hljs-keyword">error</span> &#123;<br>    ...<br>    <span class="hljs-comment">// If leader election is enabled, runCommand via LeaderElector until done and exit.</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">cc</span>.LeaderElection != nil &#123;<br>        <span class="hljs-keyword">cc</span>.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: sched.<span class="hljs-keyword">Run</span>,    <span class="hljs-comment">// 本节点成为leader时运行</span><br>            OnStoppedLeading: func() &#123;<br>                klog.Fatalf(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>            &#125;,<br>        &#125;<br>        leaderElector, <span class="hljs-keyword">err</span> := leaderelection.NewLeaderElector(*<span class="hljs-keyword">cc</span>.LeaderElection)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;couldn&#x27;t create leader elector: %v&quot;</span>, <span class="hljs-keyword">err</span>)<br>        &#125;<br>        leaderElector.<span class="hljs-keyword">Run</span>(ctx)<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;lost lease&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 如果未开启选主</span><br>    sched.<span class="hljs-keyword">Run</span>(ctx)<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;finished without leader elect&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>k8s controller-manager 的选主逻辑</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span><br>func <span class="hljs-built_in">Run</span>(c *config<span class="hljs-selector-class">.CompletedConfig</span>, stopCh &lt;-chan struct&#123;&#125;) error &#123;<br>    ...<br>    run := <span class="hljs-built_in">func</span>(ctx context.Context) &#123;<br>        ...<br>    &#125;<br>    ...<br>    rl, err := resourcelock<span class="hljs-selector-class">.New</span>(c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.ResourceLock</span>,...)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>klog<span class="hljs-selector-class">.Fatalf</span>(<span class="hljs-string">&quot;error creating lock: %v&quot;</span>, err)<br>    &#125;<br>    leaderelection<span class="hljs-selector-class">.RunOrDie</span>(context<span class="hljs-selector-class">.TODO</span>(), leaderelection.LeaderElectionConfig&#123;<br>Lock:          rl,<br>LeaseDuration: c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.LeaseDuration</span><span class="hljs-selector-class">.Duration</span>,<br>RenewDeadline: c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.RenewDeadline</span><span class="hljs-selector-class">.Duration</span>,<br>RetryPeriod:   c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.RetryPeriod</span><span class="hljs-selector-class">.Duration</span>,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: run,<br>OnStoppedLeading: <span class="hljs-built_in">func</span>() &#123;<br>klog<span class="hljs-selector-class">.Fatalf</span>(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>&#125;,<br>&#125;,<br>WatchDog: electionChecker,<br>Name:     <span class="hljs-string">&quot;kube-controller-manager&quot;</span>,<br>    &#125;)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>controller-runtime 是k8s 为支持自定义Controller 写的公共库，入口代码即为<code>Controller.Start</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cm *controllerManager)</span></span> Start(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 启动不用选主的任务</span><br>    <span class="hljs-keyword">go</span> cm.startNonLeaderElectionRunnables()<br><span class="hljs-keyword">if</span> cm.resourceLock != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果resourceLock 不为空， 表示需要选主，启动选主逻辑</span><br>err := cm.startLeaderElection()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<br>&#125; <br>    ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cm *controllerManager)</span></span> startLeaderElection() (err <span class="hljs-type">error</span>) &#123;<br>l, err := leaderelection.NewLeaderElector(leaderelection.LeaderElectionConfig&#123;<br>Lock:          cm.resourceLock,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ context.Context)</span></span> &#123;<br>cm.startLeaderElectionRunnables()   <span class="hljs-comment">// 启动需要选主的任务</span><br>&#125;,<br>OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>cm.errSignal.SignalError(fmt.Errorf(<span class="hljs-string">&quot;leader election lost&quot;</span>))<br>&#125;,<br>&#125;,<br>&#125;)<br>ctx, cancel := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-cm.internalStop:<br>cancel()<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>&#125;<br>&#125;()<br><span class="hljs-comment">// Start the leader elector process</span><br><span class="hljs-keyword">go</span> l.Run(ctx)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从示例中可以看到</p><ol><li>选主一般是一次性的，成为leader 后即执行核心业务逻辑，或者说业务逻辑由OnStartedLeading 触发。</li><li>如果成为leader 后失去leader，则主协程执行结束。</li></ol><p>scheduler 和 controller-manager 部署在容器中，所以主协程执行结束后，一般会自动重启。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang实现生产者消费者模型</title>
    <link href="/2025/03/25/golang%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/25/golang%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="golang实现生产者消费者模型"><a href="#golang实现生产者消费者模型" class="headerlink" title="golang实现生产者消费者模型"></a>golang实现生产者消费者模型</h1><p>使用context实现优雅退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">int</span>, jobs <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">500</span>)) * time.Millisecond)<br>job := id*<span class="hljs-number">100</span> + i<br>jobs &lt;- job<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d produced job %d\n&quot;</span>, id, job)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> job, ok := &lt;-jobs:<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d: channel closed\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br>&#125;<br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1000</span>)) * time.Millisecond)<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d processed job %d\n&quot;</span>, id, job)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rand.Seed(time.Now().UnixNano())<br><br><span class="hljs-keyword">const</span> numProducers = <span class="hljs-number">3</span><br><span class="hljs-keyword">const</span> numConsumers = <span class="hljs-number">2</span><br><br>jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>ctx, cancel := context.WithCancel(context.Background())<br><br><span class="hljs-comment">// 启动生产者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= numProducers; i++ &#123;<br><span class="hljs-keyword">go</span> producer(ctx, i, jobs)<br>&#125;<br><br><span class="hljs-comment">// 启动消费者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= numConsumers; i++ &#123;<br><span class="hljs-keyword">go</span> consumer(ctx, i, jobs)<br>&#125;<br><br><span class="hljs-comment">// 运行一段时间后停止</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;Stopping producers and consumers...&quot;</span>)<br>cancel() <span class="hljs-comment">// 发送停止信号</span><br><span class="hljs-built_in">close</span>(jobs) <span class="hljs-comment">// 关闭channel</span><br><br><span class="hljs-comment">// 等待一段时间让goroutine退出</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;All done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang GC</title>
    <link href="/2025/03/25/Golang-GC/"/>
    <url>/2025/03/25/Golang-GC/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GC"><a href="#Golang-GC" class="headerlink" title="Golang GC"></a>Golang GC</h1><p>转自: <a href="https://www.yuque.com/aceld/golang/zhzanb">https://www.yuque.com/aceld/golang/zhzanb</a></p><p>本节为重点章节</p><p><img src="/2025/03/25/Golang-GC/1650786480776-52768cf0-0457-4875-a390-543ed516861f.webp" alt="Image 1: 标题.jpeg"></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV1wz4y1y7Kd">https://www.bilibili.com/video/BV1wz4y1y7Kd</a></p><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><p>Golang在GC的演进过程中也经历了很多次变革，本文将按照一下顺序介绍：</p><ul><li>Go V1.3之前的标记-清除(mark and sweep)算法，缺点</li><li>Go V1.5的三色并发标记法</li><li>Go V1.5的三色标记为什么需要STW</li></ul><p>●Go V1.5的三色并发标记法<br>●Go V1.5的三色标记为什么需要STW<br>●Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )<br>●Go V1.8混合写屏障机制<br>●Go V1.8混合写屏障机制的全场景分析</p><h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>接下来我们来看一下在Golang1.3之前的时候主要用的普通的标记-清除算法，此算法主要有两个主要的步骤：</p><p>●标记(Mark phase)<br>●清除(Sweep phase)</p><p>1 标记清除算法的具体步骤</p><p>第一步，暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。</p><p><img src="/2025/03/25/Golang-GC/1650787873045-d038fe47-4898-4b07-9e16-007bebb6fb9c.webp" alt="Image 2: 44-GC1.png"></p><p>图中表示是程序与对象的可达关系，目前程序的可达对象有对象1-2-3，对象4-7等五个对象。</p><p>第二步, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p><p><img src="/2025/03/25/Golang-GC/1650787891194-883ec541-5f13-4934-9274-080e5f44cf5e.webp" alt="Image 3: 42-GC2.png"></p><p>所以对象1-2-3、对象4-7等五个对象被做上标记。</p><p>第三步,  标记完了之后，然后开始清除未标记的对象. 结果如下。</p><p><img src="/2025/03/25/Golang-GC/1650787913616-ecf21ee2-c247-4401-9d3e-5e2fa278726f.webp" alt="Image 4: 45-GC3.png"></p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。</p><p>第四步, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p><p>以上便是标记-清除（mark and sweep）回收的算法。</p><h2 id="二、-标记-清除-mark-and-sweep-的缺点"><a href="#二、-标记-清除-mark-and-sweep-的缺点" class="headerlink" title="二、 标记-清除(mark and sweep)的缺点"></a>二、 标记-清除(mark and sweep)的缺点</h2><p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。</p><p>●STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)；<br>●标记需要扫描整个heap；<br>●清除数据会产生heap碎片。</p><p>Go V1.3版本之前就是以上来实施的,  在执行GC的基本流程就是首先启动STW暂停，然后执行标记，再执行数据回收，最后停止STW，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1650787936233-9002040d-220b-4af6-8e51-75d7887569b4.webp" alt="Image 5: 53-STW1.png"></p><p>从上图来看，全部的GC时间都是包裹在STW范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围.如下所示</p><p><img src="/2025/03/25/Golang-GC/1650788071197-26a29703-0fb5-43f4-afc5-87a35fc78a4b.webp" alt="Image 6: 54-STW2.png"></p><p>上图主要是将STW的步骤提前了一步，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。</p><p>但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。</p><p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用三色并发标记法来优化这个问题.</p><h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，所谓三色标记法实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？我们来看一下具体的过程。</p><p>第一步 , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035738281-051f7a89-e07f-418c-ad0e-7cb94ef1a3b8.webp" alt="Image 7: 46-GC4.png"></p><p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表，是用来记录目前每个对象的标记颜色分类。这里面需要注意的是，所谓“程序”，则是一些对象的根节点集合。所以我们如果将“程序”展开，会得到类似如下的表现形式，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035821416-b0ad644e-ef8e-440a-bbf4-b9e24a7e0257.webp" alt="Image 8: 47-GC5.jpeg"></p><p>第二步, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035842467-7341846f-6dee-4f8b-ad37-dc9723aa6407.webp" alt="Image 9: 48-GC6.jpeg"></p><p>这里 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p><p>第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035859950-96053775-24f7-4bdc-a1fb-295747055b3e.webp" alt="Image 10: 49-GC7.jpeg"></p><p>这一次遍历是只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7. 而之前的灰色对象1和对象4则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p><p>第四步, 重复第三步, 直到灰色中无任何对象，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035907012-927d6cbc-686b-4f81-a1de-097ac7598a8e.webp" alt="Image 11: 50-GC8.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651035916208-9c293dc0-8988-4180-a9b7-412e2599af0e.webp" alt="Image 12: 51-GC9.jpeg"></p><p>当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p><p>第五步: 回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。 以上我们将全部的白色对象进行删除回收，</p><p><img src="/2025/03/25/Golang-GC/1651035960263-e50436a6-4a3c-48f9-82cb-bb5729d71116.webp" alt="Image 13: 52-GC10.jpeg"></p><p>剩下的就是全部依赖的黑色对象。</p><p>以上便是三色并发标记法，不难看出，我们上面已经清楚的体现三色的特性。但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。</p><p>那么Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p><h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？ 我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?</p><p>我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035994109-83972e84-be65-4950-b9bf-a48b676856a5.webp" alt="Image 14: 55-三色标记问题1.jpeg"></p><p>现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。</p><p><img src="/2025/03/25/Golang-GC/1651036029588-29e317e6-8f92-41ca-a28e-65153913d227.webp" alt="Image 15: 56-三色标记问题2.jpeg"></p><p>与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036292354-f70d8185-66a2-4478-9036-b4de940285c5.webp" alt="Image 16: 57-三色标记问题3.jpeg"></p><p>然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036347628-d63c17c4-7cee-4149-8ce9-13cc11bbd343.webp" alt="Image 17: 58-三色标记问题4.jpeg"></p><p>那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036362636-5a98e196-e1cd-49fc-9542-1cb0772a41c4.webp" alt="Image 18: 59-三色标记问题5.jpeg"></p><p>但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。</p><p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p><p>●条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)<br>●条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色) 如果当以上两个条件同时满足时，就会出现对象丢失现象!</p><p>并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。</p><p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p><h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。  这两种方式就是“强三色不变式”和“弱三色不变式”。</p><p>(1) “强-弱” 三色不变式</p><p>●强三色不变式</p><p>不存在黑色对象引用到白色对象的指针。</p><p><img src="/2025/03/25/Golang-GC/1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654.webp" alt="Image 19: 60-三色标记问题6.jpeg"></p><p>强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><p>●弱三色不变式</p><p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p><p><img src="/2025/03/25/Golang-GC/1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed.webp" alt="Image 20: 61-三色标记问题7.jpeg"></p><p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</p><p>(2)  插入屏障</p><p>具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p><p>满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p>伪码如下:</p><p>场景：</p><p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, 栈和堆. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中.</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="/2025/03/25/Golang-GC/1651036442131-91f36e55-5c94-4931-a140-58ff5627c681.webp" alt="Image 21: 62-三色标记插入写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4.webp" alt="Image 22: 63-三色标记插入写屏障2.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d.webp" alt="Image 23: 64-三色标记插入写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036465710-e260440e-b53d-4f76-a826-842e28666efe.webp" alt="Image 24: 65-三色标记插入写屏障4.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036474130-755abe1f-d070-47e6-93cf-7aa129489206.webp" alt="Image 25: 66-三色标记插入写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982.webp" alt="Image 26: 67-三色标记插入写屏障6.jpeg"></p><p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9).  所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p><p><img src="/2025/03/25/Golang-GC/1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431.webp" alt="Image 27: 68-三色标记插入写屏障7.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8.webp" alt="Image 28: 69-三色标记插入写屏障9.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9.webp" alt="Image 29: 70-三色标记插入写屏障10.jpeg"></p><p>最后将栈和堆空间 扫描剩余的全部 白色节点清除.  这次STW大约的时间在10~100ms间.</p><p><img src="/2025/03/25/Golang-GC/1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b.webp" alt="Image 30: 71-三色标记插入写屏障11.jpeg"></p><p>(3)  删除屏障</p><p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p><p>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p><p>伪代码：</p><p>场景：</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="/2025/03/25/Golang-GC/1651036621717-80ea507c-99a9-4e61-9bde-b4cd33f478f4.webp" alt="Image 31: 72-三色标记删除写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036629775-bc69d08e-c270-46ad-b82b-5ad0d0bdcb64.webp" alt="Image 32: 73-三色标记删除写屏障2.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036637089-52a0fc99-7805-40d0-aee7-4124017e90c8.webp" alt="Image 33: 74-三色标记删除写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036644794-05a69ec6-70c9-44c7-9493-44028ba4df7f.webp" alt="Image 34: 75-三色标记删除写屏障4.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036653171-57e34942-2091-4d76-83f3-0b084ebd577d.webp" alt="Image 35: 76-三色标记删除写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036660503-4f49f494-8ede-45dd-8a4c-bfa5499b307a.webp" alt="Image 36: 77-三色标记删除写屏障6.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036668136-8592bd0f-2210-48d9-b43d-7c4a2e16a287.webp" alt="Image 37: 78-三色标记删除写屏障7.jpeg"></p><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p><p>● 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；● 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。<br>(1) 混合写屏障规则</p><p>具体操作:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p>满足: 变形的弱三色不变式.</p><p>伪代码：</p><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p><p>(2) 混合写屏障的具体场景分析</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p><p>GC开始：扫描栈区，将可达对象全部标记为黑</p><p><img src="/2025/03/25/Golang-GC/1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62.webp" alt="Image 38: 79-三色标记混合写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791.webp" alt="Image 39: 80-三色标记混合写屏障2.jpeg"></p><p>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c.webp" alt="Image 40: 81-三色标记混合写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac.webp" alt="Image 41: 82-三色标记混合写屏障4.jpeg"></p><p>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6.webp" alt="Image 42: 83-三色标记混合写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036785024-0edb665e-7b4b-46e3-b8cf-1d4ff02e73cd.webp" alt="Image 43: 84-三色标记混合写屏障6.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c.webp" alt="Image 44: 85-三色标记混合写屏障7.jpeg"></p><p>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a.webp" alt="Image 45: 86-三色标记混合写屏障8.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036833484-a18064d9-1329-42d7-8687-8a029542e85e.webp" alt="Image 46: 87-三色标记混合写屏障9.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4.webp" alt="Image 47: 88-三色标记混合写屏障10.jpeg"></p><p>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814.webp" alt="Image 48: 89-三色标记混合写屏障11.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62.webp" alt="Image 49: 90-三色标记混合写屏障12.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c.webp" alt="Image 50: 91-三色标记混合写屏障13.jpeg"></p><p>Golang中的混合写屏障满足弱三色不变式，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>你觉得怎么样才是好产品</title>
    <link href="/2025/03/25/%E4%BD%A0%E8%A7%89%E5%BE%97%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E6%98%AF%E5%A5%BD%E4%BA%A7%E5%93%81/"/>
    <url>/2025/03/25/%E4%BD%A0%E8%A7%89%E5%BE%97%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E6%98%AF%E5%A5%BD%E4%BA%A7%E5%93%81/</url>
    
    <content type="html"><![CDATA[<h1 id="如何回答”你觉得怎么样才是好产品”的面试问题"><a href="#如何回答”你觉得怎么样才是好产品”的面试问题" class="headerlink" title="如何回答”你觉得怎么样才是好产品”的面试问题"></a>如何回答”你觉得怎么样才是好产品”的面试问题</h1><p>在程序员面试中被问到”你觉得怎么样才是好产品”时，这是一个展示你技术思维与产品思维结合能力的好机会。以下是一个结构化的回答框架：</p><h2 id="1-从用户角度出发"><a href="#1-从用户角度出发" class="headerlink" title="1. 从用户角度出发"></a>1. 从用户角度出发</h2><p>“我认为一个好产品首先要解决真实用户的痛点。它应该：</p><ul><li>满足目标用户的核心需求（刚需）</li><li>提供简单直观的用户体验</li><li>在使用过程中让用户感到愉悦而不是挫败</li></ul><p>比如Slack之所以成功，就是因为它解决了团队沟通中的信息碎片化问题，而且使用起来非常直观。”</p><h2 id="2-加入技术视角"><a href="#2-加入技术视角" class="headerlink" title="2. 加入技术视角"></a>2. 加入技术视角</h2><p>“从技术实现角度看，好产品还应该具备：</p><ul><li><strong>稳定性</strong>：少崩溃、少bug</li><li><strong>性能</strong>：响应快速，不卡顿</li><li><strong>可扩展性</strong>：能随着用户增长而扩展</li><li><strong>安全性</strong>：保护用户数据和隐私</li></ul><p>例如微信在保证海量用户同时在线时的稳定性表现就非常出色。”</p><h2 id="3-商业可持续性"><a href="#3-商业可持续性" class="headerlink" title="3. 商业可持续性"></a>3. 商业可持续性</h2><p>“好产品还需要具备商业可持续性：</p><ul><li>有清晰的盈利模式</li><li>用户获取成本(CA)低于用户生命周期价值(LTV)</li><li>能形成竞争壁垒</li></ul><p>像Notion通过免费增值模式(Freemium)既获得了大量用户，又实现了盈利。”</p><h2 id="4-数据驱动迭代"><a href="#4-数据驱动迭代" class="headerlink" title="4. 数据驱动迭代"></a>4. 数据驱动迭代</h2><p>“真正的好产品会：</p><ul><li>建立完善的数据指标体系</li><li>通过A&#x2F;B测试持续优化</li><li>根据用户反馈快速迭代</li></ul><p>比如抖音的推荐算法就是通过持续的数据分析和优化，才达到如此精准的个性化推荐。”</p><h2 id="5-结合应聘公司产品"><a href="#5-结合应聘公司产品" class="headerlink" title="5. 结合应聘公司产品"></a>5. 结合应聘公司产品</h2><p>“特别是对于贵公司的产品[XXX]，我认为它很好地体现了这些特质，比如…[具体举例]。如果我有机会加入，我希望能在[某个技术方面]做出贡献，帮助产品变得更好。”</p><h2 id="回答技巧"><a href="#回答技巧" class="headerlink" title="回答技巧"></a>回答技巧</h2><ol><li><strong>结构化表达</strong>：使用清晰的逻辑框架(如上述几点)</li><li><strong>举例说明</strong>：引用知名产品或该公司产品为例</li><li><strong>展现技术深度</strong>：作为程序员，要展示你从技术角度对产品的理解</li><li><strong>适度谦虚</strong>：”这是我目前的理解，当然好产品的标准可能还有很多…”</li><li><strong>关联岗位</strong>：最后可以关联到你应聘的岗位如何帮助打造好产品</li></ol><p>记住，面试官问这个问题不仅是考察你的产品思维，也在观察你的沟通表达能力和逻辑思维能力。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang GMP模型</title>
    <link href="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GMP模型"><a href="#Golang-GMP模型" class="headerlink" title="Golang GMP模型"></a>Golang GMP模型</h1><p>转自：<a href="https://www.yuque.com/aceld/golang/srxd6d">https://www.yuque.com/aceld/golang/srxd6d</a></p><p>本节为重点章节 本章节含视频版:</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650775952013-f19f9c96-b995-42d6-bc9c-8b1e73b602d8.webp" alt="Image 1: GPM封面.png"></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV19r4y1w7Nx">https://www.bilibili.com/video/BV19r4y1w7Nx</a></p><h2 id="一、Golang“调度器”的由来？"><a href="#一、Golang“调度器”的由来？" class="headerlink" title="一、Golang“调度器”的由来？"></a>一、Golang“调度器”的由来？</h2><h3 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代”</p><p>一切的程序只能串行发生。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776039816-a8a5efb6-06be-4984-bfb0-7565c14b0a61.webp" alt="Image 2: 5-单进程操作系统.png"></p><p>早期的单进程操作系统，面临2个问题：</p><p>1.单一的执行流程，计算机只能一个任务一个任务处理。</p><p>2.进程阻塞所带来的CPU时间浪费。</p><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p><h3 id="2-多进程-线程时代有了调度器需求"><a href="#2-多进程-线程时代有了调度器需求" class="headerlink" title="(2)多进程&#x2F;线程时代有了调度器需求"></a>(2)多进程&#x2F;线程时代有了调度器需求</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776059361-384f6fb5-e2b1-4f99-8701-f57694aa8ecb.webp" alt="Image 3: 6-多进程操作系统.png"></p><p>在多进程&#x2F;多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p><p>怎么才能提高CPU的利用率呢？</p><p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776077730-2a6860a3-0466-4df9-925d-9ecd5cb9ad7d.webp" alt="Image 4: 7-cpu切换浪费成本.png"></p><p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p><h3 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3) 协程来提高CPU利用率"></a>(3) 协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。</p><p>大量的进程&#x2F;线程出现了新的问题</p><p>●高内存占用<br>●调度的高消耗CPU</p><p>好了，然后工程师们就发现，其实一个线程分为<strong>“内核态“线程和”用户态“线程</strong>。</p><p><strong>一个“用户态线程”必须要绑定一个“内核态线程”</strong>，但是**CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)**。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776112186-eff4e8b8-8742-44cd-a828-db1653649ee7.webp" alt="Image 5: 8-线程的内核和用户态.png"></p><p>这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”.</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776128796-5b795bfb-3289-4f6b-85a0-f24399dfc79c.webp" alt="Image 6: 9-协程和线程.png"></p><p>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p><p>之后，我们就看到了有3中协程和线程的映射关系：</p><p>N:1关系</p><p>N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上</p><p>缺点：</p><p>●某个程序用不了硬件的多核加速能力<br>●一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776145617-04763b3d-1b15-42c7-9653-cde21bcc98bc.webp" alt="Image 7: 10-N-1关系.png"></p><p>1:1 关系</p><p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，</p><p>缺点：</p><p>●协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776180139-043037ed-cb5b-4c24-9fcf-691a05db17f9.webp" alt="Image 8: 11-1-1.png"></p><p>M:N关系</p><p>M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776193242-4fecd540-5cbb-4f2d-8121-5312dbc6958a.webp" alt="Image 9: 12-m-n.png"></p><p>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p><h3 id="4-Go语言的协程goroutine"><a href="#4-Go语言的协程goroutine" class="headerlink" title="(4) Go语言的协程goroutine"></a>(4) Go语言的协程goroutine</h3><p>Go为了提供更容易使用的并发方法，使用了goroutine和channel。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被runtime调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。</p><p>Goroutine特点：</p><p>●占用内存更小（几kb）<br>●调度更灵活(runtime调度)</p><h3 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5) 被废弃的goroutine调度器"></a>(5) 被废弃的goroutine调度器</h3><p>好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p><p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p><p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776259684-6015cb7b-b33e-47f9-b241-185c57dc2745.webp" alt="Image 10: 13-gm.png"></p><p>下面我们来看看被废弃的golang调度器是如何实现的？</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776272668-ac680807-d927-4c10-9e1d-3960bdabd0e3.webp" alt="Image 11: 14-old调度器.png"></p><p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局G队列是有互斥锁进行保护的。</p><p>老调度器有几个缺点：</p><ol><li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。</li><li>M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol><h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。</p><p>在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776288599-36c23cc6-3d25-4f6f-8f80-83bd43aa6dec.webp" alt="Image 12: 15-gmp.png"></p><p>Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p><h3 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1) GMP模型"></a>(1) GMP模型</h3><p>在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776301442-fb76123c-8d0e-4375-af35-b5728a5b1bc7.webp" alt="Image 13: 16-GMP-调度.png"></p><ol><li>全局队列（Global Queue）：存放等待运行的G。</li><li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li><li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol><p>Goroutine调度器和OS调度器是通过M结合起来的，<strong>每个M都代表了1个内核线程</strong>，OS调度器负责把内核线程分配到CPU的核上执行。</p><p>有关P和M的个数问题</p><p>1、P的数量：</p><p>●由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。</p><p>2、M的数量:</p><p>●go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。<br>●runtime&#x2F;debug中的SetMaxThreads函数，设置M的最大数量<br>●一个M阻塞了，会创建新的M。</p><p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p><p>P和M何时会被创建</p><p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p><p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p><h3 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2) 调度器的设计策略"></a>(2) 调度器的设计策略</h3><p>复用线程：避免频繁的创建、销毁线程，而是对线程的复用。</p><p>1）work stealing机制</p><p>当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p><p>2）hand off机制</p><p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p><p>利用并行：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS &#x3D; 核数&#x2F;2，则最多利用了一半的CPU核进行并行。</p><p>抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p><p>全局G队列：在新的调度器中依然有全局G队列，当P的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过work stealing机制从其他P的本地队列偷取G。</p><h3 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func()  调度流程"></a>(3) go func()  调度流程</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776333419-50d3a922-bd53-4bff-b0b6-280e6abc5d74.webp" alt="Image 14: 18-go-func调度周期.jpeg"></p><p>从上图我们可以分析出几个结论：</p><p>1、我们通过 go func()来创建一个goroutine；</p><p>2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p><p>3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p><p>4、一个M调度G执行的过程是一个循环机制；</p><p>5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在等待执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p><p>6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p><h3 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4) 调度器的生命周期"></a>(4) 调度器的生命周期</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776346389-ab0ffa04-c707-4ec8-a810-0929533fd00c.webp" alt="Image 15: 17-pic-go调度器生命周期.png"></p><p>特殊的M0和G0</p><p>M0</p><p>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p><p>G0</p><p>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p><p>我们来跟踪一段代码</p><p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p><p>也会经历如上图所示的过程：</p><ol><li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li><li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li><li>示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li><li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li><li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li><li>M运行G</li><li>G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</li></ol><p>调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。</p><h3 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5) 可视化GMP编程"></a>(5) 可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据。</p><p>方式1：go tool trace</p><p>trace记录了运行时的信息，能提供可视化的Web页面。</p><p>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p><p>trace.go</p><p>运行程序</p><p>会得到一个trace.out文件，然后我们可以用一个工具打开，来分析这个文件。</p><p>我们可以通过浏览器打开<a href="http://127.0.0.1:33479网址，点击view">http://127.0.0.1:33479网址，点击view</a> trace 能够看见可视化的调度流程。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776395564-f4f1ba06-1af0-4842-a241-8ea7e56b0612.webp" alt="Image 16: 19-go-trace1.png"></p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776402701-9db41a28-ffc9-4702-8cd1-6670f8cd0d28.webp" alt="Image 17: 20-go-trace2.png"></p><p>G信息</p><p>点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776424129-7608477e-4b67-40f3-8782-a0eb346ef8eb.webp" alt="Image 18: 20-go-trace3.png"></p><p>一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p><p>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p><p>M信息</p><p>点击Threads那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776444325-d259c370-0aa5-4650-a5fd-2449190c97a1.webp" alt="Image 19: 22-go-trace4.png"></p><p>一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。</p><p>P信息</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776459340-7053a162-0e39-4955-b0e6-d4714171be3a.webp" alt="Image 20: 23-go-trace5.png"></p><p>G1中调用了main.main，创建了trace goroutine g18。G1运行在P1上，G18运行在P0上。</p><p>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。</p><p>我们在来看看上面的M信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776484643-1c8841a4-01a1-4948-a8a7-616678fb5317.webp" alt="Image 21: 24-go-trace6.png"></p><p>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776494915-1d38f0bf-cbd8-4958-ae55-1144a86e50a2.webp" alt="Image 22: 25-go-trace7.png"></p><p>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p><p>方式2：Debug trace</p><p>编译</p><p>通过Debug方式运行</p><p>●SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；<br>●0ms：即从程序启动到输出这行日志的时间；<br>●gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；<br>●idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；<br>●threads: os threads&#x2F;M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；<br>●spinningthreads: 处于自旋状态的os thread数量；<br>●idlethread: 处于idle状态的os thread的数量；<br>●runqueue&#x3D;0： Scheduler全局队列中G的数量；<br>●[0 0]: 分别为2个P的local queue中的G的数量。</p><p>下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。</p><h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><p>(1)场景1</p><p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P的本地队列。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776522560-a33b69e2-2842-4132-8cbe-f2bad017bc7e.webp" alt="Image 23: 26-gmp场景1.png"></p><p>(2)场景2</p><p>G1运行完成后(函数：goexit)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：schedule）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了线程M1的复用。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776536644-c6fba007-d952-4a22-8939-ca1a898a5c3c.webp" alt="Image 24: 27-gmp场景2.png"></p><p>(3)场景3</p><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776549767-57ceac17-5504-46ac-af56-0dba59359e8b.webp" alt="Image 25: 28-gmp场景3.png"></p><p>(4)场景4</p><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列)</p><p>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776570176-d9d5abd4-3a48-461c-a43c-6ef504c4038f.webp" alt="Image 26: 29-gmp场景4.png"></p><p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。<br>(5)场景5</p><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776584395-dfb9c26b-b0a8-4c17-b46e-649302df87d5.webp" alt="Image 27: 30-gmp场景5.png"></p><p>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。<br>(6)场景6</p><p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776600276-58bdcec4-00e6-4f24-89c8-e4f01fd1d9fb.webp" alt="Image 28: 31-gmp场景6.png"></p><p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程（没有G但为运行状态的线程，不断寻找G）。<br>(7)场景7</p><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。M2从全局队列取的G数量符合下面的公式：</p><p>相关源码参考:</p><p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是从全局队列到P本地队列的负载均衡。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776688586-9207de08-5203-403f-8857-42942e84dcb1.webp" alt="Image 29: 32-gmp场景7.001.jpeg"></p><p>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。<br>(8)场景8</p><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777780659-cef000df-3d46-4fd5-b0ed-3dc466bf1cd2.webp" alt="Image 30: 33-gmp场景8.png"></p><p>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。<br>(9)场景9</p><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777794441-a7ed7fc2-e495-4022-a3b6-581930e5acd0.webp" alt="Image 31: 34-gmp场景9.png"></p><p>为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们希望当有新goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程(当前例子中的GOMAXPROCS&#x3D;4，所以一共4个P)，多余的没事做线程会让他们休眠。<br>(10)场景10</p><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;&#x3D;P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777810926-ca4030f3-f29a-4211-8722-677b229be440.webp" alt="Image 32: 35-gmp场景10.png"></p><p>(11)场景11</p><p>G8创建了G9，假如G8进行了非阻塞系统调用。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777823944-25f0ea1a-3431-457e-b4cf-342654a953b6.webp" alt="Image 33: 36-gmp场景11.png"></p><p>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go Map</title>
    <link href="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Map"><a href="#Go-Map" class="headerlink" title="Go Map"></a>Go Map</h1><p>map 是一种key-value的键值对存储结构，其中key不能重复，底层用<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=hash%E8%A1%A8&zhida_source=entity">hash表</a>存储。</p><p>平日里我们一般是这样使用map的：</p><blockquote><p>&#x2F;&#x2F; 创建<br>&#x2F;&#x2F; map[KeyType]ValueType<br>var m map[int]int<br>m :&#x3D; make(map[int]int)<br>m :&#x3D; map[int]int{<br>1: 1,<br>2: 2,<br>}<br>&#x2F;&#x2F; 读取<br>i :&#x3D; m[1]<br>v, ok :&#x3D; m[1]<br>​<br>&#x2F;&#x2F; 遍历<br>for key, value :&#x3D; range m {<br>println(“Key: “, key, “Value: “, value)<br>}<br>​<br>&#x2F;&#x2F; 删除<br>delete(m, 1)</p></blockquote><p>map的数据结构在源码结构中的关键字段如下，在<code>src/runtime/map.go</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    count     <span class="hljs-type">int</span>    <span class="hljs-comment">// 元素的个数</span><br>    B         <span class="hljs-type">uint8</span>  <span class="hljs-comment">// buckets 数组的长度就是 2^B 个</span><br>    overflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// 溢出桶的数量</span><br><br>    buckets    unsafe.Pointer <span class="hljs-comment">// 2^B个桶对应的数组指针</span><br>    oldbuckets unsafe.Pointer  <span class="hljs-comment">// 发生扩容时，记录扩容前的buckets数组指针</span><br><br>    extra *mapextra <span class="hljs-comment">//用于保存溢出桶的地址</span><br>&#125;<br><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>    overflow    *[]*bmap<br>    oldoverflow *[]*bmap<br><br>    nextOverflow *bmap<br>&#125;<br><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br><br><span class="hljs-comment">//在编译期间会产生新的结构体</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存储哈希值的高8位</span><br>    data    <span class="hljs-type">byte</span>[<span class="hljs-number">1</span>]  <span class="hljs-comment">//key value数据:key/key/key/.../value/value/value...</span><br>    overflow *bmap   <span class="hljs-comment">//溢出bucket的地址</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了便于理解源码的结构，我们提炼关键字段并转换为图形模式：</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-a8fbef952441e788d882d0656c2cf091_1440w.jpg" alt="img"></p><p>在go的map实现中，它的底层结构体是hmap，hmap里维护着若干个bucket数组 (即桶数组)。</p><p>Bucket数组中每个元素都是bmap结构，也即每个bucket（桶）都是bmap结构，【ps：后文为了语义一致，和方便理解，就不再提bmap了，统一叫作桶】 每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶(溢出桶)。</p><h2 id="map中数据操作"><a href="#map中数据操作" class="headerlink" title="map中数据操作"></a><strong>map中数据操作</strong></h2><p>了解了map的数据结构后，下面让我们学习一下在map中存取数据的过程：</p><h3 id="GET获取数据"><a href="#GET获取数据" class="headerlink" title="GET获取数据"></a><strong>GET获取数据</strong></h3><p><strong>假设当前 B&#x3D;4 即桶数量为2^B&#x3D;16个</strong>，要从map中获取k4对应的value</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>参考上图，k4的get流程可以归纳为如下几步：</strong></p><p>①<strong>计算k4的hash值</strong>。[由于当前主流机都是64位操作系统，所以计算结果有64个比特位]</p><p>②<strong>通过最后的“B”位来确定在哪号桶</strong>，此时B为4，所以取k4对应哈希值的后4位，也就是0101，0101用十进制表示为5，所以在5号桶）</p><p>③<strong>根据k4对应的hash值前8位快速确定是在这个桶的哪个位置</strong>（额外说明一下，在bmap中存放了每个key对应的tophash，是key的哈希值前8位),一旦发现前8位一致，则会执行下一步</p><p>④<strong>对比key完整的hash是否匹配</strong>，如果匹配则获取对应value</p><p>⑤<strong>如果都没有找到，就去连接的下一个溢出桶中找</strong></p><p>有很多同学会问这里为什么要多维护一个tophash，即hash前8位？</p><p>这是因为tophash可以快速确定key是否正确，也可以把它理解成一种缓存措施，如果前8位都不对了，后面就没有必要比较了。</p><h3 id="PUT存放数据"><a href="#PUT存放数据" class="headerlink" title="PUT存放数据"></a><strong>PUT存放数据</strong></h3><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>map的赋值流程可总结位如下几步：</strong></p><p>①<strong>通过key的hash值后“B”位确定是哪一个桶</strong>，图中示例为4号桶。</p><p>② 遍历当前桶，通过key的tophash和hash值，防止key重复，然后<strong>找到第一个可以插入的位置</strong>，即空位置处存储数据。</p><p>③如果<strong>当前桶元素已满，会通过overflow链接创建一个新的桶</strong>，来存储数据。</p><p><strong>关于hash冲突</strong>：当两个不同的 key 落在同一个桶中，就是发生了哈希冲突。冲突的解决手段是采用链表法：在 桶 中，从前往后找到第一个空位进行插入。如果8个kv满了，那么当前桶就会连接到下一个溢出桶（bmap）。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a><strong>扩容</strong></h3><h3 id="扩容的方式"><a href="#扩容的方式" class="headerlink" title="扩容的方式"></a><strong>扩容的方式</strong></h3><p>扩容有两种，一种是等量扩容，另一种是2倍扩容</p><ul><li><strong>相同容量扩容</strong></li></ul><p>由于map中不断的put和delete key，桶中可能会出现很多断断续续的空位，这些空位会导致连接的bmap溢出桶很长，导致扫描时间边长。这种扩容实际上是一种整理，把后置位的数据整理到前面。<strong>这种情况下，元素会发生重排，但不会换桶。</strong></p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-2ecbb8a8c52d395061f67e41620b1504_1440w.jpg" alt="img"></p><p>img</p><ul><li><strong>2倍容量扩容</strong></li></ul><p>这种2倍扩容是由于当前桶数组确实不够用了，<strong>发生这种扩容时，元素会重排，可能会发生桶迁移</strong>。</p><p>如图中所示，扩容前B&#x3D;2,扩容后B&#x3D;3，假设一元素key的hash值后三位为101，那么由上文的介绍可知，在扩容前，由hash值的后两位来决定几号桶，即 01 所以元素在1号桶。 在扩容发生后，由hash值得后三位来决定几号桶，即101所以元素会迁移到5号桶。</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-d38e6d960012d58d4192f904985a4ca1_1440w.jpg" alt="img"></p><p>img</p><h2 id="发生扩容的条件"><a href="#发生扩容的条件" class="headerlink" title="发生扩容的条件"></a><strong>发生扩容的条件</strong></h2><p>首先我们了解下**<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90&zhida_source=entity">装载因子</a>(loadFactor)**的概念</p><p>loadFactor:&#x3D;count &#x2F; (2^B) 即 装载因子 &#x3D; map中元素的个数 &#x2F; map中当前桶的个数</p><p>通过计算公式我们可以得知，<strong>装载因子是指当前map中，每个桶中的平均元素个数。</strong></p><p><strong>扩容条件1</strong>：<strong>装载因子 &gt; 6.5</strong> (源码中定义的)</p><p>这个也非常容易理解，正常情况下，如果没有溢出桶，那么一个桶中最多有8个元素，当平均每个桶中的数据超过了6.5个，那就意味着当前容量要不足了，发生扩容。</p><p><strong>扩容条件2</strong>: <strong>溢出桶的数量过多</strong></p><p>当 B &lt; 15 时，如果overflow的bucket数量超过 2^B。</p><p>当 B &gt;&#x3D; 15 时，overflow的bucket数量超过 2^15。</p><p>简单来讲，新加入key的hash值后B位都一样，使得个别桶一直在插入新数据，进而导致它的溢出桶链条越来越长。如此一来，当map在操作数据时，扫描速度就会变得很慢。及时的扩容，可以对这些元素进行重排，使元素在桶的位置更平均一些。</p><p><strong>扩容时的细节</strong></p><ol><li>在我们的hmap结构中有一个oldbuckets吗，扩容刚发生时，会先将老数据存到这个里面。</li><li>每次对map进行删改操作时，会触发从oldbucket中迁移到bucket的操作【非一次性，分多次】</li><li>在扩容没有完全迁移完成之前，每次get或者put遍历数据时，都会先遍历oldbuckets，然后再遍历buckets。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><p><strong>map是线程不安全的</strong></p><p>在同一时间点，两个 <a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=goroutine&zhida_source=entity">goroutine</a> 对同一个map进行读写操作是不安全的。举个栗子：</p><p>某map桶数量为4，即B&#x3D;2。此时 goroutine1来插入key1， goroutine2来读取 key2. 可能会发生如下过程：</p><p>① goroutine2 计算key2的hash值,B&#x3D;2，并确定桶号为1。</p><p>② goroutine1添加key1，触发扩容条件。</p><p>③ B&#x3D;B+1&#x3D;3, buckets数据迁移到oldbuckets。</p><p>④ goroutine2从桶1中遍历，获取数据失败。</p><p>在工作中，当我们涉及到对一个map进行并发读写时，一般采用的做法是采用golang中自带的<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=mutex%E9%94%81&zhida_source=entity">mutex锁</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">struct</span> &#123;<br>    sync.RWMutex<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := Resource&#123;m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine写map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.Lock()<br>            r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)] = j<br>            r.Unlock()<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine读map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.RLock()<br>            fmt.Println(r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)])<br>            r.RUnlock()<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对map数据进行操作时不可取地址</li></ul><p>因为随着map元素的增长，map底层重新分配空间会导致之前的地址无效。</p><p>[<a href="https://zhuanlan.zhihu.com/p/495998623#ref_1">1]</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/495998623#ref_1_0">^</a>Map <a href="https://juejin.cn/post/7029679896183963678#heading-1">https://juejin.cn/post/7029679896183963678#heading-1</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.jpg" alt="排序算法"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums<br>    &#125;<br>    <span class="hljs-comment">// 冒泡排序核心实现代码</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        flag := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(nums) - i - <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>] &#123;<br>                nums[j], nums[j+<span class="hljs-number">1</span>] = nums[j+<span class="hljs-number">1</span>], nums[j]<br>                flag = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !flag &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br>    nums = bubbleSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.webp" alt="冒泡排序"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(list []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pivot := list[low] <span class="hljs-comment">//导致 low 位置值为空</span><br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        <span class="hljs-comment">//high指针值 &gt;= pivot high指针👈移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &lt;= list[high] &#123;<br>            high--<br>        &#125;<br>        <span class="hljs-comment">//填补low位置空值</span><br>        <span class="hljs-comment">//high指针值 &lt; pivot high值 移到low位置</span><br>        <span class="hljs-comment">//high 位置值空</span><br>        list[low] = list[high]<br>        <span class="hljs-comment">//low指针值 &lt;= pivot low指针👉移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &gt;= list[low] &#123;<br>            low++<br>        &#125;<br>        <span class="hljs-comment">//填补high位置空值</span><br>        <span class="hljs-comment">//low指针值 &gt; pivot low值 移到high位置</span><br>        <span class="hljs-comment">//low位置值空</span><br>        list[high] = list[low]<br>    &#125;<br>    <span class="hljs-comment">//pivot 填补 low位置的空值</span><br>    list[low] = pivot<br>    <span class="hljs-keyword">return</span> low<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(list []<span class="hljs-type">int</span>,low,high <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> high &gt; low&#123;<br>        <span class="hljs-comment">//位置划分</span><br>        pivot := partition(list,low,high)<br>        <span class="hljs-comment">//左边部分排序</span><br>        QuickSort(list,low,pivot<span class="hljs-number">-1</span>)<br>        <span class="hljs-comment">//右边排序</span><br>        QuickSort(list,pivot+<span class="hljs-number">1</span>,high)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestQuickSort</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    list := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">44</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">33</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>,<span class="hljs-number">54</span>,<span class="hljs-number">9</span>&#125;<br>    QuickSort(list,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(list)<span class="hljs-number">-1</span>)<br>    t.Log(list)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quick_sort_partition_animation.gif" alt="快速排序"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入url后发生了什么</title>
    <link href="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器输入url后发生了什么"><a href="#浏览器输入url后发生了什么" class="headerlink" title="浏览器输入url后发生了什么"></a>浏览器输入url后发生了什么</h2><h3 id="1-输入地址"><a href="#1-输入地址" class="headerlink" title="1. 输入地址"></a>1. 输入地址</h3><p>浏览器从历史记录，书签中智能匹配url，甚至从缓存中直接把网页展示出来。</p><h3 id="2-浏览器查找域名对应的IP地址"><a href="#2-浏览器查找域名对应的IP地址" class="headerlink" title="2. 浏览器查找域名对应的IP地址"></a>2. 浏览器查找域名对应的IP地址</h3><ol><li><p>查找本地硬盘的hosts文件，如果有的话直接使用hosts文件中的ip地址。</p></li><li><p>如果hosts文件中没有，则向本地DNS服务器发送请求。本地DNS服务器一般是网络接入供应商提供，比如中国电信，中国移动。</p></li><li><p>本地DNS服务器查缓存，有的话就直接返回。</p></li><li><p>本地DNS服务器缓存没有命中的话，向根服务器查询。</p></li><li><p>根服务器提供下一层级服务器地址。</p></li><li><p>迭代查询直到查询到IP地址。</p></li><li><p>本地DNS服务器向浏览器返回IP地址，并将IP地址记录在自己的缓存中，已备下次使用。</p></li></ol><h3 id="3-浏览器跟web服务器建立TCP连接"><a href="#3-浏览器跟web服务器建立TCP连接" class="headerlink" title="3. 浏览器跟web服务器建立TCP连接"></a>3. 浏览器跟web服务器建立TCP连接</h3><p>通过TCP三次握手，建立连接。</p><h3 id="4-浏览器发送HTTP请求"><a href="#4-浏览器发送HTTP请求" class="headerlink" title="4. 浏览器发送HTTP请求"></a>4. 浏览器发送HTTP请求</h3><p>请求信息包含三个部分：</p><ul><li>请求方法URI协议&#x2F;版本</li><li>请求头(Request Header)</li><li>请求正文</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span>/sample.jspHTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Accept</span>:image/gif.image/jpeg,*/*<br><span class="hljs-attribute">Accept</span>-Language:zh-cn<br><span class="hljs-attribute">Connection</span>:Keep-Alive<br><span class="hljs-attribute">Host</span>:localhost<br><span class="hljs-attribute">User</span>-Agent:Mozila/<span class="hljs-number">4</span>.<span class="hljs-number">0</span>(compatible;MSIE5.<span class="hljs-number">01</span>;Window NT5.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">Accept</span>-Encoding:gzip,deflate<br><br><span class="hljs-attribute">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>TCP三次握手</p><ol><li><p>第一次握手：</p><p>客户端生成数据包：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">SYN</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">seq</span> <span class="hljs-operator">=</span> J (随机生成一个数J)<br></code></pre></td></tr></table></figure><p>发送出数据包后，客户端进入SYN_SENT状态，等待服务端确认。</p></li><li><p>第二次握手：</p><p>服务端收到数据包，生成返回数据包：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">SYN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = K (随机生成一个数K)<br><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = J + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>发送出数据包后，服务端进入SYN_RCVD状态。</p></li><li><p>第三次握手：</p><p>客户端收到数据包，检查ack是否为J+1，ACK是否为1。若正确，则生成数据包：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = K + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>将数据包发出，客户端进入ESTABLISHED状态。</p><p>服务端收到数据包后，检查ack是否为K+1，ACK是否为1。若正确，服务端进入ESTABLISHED状态。</p></li><li><p>完成三次握手，开始传输数据。</p></li></ol><p><img src="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p>为什么需要三次握手</p><p>主要是为了防止服务端一直等待，浪费资源。</p><p>假设没有三次握手，客户端发出的连接请求在网络中滞留了，客户端超时已经释放了连接。服务端接收到请求后，发出确认。确认发出后连接就建立了，服务端就会一直等待客户端发来数据，而客户端实际已经释放了连接，收到确认后不会理睬，这将导致服务端浪费资源。</p><p>TCP四次挥手</p><ol><li><p>第一次挥手：</p><p>客户端发送FIN，用来关闭客户端到服务端的数据传输，客户端进入FIN_WAIT_1状态</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">FIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">seq</span> <span class="hljs-operator">=</span> x<br><span class="hljs-attribute">ack</span> <span class="hljs-operator">=</span> y<br></code></pre></td></tr></table></figure></li><li><p>第二次挥手：</p><p>服务端收到FIN，发送一个ACK给客户端，服务端进入CLOSE_WAIT状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = y<br><span class="hljs-attr">ack</span> = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>客户端收到ACK，进入FIN_WAIT_2状态。</p></li><li><p>第三次挥手：</p><p>服务端处理完剩余数据后，也向客户端发送FIN，服务端进入LAST_ACK状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">FIN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = y<br><span class="hljs-attr">ack</span> = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>第四次挥手：</p><p>客户端收到FIN，发送一个ACK给服务端，客户端进入TIME_WAIT状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = x + <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = y + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>服务端收到ACK，进入CLOSE状态。</p><p><img src="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中的byte类型和rune类型</title>
    <link href="/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.cnblogs.com/wjaaron/p/14822799.html">https://www.cnblogs.com/wjaaron/p/14822799.html</a></p><p>Go 语言中定义字符串要用双引号，而不是单引号，单引号中只能包含一个元素，表示一个字符。</p><p>Go语言中字符有两种类型，分别是：</p><p>uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符<br>rune 类型，代表一个 UTF-8 字符<br>了解编码知识的应该知道，ASCII 编码字符是1个字节的，而 UTF-8 是可变长的编码，当要表示中文等非 ASCll 编码的字符时，需要使用 UTF-8 编码来保证不会乱码。关于字符编码相关知识，推荐看这篇廖雪峰的介绍 字符编码</p><p>假如我们要遍历输出一个包含中文的字符串时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Println(str[i])<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的打印结果是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">104<br>101<br>108<br>108<br>111<br>32<br>228<br>184<br>150<br>231<br>149<br>140<br></code></pre></td></tr></table></figure><p>Go 语言字符串存储的其实是类型为 byte 的只读切片，或者说一个字符串就是一堆字节。在 UTF-8 编码中一个英文字符可以用一个字节存储，一个中文字符需要三个或四个字节存储，而 ASCII 码符号只有 128 个，大于 128 的都不在范围内。上述代码的遍历方式就是以 ASCII 类型来读字符的。</p><p>可以看到输出结果中的前 6 个都是在 ASCII 表中的，但是后 6 个就不在表中了，后面 6 个的每一个字节都不能单独表示一个字符，而是用 3 个在一起才能表示一个字符，明显超出了 ASCII 表的范围，所以当打印具体字符时就会乱码，比如我们现在来打印每一个真实字符，需要使用到占位符 %c：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, str[i]) <span class="hljs-comment">// hello ä¸ç</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello ä¸ç<br></code></pre></td></tr></table></figure><p>明显乱码了。解释这么多就是为了说明如果字符串中有非 ASCII 码的字符时，就不能使用 byte 来表示字符，需要使用 rune 类型来表示。</p><p>使用 rune 类型来遍历字符串<br>在 Go 中，有一个遍历方式是 range，它默认就是以 UTF-8 编码形式去读每一个字符。当涉及到的字符串中含有非英文字符时，可以使用 range 来遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> str &#123;<br>  fmt.Println(r)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">104<br>101<br>108<br>108<br>111<br>32<br>19990<br>30028<br></code></pre></td></tr></table></figure><p>此时输出的字节编码就是 UTF-8 编码号，UTF-8 编码是包含 ASCII 编码的，所以前 6 个编号还是一样的，后面两个编号分别代表世，界。</p><p>修改字符串<br>Go 语言中对字符串的修改其实不是对字符串本身的修改，而是复制字符串，同时修改值，即重新分配来内存，需要先将字符串转化成数组，[]byte 或 []rune，然后再转换成 string 型。</p><p>那么我要说的也很明显了，就是要区别使用 []byte 或 []rune。</p><p>对于全是ASCII编码的字符串，使用 []byte 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;abc&quot;</span><br> s2 := []<span class="hljs-type">byte</span>(str)<br> s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span><br> fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//bbc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; string()表示强制类型转换，转换为字符串<br>对于包含中文等字符的字符串时，那就要用 []rune 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    str:=<span class="hljs-string">&quot;白猫&quot;</span><br>    s2:=[]<span class="hljs-type">rune</span>(str)<br>    s2[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;黑&#x27;</span><br>    fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//黑猫</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结<br>在处理字符时，要考虑字符的编码范围，然后根据需要使用 byte 类型或 rune类型。</p><p>byte 类型只能正常输出 ASCII 编码范围的字符；rune 类型可以输出 UTF-8 编码范围的字符。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang并发编程</title>
    <link href="/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="goroutine的使用"><a href="#goroutine的使用" class="headerlink" title="goroutine的使用"></a>goroutine的使用</h2><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。<br>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。<br>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> hello() <span class="hljs-comment">// 启动另外一个goroutine去执行hello函数</span><br>    fmt.Println(<span class="hljs-string">&quot;main goroutine done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h2><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// goroutine结束就登记-1</span><br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 启动一个goroutine就登记+1</span><br>        <span class="hljs-keyword">go</span> hello(i)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 等待所有登记的goroutine都结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p><h2 id="注意退出"><a href="#注意退出" class="headerlink" title="注意退出"></a>注意退出</h2><p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大纲</title>
    <link href="/2024/12/05/%E5%A4%A7%E7%BA%B2/"/>
    <url>/2024/12/05/%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol><li>为什么对slice append时，要用原来的变量来接收<br>s &#x3D; append(s, 1)</li></ol><p>因为append是一个函数，函数的传参是值拷贝，传进去的s在函数内部已经是另一个s了，而函数外部原来的s.len并不会被改变，所以要用函数返回的新s来覆盖原来的s</p><p>go内存管理<br>go协程原理<br>go并发编程<br>go网络编程</p><p>gin框架</p><p>context包</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>namespace</p><p>cgroups</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p>list-watch 底层原理</p><p>helm chart</p><p>pod创建全链路分析</p><p>k8s集群部署实战</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>socket编程</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>测试文章图片：<br><img src="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.jpg" alt="测试"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/20/hello-world/"/>
    <url>/2024/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
