<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kubebuilder创建operator流程</title>
    <link href="/2025/09/16/kubebuilder%E5%88%9B%E5%BB%BAoperator%E6%B5%81%E7%A8%8B/"/>
    <url>/2025/09/16/kubebuilder%E5%88%9B%E5%BB%BAoperator%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="开发流程详解（以-Kubebuilder-为例）"><a href="#开发流程详解（以-Kubebuilder-为例）" class="headerlink" title="开发流程详解（以 Kubebuilder 为例）"></a>开发流程详解（以 Kubebuilder 为例）</h3><p>我们将通过一个简单的例子来说明：开发一个名为 <code>Guestbook</code> 的 Operator。用户创建一个 <code>Guestbook</code> 资源时，Operator 会自动为我们部署一个 Redis 主实例和一个 Redis 从实例。</p><h4 id="阶段一：环境准备"><a href="#阶段一：环境准备" class="headerlink" title="阶段一：环境准备"></a>阶段一：环境准备</h4><ol><li><strong>安装必备工具</strong>：<ul><li><code>go</code>： Golang 开发环境。</li><li><code>docker</code>： 用于构建 Operator 的容器镜像。</li><li><code>kubectl</code>： 与 Kubernetes 集群交互。</li><li><code>kustomize</code>： Kubebuilder 用来配置部署 YAML 的工具（通常包含在 <code>kubebuilder</code> 安装包中）。</li><li>**<code>kubebuilder</code>**： 核心框架工具。跟随<a href="https://github.com/kubernetes-sigs/kubebuilder">官方文档</a>安装。</li></ul></li><li><strong>准备一个 Kubernetes 集群</strong>：<ul><li>可以使用 Minikube、Kind（Docker in Docker）或任何开发测试集群。</li></ul></li></ol><h4 id="阶段二：初始化项目"><a href="#阶段二：初始化项目" class="headerlink" title="阶段二：初始化项目"></a>阶段二：初始化项目</h4><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建项目目录并进入</span><br><span class="hljs-built_in">mkdir</span> guestbook-operator<br><span class="hljs-built_in">cd</span> guestbook-operator<br><br><span class="hljs-comment"># 使用 go mod 初始化项目</span><br>go mod init guestbook-operator<br><br><span class="hljs-comment"># 使用 kubebuilder 初始化项目脚手架</span><br><span class="hljs-comment"># 参数说明：--domain 指定 API 组，所有 API 都将属于这个域</span><br><span class="hljs-comment">#          --repo 指定 go mod 的模块名</span><br>kubebuilder init --domain my.domain.com --repo guestbook-operator<br></code></pre></td></tr></table></figure><p>这个命令会生成大量的项目基础文件，包括 <code>main.go</code>（Operator 的入口）、<code>go.mod</code> 依赖管理、以及基本的 <code>Makefile</code> 用于构建和部署。</p><h4 id="阶段三：创建-API（定义-CRD）"><a href="#阶段三：创建-API（定义-CRD）" class="headerlink" title="阶段三：创建 API（定义 CRD）"></a>阶段三：创建 API（定义 CRD）</h4><p>这是最关键的一步，我们在这里定义自定义资源 <code>Guestbook</code> 的“模样”。</p><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个新的 API（Kind）和控制器</span><br><span class="hljs-comment"># 参数说明：--group 指定API组（webapp），--version 指定版本（v1），--kind 指定资源类型（Guestbook）</span><br><span class="hljs-comment">#          --plural 指定资源复数形式（可选，通常框架会自动生成）</span><br>kubebuilder create api --group webapp --version v1 --kind Guestbook<br></code></pre></td></tr></table></figure><p>执行这个命令后，它会问你两个问题：</p><ol><li><code>Create Resource [y/n]</code>? <strong>y</strong> (我们要创建资源)</li><li><code>Create Controller [y/n]</code>? <strong>y</strong> (我们也要创建控制器)</li></ol><p><strong>完成后，你需要修改生成的文件来定义你的 API 结构：</strong></p><p>主要修改的文件是 <code>api/v1/guestbook_types.go</code>。这里我们为 <code>Guestbook</code> 资源添加 <code>Spec</code>（期望的状态）和 <code>Status</code>（实际的状态）。</p><p>go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// api/v1/guestbook_types.go</span><br><span class="hljs-keyword">package</span> v1<br><br><span class="hljs-keyword">import</span> (<br>metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>)<br><br><span class="hljs-comment">// 编辑这个文件！这是你的专属API。</span><br><span class="hljs-comment">// 注意：json 标签是必须的。任何你添加的任何字段都必须有 json 标签。</span><br><br><span class="hljs-comment">// GuestbookSpec 定义了用户的期望状态（Desired State）</span><br><span class="hljs-keyword">type</span> GuestbookSpec <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// +kubebuilder:validation:Minimum=1</span><br><span class="hljs-comment">// +kubebuilder:validation:Maximum=10</span><br><span class="hljs-comment">// Replicas 是 Redis 从实例的数量</span><br>Replicas *<span class="hljs-type">int32</span> <span class="hljs-string">`json:&quot;replicas,omitempty&quot;`</span><br><br><span class="hljs-comment">// 可以添加更多字段，例如：</span><br><span class="hljs-comment">// Image string `json:&quot;image,omitempty&quot;`</span><br><span class="hljs-comment">// Resources ResourceRequirements `json:&quot;resources,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// GuestbookStatus 定义了观察到的实际状态（Actual State）</span><br><span class="hljs-comment">// 由控制器更新和维护</span><br><span class="hljs-keyword">type</span> GuestbookStatus <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 重要的：运行 &quot;make&quot; 来重新生成代码 after modifying this file</span><br><br><span class="hljs-comment">// Conditions 代表了最新的可用状态观察</span><br>Conditions []metav1.Condition <span class="hljs-string">`json:&quot;conditions,omitempty&quot;`</span><br><br><span class="hljs-comment">// 可以添加更多状态字段，例如：</span><br><span class="hljs-comment">// AvailableReplicas int32 `json:&quot;availableReplicas&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// +kubebuilder:object:root=true</span><br><span class="hljs-comment">// +kubebuilder:subresource:status</span><br><span class="hljs-comment">// +kubebuilder:printcolumn:name=&quot;Replicas&quot;,type=&quot;integer&quot;,JSONPath=&quot;.spec.replicas&quot;</span><br><span class="hljs-comment">// +kubebuilder:printcolumn:name=&quot;Age&quot;,type=&quot;date&quot;,JSONPath=&quot;.metadata.creationTimestamp&quot;</span><br><br><span class="hljs-comment">// Guestbook 是 Guestbook API 的 Schema</span><br><span class="hljs-keyword">type</span> Guestbook <span class="hljs-keyword">struct</span> &#123;<br>metav1.TypeMeta   <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>metav1.ObjectMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot;`</span><br><br>Spec   GuestbookSpec   <span class="hljs-string">`json:&quot;spec,omitempty&quot;`</span><br>Status GuestbookStatus <span class="hljs-string">`json:&quot;status,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// +kubebuilder:object:root=true</span><br><br><span class="hljs-comment">// GuestbookList 包含了一个 Guestbook 对象的列表</span><br><span class="hljs-keyword">type</span> GuestbookList <span class="hljs-keyword">struct</span> &#123;<br>metav1.TypeMeta <span class="hljs-string">`json:&quot;,inline&quot;`</span><br>metav1.ListMeta <span class="hljs-string">`json:&quot;metadata,omitempty&quot;`</span><br>Items           []Guestbook <span class="hljs-string">`json:&quot;items&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>SchemeBuilder.Register(&amp;Guestbook&#123;&#125;, &amp;GuestbookList&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>修改完 <code>\*_types.go</code> 文件后，必须运行以下命令来生成代码：</strong></p><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make generate<br></code></pre></td></tr></table></figure><p>这个命令会根据你的类型定义（包括那些 <code>+kubebuilder</code> 注释），生成深拷贝方法等辅助代码。</p><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make manifests<br></code></pre></td></tr></table></figure><p>这个命令会生成 CRD 的 YAML 定义文件（在 <code>config/crd/bases/</code> 目录下）。它也会读取注释，例如 <code>+kubebuilder:subresource:status</code> 会为 CRD 生成 status 子资源。</p><h4 id="阶段四：实现控制器逻辑（Reconcile-Loop）"><a href="#阶段四：实现控制器逻辑（Reconcile-Loop）" class="headerlink" title="阶段四：实现控制器逻辑（Reconcile Loop）"></a>阶段四：实现控制器逻辑（Reconcile Loop）</h4><p>现在我们要在 <code>controllers/guestbook_controller.go</code> 文件中编写核心业务逻辑。</p><p><strong>你的任务：实现 <code>Reconcile</code> 函数。</strong></p><p>框架已经生成了基本的调和循环结构。你需要填写的是“当发现期望状态和实际状态不一致时，该做什么”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// controllers/guestbook_controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GuestbookReconciler)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="hljs-type">error</span>) &#123;<br>log := log.FromContext(ctx)<br><br><span class="hljs-comment">// 1. 获取 Guestbook 实例（CR）</span><br><span class="hljs-comment">// 首先，我们通过 Name 和 Namespace 获取用户创建的 Guestbook 对象。</span><br><span class="hljs-keyword">var</span> guestbook webappv1.Guestbook<br><span class="hljs-keyword">if</span> err := r.Get(ctx, req.NamespacedName, &amp;guestbook); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 如果找不到（可能被删除了），就返回</span><br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)<br>&#125;<br><br><span class="hljs-comment">// 2. 检查并创建 Redis 主实例 Deployment</span><br>redisMasterDeployment := &amp;appsv1.Deployment&#123;&#125;<br>err := r.Get(ctx, types.NamespacedName&#123;Name: <span class="hljs-string">&quot;redis-master&quot;</span>, Namespace: req.Namespace&#125;, redisMasterDeployment)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; apierrors.IsNotFound(err) &#123;<br><span class="hljs-comment">// 找不到，需要创建</span><br>dep := r.redisMasterDeploymentForGuestbook(&amp;guestbook)<br>log.Info(<span class="hljs-string">&quot;Creating a new Redis Master Deployment&quot;</span>, <span class="hljs-string">&quot;Deployment.Namespace&quot;</span>, dep.Namespace, <span class="hljs-string">&quot;Deployment.Name&quot;</span>, dep.Name)<br><span class="hljs-keyword">if</span> err := r.Create(ctx, dep); err != <span class="hljs-literal">nil</span> &#123;<br>log.Error(err, <span class="hljs-string">&quot;Failed to create new Redis Master Deployment&quot;</span>)<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, err<br>&#125;<br><span class="hljs-comment">// 创建成功，可以返回并等待下一次调和</span><br><span class="hljs-keyword">return</span> ctrl.Result&#123;Requeue: <span class="hljs-literal">true</span>&#125;, <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Error(err, <span class="hljs-string">&quot;Failed to get Redis Master Deployment&quot;</span>)<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, err<br>&#125;<br><br><span class="hljs-comment">// 3. 检查并创建 Redis 从实例 Deployment（数量由 spec.replicas 决定）</span><br>redisReplicaDeployment := &amp;appsv1.Deployment&#123;&#125;<br>err = r.Get(ctx, types.NamespacedName&#123;Name: <span class="hljs-string">&quot;redis-replica&quot;</span>, Namespace: req.Namespace&#125;, redisReplicaDeployment)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &amp;&amp; apierrors.IsNotFound(err) &#123;<br><span class="hljs-comment">// 找不到，需要创建</span><br>dep := r.redisReplicaDeploymentForGuestbook(&amp;guestbook)<br>log.Info(<span class="hljs-string">&quot;Creating a new Redis Replica Deployment&quot;</span>, <span class="hljs-string">&quot;Deployment.Namespace&quot;</span>, dep.Namespace, <span class="hljs-string">&quot;Deployment.Name&quot;</span>, dep.Name)<br><span class="hljs-keyword">if</span> err := r.Create(ctx, dep); err != <span class="hljs-literal">nil</span> &#123;<br>log.Error(err, <span class="hljs-string">&quot;Failed to create new Redis Replica Deployment&quot;</span>)<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, err<br>&#125;<br><span class="hljs-keyword">return</span> ctrl.Result&#123;Requeue: <span class="hljs-literal">true</span>&#125;, <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Error(err, <span class="hljs-string">&quot;Failed to get Redis Replica Deployment&quot;</span>)<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, err<br>&#125;<br><br><span class="hljs-comment">// 4. （可选）检查从实例的副本数是否与 spec.replicas 一致，如果不一致，则更新</span><br>replicas := guestbook.Spec.Replicas<br><span class="hljs-keyword">if</span> *replicas != *redisReplicaDeployment.Spec.Replicas &#123;<br>log.Info(<span class="hljs-string">&quot;Updating Redis Replica Deployment replicas&quot;</span>, <span class="hljs-string">&quot;Old&quot;</span>, *redisReplicaDeployment.Spec.Replicas, <span class="hljs-string">&quot;New&quot;</span>, *replicas)<br>redisReplicaDeployment.Spec.Replicas = replicas<br><span class="hljs-keyword">if</span> err := r.Update(ctx, redisReplicaDeployment); err != <span class="hljs-literal">nil</span> &#123;<br>log.Error(err, <span class="hljs-string">&quot;Failed to update Redis Replica Deployment&quot;</span>)<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, err<br>&#125;<br><span class="hljs-keyword">return</span> ctrl.Result&#123;Requeue: <span class="hljs-literal">true</span>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 5. （可选）更新 Status</span><br><span class="hljs-comment">// guestbook.Status.Conditions = ... </span><br><span class="hljs-comment">// if err := r.Status().Update(ctx, &amp;guestbook); err != nil &#123;</span><br><span class="hljs-comment">// log.Error(err, &quot;Failed to update Guestbook status&quot;)</span><br><span class="hljs-comment">// return ctrl.Result&#123;&#125;, err</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 6. 一切正常，无需立即重新排队</span><br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 辅助函数：为 Guestbook 创建 Redis Master Deployment 的定义</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GuestbookReconciler)</span></span> redisMasterDeploymentForGuestbook(g *webappv1.Guestbook) *appsv1.Deployment &#123;<br><span class="hljs-comment">// ... 这里需要你返回一个完整的 appsv1.Deployment 对象定义。</span><br><span class="hljs-comment">// 其 Spec 模板中包含了 Redis 主镜像、端口等配置。</span><br><span class="hljs-comment">// 这是一个体力活，需要你熟悉 Kubernetes Deployment 的 YAML 结构，并用 Go struct 来表示。</span><br>&#125;<br><br><span class="hljs-comment">// 辅助函数：为 Guestbook 创建 Redis Replica Deployment 的定义</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GuestbookReconciler)</span></span> redisReplicaDeploymentForGuestbook(g *webappv1.Guestbook) *appsv1.Deployment &#123;<br><span class="hljs-comment">// ... 类似上面，但配置的是 Redis 从镜像，并且副本数初始化为 g.Spec.Replicas</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：上面的代码是一个高度简化的示例。在实际开发中，你需要：</p><ul><li>完善两个辅助函数，完整地定义 Deployment。</li><li>处理错误和边缘情况。</li><li>考虑资源的 OwnerReferences，以便在删除 <code>Guestbook</code> CR 时，其创建的 Deployment 也能被垃圾回收。</li><li>更优雅地处理状态更新。</li></ul><h4 id="阶段五：测试与部署"><a href="#阶段五：测试与部署" class="headerlink" title="阶段五：测试与部署"></a>阶段五：测试与部署</h4><ol><li><p><strong>安装 CRD</strong>：</p><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make install<br></code></pre></td></tr></table></figure><p>这将把你定义的 <code>Guestbook</code> CRD 安装到当前 <code>kubectl</code> 指向的集群中。你可以用 <code>kubectl get crds</code> 查看。</p></li><li><p><strong>本地运行测试（可选）</strong>：</p><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make run<br></code></pre></td></tr></table></figure><p>这会在本地启动你的控制器，方便你快速调试。你可以在另一个终端创建 CR 来测试。</p></li><li><p><strong>构建镜像并部署到集群</strong>：</p><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置你要推送的镜像标签</span><br><span class="hljs-built_in">export</span> IMG=your-docker-repo/guestbook-operator:v1.0.0<br><br><span class="hljs-comment"># 构建镜像</span><br>make docker-build<br><br><span class="hljs-comment"># 推送镜像到仓库</span><br>make docker-push<br><br><span class="hljs-comment"># 生成部署清单并部署到集群</span><br>make deploy<br></code></pre></td></tr></table></figure><p><code>make deploy</code> 会在集群中创建一个 Namespace 并部署 Operator 的 Deployment。</p></li><li><p><strong>验收测试</strong>：</p><p>yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># config/samples/webapp_v1_guestbook.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">webapp.my.domain.com/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Guestbook</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">guestbook-sample</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f config/samples/webapp_v1_guestbook.yaml<br>kubectl get guestbooks <span class="hljs-comment"># 查看你的自定义资源</span><br>kubectl get deployments <span class="hljs-comment"># 查看Operator自动创建的redis-master和redis-replica</span><br>kubectl get pods <span class="hljs-comment"># 查看运行的Pod</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="总结与核心要点"><a href="#总结与核心要点" class="headerlink" title="总结与核心要点"></a>总结与核心要点</h3><table><thead><tr><th align="left">步骤</th><th align="left">关键命令&#x2F;文件</th><th align="left">目的</th></tr></thead><tbody><tr><td align="left"><strong>初始化</strong></td><td align="left"><code>kubebuilder init</code></td><td align="left">创建项目脚手架和入口文件</td></tr><tr><td align="left"><strong>创建API</strong></td><td align="left"><code>kubebuilder create api</code></td><td align="left">生成 CRD 类型定义和控制器骨架</td></tr><tr><td align="left"><strong>定义API</strong></td><td align="left"><code>api/&lt;version&gt;/&lt;kind&gt;_types.go</code></td><td align="left">定义 CR 的 Spec 和 Status 结构</td></tr><tr><td align="left"><strong>生成代码</strong></td><td align="left"><code>make generate</code>, <code>make manifests</code></td><td align="left">根据类型定义生成代码和 CRD YAML</td></tr><tr><td align="left"><strong>实现逻辑</strong></td><td align="left"><code>controllers/&lt;kind&gt;_controller.go</code></td><td align="left">在 <code>Reconcile</code> 函数中编写业务逻辑</td></tr><tr><td align="left"><strong>安装CRD</strong></td><td align="left"><code>make install</code></td><td align="left">将 CRD 安装到集群</td></tr><tr><td align="left"><strong>构建部署</strong></td><td align="left"><code>make docker-build</code>, <code>make docker-push</code>, <code>make deploy</code></td><td align="left">将 Operator 本身部署到集群</td></tr><tr><td align="left"><strong>测试</strong></td><td align="left"><code>kubectl apply -f config/samples/</code></td><td align="left">创建 CR 实例，触发 Operator 工作</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s中apiserver对并发操作的控制</title>
    <link href="/2025/09/11/k8s%E4%B8%ADapiserver%E5%AF%B9%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8E%A7%E5%88%B6/"/>
    <url>/2025/09/11/k8s%E4%B8%ADapiserver%E5%AF%B9%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>这触及了 Kubernetes 的核心机制之一：<strong>并发控制</strong>。你能思考到这一层，说明你已经超出了单纯“会用”的层面，开始深入理解系统设计了。</p><p>简单直接的回答是：Kubernetes API Server 通过一种称为 <strong>乐观并发控制（Optimistic Concurrency Control）</strong> 的机制来处理这种情况，其核心是 <strong><code>resourceVersion</code></strong> 字段。</p><p>下面我为你详细拆解这个过程，并给出学习和使用中的注意事项。</p><h3 id="核心机制：resourceVersion-与乐观锁"><a href="#核心机制：resourceVersion-与乐观锁" class="headerlink" title="核心机制：resourceVersion 与乐观锁"></a>核心机制：resourceVersion 与乐观锁</h3><p>每一个从 Kubernetes API Server 获取的资源对象（Pod, Deployment, Service 等）的元数据（metadata）中都包含一个名为 <code>resourceVersion</code> 的字段。它是一个不透明的字符串（本质上是一个 ETag），唯一标识该资源在特定时刻的版本。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pod</span><br>  <span class="hljs-attr">resourceVersion:</span> <span class="hljs-string">&quot;123456&quot;</span> <span class="hljs-comment"># 这就是关键！</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>这个字段是客户端修改对象时实现并发控制的基石。其工作流程如下：</p><ol><li><p><strong>读取对象</strong>：你的代码（使用 client-go）首先从 APIServer 获取一个对象。此时，该对象的 <code>resourceVersion</code> 值（例如 <code>123456</code>）被记录下来。</p></li><li><p><strong>本地修改</strong>：你在代码中修改这个对象的某些字段，比如 <code>spec.replicas</code>。</p></li><li><p><strong>发起更新请求</strong>：当你调用 <code>Update</code> 或 <code>UpdateStatus</code> 等方法时，client-go 会将你修改后的对象（**包含之前读取到的 <code>resourceVersion</code> 值 <code>123456</code>**）发送给 APIServer。</p></li><li><p><strong>服务器端验证</strong>：APIServer 收到更新请求后，会进行以下关键检查：</p><ul><li>它会在数据库（etcd）中查找你要更新的对象。</li><li>它比较**请求中对象携带的 <code>resourceVersion</code><strong>（<code>123456</code>）和</strong>数据库中当前对象的 <code>resourceVersion</code>**。</li><li><strong>如果两者匹配</strong>：说明从你读取对象到发起更新这个时间窗口内，没有其他人修改过这个对象。验证通过，APIServer 会接受你的更新，并将对象的 <code>resourceVersion</code> 更新为一个新的值（例如 <code>123457</code>）。</li><li><strong>如果两者不匹配</strong>：说明在你读取之后、更新之前，这个对象已经被其他客户端（可能是另一个协程、另一个 Pod、或者人类通过 <code>kubectl</code>）修改过了。数据库中的当前 <code>resourceVersion</code> 已经变成了 <code>123999</code>。此时，APIServer 会认为这次更新发生了<strong>冲突（Conflict）</strong>，并直接返回一个 <strong>HTTP 409 Conflict</strong> 错误。</li></ul></li><li><p><strong>客户端处理</strong>：你的客户端代码会收到这个错误，更新操作失败。这时，你的程序需要决定如何处理这个冲突。</p></li></ol><p>这个过程就是“乐观”锁：它乐观地假定在你修改期间不会有其他人修改数据，因此不会在读取时加锁，只在提交更新时检查版本。这大大提高了系统的吞吐量。</p><h3 id="如果在代码中处理并发冲突？"><a href="#如果在代码中处理并发冲突？" class="headerlink" title="如果在代码中处理并发冲突？"></a>如果在代码中处理并发冲突？</h3><p>当你的 client-go 代码收到 <code>409 Conflict</code> 错误时，绝对不能简单地忽略它。标准的处理模式是一个<strong>重试循环</strong>：</p><ol><li><strong>重新获取对象</strong>：一旦捕获到 <code>409</code> 错误，立即重新从 APIServer 读取一次最新的对象。这个新对象包含了最新的状态和最新的 <code>resourceVersion</code>。</li><li><strong>重新应用修改</strong>：在你刚读取的最新对象基础上，重新进行你想要的修改（例如，重新设置 <code>spec.replicas</code>）。</li><li><strong>重新发起更新</strong>：用这个合并了最新状态和你修改的新对象，再次调用 <code>Update</code> 方法。</li></ol><p>这个模式非常常见，以至于 client-go 在一些更高级的组件（如 <code>controller-runtime</code>，Operator SDK 和 Kubebuilder 的基础）中已经内置了。但对于直接使用 client-go 的情况，你需要自己实现。</p><p><strong>一个简单的伪代码示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/api/errors&quot;</span><br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>)<br><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// 1. 获取最新的 Deployment</span><br>    deployment, err := clientset.AppsV1().Deployments(<span class="hljs-string">&quot;default&quot;</span>).Get(ctx, <span class="hljs-string">&quot;my-deployment&quot;</span>, metav1.GetOptions&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 在本地修改对象</span><br>    deployment.Spec.Replicas = pointer.Int32Ptr(<span class="hljs-number">5</span>)<br><br>    <span class="hljs-comment">// 3. 尝试更新</span><br>    _, err = clientset.AppsV1().Deployments(<span class="hljs-string">&quot;default&quot;</span>).Update(ctx, deployment, metav1.UpdateOptions&#123;&#125;)<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 更新成功，跳出循环</span><br>        <span class="hljs-keyword">break</span><br>    &#125;<br><br>    <span class="hljs-comment">// 4. 检查错误是否为冲突</span><br>    <span class="hljs-keyword">if</span> !errors.IsConflict(err) &#123;<br>        <span class="hljs-comment">// 如果不是冲突错误（可能是权限、校验失败等），直接返回错误</span><br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br>    <span class="hljs-comment">// 5. 如果是冲突错误，循环会继续，重新执行步骤1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="学习和使用过程中的注意事项"><a href="#学习和使用过程中的注意事项" class="headerlink" title="学习和使用过程中的注意事项"></a>学习和使用过程中的注意事项</h3><ol><li><p><strong>永远基于最新版本修改</strong>：不要缓存一个对象然后反复用它做修改。每次更新前，都应该重新 Get 一次，或者确保你处理的是最新版本。<code>resourceVersion</code> 是你的朋友，也是保证数据一致性的生命线。</p></li><li><p>**区分 <code>Update</code> 和 <code>Patch</code>**：</p><ul><li>**<code>Update</code>**：需要提供整个对象，并且受 <code>resourceVersion</code> 的乐观锁控制。上面讨论的就是这种方式。</li><li>**<code>Patch</code><strong>：允许你只发送要修改的字段。某些 Patch 类型（如 <code>strategic merge patch</code> 或 <code>JSON patch</code>）在冲突处理上比 <code>Update</code> 更友好，因为它们可以在服务器端以更细的粒度应用更改，有时可以避免冲突。例如，两个客户端分别 Patch 同一个对象的不同字段，可能不会冲突。</strong>在你需要高并发更新的场景下，优先考虑使用 <code>Patch</code>**。</li></ul></li><li><p><strong>注意 <code>ResourceVersion</code> 字段本身</strong>：</p><ul><li>你不应该手动设置或修改这个字段，它应该完全由 APIServer 管理。</li><li>在 List 操作时，你可以使用 <code>metav1.ListOptions&#123;ResourceVersion: &quot;0&quot;&#125;</code> 来请求一个“任意”版本的缓存数据（可能过时），以获得更好的性能。但用于 Watch 或作为更新依据时，必须使用具体的版本号。</li></ul></li><li><p><strong>错误处理是必选项</strong>：在你的代码中，<strong>必须</strong>处理 <code>409 Conflict</code> 错误。简单地打印错误并退出通常是不专业的做法。实现重试逻辑，并设置重试次数上限和退避策略（例如指数退避），以避免活锁。</p></li><li><p><strong>使用高级库</strong>：如果你正在编写控制器（Controller）或 Operator，强烈建议使用 <strong><code>controller-runtime</code></strong> 库（Kubebuilder&#x2F;Operator SDK 的底层库）。它抽象了大量的底层细节，其 <code>Reconcile</code> 循环模式会自动帮你处理了资源的获取和更新，包括在冲突时自动重试，让你能更专注于业务逻辑。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="left">概念</th><th align="left">作用</th><th align="left">客户端注意事项</th></tr></thead><tbody><tr><td align="left"><strong><code>resourceVersion</code></strong></td><td align="left">乐观并发控制的版本标识符</td><td align="left">不要手动修改它；更新时必须携带</td></tr><tr><td align="left"><strong>HTTP 409 Conflict</strong></td><td align="left">版本冲突的信号</td><td align="left">必须处理此错误，实现重试逻辑</td></tr><tr><td align="left"><strong>Update 操作</strong></td><td align="left">替换整个对象</td><td align="left">容易引发冲突，需重试</td></tr><tr><td align="left"><strong>Patch 操作</strong></td><td align="left">部分更新对象</td><td align="left">减少冲突概率，推荐在并发场景使用</td></tr><tr><td align="left"><strong>重试循环</strong></td><td align="left">处理冲突的标准模式</td><td align="left">应包含退避机制，避免无限重试</td></tr></tbody></table><p>理解了这个机制，你就能写出更健壮、更可靠的 Kubernetes 自动化代码了。这也是为什么 Kubernetes 系统本身及其上的众多控制器能够在高度并发的环境下稳定运行的原因。</p><p>这种原子性是由 API Server 和其底层的分布式键值存储 <strong>etcd</strong> 共同保证的。当你通过 client-go 发起一个 <code>Create</code>、<code>Update</code> 或 <code>Delete</code> 操作时，这个操作对于 API Server 来说是一个单一的请求。API Server 会进行一系列工作（认证、鉴权、准入控制、验证），最终这个操作会转化为对 etcd 的<strong>一次写操作</strong>。etcd 会将其作为一个原子事务来执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volcano调度器Reclaim-Action详解</title>
    <link href="/2025/08/27/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Reclaim-Action%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/08/27/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Reclaim-Action%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>通过分析 Volcano 的源码（主要参考 <code>master</code> 分支和最新稳定版，如 <code>v1.9.0</code>），我来为你详细解析 <strong>Reclaim Action</strong> 的具体过程。Reclaim Action 是 Volcano 调度器中负责<strong>跨队列资源回收</strong>的核心机制，它确保资源能够按照队列的权重和配额进行公平分配。</p><h3 id="🔧-Reclaim-Action-的核心作用与设计初衷"><a href="#🔧-Reclaim-Action-的核心作用与设计初衷" class="headerlink" title="🔧 Reclaim Action 的核心作用与设计初衷"></a>🔧 Reclaim Action 的核心作用与设计初衷</h3><p><strong>核心作用</strong>：Reclaim Action 的主要目标是当某个<strong>队列（Queue）</strong> 的资源使用量超过其<strong>应得份额（deserved）</strong> 时，从其他<strong>可回收（reclaimable）</strong> 的队列中<strong>回收资源</strong>，以满足资源短缺队列的需求。其设计初衷是实现多租户场景下跨队列的公平调度和资源隔离。</p><p><strong>与 Preempt Action 的区别</strong>：</p><ul><li><strong><code>Reclaim</code></strong>: 处理<strong>不同队列之间</strong>的资源回收。</li><li><strong><code>Preempt</code></strong>: 处理<strong>同一队列内部</strong>（Job 之间或 Task 之间）基于优先级的抢占。</li></ul><h3 id="📦-关键概念与前置知识"><a href="#📦-关键概念与前置知识" class="headerlink" title="📦 关键概念与前置知识"></a>📦 关键概念与前置知识</h3><p>理解 Reclaim Action 需要先了解几个关键概念：</p><ul><li><strong><code>Session</code></strong>: 调度会话的上下文，包含了当前所有待调度的 Job(<code>Jobs</code>)、节点信息(<code>Nodes</code>)、已注册的插件(<code>Plugins</code>)等。</li><li><strong><code>Queue</code></strong>: Volcano 的自定义资源，用于对作业进行分组和资源分配。每个 Queue 可以配置 <code>deserved</code>（应得资源量）、<code>capability</code>（资源上限）和 <code>guarantee</code>（保障资源量）。</li><li><strong><code>deserved</code></strong>: 队列根据其权重等因素计算出的应得资源量。</li><li><strong><code>reclaimable</code></strong>: 队列的一个属性（<code>spec.reclaimable</code>），标记该队列中的资源是否可以被其他队列回收。<strong>只有将 <code>reclaimable</code> 设置为 <code>true</code> 的队列，其资源才可能被回收</strong>。</li><li><strong>层级队列（Hierarchical Queue）</strong>: Volcano 最新版本支持队列的层级结构，子队列的资源配额受父队列限制，Reclaim Action 也需要考虑这种层级关系。</li></ul><h3 id="🔍-Reclaim-Action-详细工作流程"><a href="#🔍-Reclaim-Action-详细工作流程" class="headerlink" title="🔍 Reclaim Action 详细工作流程"></a>🔍 Reclaim Action 详细工作流程</h3><p>Reclaim Action 的入口点通常在 <code>pkg/scheduler/actions/reclaim/reclaim.go</code> 文件中的 <code>Execute</code> 函数。其工作流程可以概括为以下核心步骤：</p><ol><li><p><strong>识别资源短缺的队列</strong>：<br>Reclaim Action 会遍历所有队列，计算每个队列的 <code>deserved</code> 资源量和当前实际已分配（<code>allocated</code>）的资源量。如果某个队列的 <code>allocated</code> 资源<strong>小于</strong>其 <code>deserved</code> 资源，说明该队列<strong>可能资源短缺</strong>，有资格发起资源回收。这些队列被称为 <strong>“ reclaimor”（回收方）</strong>。</p></li><li><p><strong>识别资源超用的队列（候选受害者队列）</strong>：<br>同样，遍历所有队列，寻找那些 <code>allocated</code> 资源<strong>超过</strong>其 <code>deserved</code> 资源的队列。这些队列是潜在的 <strong>“victim”（受害者）</strong>。<strong>只有那些 <code>reclaimable</code> 字段为 <code>true</code> 的队列才会被考虑作为受害者</strong>。</p></li><li><p><strong>选择要回收的任务（Pod）</strong>：<br>对于每一个资源超用的受害者队列，Reclaim Action 会遍历其内部已运行的 Job 和 Pod（<code>TaskInfo</code>），并根据配置的插件（如 <strong>Priority</strong> 插件）<strong>选择最适合被回收的 Pod</strong>。通常，优先级较低或创建时间较早的 Pod 会被优先选择。</p></li><li><p><strong>模拟回收与安全检查</strong>：<br>在真正回收之前，会进行模拟和安全检查，这个过程严重依赖 <strong>Gang 插件</strong>：</p><ul><li>Gang 插件会检查：如果驱逐（回收）了选中的 Pod，是否会导致其所属的 Job <strong>不满足 <code>minAvailable</code> 约束</strong>（即破坏其 Gang 调度策略）。</li><li><strong>只有那些被回收后不会破坏原 Job 完整性的 Pod</strong>，才会被确定为真正的回收目标。</li></ul></li><li><p><strong>执行资源回收</strong>：<br>一旦确定了要回收的 Pod，调度器会<strong>真正地驱逐这些 Pod</strong>。这是通过调用 Kubernetes API <strong>删除这些 Pod</strong> 来实现的。这些被回收的 Pod 会进入 <code>Terminating</code> 状态，其占用的资源将被释放。</p></li><li><p><strong>资源释放与再分配</strong>：<br>受害者 Pod 被删除后，它们之前占用的资源就被释放了。这些释放出来的资源<strong>并不会立即分配给发起回收的队列</strong>，而是等待<strong>下一个调度周期</strong>，由 <code>Enqueue</code> 和 <code>Allocate</code> 等 Action 来重新分配这些资源。此时，由于之前资源短缺的队列有资源需求，它就有机会在后续的调度中获得这些资源。</p></li></ol><p>下图概括了上述流程及其与后续调度周期的关系：</p><p><img src="/2025/08/27/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Reclaim-Action%E8%AF%A6%E8%A7%A3/deepseek_mermaid_20250826_b0c4a4.png" alt="deepseek_mermaid_20250826_b0c4a4"></p><h3 id="⚙️-依赖的插件与配置"><a href="#⚙️-依赖的插件与配置" class="headerlink" title="⚙️ 依赖的插件与配置"></a>⚙️ 依赖的插件与配置</h3><p>Reclaim Action 的具体行为由一系列插件决定：</p><ul><li><strong>Gang 插件</strong>: 进行安全检查的核心插件，确保回收操作<strong>不会破坏分布式任务的原子性</strong>（”All or Nothing”）。</li><li><strong>Priority 插件</strong>: 用于在受害者队列中选择要回收的 Pod 时，比较 Pod 或 Job 的优先级。</li><li><strong>Proportion 插件</strong>: 负责计算和管理队列的 <code>deserved</code>、<code>capability</code> 等资源配额。</li><li><strong>Capacity 插件</strong> (用于层级队列): 当启用层级队列功能时（<code>enableHierarchy: true</code>），该插件负责处理跨层级队列的资源分配和回收逻辑。</li></ul><p>要使 Reclaim Action 正常工作，必须在 <code>volcano-scheduler-configmap</code> 中正确配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">actions:</span> <span class="hljs-string">&quot;enqueue, allocate, reclaim, preempt&quot;</span> <span class="hljs-comment"># 必须包含reclaim，顺序通常在allocate之后</span><br><span class="hljs-attr">tiers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">plugins:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">priority</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">gang</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">conformance</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">plugins:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">drf</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">predicates</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">proportion</span>   <span class="hljs-comment"># 比例插件，用于计算队列资源</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nodeorder</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">capacity</span>     <span class="hljs-comment"># 如果使用层级队列，需要配置capacity插件并enableHierarchy</span><br>    <span class="hljs-attr">arguments:</span><br>      <span class="hljs-attr">enableHierarchy:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>同时，需要确保希望被回收资源的队列在其定义中将 <code>spec.reclaimable</code> 设置为 <code>true</code>。</p><h3 id="🧪-结合示例说明"><a href="#🧪-结合示例说明" class="headerlink" title="🧪 结合示例说明"></a>🧪 结合示例说明</h3><p>假设有两个队列：</p><ul><li><strong><code>queue-online</code></strong> (高优先级): <code>deserved</code> 为 20 核 CPU，<code>reclaimable: false</code>。</li><li><strong><code>queue-offline</code></strong> (低优先级): <code>deserved</code> 为 20 核 CPU，<code>reclaimable: true</code>。</li></ul><p>当前 <code>queue-offline</code> 中有一个 Job 正在运行，占用了 40 核 CPU（即 <code>allocated</code> &gt; <code>deserved</code>）。此时，如果有一个新的 Job 被提交到 <code>queue-online</code>，需要 10 核 CPU，但集群当前没有足够空闲资源。</p><ol><li><p><strong>Reclaim Action 触发</strong>：</p><ul><li>识别到 <code>queue-online</code> 的 <code>allocated</code> (0核) &lt; <code>deserved</code> (20核)，资源短缺，成为回收方。</li><li>识别到 <code>queue-offline</code> 的 <code>allocated</code> (40核) &gt; <code>deserved</code> (20核)，且 <code>reclaimable: true</code>，成为受害者队列。</li></ul></li><li><p><strong>选择与检查</strong>：</p><ul><li>从 <code>queue-offline</code> 中选择一个或多个合适的 Pod（例如优先级最低的），假设这些 Pod 总共占用 10 核 CPU。</li><li>Gang 插件检查回收这些 Pod 是否会影响其所属 Job 的 <code>minAvailable</code>。假设检查通过。</li></ul></li><li><p><strong>执行回收</strong>：</p><ul><li>驱逐选中的 Pod，释放 10 核 CPU。</li></ul></li><li><p><strong>资源再分配</strong>：</p><ul><li>在下一个调度周期，<code>queue-online</code> 中的新 Job 有机会通过 <code>Allocate</code> Action 分配到这 10 核 CPU，从而成功运行。</li></ul></li></ol><h3 id="⚠️-重要注意事项"><a href="#⚠️-重要注意事项" class="headerlink" title="⚠️ 重要注意事项"></a>⚠️ 重要注意事项</h3><ol><li><strong><code>reclaimable</code> 配置</strong>：队列的 <code>reclaimable</code> 字段必须显式设置为 <code>true</code> 才能被回收。</li><li><strong>与 Enqueue Action 的潜在冲突</strong>：如果同时配置了 <code>enqueue</code> 和 <code>reclaim</code>，且 <code>enqueue</code> 因资源不足阻止 PodGroup 入队，会导致没有 Pending 状态的 Pod，进而可能无法触发 <code>reclaim</code> 机制。</li><li><strong>Overcommit 插件的影响</strong>：<code>overcommit</code> 插件可能会阻止资源超限的作业进入队列，这与回收机制可能产生冲突，在实际部署中需要留意。</li><li><strong>层级队列</strong>：在层级队列中，资源回收可能会在兄弟队列之间进行，若兄弟队列资源不足，可能会向祖先队列查找。</li></ol><h3 id="💡-总结"><a href="#💡-总结" class="headerlink" title="💡 总结"></a>💡 总结</h3><p>Volcano 的 <strong>Reclaim Action</strong> 是其实现<strong>多租户公平调度</strong>和<strong>跨队列资源弹性</strong>的关键组件。它通过一套严谨的流程（识别短缺队列、选择受害者队列、模拟安全检查、执行回收）和与其他插件（尤其是 Gang 插件）的协同，确保了在回收资源时不会破坏现有作业的完整性，同时又能高效地将资源重新分配给更需要的队列。</p><p>希望这份结合源码的详细解读，能帮助你透彻地理解 Volcano Reclaim Action 的工作机制。</p><h2 id="问题一：reclaim和preempt都需要有pending状态的pod来触发，那么由于enqueue-action的存在，集群资源不足时，会禁止Job创建出pod，如何处理这种矛盾"><a href="#问题一：reclaim和preempt都需要有pending状态的pod来触发，那么由于enqueue-action的存在，集群资源不足时，会禁止Job创建出pod，如何处理这种矛盾" class="headerlink" title="问题一：reclaim和preempt都需要有pending状态的pod来触发，那么由于enqueue action的存在，集群资源不足时，会禁止Job创建出pod，如何处理这种矛盾"></a>问题一：reclaim和preempt都需要有pending状态的pod来触发，那么由于enqueue action的存在，集群资源不足时，会禁止Job创建出pod，如何处理这种矛盾</h2><p>您提出的这个问题非常尖锐且完全正确，您指出了一个在配置 Volcano 时非常关键但容易被忽略的逻辑矛盾。您的推理是完全准确的：<strong>如果高优先级作业被 <code>enqueue</code>  action 阻挡，无法创建 Pod，那么后续的 <code>preempt</code>  action 就失去了作用对象，优先级机制也就形同虚设了。</strong></p><h3 id="🧠-理解冲突的本质"><a href="#🧠-理解冲突的本质" class="headerlink" title="🧠 理解冲突的本质"></a>🧠 理解冲突的本质</h3><p>首先，明确一下冲突的根源：</p><ul><li><strong><code>Enqueue</code></strong> 是 <strong>“预防式”</strong> 的策略：它在作业的Pod被实际创建<strong>之前</strong>就进行资源预检。它的目标是<strong>避免</strong>在资源不足时创建大量永远无法调度的Pending Pod，从而减轻API Server的压力并避免资源碎片化。它追求的是<strong>集群稳定性</strong>。</li><li><strong><code>Reclaim</code>&#x2F;<code>Preempt</code></strong> 是 <strong>“补救式”</strong> 的策略：它们依赖于系统中已经存在<strong>Pending状态的Pod</strong>作为“触发器”。这些Pending Pod代表了未被满足的资源需求，从而驱动调度器去抢占或回收其他低优先级作业的资源。它追求的是<strong>资源利用率和调度公平性</strong>。</li></ul><p>因此，<code>Enqueue</code> 和 <code>Reclaim</code> 在逻辑上存在一个“死锁”：</p><ol><li>没有资源 -&gt; <code>Enqueue</code> 阻止PodGroup入队 -&gt; 没有Pending Pod被创建</li><li>没有Pending Pod -&gt; <code>Reclaim</code> 没有回收资源的触发信号 -&gt; 资源无法被释放</li><li>资源无法被释放 -&gt; 继续没有资源 -&gt; 回到第1步</li></ol><p>这确实是 <code>enqueue</code> 和 <code>preempt</code> 这两个 action 在设计哲学上的一个根本性冲突。在实际生产中，为了解决这个死锁，社区形成了一种共识和最佳实践。</p><h3 id="🧠-核心解决方案：通常选择禁用-Enqueue"><a href="#🧠-核心解决方案：通常选择禁用-Enqueue" class="headerlink" title="🧠 核心解决方案：通常选择禁用 Enqueue"></a>🧠 核心解决方案：通常选择禁用 Enqueue</h3><p>正如我之前提到的，<strong>最常见的解决方案是：在 <code>volcano-scheduler-configmap</code> 的 <code>actions</code> 列表中移除 <code>enqueue</code>。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 推荐的真实生产配置（尤其是需要抢占功能的场景）</span><br><span class="hljs-attr">actions:</span> <span class="hljs-string">&quot;allocate, reclaim, preempt, backfill&quot;</span> <span class="hljs-comment"># 移除了 enqueue</span><br></code></pre></td></tr></table></figure><p><strong>这样配置的工作原理和后果如下：</strong></p><ol><li><strong>Pod 立即创建</strong>：当一个高优先级的 Volcano Job 被提交后，<code>volcano-controller-manager</code> 会<strong>立即</strong>为其创建所有 Pod，无论当前集群资源是否充足。这些 Pod 会直接进入 <code>Pending</code> 状态。</li><li><strong>Preempt Action 获得触发器</strong>：这些 <code>Pending</code> 状态的高优先级 Pod 为 <code>preempt</code>  action 提供了明确的<strong>抢占目标</strong>。<code>preempt</code>  action 会检测到这些 Pod 因为资源不足而无法调度，但同时它们的优先级又很高。</li><li><strong>触发抢占</strong>：<code>preempt</code>  action 开始工作，在同一队列内寻找低优先级的、已运行的、并且抢占后不会破坏其 Gang 约束的 Pod 作为受害者。</li><li><strong>执行抢占</strong>：驱逐（删除）受害者 Pod，释放资源。</li><li><strong>资源再分配</strong>：在下一个调度周期，被释放的资源就可以分配给之前处于 <code>Pending</code> 状态的高优先级 Pod，使其得以运行。</li></ol><p><strong>通过这个流程，优先级的语义就得到了真正的贯彻执行。</strong> 高优先级作业通过“牺牲”低优先级作业来获得资源。</p><h3 id="⚖️-代价与权衡"><a href="#⚖️-代价与权衡" class="headerlink" title="⚖️ 代价与权衡"></a>⚖️ 代价与权衡</h3><p>当然，禁用 <code>enqueue</code> 是有代价的，这就是一个典型的<strong>权衡（Trade-off）</strong>：</p><ul><li><strong>你获得了什么</strong>：<strong>强大的抢占能力和优先级保证</strong>。确保了高优先级工作负载能够及时获得资源，满足 SLA（服务等级协议）。</li><li><strong>你付出了什么</strong>：<strong>API Server 和 Controller 的压力</strong>。在大型集群中，可能会有成千上万个长期处于 <code>Pending</code> 状态的 Pod，它们会对 Kubernetes 的控制平面（特别是 API Server 和 etcd）造成额外的压力，因为所有组件都需要持续地监听和处理这些 Pod 对象。</li></ul><h3 id="🔧-其他辅助解决方案"><a href="#🔧-其他辅助解决方案" class="headerlink" title="🔧 其他辅助解决方案"></a>🔧 其他辅助解决方案</h3><p>除了完全禁用 <code>enqueue</code>，还有一些更精细化的策略来缓解这个矛盾：</p><ol><li><p><strong>按队列粒度启用&#x2F;禁用 Enqueue</strong>（高级功能）：<br>这是一种理想但实现起来更复杂的方式。理论上，你可以：</p><ul><li>对<strong>高优先级队列</strong>的 Job，使其绕过 <code>enqueue</code> 检查，确保 Pod 能被立即创建以触发抢占。</li><li>对<strong>低优先级队列</strong>的 Job，仍然启用 <code>enqueue</code>，让它们在资源充足时才创建 Pod，避免给系统增加不必要的负担。</li><li>（注：Volcano 原生可能不直接支持这么精细的控制，但这可以通过开发自定义的准入控制器或修改调度器配置来间接实现）。</li></ul></li><li><p><strong>设置超时机制</strong>：<br>即使启用了 <code>enqueue</code>，也可以设置一个超时时间。如果一个 PodGroup 在 <code>Pending</code> 状态停留了太久（例如 10 分钟），可以通过外部脚本或控制器强制将其状态改为 <code>Inqueue</code>，从而触发 Pod 创建和后续的抢占流程。这是一种折中方案。</p></li></ol><h3 id="💡-结论与最终建议"><a href="#💡-结论与最终建议" class="headerlink" title="💡 结论与最终建议"></a>💡 结论与最终建议</h3><table><thead><tr><th align="left">配置策略</th><th align="left">优先级保障</th><th align="left">对控制面压力</th><th align="left">建议场景</th></tr></thead><tbody><tr><td align="left"><strong>启用 <code>enqueue</code></strong></td><td align="left"><strong>弱</strong>。高优先级作业可能无法及时触发抢占。</td><td align="left"><strong>小</strong>。避免了大量 Pending Pod。</td><td align="left">资源充裕、环境稳定、对优先级要求不高的批处理场景。</td></tr><tr><td align="left"><strong>禁用 <code>enqueue</code></strong></td><td align="left"><strong>强</strong>。优先级机制能得到完美执行。</td><td align="left"><strong>大</strong>。存在大量 Pending Pod。</td><td align="left"><strong>主流选择</strong>。多租户、资源紧张、需要严格保证高优先级作业 SLA 的生产环境。</td></tr></tbody></table><p><strong>对于绝大多数需要优先级和抢占功能的生产环境，社区给出的明确答案是：禁用 <code>enqueue</code> action。</strong></p><p><strong>因此，您不应该在配置中同时使用 <code>enqueue</code> 和 <code>preempt</code> 而期望它们能协同工作。正确的做法是舍弃 <code>enqueue</code>，接受它所带来的控制面压力，以换取强大的调度能力。</strong> 这种压力通常可以通过升级控制平面硬件、优化 etcd 配置等方式来缓解。</p><p>您的质疑非常到位，这确实是 Volcano 调度配置中最核心的一个决策点。感谢您的追问，让我有机会更清晰地解释这一点。</p><h2 id="问题二：queue中的deserved（应得资源量）、capability（资源上限）和-guarantee（保障资源量）这几个参数分别是什么作用，是如何配合的"><a href="#问题二：queue中的deserved（应得资源量）、capability（资源上限）和-guarantee（保障资源量）这几个参数分别是什么作用，是如何配合的" class="headerlink" title="问题二：queue中的deserved（应得资源量）、capability（资源上限）和 guarantee（保障资源量）这几个参数分别是什么作用，是如何配合的"></a>问题二：queue中的deserved（应得资源量）、capability（资源上限）和 guarantee（保障资源量）这几个参数分别是什么作用，是如何配合的</h2><p>您提出的这个问题非常核心，是理解 Volcano 多租户资源管理模型的关键。<code>deserved</code>、<code>capability</code> 和 <code>guarantee</code> 这三个参数共同构成了一个既<strong>公平</strong>又<strong>具弹性</strong>且<strong>安全</strong>的资源分配体系。</p><p>简单来说，它们回答了三个问题：</p><ol><li><strong>公平性 (Fairness)<strong>：在资源竞争时，每个队列</strong>应该</strong>分到多少？ -&gt; <code>deserved</code></li><li><strong>隔离性 (Isolation)<strong>：每个队列最多</strong>允许</strong>使用多少？ -&gt; <code>capability</code></li><li><strong>保障性 (Guarantee)<strong>：每个队列最少</strong>确保</strong>能得到多少？ -&gt; <code>guarantee</code></li></ol><p>下面我们进行详细的分解。</p><h3 id="1-三个参数的角色与作用"><a href="#1-三个参数的角色与作用" class="headerlink" title="1. 三个参数的角色与作用"></a>1. 三个参数的角色与作用</h3><table><thead><tr><th align="left">参数</th><th align="left">英文名</th><th align="left">核心作用</th><th align="left">类比理解</th></tr></thead><tbody><tr><td align="left"><strong><code>guarantee</code></strong></td><td align="left">Guarantee</td><td align="left"><strong>资源保障</strong>。队列<strong>绝对最小</strong>可使用的资源量，即使集群资源紧张，这部分资源也应由该队列独占或被回收回来。</td><td align="left">你的<strong>基本工资</strong>。无论公司业绩多差，这笔钱必须发给你。</td></tr><tr><td align="left"><strong><code>capability</code></strong></td><td align="left">Capability</td><td align="left"><strong>资源上限</strong>。队列<strong>绝对最大</strong>可使用的资源量，即使集群资源空闲，该队列也无法超过此限制。</td><td align="left">你的<strong>年度薪资封顶</strong>。今年业绩再好，收入也不会超过这个数。</td></tr><tr><td align="left"><strong><code>deserved</code></strong></td><td align="left">Deserved</td><td align="left"><strong>应得资源</strong>。队列<strong>按权重</strong>在当前集群条件下<strong>应得</strong>的资源量。这是一个<strong>动态计算</strong>的值，介于 <code>guarantee</code> 和 <code>capability</code> 之间。</td><td align="left">你的<strong>绩效工资</strong>。根据你的贡献（权重）和公司当前利润（集群资源），今年<strong>应该</strong>发给你这么多。</td></tr></tbody></table><h3 id="2-为什么需要这三个参数？"><a href="#2-为什么需要这三个参数？" class="headerlink" title="2. 为什么需要这三个参数？"></a>2. 为什么需要这三个参数？</h3><p>它们解决了多租户集群中的不同问题：</p><ol><li><p>**<code>guarantee</code>**：解决 <strong>“饿死” (Starvation)</strong> 问题。</p><ul><li><strong>场景</strong>：如果没有 <code>guarantee</code>，一个权重很低但运行着重要基础服务的队列，可能会被权重高的大作业完全挤占资源，导致服务不可用。</li><li><strong>作用</strong>：它为重要队列提供了一个<strong>安全垫</strong>，确保了其业务的基线服务能力。</li></ul></li><li><p>**<code>capability</code>**：解决 <strong>“贪婪” (Greediness)</strong> 问题。</p><ul><li><strong>场景</strong>：如果没有 <code>capability</code>，一个队列可能会无限占用所有集群资源，导致其他队列完全无法工作（例如，代码有 bug 提交了无限量的作业）。</li><li><strong>作用</strong>：它为每个队列设置了<strong>资源边界</strong>，提供了资源隔离，是多租户安全的基石。</li></ul></li><li><p>**<code>deserved</code>**：解决 <strong>“公平” (Fairness)</strong> 与 <strong>“弹性” (Elasticity)</strong> 问题。</p><ul><li><strong>场景</strong>：集群资源是波动的。<code>deserved</code> 根据每个队列的 <code>weight</code> 和集群当前<strong>可用资源总量</strong>，动态计算出一个公平的分配额。</li><li><strong>作用</strong>：它使得资源分配不是僵化的，而是在保障基本盘 (<code>guarantee</code>) 的前提下，允许队列<strong>弹性地</strong>共享集群的空闲资源，从而最大限度地提高整体资源利用率。</li></ul></li></ol><h3 id="3-它们是如何协同工作的？（核心）"><a href="#3-它们是如何协同工作的？（核心）" class="headerlink" title="3. 它们是如何协同工作的？（核心）"></a>3. 它们是如何协同工作的？（核心）</h3><p><strong>计算过程与交互</strong>：</p><ol><li><p>**计算 <code>deserved</code>**：</p><ul><li><code>deserved</code> 不是静态配置的，而是由 <strong>Proportion 插件</strong>动态计算出来的。</li><li>计算公式可以简化为：<code>queue&#39;s deserved = (queue&#39;s weight / total weight of all queues) * (available idle resources) + queue&#39;s guarantee</code></li><li>但它最终会被钳制在 <code>[guarantee, capability]</code> 区间内。计算出的 <code>deserved</code> 值永远不能小于 <code>guarantee</code>，也不能大于 <code>capability</code>。</li></ul></li><li><p><strong>驱动 <code>Reclaim</code> Action</strong>：</p><ul><li><strong>回收目标</strong>：<code>Reclaim</code> Action 会持续检查所有队列。如果一个队列的<strong>当前已使用资源 (<code>allocated</code>)</strong> <strong>大于</strong>其 <code>deserved</code>，并且它的 <code>reclaimable=true</code>，那么它就成为资源回收的<strong>目标</strong>（受害者）。</li><li><strong>回收来源</strong>：同时，如果一个队列的 <code>allocated</code> <strong>小于</strong>其 <code>deserved</code>，说明它应该得到更多资源，它就成为资源回收的<strong>发起方</strong>。</li><li><strong>回收目标值</strong>：<code>Reclaim</code> 的目标是将队列的资源使用量调整到其 <code>deserved</code> 的水平。</li></ul></li></ol><h3 id="4-一个具体的例子"><a href="#4-一个具体的例子" class="headerlink" title="4. 一个具体的例子"></a>4. 一个具体的例子</h3><p>假设一个集群有 <strong>100核 CPU</strong>。<br>有两个队列：</p><ul><li><strong>Queue-online</strong>:<ul><li><code>weight: 2</code></li><li><code>guarantee: 30</code></li><li><code>capability: 70</code></li></ul></li><li><strong>Queue-offline</strong>:<ul><li><code>weight: 1</code></li><li><code>guarantee: 10</code></li><li><code>capability: 50</code></li></ul></li></ul><p><strong>场景 1：集群空闲时（两个队列都已使用各自 <code>guarantee</code> 的资源）</strong></p><ul><li>空闲资源 &#x3D; 100 - 30 - 10 &#x3D; 60核。</li><li>计算 <code>deserved</code>：<ul><li><code>Queue-online.deserved</code> &#x3D; 30 + (2&#x2F;3) * 60 &#x3D; 30 + 40 &#x3D; <strong>70核</strong> (达到capability上限)</li><li><code>Queue-offline.deserved</code> &#x3D; 10 + (1&#x2F;3) * 60 &#x3D; 10 + 20 &#x3D; <strong>30核</strong> (在10-50之间)</li></ul></li><li><strong>结果</strong>：<code>Queue-online</code> 最多可用到70核，<code>Queue-offline</code> 最多可用到30核。<code>Reclaim</code> 不会触发，因为双方都用不到自己的 <code>deserved</code>。</li></ul><p><strong>场景 2：集群繁忙时（<code>Queue-offline</code> 已用了50核，超过了其 <code>deserved</code>）</strong></p><ul><li>假设 <code>Queue-offline</code> 当前用了50核（达到了它的 <code>capability</code>）。</li><li>而 <code>Queue-online</code> 只用了40核（低于它的 <code>deserved</code> 70核）。</li><li><strong><code>Reclaim</code> Action 触发</strong>：<ul><li><code>Queue-offline</code> (allocated&#x3D;50) &gt; <code>Queue-offline.deserved</code> (~30) -&gt; <strong>受害者</strong></li><li><code>Queue-online</code> (allocated&#x3D;40) &lt; <code>Queue-online.deserved</code> (70) -&gt; <strong>发起方</strong></li></ul></li><li><strong><code>Reclaim</code> 执行</strong>：从 <code>Queue-offline</code> 中回收资源，直到它的使用量接近其 <code>deserved</code> 的30核。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong><code>guarantee</code><strong>：是</strong>底线</strong>，确保重要队列不被“饿死”，是防御性的。</li><li><strong><code>capability</code><strong>：是</strong>天花板</strong>，防止单个队列“吃撑”，是隔离性的。</li><li><strong><code>deserved</code><strong>：是</strong>目标线</strong>，在底线和天花板之间动态调整，追求<strong>公平</strong>和<strong>弹性</strong>，是调度器（特别是 <code>Reclaim</code> Action）操作的<strong>核心依据</strong>。</li></ul><p>这三个参数共同作用，使得 Volcano 能够实现一个真正生产级可用的、兼顾公平、效率与安全的多租户资源管理模型。</p><h3 id="💎-总结"><a href="#💎-总结" class="headerlink" title="💎 总结"></a>💎 总结</h3><p>所以，回答你的问题：<strong>即使两个队列总和未超100核，且 <code>queue-online</code> 暂时无额外需求，<code>reclaim</code> 机制仍可能主动触发。</strong></p><p>这并非多此一举，而是为了：</p><ol><li><strong>即刻的公平性</strong>：确保每个队列的资源使用量符合其 <code>deserved</code> 份额设定的公平原则。</li><li><strong>规则的强制性</strong>：维护资源分配规则的权威性，确保资源配额不是“软约束”。</li><li><strong>未来的灵活性</strong>：为其他队列可能随时出现的资源需求做好准备，保持集群资源的弹性和流动性。</li></ol><p>可以说，<code>reclaim</code> 是一种积极的、预防性的调度手段，而不仅仅是被动的应急反应。它致力于在问题发生前就维持一个清晰、公平且高效的资源状态。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>volcano调度器Backfill-Action详解</title>
    <link href="/2025/08/26/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Backfill-Action%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/08/26/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Backfill-Action%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>下面将结合最新版本（以主分支 <code>master</code> 和最新的稳定版本，如 <code>v1.9.0</code> 为参考）的源码，为你深入解析 <strong>Backfill Action</strong> 的具体过程。</p><p>Backfill Action 是 Volcano 调度器中一个非常精巧且重要的组件，它扮演着 <strong>“资源碎片整理者”</strong> 和 <strong>“机会主义者”</strong> 的角色。</p><h3 id="🔧-Backfill-Action-的核心作用与设计哲学"><a href="#🔧-Backfill-Action-的核心作用与设计哲学" class="headerlink" title="🔧 Backfill Action 的核心作用与设计哲学"></a>🔧 Backfill Action 的核心作用与设计哲学</h3><p><strong>核心作用</strong>：当常规的 <code>Allocate</code> Action 因资源不足（无法满足 Gang 策略的 <code>minAvailable</code> 要求）而无法调度一个作业时，<code>Backfill</code> Action 会尝试<strong>绕过 Gang 策略的限制</strong>，将那些<strong>已经分配了资源但尚未完全满足最小执行条件</strong>的作业中的<strong>部分 Pod</strong> 调度到集群的<strong>资源碎片</strong>上。</p><p><strong>设计哲学</strong>：其核心思想是 <strong>“有总比没有好”</strong>。与其让资源碎片闲置，不如先让部分 Pod 运行起来，这有助于：</p><ol><li><strong>提高集群利用率</strong>：充分利用碎片化的资源。</li><li><strong>加速作业完成</strong>：部分 Pod 先运行，可以进行数据加载、预处理等任务。</li><li><strong>试探性调度</strong>：部分 Pod 的成功运行可能为后续 Pod 的调度创造条件（例如，释放更多资源）。</li></ol><h3 id="📦-关键概念与前置知识"><a href="#📦-关键概念与前置知识" class="headerlink" title="📦 关键概念与前置知识"></a>📦 关键概念与前置知识</h3><ul><li><strong><code>Session</code></strong>: 调度会话上下文，包含 <code>Jobs</code> (待调度的 <code>JobInfo</code>), <code>Nodes</code> 等信息。</li><li><strong><code>JobInfo</code></strong>: 内部对一个 PodGroup 及其所有 Pod 的封装。</li><li><strong><code>TaskInfo</code></strong>: 内部对一个 Pod 的封装。</li><li><strong>Victims (受害者) 与 Candidates (候选者)</strong>:<ul><li><strong>Candidates</strong>: 指那些已经分配了一些资源（部分 Pod 已运行），但尚未达到 <code>minAvailable</code>，因此整个作业还在等待的 <code>JobInfo</code>。它们是 Backfill <strong>试图帮助的对象</strong>。</li><li><strong>Victims</strong>: 在 Backfill 的上下文中，这个词可能有些误导。它<strong>不是指被抢占的 Pod</strong>，而是指那些因资源不足而完全无法被 <code>Allocate</code> Action 调度的 <code>JobInfo</code>。Backfill <strong>不会抢占或驱逐任何正在运行的 Pod</strong>。</li></ul></li></ul><h3 id="🔍-Backfill-Action-详细工作流程"><a href="#🔍-Backfill-Action-详细工作流程" class="headerlink" title="🔍 Backfill Action 详细工作流程"></a>🔍 Backfill Action 详细工作流程</h3><p>Backfill Action 的入口点在 <code>pkg/scheduler/actions/backfill/backfill.go</code> 文件中的 <code>Execute</code> 函数。其工作流程可以概括为以下核心步骤：</p><ol><li><p><strong>识别候选作业 (Candidate Selection)<strong>：<br>Backfill 会遍历 Session 中的所有 <code>JobInfo</code>，寻找那些</strong>已经有一部分 Pod 被分配和运行，但尚未达到 <code>minAvailable</code> 要求</strong>的作业。这些作业就是 Backfill 的 <strong>Candidates</strong>。它们处于一种“半调度”状态，是 Backfill 的主要帮助目标。</p></li><li><p><strong>筛选与排序</strong>：<br>对筛选出的 Candidate Jobs，Backfill 会使用配置的插件（如 <strong>Priority</strong> 插件）对它们进行<strong>排序</strong>，决定优先处理哪个作业。</p></li><li><p><strong>遍历候选作业的任务</strong>：<br>对于每一个 Candidate Job，Backfill 会遍历其内部所有仍处于 <code>Pending</code> 状态的 <code>TaskInfo</code>（Pod）。</p></li><li><p><strong>为单个任务执行分配</strong>：<br>对于每一个待调度的 Pending Task，Backfill 会尝试为其分配节点。这个过程与 <code>Allocate</code> Action 类似，但有一个<strong>关键区别</strong>：</p><ul><li><strong>绕过 Gang 策略检查</strong>: Backfill <strong>不会</strong>在执行分配前调用 Gang 插件来检查整个 Job 的 <code>minAvailable</code> 是否满足。它只关心<strong>当前这个单独的 Pod</strong> 能否找到合适的节点。</li><li>**执行预选 (Predicate) 和优选 (NodeOrder)**：它与 <code>Allocate</code> 一样，会调用 <code>Predicates</code> 插件过滤节点，并用 <code>NodeOrder</code> 插件为候选节点打分，选择一个最优节点。</li><li>**资源预留 (Reservation)**：在 Session 缓存中，从选中的节点上扣除该 Pod 所需的资源。</li><li><strong>记录分配指令</strong>：生成 <code>(Task, Node)</code> 的绑定对，暂存在 Session 中。</li></ul></li><li><p><strong>提交分配决策</strong>：<br>在所有 Candidate Jobs 和它们的 Tasks 都处理完毕后，Backfill 会<strong>一次性提交</strong>本周期内所有的分配决策。调度器会通过这些绑定信息更新 API Server，将 Pod 绑定到对应的节点上。</p><p><img src="/2025/08/26/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Backfill-Action%E8%AF%A6%E8%A7%A3/deepseek_mermaid_20250826_13aae3.png" alt="deepseek_mermaid_20250826_13aae3"></p></li></ol><h3 id="⚙️-依赖的插件"><a href="#⚙️-依赖的插件" class="headerlink" title="⚙️ 依赖的插件"></a>⚙️ 依赖的插件</h3><p>Backfill Action 的实现相对独立，但它依赖于其他插件来完成具体决策：</p><ul><li><strong>Predicates 插件</strong>: 负责节点过滤，检查 Pod 是否能调度到某个节点上。</li><li><strong>NodeOrder 插件</strong>: 负责节点打分，选择最优节点。</li><li><strong>Priority 插件</strong>: 用于在多个 Candidate Job 之间进行排序，决定哪个 Job 的 Pod 优先被 Backfill 调度。</li></ul><p><strong>特别注意</strong>：<strong>Gang 插件不参与 Backfill 的决策过程</strong>。这是 Backfill 和 Allocate 最根本的区别。Backfill 故意避开了 Gang 的“All or Nothing”检查。</p><h3 id="🧪-结合示例说明"><a href="#🧪-结合示例说明" class="headerlink" title="🧪 结合示例说明"></a>🧪 结合示例说明</h3><p>假设我们有一个 Job，其 <code>minAvailable</code> 为 5，它已经成功调度并运行了 3 个 Pod，但还有 2 个 Pod 因资源不足而处于 Pending。</p><ol><li><strong>Allocate Action 失败</strong>：在常规的 <code>Allocate</code> Action 中，Gang 插件会检查整个 Job。由于当前只运行了 3 个 Pod (&lt; <code>minAvailable=5</code>)，Gang 插件会<strong>阻止</strong>任何新的分配发生，即使有足够的资源再运行 1 个 Pod。这是为了确保作业的完整性。</li><li><strong>Backfill Action 介入</strong>：<ul><li>Backfill 识别到这个 Job 是一个 Candidate（已有 3 个运行，但未达 5）。</li><li>它绕过 Gang 检查，直接尝试为那 2 个 Pending 的 Pod 分配节点。</li><li>假设集群目前有恰好够 1 个 Pod 运行的资源碎片。</li><li>Backfill 会成功地将其中 1 个 Pod 调度并绑定到节点上。</li></ul></li><li><strong>结果</strong>：现在，这个 Job 有 4 个 Pod 在运行。虽然仍未达到 <code>minAvailable=5</code>，但：<ul><li>集群资源利用率提高了。</li><li>该 Job 的完成进度从 3&#x2F;5 推进到了 4&#x2F;5。</li><li>当更多资源释放时，Backfill 或 Allocate 可以更容易地调度最后一个 Pod。</li></ul></li></ol><h3 id="⚠️-重要配置与注意事项"><a href="#⚠️-重要配置与注意事项" class="headerlink" title="⚠️ 重要配置与注意事项"></a>⚠️ 重要配置与注意事项</h3><ol><li><strong>执行顺序</strong>：在 <code>volcano-scheduler-configmap</code> 中，<code>backfill</code> <strong>必须</strong>放置在 <code>allocate</code> 之后。因为它的职责是处理 <code>allocate</code> 无法解决的问题。典型的配置是：<code>actions: &quot;enqueue, allocate, backfill, preempt&quot;</code>。</li><li><strong>非抢占性</strong>：Backfill <strong>不会</strong>抢占或驱逐任何已经运行的 Pod。它只利用当前集群的<strong>空闲资源</strong>。这是它与 <code>Preempt</code> Action 的本质区别。</li><li><strong>作用对象</strong>：Backfill 主要作用于那些<strong>已经有一部分 Pod 在运行</strong>的作业。对于那些一个 Pod 都还没运行起来的全新作业，Backfill 通常无能为力，因为它们需要靠 <code>Enqueue</code> 和 <code>Allocate</code> 来启动。</li><li><strong>性能考量</strong>：由于 Backfill 需要遍历所有“半调度”状态的作业，在大型集群中可能会带来一定的性能开销。但其带来的集群利用率提升通常是值得的。</li></ol><h3 id="💡-总结"><a href="#💡-总结" class="headerlink" title="💡 总结"></a>💡 总结</h3><p>Backfill Action 是 Volcano 调度器优化集群资源利用率的<strong>关键补充策略</strong>。它通过一种<strong>务实且灵活</strong>的方式，巧妙地绕过了 Gang 调度在极端资源竞争情况下的刚性限制，在保证分布式作业最终一致性的前提下，最大限度地利用了碎片资源，加速了作业的整体完成进度。理解 Backfill 的工作机制，对于调优 Volcano 调度性能和解决复杂的资源调度问题非常有帮助。</p><h2 id="问题一：为什么有的Job会出现部分pod已运行，但pod数量未达到minAvailable"><a href="#问题一：为什么有的Job会出现部分pod已运行，但pod数量未达到minAvailable" class="headerlink" title="问题一：为什么有的Job会出现部分pod已运行，但pod数量未达到minAvailable"></a>问题一：为什么有的Job会出现部分pod已运行，但pod数量未达到minAvailable</h2><p>这个问题非常棒，直接点出了 Volcano 调度策略中一个精妙且关键的地方。您的推理完全正确：在严格的 Gang 调度策略下，<code>Enqueue</code> 和 <code>Allocate</code> 确实不会允许一个未达到 <code>minAvailable</code> 的 Job 启动。</p><p>那么，一个 Job 是如何陷入这种“部分运行”的状态，从而成为 <code>Backfill</code> 的处理对象的呢？这主要是由<strong>集群状态的动态变化</strong>和 <strong><code>Reclaim</code> Action</strong> 导致的。</p><h3 id="🔄-“部分运行”状态是如何产生的？"><a href="#🔄-“部分运行”状态是如何产生的？" class="headerlink" title="🔄 “部分运行”状态是如何产生的？"></a>🔄 “部分运行”状态是如何产生的？</h3><p>主要有以下几种场景：</p><h4 id="1-调度后发生节点故障-资源挤压-最常见"><a href="#1-调度后发生节点故障-资源挤压-最常见" class="headerlink" title="1. 调度后发生节点故障&#x2F;资源挤压 (最常见)"></a>1. 调度后发生节点故障&#x2F;资源挤压 (最常见)</h4><p>这是最典型的情况。我们假设一个 Job 的 <code>minAvailable</code> 是 5。</p><ul><li><p><strong>第 1 步：正常调度</strong></p><ul><li>集群初始状态资源充足。</li></ul></li><li><p><strong><code>Enqueue</code> Action</strong> 检查通过，PodGroup 状态变为 <code>Inqueue</code>。</p></li><li><p><strong><code>Allocate</code> Action</strong> 成功地为 5 个 Pod 分配了节点，<strong>Gang 插件检查通过</strong>（因为 5 &gt;&#x3D; 5）。</p></li><li><p>调度器提交绑定决策，5 个 Pod 的 <code>nodeName</code> 被更新。</p></li><li><p><strong>kubelet</strong> 开始拉取镜像并创建容器，Pod 进入 <code>Running</code> 状态。</p><ul><li>至此，Job 完全满足 Gang 策略。</li></ul></li><li><p><strong>第 2 步：状态异常</strong></p><ul><li>之后，某个节点突然<strong>宕机</strong>（Node NotReady）。</li><li>或者，某个节点上的 <strong>kubelet</strong> 或容器运行时发生问题，导致该节点上的 <strong>1 个 Pod 失败并被驱逐</strong>（Evicted）。</li><li>Kubernetes 的控制面会删除这个失败的 Pod。</li><li><strong>Volcano Controller</strong> 会监测到 Pod 数量不足，为了满足 <code>replicas</code> 定义，它会<strong>立即创建一个新的 Pod 来替换它</strong>。</li></ul></li><li><p><strong>第 3 步：陷入“部分运行”状态</strong></p><ul><li>此时，这个新创建的 Pod 是 <code>Pending</code> 状态。</li><li>而集群当前的状态可能已经<strong>没有足够的空闲资源</strong>来同时满足这个新 Pod 的需求了。</li><li>现在，这个 Job 有 4 个 <code>Running</code> 的 Pod 和 1 个 <code>Pending</code> 的 Pod。</li><li>在接下来的调度周期中：<ul><li><strong><code>Allocate</code> Action 会失败</strong>：Gang 插件检查当前已运行的 Pod 数 (4) &lt; <code>minAvailable</code> (5)，因此它<strong>禁止</strong>为那个 Pending 的 Pod 分配资源，即使有零散资源可用。</li><li>于是，这个 Job 就成为了 <code>Backfill</code> Action 的完美<strong>候选者</strong>。</li></ul></li></ul></li></ul><h4 id="2-通过-Reclaim-Action-回收资源"><a href="#2-通过-Reclaim-Action-回收资源" class="headerlink" title="2. 通过 Reclaim Action 回收资源"></a>2. 通过 <code>Reclaim</code> Action 回收资源</h4><p><code>Reclaim</code> Action 用于跨队列的资源回收。例如，一个高优先级队列的资源被一个低优先级队列的 Job 占用时，<code>Reclaim</code> 可能会驱逐低优先级 Job 的 Pod 来回收资源。</p><ul><li><strong>第 1 步</strong>：一个低优先级的 Job 正在运行，拥有 5 个 Pod。</li><li><strong>第 2 步</strong>：一个高优先级的 Job 被提交，但资源不足。</li><li><strong>第 3 步</strong>：<code>Reclaim</code> Action <strong>驱逐（Evict）</strong> 了低优先级 Job 的 <strong>2 个 Pod</strong>，将资源还给它的队列。</li><li><strong>第 4 步</strong>：Volcano Controller 会创建 2 个新的 Pod 来替换被驱逐的 Pod。</li><li><strong>第 5 步</strong>：现在低优先级 Job 有 3 个 <code>Running</code> 的 Pod 和 2 个 <code>Pending</code> 的 Pod。如果它的 <code>minAvailable</code> 是 5，那么 <code>Allocate</code> 将无法调度这 2 个新 Pod，而 <code>Backfill</code> 就可以介入。</li></ul><h4 id="3-初始资源充足，后续资源被占用"><a href="#3-初始资源充足，后续资源被占用" class="headerlink" title="3. 初始资源充足，后续资源被占用"></a>3. 初始资源充足，后续资源被占用</h4><ul><li><strong>第 1 步</strong>：一个 Job 被成功调度，5 个 Pod 都处于 <code>Running</code> 状态。</li><li><strong>第 2 步</strong>：用户手动删除了其中 1 个 Pod（或由于资源限额被杀死）。</li><li><strong>第 3 步</strong>：Controller 创建替换 Pod，但此时集群资源已经被其他新提交的 Job 占用，导致无法一次性满足 5 个 Pod 的需求。</li></ul><h3 id="🧠-总结与类比"><a href="#🧠-总结与类比" class="headerlink" title="🧠 总结与类比"></a>🧠 总结与类比</h3><p>您可以这样理解：</p><ol><li><strong><code>Enqueue</code> 和 <code>Allocate</code></strong> 是 <strong>“建设者”</strong>，它们严格按照蓝图（Gang 策略）来盖楼，必须地基（资源）足够盖一整栋（<code>minAvailable</code>）才会开工。</li><li><strong><code>Backfill</code></strong> 是 <strong>“修补匠”</strong> 或 <strong>“救护员”</strong>。它处理的是“蓝图”已经被执行了一半，但工地突然出了意外（节点故障）或材料被临时征用（<code>Reclaim</code>）的情况。它的任务不是重新盖楼，而是用<strong>当前能找到的任何砖块（资源碎片）</strong>，尽力把未完成的部分修补好。</li></ol><p>因此，<code>Backfill</code> 处理的状态<strong>不是一个正常流程产生的结果，而是一个异常状态</strong>。它是 Volcano 调度器应对分布式环境下各种故障和动态变化，从而提高集群<strong>韧性</strong>和<strong>资源利用率</strong>的关键机制。</p><p>您能注意到这个看似矛盾的点，说明您对 Volcano 的工作机制思考得非常深入！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>volcano调度器Preempt-Action详解</title>
    <link href="/2025/08/25/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Preempt-Action%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/08/25/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Preempt-Action%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>通过对 Volcano 源码（主要是 <code>v1.12.0</code> 版本）的分析，我来为你详细解析 <strong>Preempt Action</strong> 的具体过程。Preempt Action（抢占动作）是 Volcano 调度器中用于处理<strong>同一队列内</strong>高优先级任务抢占低优先级任务资源的核心机制。</p><h3 id="🔧-Preempt-Action-的核心作用与设计初衷"><a href="#🔧-Preempt-Action-的核心作用与设计初衷" class="headerlink" title="🔧 Preempt Action 的核心作用与设计初衷"></a>🔧 Preempt Action 的核心作用与设计初衷</h3><p>Preempt Action 的核心目标是当集群资源不足时，<strong>确保高优先级的 Job 或 Task 能够优先获得资源</strong>，及时完成计算任务。它通过<strong>选择性驱逐</strong>低优先级的 Pod 来释放资源，满足高优先级任务的调度需求。</p><p>值得注意的是，Volcano 的 Preempt Action 通常用于<strong>同一队列（Queue）内</strong>的抢占。这与 Reclaim Action 不同，后者主要负责<strong>跨队列</strong>的资源回收。</p><h3 id="📦-关键数据结构与前置知识"><a href="#📦-关键数据结构与前置知识" class="headerlink" title="📦 关键数据结构与前置知识"></a>📦 关键数据结构与前置知识</h3><p>在深入了解流程之前，明确几个关键概念和数据结构：</p><ul><li><strong><code>Session</code></strong>: 调度会话的上下文，包含了当前所有待调度的 Job(<code>Jobs</code>)、节点信息(<code>Nodes</code>)、已注册的插件(<code>Plugins</code>)等。</li><li><strong><code>JobInfo</code></strong>: 调度器内部对 <strong>PodGroup</strong> 的封装，包含了优先级信息（通过 <code>priortyClassName</code> 获取）。</li><li><strong><code>TaskInfo</code></strong>: 调度器内部对 <strong>Pod</strong> 的封装，也拥有优先级信息。</li><li><strong>优先级来源</strong>: 优先级通常来源于 Pod 或 Job 的 <code>priorityClassName</code> 字段，其值映射到一个整数 Value，<strong>值越大，优先级越高</strong>。</li></ul><h3 id="🔍-Preempt-Action-详细工作流程"><a href="#🔍-Preempt-Action-详细工作流程" class="headerlink" title="🔍 Preempt Action 详细工作流程"></a>🔍 Preempt Action 详细工作流程</h3><p>Preempt Action 的入口点在 <code>pkg/scheduler/actions/preempt/preempt.go</code> 文件中的 <code>Execute</code> 函数。其工作流程可以概括为以下核心步骤：</p><ol><li><p><strong>识别受害者（Victim Selection）</strong>：<br>Preempt Action 会遍历所有当前<strong>已调度</strong>（处于 <code>Running</code> 或 <code>Bound</code> 状态）的 <code>TaskInfo</code>（Pod），寻找那些<strong>优先级低于</strong>当前待调度任务的 Pod。这些低优先级的 Pod 被标记为“潜在的”抢占受害者。</p></li><li><p><strong>模拟抢占与安全检查</strong>：<br>对于每一个待调度的高优先级任务和每一个潜在的受害者，调度器会进行<strong>模拟抢占</strong>。这个过程严重依赖 <strong>Gang 插件</strong>：</p><ul><li>Gang 插件会检查：如果驱逐（抢占）了某个（或某些）低优先级的 Pod，是否会导致其所属的 Job <strong>不满足 <code>minAvailable</code> 约束</strong>（即破坏其 Gang 调度策略）。</li><li>同时，<strong>Conformance 插件</strong>会确保 <code>kube-system</code> 命名空间下的关键 Pod <strong>不会被抢占</strong>。</li><li>只有那些被驱逐后<strong>不会破坏其原 Job 完整性</strong>的低优先级 Pod，才会被确定为“真正的”受害者。</li></ul></li><li><p><strong>执行抢占</strong>：<br>一旦确定了可行的受害者，调度器会<strong>真正地驱逐这些 Pod</strong>。这是通过调用 Kubernetes API <strong>删除这些 Pod</strong> 来实现的。这些被抢占的 Pod 会进入 <code>Terminating</code> 状态，其资源将被释放。</p></li><li><p><strong>资源释放与后续调度</strong>：<br>受害者 Pod 被删除后，它们之前占用的资源（CPU、内存等）也就释放了。这些释放出来的资源<strong>不会立即分配给发起抢占的高优先级任务</strong>。而是等待<strong>下一个调度周期</strong>，由 <code>Enqueue</code> 和 <code>Allocate</code> 等 Action 来重新分配这些资源。此时，由于高优先级任务仍在队列中，并且资源变得可用，它就有很大概率在后续的调度中被成功分配资源。</p></li></ol><p>下图概括了上述流程及其与后续调度周期的关系：</p><p><img src="/2025/08/25/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Preempt-Action%E8%AF%A6%E8%A7%A3/deepseek_mermaid_20250825_eb671f.png" alt="deepseek_mermaid_20250825_eb671f"></p><h3 id="⚙️-依赖的关键插件"><a href="#⚙️-依赖的关键插件" class="headerlink" title="⚙️ 依赖的关键插件"></a>⚙️ 依赖的关键插件</h3><p>Preempt Action 的具体行为由一系列插件决定：</p><ul><li><strong>Gang 插件</strong>: 这是安全检查的核心。它确保了抢占行为<strong>不会破坏分布式任务的原子性</strong>（”All or Nothing”）。这是 Preempt Action 能安全工作的基石。</li><li><strong>Priority 插件</strong>: 用于比较 <code>JobInfo</code> 或 <code>TaskInfo</code> 之间的优先级，确定谁可以抢占谁。</li><li><strong>Conformance 插件</strong>: 提供系统层面的安全保护，确保 <code>kube-system</code> 命名空间下的关键 Pod <strong>不会被抢占</strong>，维护集群的稳定性。</li></ul><h3 id="⚠️-重要配置与注意事项"><a href="#⚠️-重要配置与注意事项" class="headerlink" title="⚠️ 重要配置与注意事项"></a>⚠️ 重要配置与注意事项</h3><p>要使 Preempt Action 正常工作，必须在 <code>volcano-scheduler-configmap</code> 中进行正确配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">actions:</span> <span class="hljs-string">&quot;enqueue, allocate, backfill, preempt&quot;</span> <span class="hljs-comment"># 必须包含preempt</span><br><span class="hljs-attr">tiers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">plugins:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">priority</span>   <span class="hljs-comment"># 优先级比较</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">gang</span>       <span class="hljs-comment"># Gang策略检查</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">conformance</span> <span class="hljs-comment"># 保护系统Pod</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">plugins:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">drf</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">predicates</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nodeorder</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">preemption</span>  <span class="hljs-comment"># 抢占插件本身及其参数</span><br>    <span class="hljs-attr">arguments:</span><br>      <span class="hljs-attr">enablePreemption:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment"># 必须显式启用抢占</span><br>      <span class="hljs-attr">enableJobStarving:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 通常需要设置为false以允许抢占</span><br></code></pre></td></tr></table></figure><p><strong>关键参数解析</strong>：</p><ul><li><code>enablePreemption</code>: <strong>必须设置为 <code>true</code></strong> 来全局启用抢占功能。</li><li><code>enableJobStarving</code>: 这个参数的名称有些误导性。将其设置为 <code>false</code> 通常意味着<strong>允许低优先级任务被抢占</strong>（即“挨饿”），从而为高优先级任务让路。设置为 <code>true</code> 反而可能会保护它们不被抢占。</li></ul><h3 id="🧪-结合示例说明"><a href="#🧪-结合示例说明" class="headerlink" title="🧪 结合示例说明"></a>🧪 结合示例说明</h3><p>假设队列 <code>queue-a</code> 中有两个 Job：</p><ul><li><strong>Job-Low</strong>: 优先级为 10，已运行 5 个 Pod（其 <code>minAvailable</code> 为 3）。</li><li><strong>Job-High</strong>: 优先级为 100，需要 3 个 Pod，但因资源不足处于 Pending。</li></ul><p>当 Preempt Action 执行时：</p><ol><li><strong>识别受害者</strong>: 发现 <code>Job-Low</code> 的优先级 (10) 低于 <code>Job-High</code> (100)，其 Pod 被列为潜在受害者。</li><li><strong>模拟与检查</strong>: Gang 插件检查抢占 <code>Job-Low</code> 的 2 个 Pod 是否可行。由于 <code>Job-Low</code> 的 <code>minAvailable</code> 是 3，抢占 2 个后还剩 3 个运行中的 Pod，满足条件，安全检查通过。如果 <code>minAvailable</code> 是 5，则抢占任何 1 个 Pod 都会导致其不满足条件，抢占会被禁止。</li><li><strong>执行抢占</strong>: 驱逐 <code>Job-Low</code> 的 2 个 Pod。</li><li><strong>资源释放</strong>: 这 2 个 Pod 占用的资源被释放。</li><li><strong>后续调度</strong>: 在下一个调度周期，<code>Job-High</code> 的 3 个 Pod 因为优先级高，在 <code>Allocate</code> action 中成功分配到这部分新释放的资源。</li></ol><h3 id="💡-总结与关键点"><a href="#💡-总结与关键点" class="headerlink" title="💡 总结与关键点"></a>💡 总结与关键点</h3><ol><li><strong>队列内抢占</strong>: Volcano 的 Preempt Action 主要处理<strong>同一队列内</strong>的抢占。</li><li><strong>安全第一</strong>: 抢占过程受到 <strong>Gang 策略的严格约束</strong>，绝不会以破坏一个分布式应用的完整性为代价去满足另一个应用。</li><li><strong>异步过程</strong>: 抢占（删除 Pod）和资源的再分配（调度高优先级 Pod）是<strong>跨调度周期</strong>的异步过程。</li><li><strong>配置是关键</strong>: 必须正确配置调度器 ConfigMap 中的 <code>actions</code> 和 <code>preemption</code> 插件参数（特别是 <code>enablePreemption: true</code>）才能启用抢占功能。</li><li><strong>系统保护</strong>: 关键系统 Pod 默认受到保护，不会被抢占，确保了集群的稳定性。</li></ol><p>希望这份结合源码的详细解读，能帮助你透彻地理解 Volcano Preempt Action 的工作机制。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>volcano-allocate-action详解</title>
    <link href="/2025/08/24/volcano-allocate-action%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/08/24/volcano-allocate-action%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Volcano 调度器中的 <strong>Allocate Action</strong> 是调度流程的核心环节，它负责为已经入队（Inqueue）的 Pod 分配具体的节点。这个过程非常精密，涉及到预选、优选、资源预留和最终的绑定决策。</p><p>下面我将结合 Volcano 的最新源码（主要参考 <code>v1.12.0</code> 版本），为你详细解析 Allocate Action 的具体过程。</p><h3 id="🔧-Allocate-Action-的核心作用"><a href="#🔧-Allocate-Action-的核心作用" class="headerlink" title="🔧 Allocate Action 的核心作用"></a>🔧 Allocate Action 的核心作用</h3><p>Allocate Action 的核心任务是<strong>为每个已入队的 Pod 尝试分配一个合适的节点</strong>。它不仅会检查节点资源的充足性，还要确保满足作业级别的约束（如 Gang 调度策略），并在最终一次性提交所有绑定决策。</p><h3 id="📦-关键数据结构"><a href="#📦-关键数据结构" class="headerlink" title="📦 关键数据结构"></a>📦 关键数据结构</h3><p>在深入流程之前，了解几个关键的数据结构有助于理解后续过程：</p><ul><li><strong><code>Session</code></strong>: 代表一个调度周期（Session）的上下文，包含了当前调度所需的所有信息，如待调度的 Job 列表 (<code>Jobs</code>)、集群节点信息 (<code>Nodes</code>)、已注册的插件 (<code>Plugins</code>) 等。Allocate Action 会操作这个 Session。</li><li><strong><code>JobInfo</code></strong>: 并非直接对应 Volcano Job CRD，而是调度器内部对 <strong>PodGroup</strong> 及其所属 Pod 的封装。一个 <code>JobInfo</code> 包含了一个 PodGroup 下的所有 Pod（封装为 <code>TaskInfo</code>）。</li><li><strong><code>TaskInfo</code></strong>: 调度器内部对 <strong>Pod</strong> 的封装。包含了 Pod 的详细信息以及其资源请求。</li><li><strong><code>NodeInfo</code></strong>: 调度器内部对 <strong>Kubernetes Node</strong> 的封装。包含了节点的资源容量、已分配资源、支持的操作系统架构等信息。</li></ul><h3 id="🔍-Allocate-Action-详细工作流程"><a href="#🔍-Allocate-Action-详细工作流程" class="headerlink" title="🔍 Allocate Action 详细工作流程"></a>🔍 Allocate Action 详细工作流程</h3><p>Allocate Action 的入口点在 <code>pkg/scheduler/actions/allocate/allocate.go</code> 文件中的 <code>Execute</code> 函数。其工作流程可以概括为以下几个核心步骤：</p><ol><li><strong>准备待调度的任务</strong>：遍历当前 Session 中的所有 <code>JobInfo</code>，收集其中处于 <code>Pending</code> 状态的 <code>TaskInfo</code>（Pod）。这些任务就是本轮 Allocate Action 需要尝试调度的对象。</li><li><strong>任务排序</strong>：根据配置的插件（如 <strong>Priority</strong> 插件），对这些待调度的 <code>TaskInfo</code> 进行排序。通常优先级高的任务会优先得到调度。</li><li><strong>遍历任务，尝试分配</strong>：这是最核心的循环。对于每一个待调度的任务，执行以下子步骤：<ul><li><strong>a. 预选 (Predicate)<strong>：调用 <strong>Predicates</strong> 插件，过滤掉所有不满足该 Pod 基本要求的节点。例如，检查节点的资源（CPU、内存、GPU）是否 &gt;&#x3D; Pod 的请求，检查节点Selector、亲和性&#x2F;反亲和性、污点容忍等。通过这一步，会得到一个</strong>候选节点列表</strong>。</li><li><strong>b. 优选 (Prioritize&#x2F;Node Ordering)<strong>：如果预选后还有多个候选节点，则会调用 <strong>NodeOrder</strong> 等插件为这些节点打分。插件会考虑多种因素，如资源平衡（Binpack 或 Spread）、节点亲和性、镜像是否已存在等，最终选出一个</strong>最优节点</strong>。</li><li><strong>c. 资源预留 (Reservation)<strong>：并不是立即调用 Kubernetes API 进行绑定，而是在当前 Session 的缓存中，</strong>模拟</strong>从选出的最优节点上扣除该 Pod 所请求的资源。这一步确保了后续的调度决策是基于最新的资源视图，避免了重复分配。</li><li><strong>d. 生成分配指令</strong>：将 <code>(TaskInfo, NodeInfo)</code> 这个分配决策记录下来，存储在 Session 中，等待后续提交。</li></ul></li><li><strong>提交分配决策 (Commit)<strong>：在所有合适的任务都经过上述流程后，Allocate Action 会</strong>一次性提交</strong>本周期内所有的分配决策。调度器会将这些绑定信息（Pod 和 Node 的对应关系）通过 Kubernetes API Server 进行更新（设置 Pod 的 <code>nodeName</code> 字段）。</li></ol><p><img src="/2025/08/24/volcano-allocate-action%E8%AF%A6%E8%A7%A3/deepseek_mermaid_20250823_5e5c2b.png" alt="deepseek_mermaid_20250823_5e5c2b"></p><h3 id="⚙️-依赖的关键插件"><a href="#⚙️-依赖的关键插件" class="headerlink" title="⚙️ 依赖的关键插件"></a>⚙️ 依赖的关键插件</h3><p>Allocate Action 本身是一个框架，其具体行为由一系列插件决定：</p><ul><li><strong>Gang 插件</strong>: 这是 <strong>“All or Nothing” 策略的强制执行者</strong>。即使一个 Pod 通过了预选和优选，Gang 插件也会检查其所属的整个 <code>JobInfo</code> (PodGroup) 是否满足 <code>minAvailable</code> 条件。<strong>只有在满足 <code>minAvailable</code> 时，本次会话中为该 Job 所做的所有分配才会被提交；否则，所有分配都会被回滚</strong>，该 Job 的 Pod 不会绑定到任何节点。<strong>Gang检查是在遍历完所有的pod之后</strong>。</li><li><strong>Predicates 插件</strong>: 负责<strong>预选</strong>，实现节点过滤的逻辑。它检查 Pod 是否适合调度到某个节点上。</li><li><strong>NodeOrder 插件</strong>: 负责<strong>优选</strong>，实现节点打分的逻辑。它为每个候选节点计算一个分数，调度器选择分数最高的节点。</li><li><strong>Binpack 插件</strong>: 通常与 NodeOrder 插件协同工作，倾向于将资源分配集中在尽可能少的节点上，以提高节点利用率，便于后续腾空节点。</li><li><strong>Priority 插件</strong>: 用于在多个待调度的 Task(Pod) 之间进行优先级排序，决定哪个 Pod 优先进行分配。</li></ul><h3 id="🧪-结合示例说明"><a href="#🧪-结合示例说明" class="headerlink" title="🧪 结合示例说明"></a>🧪 结合示例说明</h3><p>假设我们有一个包含 1 个 <code>ps</code> 和 2 个 <code>worker</code> 的 TensorFlow 作业（PodGroup，<code>minAvailable=3</code>），并且已通过 Enqueue Action 检查，Pod 已被创建。</p><ol><li><strong>Allocate Action 开始</strong>：调度器收集这 3 个处于 Pending 状态的 Pod。</li><li><strong>任务排序</strong>：假设优先级相同，则按创建时间等顺序处理。</li><li><strong>为 <code>ps</code> Pod 分配</strong>：<ul><li><strong>Predicate</strong>：过滤出所有满足 <code>ps</code> 资源请求（例如 1 CPU, 2GiB Mem）的节点。</li><li><strong>NodeOrder</strong>：对候选节点打分（例如，选择资源碎片最少的节点 <code>node-a</code>）。</li><li><strong>预留</strong>：在 Session 中标记 <code>node-a</code> 的 1 CPU 和 2GiB Mem 被预留。</li></ul></li><li><strong>为 <code>worker-1</code> Pod 分配</strong>：<ul><li><strong>Predicate</strong>：过滤节点（现在 <code>node-a</code> 可用资源减少了）。</li><li><strong>NodeOrder</strong>：选出最优节点 <code>node-b</code>。</li><li><strong>预留</strong>：预留 <code>node-b</code> 上 2 CPU 和 4GiB Mem。</li></ul></li><li><strong>为 <code>worker-2</code> Pod 分配</strong>：<ul><li><strong>Predicate</strong>：过滤节点。</li><li><strong>NodeOrder</strong>：选出最优节点 <code>node-c</code>。</li><li><strong>预留</strong>：预留 <code>node-c</code> 上 2 CPU 和 4GiB Mem。</li></ul></li><li><strong>Gang 插件检查</strong>：调度器检查到该 Job 的 3 个 Pod 都已成功分配节点，满足 <code>minAvailable=3</code> 的条件。</li><li><strong>提交</strong>：调度器通过 API Server 将这 3 个 Pod 分别绑定到 <code>node-a</code>, <code>node-b</code>, <code>node-c</code>。</li></ol><p>如果集群资源只够运行 2 个 <code>worker</code>，不够运行 <code>ps</code>，那么 Gang 插件会检查失败，导致<strong>所有 3 个 Pod 的分配都会被撤销</strong>，等待下一个调度周期再尝试。这就有效防止了分布式任务因部分进程无法启动而造成的死锁。</p><h3 id="⚠️-注意事项"><a href="#⚠️-注意事项" class="headerlink" title="⚠️ 注意事项"></a>⚠️ 注意事项</h3><ol><li><strong>执行顺序</strong>：在 <code>volcano-scheduler-configmap</code> 中，<code>allocate</code> 通常放置在 <code>enqueue</code> 之后，<code>backfill</code> 之前。Action 的执行顺序很重要。</li><li><strong>插件配置</strong>：确保 <code>allocate</code> 所依赖的插件（如 <code>predicates</code>, <code>nodeorder</code>, <code>gang</code>）已在配置中正确启用并放置在合适的 tier 中。</li><li><strong>与 Preempt&#x2F;Reclaim 的区别</strong>：<code>Allocate</code> 是正常分配，而 <code>Preempt</code> 是同一队列内基于优先级的抢占，<code>Reclaim</code> 是跨队列的资源回收。它们解决的是不同层面的资源分配问题。</li></ol><p>希望这份结合源码的详细解读，能帮助你透彻地理解 Volcano Allocate Action 的工作机制。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PVC-StorageClass-PV原理解读</title>
    <link href="/2025/08/22/PVC-StorageClass-PV%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/"/>
    <url>/2025/08/22/PVC-StorageClass-PV%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="PVC、StorageClass、PV是什么"><a href="#PVC、StorageClass、PV是什么" class="headerlink" title="PVC、StorageClass、PV是什么"></a>PVC、StorageClass、PV是什么</h1><p>你好！欢迎来到Kubernetes的世界！你遇到的这三个概念（PVC, PV, StorageClass）确实是存储部分的核心，也是很多初学者会感到困惑的地方。别担心，我用一个简单的比喻和详细的解释来帮你彻底搞懂它们。</p><h3 id="一个生动的比喻：租房"><a href="#一个生动的比喻：租房" class="headerlink" title="一个生动的比喻：租房"></a>一个生动的比喻：租房</h3><p>想象一下你要租房子：</p><ol><li><p><strong>PVC (PersistentVolumeClaim) - 你的“租房需求”</strong></p><ul><li>你告诉中介：“我需要一个<strong>不小于20平米、带窗户、月租不超过2000块</strong>的房子。” 这份“需求清单”就是你的<strong>PVC</strong>。它不关心房子具体在哪、房东是谁，只关心你的<strong>规格要求</strong>。</li></ul></li><li><p><strong>PV (PersistentVolume) - 具体的“房子”</strong></p><ul><li>中介手里有一套<strong>真实的、具体的</strong>房子，地址是“XX小区1号楼101”，面积25平米，月租1800块。这套房子就是一个<strong>PV</strong>。它是集群中的<strong>一块实际的存储资源</strong>，就像一块硬盘。</li></ul></li><li><p><strong>StorageClass - 高效的“房产开发商 + 中介”</strong></p><ul><li>现在，你不用等中介去找现成的房子了。有一个超级高效的<strong>“开发商+中介”联合体</strong>（StorageClass）。你一旦提出需求（PVC），这个联合体就立刻<strong>按需</strong>为你建好一套新房（PV）并租给你。它定义了<strong>如何动态地创建PV</strong>（房子的建造标准、用什么材料等）。</li></ul></li></ol><p><strong>关系总结：</strong></p><ul><li><strong>PVC</strong> 是 <strong>需求</strong>。</li><li><strong>PV</strong> 是 <strong>资源</strong>。</li><li><strong>StorageClass</strong> 是 <strong>按需创建资源的模板和自动化工具</strong>。</li><li><strong>PVC 向系统申请资源，系统则寻找一个现有的PV（静态供给）或通过StorageClass创建一个新的PV（动态供给）来满足这个PVC的需求。</strong></li></ul><hr><h3 id="详细概念解释"><a href="#详细概念解释" class="headerlink" title="详细概念解释"></a>详细概念解释</h3><h4 id="1-PV-PersistentVolume-持久化卷"><a href="#1-PV-PersistentVolume-持久化卷" class="headerlink" title="1. PV (PersistentVolume) - 持久化卷"></a>1. PV (PersistentVolume) - 持久化卷</h4><ul><li><strong>是什么</strong>： 集群中的一块<strong>网络存储空间</strong>。它是集群级别的资源，就像集群中的一台Node一样，不属于任何Namespace。它是对底层共享存储（如NFS, Ceph, AWS EBS, Google Persistent Disk等）的一种抽象定义。</li><li><strong>作用</strong>： <strong>提供存储</strong>。PV是有实际存储介质backing的。</li><li><strong>关键配置</strong>： 定义存储容量（<code>capacity</code>）、访问模式（<code>accessModes</code>，如ReadWriteOnce, ReadOnlyMany等）和存储类型（<code>storageClassName</code>）。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolume</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-manual-pv</span>  <span class="hljs-comment"># PV的名字</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">capacity:</span><br>    <span class="hljs-attr">storage:</span> <span class="hljs-string">10Gi</span>  <span class="hljs-comment"># 存储大小</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span>  <span class="hljs-comment"># 访问模式：允许单个节点读写</span><br>  <span class="hljs-attr">persistentVolumeReclaimPolicy:</span> <span class="hljs-string">Retain</span>  <span class="hljs-comment"># 回收策略：删除PVC后，PV保留数据和本身</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">slow</span>  <span class="hljs-comment"># 属于哪个StorageClass（可选）</span><br>  <span class="hljs-attr">nfs:</span>  <span class="hljs-comment"># 具体的后端存储类型和配置</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-number">172.17</span><span class="hljs-number">.0</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure><h4 id="2-PVC-PersistentVolumeClaim-持久化卷声明"><a href="#2-PVC-PersistentVolumeClaim-持久化卷声明" class="headerlink" title="2. PVC (PersistentVolumeClaim) - 持久化卷声明"></a>2. PVC (PersistentVolumeClaim) - 持久化卷声明</h4><ul><li><strong>是什么</strong>： 用户（或Pod）对存储的<strong>一个请求</strong>或<strong>声明</strong>。它是Namespace级别的资源。它就像一个“提货单”。</li><li><strong>作用</strong>： <strong>申请和使用存储</strong>。Pod不直接使用PV，而是通过PVC来申请合适的存储资源。PVC让用户无需关心底层存储的具体实现细节。</li><li><strong>关键配置</strong>： 申请存储的大小（<code>resources.requests.storage</code>）、访问模式（<code>accessModes</code>）和通过<code>storageClassName</code>来指定向哪个StorageClass申请。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-pvc</span>  <span class="hljs-comment"># PVC的名字</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">slow</span>  <span class="hljs-comment"># 指名需要由哪个StorageClass来动态 provisioning（可选）</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span>  <span class="hljs-comment"># 申请5G空间</span><br></code></pre></td></tr></table></figure><h4 id="3-StorageClass-SC-存储类"><a href="#3-StorageClass-SC-存储类" class="headerlink" title="3. StorageClass (SC) - 存储类"></a>3. StorageClass (SC) - 存储类</h4><ul><li><strong>是什么</strong>： 对存储的<strong>抽象分类</strong>和<strong>动态配置器</strong>。它定义了“一类”存储，并指定了用什么** Provisioner**（驱动）来动态创建PV。</li><li><strong>作用</strong>： **实现存储的动态供给(Dynamic Provisioning)**。管理员无需预先创建一堆PV等着。当用户提交一个PVC时，Kubernetes会根据PVC中指定的StorageClass，自动调用相应的驱动去创建合适的PV。</li><li><strong>关键配置</strong>： Provisioner（供应商驱动，如 <code>kubernetes.io/aws-ebs</code>）、参数（<code>parameters</code>，如磁盘类型、区域等）。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fast-ssd</span>  <span class="hljs-comment"># StorageClass的名字，PVC通过这个名字来指向它</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/aws-ebs</span>  <span class="hljs-comment"># 使用的驱动</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">gp3</span>  <span class="hljs-comment"># 参数：要求创建gp3类型的EBS卷</span><br>  <span class="hljs-attr">fsType:</span> <span class="hljs-string">ext4</span><br></code></pre></td></tr></table></figure><hr><h3 id="为什么Kubernetes要这样设计？"><a href="#为什么Kubernetes要这样设计？" class="headerlink" title="为什么Kubernetes要这样设计？"></a>为什么Kubernetes要这样设计？</h3><p>这种设计（PVC&#x2F;PV&#x2F;StorageClass）解决了以下几个核心问题：</p><ol><li><p><strong>解耦与应用和存储</strong>：</p><ul><li><strong>开发人员</strong>（Pod的开发者）只需要关心<strong>需要多大的存储</strong>（写PVC），而不用关心存储的具体技术细节（是NFS还是云硬盘？性能如何？）。</li><li><strong>集群管理员</strong>负责管理和配置后端的存储系统和StorageClass，而不用为每个应用手动去创建对应的PV。</li></ul></li><li><p><strong>资源的灵活性与动态性</strong>：</p><ul><li>**静态供给(Static Provisioning)**： 管理员预先创建一批PV。PVC只能在现有的PV池里寻找匹配的。如果找不到，申请就会 pending。这种方式很笨拙，容易造成资源浪费或不足。</li><li><strong>动态供给(Dynamic Provisioning)<strong>： <strong>这是现代K8s集群的标配和推荐做法</strong>。通过StorageClass，可以实现“按需分配”。用户提交PVC -&gt; K8s看到没有现成的PV能匹配 -&gt; 调用SC创建新的PV -&gt; PVC自动绑定到新PV。</strong>极大提高了自动化程度和资源利用率</strong>。</li></ul></li><li><p><strong>支持多种存储后端</strong>：<br>通过不同的Provisioner，Kubernetes可以无缝地接入各种各样、来自不同供应商的存储系统（公有云、私有云、本地存储等），为用户提供统一的存储使用体验。</p></li></ol><h3 id="工作流程总结"><a href="#工作流程总结" class="headerlink" title="工作流程总结"></a>工作流程总结</h3><p>下图清晰地展示了三者之间的关系与两种供给方式的工作流程：</p><p><img src="/2025/08/22/PVC-StorageClass-PV%E5%8E%9F%E7%90%86%E8%A7%A3%E8%AF%BB/deepseek_mermaid_20250822_b867d7.png" alt="deepseek_mermaid_20250822_b867d7"></p><h3 id="如何记住和使用？"><a href="#如何记住和使用？" class="headerlink" title="如何记住和使用？"></a>如何记住和使用？</h3><ul><li><strong>作为使用者（开发者）</strong>：你99%的情况只需要和<strong>PVC</strong>打交道。在你的Deployment的Pod模板中，定义<code>volumes</code>时引用的是<strong>PVC的名字</strong>。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">app-storage</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">my-pvc</span>  <span class="hljs-comment"># 你上面创建的PVC的名字</span><br></code></pre></td></tr></table></figure></li><li><strong>作为管理员</strong>：你需要根据公司的存储基础设施，创建和维护合适的<strong>StorageClass</strong>。对于简单的测试环境（如minikube），通常已经有一个默认的StorageClass。</li></ul><p>希望这个解释能帮你彻底理解这三个概念！这是掌握Kubernetes持久化存储非常重要的一步。祝你学习顺利！</p><h1 id="Kubernetes-持久化存储实战：NFS-动态供给示例"><a href="#Kubernetes-持久化存储实战：NFS-动态供给示例" class="headerlink" title="Kubernetes 持久化存储实战：NFS 动态供给示例"></a>Kubernetes 持久化存储实战：NFS 动态供给示例</h1><p>我理解你希望在理解PVC、PV和StorageClass的基本概念后，通过一个具体的实战例子来加深理解。下面我将以一个基于<strong>NFS存储</strong>的<strong>动态存储配置</strong>为例，详细展示如何在实际的Kubernetes集群中创建和使用这些资源。</p><p>这个例子会使用NFS作为后端存储，并部署一个NFS Client Provisioner来动态创建PV。之后，我们会创建一个PVC来申请存储，最后在一个Pod中使用这个PVC。</p><h1 id="🚀-Kubernetes-持久化存储实战：NFS-动态供给示例"><a href="#🚀-Kubernetes-持久化存储实战：NFS-动态供给示例" class="headerlink" title="🚀 Kubernetes 持久化存储实战：NFS 动态供给示例"></a>🚀 Kubernetes 持久化存储实战：NFS 动态供给示例</h1><p>为了让刚才讨论的存储概念更加具体，我们来看一个基于NFS（Network File System）的<strong>动态存储配置实战例子</strong>。在这个例子中，我们会：</p><ol><li><strong>搭建NFS服务器</strong>（假设还没有）</li><li><strong>部署NFS Client Provisioner</strong>（负责动态创建PV）</li><li><strong>创建StorageClass</strong></li><li><strong>创建PVC并验证动态创建PV</strong></li><li><strong>在Pod中使用PVC</strong></li></ol><h2 id="准备工作：准备NFS服务器"><a href="#准备工作：准备NFS服务器" class="headerlink" title="准备工作：准备NFS服务器"></a>准备工作：准备NFS服务器</h2><p>首先，你需要一个NFS服务器。如果你还没有，可以在一个Linux节点（可以是Kubernetes集群中的一个节点，也可以是外部节点）上快速搭建：</p><ol><li><p><strong>安装NFS服务器</strong>（在NFS服务器节点上执行）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt-get update &amp;&amp; <span class="hljs-built_in">sudo</span> apt-get install -y nfs-kernel-server <span class="hljs-comment"># 对于Ubuntu/Debian</span><br><span class="hljs-comment"># 或者</span><br><span class="hljs-comment"># sudo yum install -y nfs-utils nfs-utils-lib # 对于CentOS/RHEL</span><br></code></pre></td></tr></table></figure></li><li><p><strong>创建共享目录并配置导出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> -p /srv/nfs/k8s-pv  <span class="hljs-comment"># 创建一个共享目录</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chown</span> nobody:nogroup /srv/nfs/k8s-pv  <span class="hljs-comment"># 修改目录所有权，根据NFS配置可能需要</span><br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 777 /srv/nfs/k8s-pv  <span class="hljs-comment"># 为了示例简单，设置宽松的权限</span><br></code></pre></td></tr></table></figure><p>编辑 <code>/etc/exports</code> 文件，添加以下行（请根据你的网络情况调整网段）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/srv/</span>nfs<span class="hljs-regexp">/k8s-pv 192.168.100.0/</span><span class="hljs-number">24</span>(rw,sync,no_subtree_check,no_root_squash)<br></code></pre></td></tr></table></figure><p>保存后，导出配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> exportfs -a<br><span class="hljs-built_in">sudo</span> systemctl restart nfs-kernel-server<br><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> nfs-kernel-server<br></code></pre></td></tr></table></figure></li><li><p><strong>（可选）在Kubernetes集群节点上安装NFS客户端</strong>：<br>通常，Kubernetes节点已经安装了NFS客户端支持。如果没有，你可能需要安装 <code>nfs-common</code> (Ubuntu&#x2F;Debian) 或 <code>nfs-utils</code> (CentOS&#x2F;RHEL)。</p></li></ol><h2 id="步骤一：部署NFS-Client-Provisioner"><a href="#步骤一：部署NFS-Client-Provisioner" class="headerlink" title="步骤一：部署NFS Client Provisioner"></a>步骤一：部署NFS Client Provisioner</h2><p>NFS本身不支持动态供给，我们需要一个叫做 <strong>NFS Client Provisioner</strong> 的控制器，它可以根据PVC的请求，自动在NFS服务器上创建目录并生成对应的PV。</p><p>首先，我们需要为Provisioner创建RBAC（基于角色的访问控制）资源，因为它需要在集群中创建PV等资源。</p><h3 id="1-创建RBAC授权"><a href="#1-创建RBAC授权" class="headerlink" title="1. 创建RBAC授权"></a>1. 创建RBAC授权</h3><p>将以下内容保存为 <code>nfs-rbac.yaml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span> <span class="hljs-comment"># 通常部署在default命名空间，可根据需要修改</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner-runner</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;persistentvolumes&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;persistentvolumeclaims&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;storage.k8s.io&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;storageclasses&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;events&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;endpoints&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">run-nfs-client-provisioner</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner-runner</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br><span class="hljs-meta">---</span><br><span class="hljs-comment"># 如果需要Leader选举，可能还需要一个Role和RoleBinding</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">apiGroups:</span> [<span class="hljs-string">&quot;&quot;</span>]<br>    <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;endpoints&quot;</span>]<br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RoleBinding</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">Role</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">leader-locking-nfs-client-provisioner</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br></code></pre></td></tr></table></figure><p>应用RBAC配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f nfs-rbac.yaml<br></code></pre></td></tr></table></figure><h3 id="2-部署NFS-Client-Provisioner"><a href="#2-部署NFS-Client-Provisioner" class="headerlink" title="2. 部署NFS Client Provisioner"></a>2. 部署NFS Client Provisioner</h3><p>将以下内容保存为 <code>nfs-provisioner-deployment.yaml</code> 文件。<strong>请务必将 <code>192.168.100.200</code> 替换为你实际的NFS服务器IP地址，将 <code>/srv/nfs/k8s-pv</code> 替换为你实际的NFS共享路径。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">strategy:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">Recreate</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nfs-client-provisioner</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">nfs-client-provisioner</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-provisioner</span><br>          <span class="hljs-comment"># 一个常用的NFS Client Provisioner镜像</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">chronolaw/nfs-subdir-external-provisioner:v4.0.2</span><br>          <span class="hljs-attr">volumeMounts:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-root</span><br>              <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/persistentvolumes</span><br>          <span class="hljs-attr">env:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PROVISIONER_NAME</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">nfs-storage</span> <span class="hljs-comment"># 分配器的名称，后续创建StorageClass时会用到</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NFS_SERVER</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.200</span> <span class="hljs-comment"># 请修改为你的NFS服务器IP</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">NFS_PATH</span><br>              <span class="hljs-attr">value:</span> <span class="hljs-string">/srv/nfs/k8s-pv</span> <span class="hljs-comment"># 请修改为你的NFS共享目录</span><br>      <span class="hljs-attr">volumes:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client-root</span><br>          <span class="hljs-attr">nfs:</span><br>            <span class="hljs-attr">server:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.100</span><span class="hljs-number">.200</span> <span class="hljs-comment"># 请修改为你的NFS服务器IP</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/srv/nfs/k8s-pv</span> <span class="hljs-comment"># 请修改为你的NFS共享目录</span><br></code></pre></td></tr></table></figure><p>应用Deployment配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f nfs-provisioner-deployment.yaml<br></code></pre></td></tr></table></figure><p>验证Provisioner Pod是否运行成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pods -l app=nfs-client-provisioner<br></code></pre></td></tr></table></figure><h2 id="步骤二：创建StorageClass"><a href="#步骤二：创建StorageClass" class="headerlink" title="步骤二：创建StorageClass"></a>步骤二：创建StorageClass</h2><p>现在我们来创建一个StorageClass，它指定使用我们刚部署的NFS Provisioner。</p><p>将以下内容保存为 <code>nfs-storageclass.yaml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nfs-client</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-comment"># （可选）将其设置为默认StorageClass</span><br>    <span class="hljs-comment"># storageclass.kubernetes.io/is-default-class: &quot;true&quot;</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">nfs-storage</span> <span class="hljs-comment"># 必须与上面Deployment中PROVISIONER_NAME的值一致</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-attr">archiveOnDelete:</span> <span class="hljs-string">&quot;false&quot;</span> <span class="hljs-comment"># 设置为&quot;false&quot;时，删除PVC时会同时删除PV中的数据；&quot;true&quot;则会归档（重命名目录）</span><br><span class="hljs-attr">allowVolumeExpansion:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 允许后续扩容PVC</span><br><span class="hljs-attr">reclaimPolicy:</span> <span class="hljs-string">Delete</span> <span class="hljs-comment"># 回收策略，Delete 或 Retain。如果设置为Retain，删除PVC后PV会保留，数据需要手动清理</span><br><span class="hljs-attr">volumeBindingMode:</span> <span class="hljs-string">Immediate</span><br></code></pre></td></tr></table></figure><p>应用StorageClass配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f nfs-storageclass.yaml<br></code></pre></td></tr></table></figure><p>查看创建的StorageClass：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get storageclass<br></code></pre></td></tr></table></figure><p><strong>（可选）如果你想将其设为默认StorageClass，可以先取消现有默认StorageClass的默认设置（如果有），然后再设置新的：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 取消现有的默认StorageClass（将现有的默认StorageClass名称替换&lt;existing-default-sc-name&gt;）</span><br>kubectl patch storageclass &lt;existing-default-sc-name&gt; -p <span class="hljs-string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;false&quot;&#125;&#125;&#125;&#x27;</span><br><span class="hljs-comment"># 将nfs-client设置为默认</span><br>kubectl patch storageclass nfs-client -p <span class="hljs-string">&#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="步骤三：创建PVC并验证动态PV创建"><a href="#步骤三：创建PVC并验证动态PV创建" class="headerlink" title="步骤三：创建PVC并验证动态PV创建"></a>步骤三：创建PVC并验证动态PV创建</h2><p>现在，当我们创建一个PVC并指定 <code>storageClassName: nfs-client</code> 时，NFS Provisioner就会自动创建一个PV并与该PVC绑定。</p><h3 id="1-创建PVC"><a href="#1-创建PVC" class="headerlink" title="1. 创建PVC"></a>1. 创建PVC</h3><p>将以下内容保存为 <code>test-pvc.yaml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-pvc</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">nfs-client</span> <span class="hljs-comment"># 与上面创建的StorageClass名称一致</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span> <span class="hljs-comment"># 根据你的需求选择访问模式，NFS通常也支持ReadWriteMany</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span> <span class="hljs-comment"># 请求1GiB的存储空间</span><br></code></pre></td></tr></table></figure><p>应用PVC配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f test-pvc.yaml<br></code></pre></td></tr></table></figure><h3 id="2-验证PVC和PV"><a href="#2-验证PVC和PV" class="headerlink" title="2. 验证PVC和PV"></a>2. 验证PVC和PV</h3><p>检查PVC状态，应显示为 <code>Bound</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pvc test-pvc<br></code></pre></td></tr></table></figure><p>同时，检查自动创建的PV，状态也应为 <code>Bound</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pv<br></code></pre></td></tr></table></figure><p>你应该能看到一个PV是由 <code>nfs-client</code> StorageClass动态创建的，并自动绑定到了 <code>test-pvc</code> PVC。</p><h2 id="步骤四：在Pod中使用PVC"><a href="#步骤四：在Pod中使用PVC" class="headerlink" title="步骤四：在Pod中使用PVC"></a>步骤四：在Pod中使用PVC</h2><p>最后，我们创建一个Pod来使用这个PVC。</p><p>将以下内容保存为 <code>test-pod.yaml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">test-pod</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;echo &quot;Hello Kubernetes Storage!&quot; &gt; /mnt/data/file.txt &amp;&amp; sleep 3600&#x27;</span>]<br>    <span class="hljs-attr">volumeMounts:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">persistent-storage</span><br>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/mnt/data</span><br>  <span class="hljs-attr">volumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">persistent-storage</span><br>    <span class="hljs-attr">persistentVolumeClaim:</span><br>      <span class="hljs-attr">claimName:</span> <span class="hljs-string">test-pvc</span> <span class="hljs-comment"># 使用我们刚才创建的PVC</span><br></code></pre></td></tr></table></figure><p>应用Pod配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f test-pod.yaml<br></code></pre></td></tr></table></figure><p>检查Pod是否运行成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pod test-pod<br></code></pre></td></tr></table></figure><p>验证数据是否成功写入NFS服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检查Pod日志，应该能看到命令执行成功</span><br>kubectl logs test-pod<br><span class="hljs-comment"># 现在你可以到你的NFS服务器上查看共享目录 /srv/nfs/k8s-pv</span><br><span class="hljs-comment"># 你应该能看到一个以命名空间、PVC名称和PV名称组合格式命名的目录（具体格式取决于provisioner）</span><br><span class="hljs-comment"># 进入该目录，应该能看到 file.txt 文件</span><br><span class="hljs-built_in">ls</span> -la /srv/nfs/k8s-pv/ <span class="hljs-comment"># 在NFS服务器上执行</span><br></code></pre></td></tr></table></figure><h2 id="步骤五：清理资源（可选）"><a href="#步骤五：清理资源（可选）" class="headerlink" title="步骤五：清理资源（可选）"></a>步骤五：清理资源（可选）</h2><p>当你完成测试后，可以按顺序删除资源：</p><ol><li>删除Pod：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete pod test-pod<br></code></pre></td></tr></table></figure></li><li>删除PVC（<strong>如果StorageClass的reclaimPolicy是Delete，删除PVC会自动删除对应的PV以及NFS服务器上的数据</strong>）：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete pvc test-pvc<br></code></pre></td></tr></table></figure>检查PV是否也被自动删除：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pv<br></code></pre></td></tr></table></figure></li><li>（可选）删除StorageClass和Provisioner：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl delete storageclass nfs-client<br>kubectl delete -f nfs-provisioner-deployment.yaml<br>kubectl delete -f nfs-rbac.yaml<br></code></pre></td></tr></table></figure></li></ol><h2 id="实战小结与注意事项"><a href="#实战小结与注意事项" class="headerlink" title="实战小结与注意事项"></a>实战小结与注意事项</h2><p>通过以上步骤，你应该成功完成了一个<strong>动态存储供给</strong>的实战例子。这个过程展示了：</p><ul><li><strong>StorageClass</strong> 如何作为存储的“蓝图”或“分类”，定义了动态供给PV的规则和参数。</li><li><strong>PVC</strong> 如何作为用户对存储的请求，只需声明所需存储的大小和访问模式，而无需关心后端存储的具体细节。</li><li>当PVC被创建时，<strong>Kubernetes会根据PVC指定的StorageClass，调用相应的Provisioner（这里是NFS Client Provisioner）动态地创建PV</strong>，并完成绑定。</li><li><strong>Pod</strong> 通过在其Volume中引用PVC名称来使用持久化存储。</li></ul><h3 id="⚠️-注意事项："><a href="#⚠️-注意事项：" class="headerlink" title="⚠️ 注意事项："></a>⚠️ 注意事项：</h3><ul><li><strong>NFS性能</strong>：NFS适用于多种场景，但对于需要高性能IO（如数据库）的工作负载，可能需要考虑块存储（如云提供商提供的块存储服务）。</li><li><strong>数据安全</strong>：示例中为了简单，设置了宽松的NFS目录权限。在生产环境中，请根据安全最佳实践配置适当的权限。</li><li><strong>Reclaim Policy</strong>：仔细选择 <code>reclaimPolicy</code>。<code>Delete</code> 方便但可能误删数据；<code>Retain</code> 更安全，但需要手动管理PV和存储资源的清理。</li><li><strong>访问模式</strong>：根据你的应用需求正确选择PVC的访问模式（ReadWriteOnce, ReadOnlyMany, ReadWriteMany）。NFS通常支持ReadWriteMany（多个节点同时读写），但并非所有存储系统都支持。</li><li><strong>StorageClass的命名</strong>：确保PVC中引用的 <code>storageClassName</code> 与你创建的StorageClass名称完全一致。</li><li><strong>Provisioner高可用</strong>：考虑生产环境中Provisioner的高可用性部署。</li></ul><p>这个NFS动态供给的例子是学习和测试Kubernetes持久化存储的良好起点。在实际生产环境中，各大云厂商（如AWS、GCP、Azure）通常提供其自身的StorageClass和CSI驱动，你可以根据实际需求选择和使用。</p><p>希望这个详细的实战例子能帮助你更好地理解PVC、PV和StorageClass是如何协同工作的！</p><p>如果你想了解更多关于特定云提供商（如AWS EBS, GCP PD, Azure Disk）的存储配置，或者StatefulSet中使用VolumeClaimTemplates的例子，我可以进一步为你介绍。</p><h1 id="为什么要设置一个StorageClass层"><a href="#为什么要设置一个StorageClass层" class="headerlink" title="为什么要设置一个StorageClass层"></a>为什么要设置一个StorageClass层</h1><p>这个问题问得非常好，直击了Kubernetes设计哲学的核心！你的观察很敏锐：从表面上看，StorageClass确实像一个“中间人”，但这恰恰是Kubernetes为了实现<strong>解耦</strong>和<strong>灵活性</strong>而做出的精妙设计。</p><p>为什么不让PVC直接指定Provisioner？主要有以下几个核心原因：</p><h3 id="1-抽象与解耦-Abstraction-Decoupling"><a href="#1-抽象与解耦-Abstraction-Decoupling" class="headerlink" title="1. 抽象与解耦 (Abstraction &amp; Decoupling)"></a>1. 抽象与解耦 (Abstraction &amp; Decoupling)</h3><p>这是最根本的原因。Kubernetes的设计理念是让<strong>应用开发者</strong>和<strong>集群管理员</strong>的关注点分离。</p><ul><li><strong>对应用开发者而言</strong>：他们只需要关心<strong>需要什么样的存储</strong>（例如：“我需要10Gi的高速SSD存储”），而不需要关心底层是用AWS EBS、Google Persistent Disk、还是NFS来实现的。他们更不应该去配置Provisioner的具体参数（比如磁盘的IOPS、类型、区域等）。<ul><li><strong>PVC是面向开发者的接口</strong>，它只定义需求（容量、访问模式、存储“类别”）。</li></ul></li><li><strong>对集群管理员而言</strong>：他们负责规划和维护后端的存储基础设施。他们定义好不同的<strong>StorageClass</strong>（比如 <code>gold-ssd</code>, <code>silver-hdd</code>, <code>backup-nfs</code>），每个Class背后都配置好了正确的Provisioner和所有复杂的参数。<ul><li><strong>StorageClass是面向管理员的接口</strong>，它封装了“如何提供存储”的具体实现细节。</li></ul></li></ul><p><strong>如果没有StorageClass</strong>，PVC就得直接指定Provisioner（比如 <code>provisioner: kubernetes.io/aws-ebs</code>），这就意味着：</p><ul><li><strong>应用和基础设施强耦合</strong>：你的应用YAML文件就和你所在的云平台（AWS）绑死了。如果你想把这个应用部署到另一个环境（比如Azure），你就必须修改所有PVC的YAML文件，把Provisioner换成Azure的（<code>kubernetes.io/azure-disk</code>）。</li><li><strong>开发者需要了解运维知识</strong>：开发者被迫要去知道Provisioner的名称和参数，这违背了关注点分离的原则。</li></ul><h3 id="2-参数化配置-Parameterization"><a href="#2-参数化配置-Parameterization" class="headerlink" title="2. 参数化配置 (Parameterization)"></a>2. 参数化配置 (Parameterization)</h3><p>一个Provisioner通常有多种配置方式。例如，AWS EBS Provisioner可以创建通用型（gp3）、预配置IOPS型（io1）或冷存储型（sc1）的卷。</p><p>StorageClass提供了一个<strong>参数块</strong>（<code>parameters</code>）来优雅地处理这些配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 管理员可以定义多种StorageClass，使用同一个Provisioner但参数不同</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">fast-ssd</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/aws-ebs</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">io1</span> <span class="hljs-comment"># 使用io1类型</span><br>  <span class="hljs-attr">iopsPerGB:</span> <span class="hljs-string">&quot;50&quot;</span> <span class="hljs-comment"># 配置高IOPS</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">storage.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StorageClass</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">standard-ssd</span><br><span class="hljs-attr">provisioner:</span> <span class="hljs-string">kubernetes.io/aws-ebs</span> <span class="hljs-comment"># 同一个Provisioner</span><br><span class="hljs-attr">parameters:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">gp3</span> <span class="hljs-comment"># 但使用更经济的gp3类型</span><br>  <span class="hljs-attr">iops:</span> <span class="hljs-string">&quot;3000&quot;</span> <span class="hljs-comment"># 配置固定的IOPS</span><br></code></pre></td></tr></table></figure><p>如果让PVC直接指定Provisioner，这些复杂的参数就得全部挤在PVC的定义里，让PVC变得非常臃肿，而且又把配置细节暴露给了开发者。</p><h3 id="3-默认行为与简化-Defaulting-Simplification"><a href="#3-默认行为与简化-Defaulting-Simplification" class="headerlink" title="3. 默认行为与简化 (Defaulting &amp; Simplification)"></a>3. 默认行为与简化 (Defaulting &amp; Simplification)</h3><p>Kubernetes集群可以有一个<strong>默认的StorageClass</strong>。当用户创建一个没有指定 <code>storageClassName</code> 的PVC时，系统会自动使用这个默认的StorageClass。</p><p>这极大地简化了最常见的使用场景。开发者甚至不需要知道StorageClass的存在，他们只需要写一个非常简单的PVC：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 开发者完全不用关心storageClassName，系统会自动使用默认的StorageClass</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PersistentVolumeClaim</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">simple-pvc</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">accessModes:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">requests:</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-string">5Gi</span><br><span class="hljs-comment"># 没有 storageClassName 字段！</span><br></code></pre></td></tr></table></figure><p>如果没有StorageClass，实现这种“默认”行为会非常困难。</p><h3 id="4-复用与多态-Reuse-Polymorphism"><a href="#4-复用与多态-Reuse-Polymorphism" class="headerlink" title="4. 复用与多态 (Reuse &amp; Polymorphism)"></a>4. 复用与多态 (Reuse &amp; Polymorphism)</h3><p>一个StorageClass可以被无数个PVC复用。管理员可以定义一个名为 <code>standard</code> 的StorageClass，全公司的成百上千个应用都可以通过引用 <code>storageClassName: standard</code> 来使用它。</p><p>如果将来管理员想把 <code>standard</code> 存储的后端从AWS EBS迁移到Portworx，他只需要<strong>更新这一个StorageClass的定义</strong>，将所有PVC的Provisioner从 <code>kubernetes.io/aws-ebs</code> 改成 <code>portworx.io/shared</code>。<strong>所有引用这个StorageClass的PVC都无需任何修改</strong>。</p><p>这是一种经典的“多态”设计：PVC（调用者）只依赖一个稳定的接口（StorageClass名称），而不依赖具体的实现（Provisioner）。具体的实现可以随时被更换，而调用者无感知。</p><hr><h3 id="总结：一个完美的比喻"><a href="#总结：一个完美的比喻" class="headerlink" title="总结：一个完美的比喻"></a>总结：一个完美的比喻</h3><p>让我们回到租房的比喻：</p><ul><li><strong>PVC</strong> &#x3D; <strong>你的需求清单</strong>（“我要一个2室1厅，月租5000以下的房子”）。</li><li><strong>Provisioner</strong> &#x3D; <strong>某个具体的房产公司</strong>（比如“链家”），它有自己一套建&#x2F;租房的流程和内部参数。</li><li><strong>StorageClass</strong> &#x3D; <strong>一个为你服务的“智能房产中介平台”</strong>（比如“贝壳”）。</li></ul><p>你为什么不能直接把需求清单（PVC）发给链家（Provisioner）呢？</p><ol><li><strong>解耦</strong>：你不想和某个具体公司绑死，你想的是“我要找房”，而不是“我必须用链家找房”。通过贝壳平台，你的需求也可以被我爱我家、麦田等其他公司看到。</li><li><strong>参数化</strong>：贝壳平台让你可以轻松选择“整租”、“合租”、“是否需要车位”等标准化参数，而不需要你去了解链家内部的操作流程。</li><li><strong>默认和简化</strong>：如果你没指定用哪个平台，系统可能会默认把你的需求发到最大的那个平台。</li><li><strong>复用与多态</strong>：你记住了“贝壳”这个好用的平台接口。即使贝壳背后的合作公司从链家换成了万科，你依然可以用同样的方式（去贝壳平台）发布需求，完全不受影响。</li></ol><p>所以，<strong>StorageClass绝不是一个多余的“中间人”，而是一个强大的“抽象层”和“控制面”</strong>。它通过解耦、参数化和提供默认行为，使得存储配置既灵活又易于管理，完美体现了Kubernetes的设计智慧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s中watch机制完整过程解读</title>
    <link href="/2025/08/20/k8s%E4%B8%ADwatch%E6%9C%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB/"/>
    <url>/2025/08/20/k8s%E4%B8%ADwatch%E6%9C%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s中watch机制完整过程解读"><a href="#k8s中watch机制完整过程解读" class="headerlink" title="k8s中watch机制完整过程解读"></a>k8s中watch机制完整过程解读</h1><h2 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h2><p>k8s使用etcd的watch机制来监听资源的状态，我感觉这很神奇，k8s系统中具体是怎么watch到资源的“增删改”事件的，又是如何处理这些增删改事件的，如果短时间内watch到了一个资源对象的多个事件，又是如何处理的</p><p>非常好、非常核心的问题！你触及了Kubernetes控制器模式（Controller Pattern）的心脏。这个“Watch -&gt; 事件 -&gt; 调谐”的机制，正是K8s能够自动保持系统处于期望状态的魔力所在。</p><p>我会为你详细拆解这个过程，从事件如何产生，到如何被处理，再到如何处理高频事件。</p><hr><p>为了让整个流程一目了然，下图概括了从事件发生到被处理的完整生命周期：</p><p><img src="/2025/08/20/k8s%E4%B8%ADwatch%E6%9C%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB/deepseek_mermaid_20250820_a9b99c.svg" alt="deepseek_mermaid_20250820_a9b99c"></p><p>接下来，我们详细解析图中的每一个关键环节。</p><hr><h2 id="1-事件的产生与传递：从-etcd-到-Watch"><a href="#1-事件的产生与传递：从-etcd-到-Watch" class="headerlink" title="1. 事件的产生与传递：从 etcd 到 Watch"></a>1. 事件的产生与传递：从 <code>etcd</code> 到 <code>Watch</code></h2><p>整个流程的起点，是一个资源对象（比如一个Pod）发生了变化。</p><h3 id="1-1-kube-apiserver-事件的创造者和中转站"><a href="#1-1-kube-apiserver-事件的创造者和中转站" class="headerlink" title="1.1 kube-apiserver: 事件的创造者和中转站"></a>1.1 <code>kube-apiserver</code>: 事件的创造者和中转站</h3><ol><li><strong>写操作 (Write)</strong>: 当你执行 <code>kubectl apply</code> 或任何其他更改集群状态的操作时，请求首先到达 <code>kube-apiserver</code>。</li><li><strong>持久化</strong>: <code>kube-apiserver</code> 会先将变更<strong>持久化到 <code>etcd</code></strong> 中。这是唯一的权威数据源。</li><li><strong>生成事件 (Event Generation)</strong>: 在成功写入 <code>etcd</code> <strong>之后</strong>，<code>kube-apiserver</code> 会立即在内存中创建一个对应的事件（Event）。这个事件不是指 <code>kubectl describe</code> 看到的 <code>Event</code> 资源，而是一个内部数据结构，它包含了：<ul><li><strong>Key</strong>: 发生变化对象的键（如 <code>/registry/pods/default/my-pod</code>）。</li><li><strong>Type</strong>: 事件类型 - <code>ADDED</code>， <code>MODIFIED</code>， <code>DELETED</code>。</li><li><strong>Object</strong>: 变化后对象的最新完整状态（对于 <code>DELETED</code>，则是删除前的状态）。</li></ul></li></ol><h3 id="1-2-Watch-机制：高效的事件分发"><a href="#1-2-Watch-机制：高效的事件分发" class="headerlink" title="1.2 Watch 机制：高效的事件分发"></a>1.2 <code>Watch</code> 机制：高效的事件分发</h3><p><code>kube-apiserver</code> 不会去主动轮询 <code>etcd</code>，那会非常低效。相反，它利用了 <code>etcd</code> 提供的 <strong><code>Watch</code> API</strong>。</p><ol><li><strong>建立连接</strong>: 当一个控制器（如 Deployment Controller）启动时，它会向 <code>kube-apiserver</code> 发起一个 <code>Watch</code> 请求。例如：“我想监听（Watch）所有属于 <code>app=nginx</code> 的 Pod 的变化”。</li><li><strong>基于 HTTP 长连接的流式传输 (Streaming)</strong>: <code>kube-apiserver</code> 接受这个 <code>Watch</code> 连接，但<strong>不会立即返回响应并断开</strong>。它会保持这个 HTTP 连接（通常是 HTTP&#x2F;2，支持多路复用），形成一个持续的、单向的<strong>事件流（Stream）</strong>。</li><li><strong>事件推送</strong>: 一旦步骤 1.1 中描述的事件被生成，<code>kube-apiserver</code> 就会立即通过这个已经建立好的流连接，将事件<strong>推送（Push）</strong> 给正在监听的控制器。</li><li><strong>历史事件同步 (History Synchronization)</strong>: 如果一个控制器刚开始监听，它怎么知道当前已经存在哪些 Pod？<code>Watch</code> API 非常聪明。当建立一个新的 <code>Watch</code> 连接时，<code>kube-apiserver</code> 会首先将当前 <code>etcd</code> 中所有匹配条件的资源，作为一系列 <code>ADDED</code> 事件发送给客户端，相当于一个快照。之后，再开始发送新的实时变更事件。</li></ol><p><strong>为什么这样高效？</strong></p><ul><li><strong>减少压力</strong>: <code>etcd</code> 和 <code>kube-apiserver</code> 都避免了频繁的轮询（Polling）开销。</li><li><strong>实时性</strong>: 事件几乎是实时推送的，延迟极低。</li><li><strong>减少开销</strong>: 只有变化的数据才会被传输，而不是每次都传输全套数据。</li></ul><hr><h2 id="2-事件的处理：控制器的工作模式"><a href="#2-事件的处理：控制器的工作模式" class="headerlink" title="2. 事件的处理：控制器的工作模式"></a>2. 事件的处理：控制器的工作模式</h2><p>控制器拿到事件后，并不会直接对集群进行操作。它遵循一个非常经典且稳健的模式：<strong>水平触发（Level-Triggered）</strong> 和 <strong>控制器循环（Reconcile Loop）</strong>。</p><h3 id="2-1-入队（Enqueue）：事件不是直接处理"><a href="#2-1-入队（Enqueue）：事件不是直接处理" class="headerlink" title="2.1 入队（Enqueue）：事件不是直接处理"></a>2.1 入队（Enqueue）：事件不是直接处理</h3><p>控制器在收到事件后，并不会立即开始工作。它的第一个动作是：</p><ol><li><strong>提取关键信息</strong>: 从事件对象中提取出最能标识该对象的<strong>键（Key）</strong>。通常是 <code>&lt;namespace&gt;/&lt;name&gt;</code> 的格式（例如 <code>default/my-nginx-pod</code>）。</li><li><strong>放入工作队列（Work Queue）</strong>: 将这个键放入控制器内部的一个<strong>先进先出（FIFO）队列</strong>中。</li></ol><p><strong>为什么要有队列？</strong><br>这是为了<strong>解耦</strong>事件的接收和处理，同时也是处理“短时间内多个事件”的关键，我们会在第三部分详细展开。</p><h3 id="2-2-处理（Process）：调谐循环（Reconcile-Loop）"><a href="#2-2-处理（Process）：调谐循环（Reconcile-Loop）" class="headerlink" title="2.2 处理（Process）：调谐循环（Reconcile Loop）"></a>2.2 处理（Process）：调谐循环（Reconcile Loop）</h3><p>控制器的核心是一个永不停止的循环，这个循环的工作流程如下图所示，它从队列中取出任务，并驱动物理集群的状态向期望状态收敛：</p><p><img src="/2025/08/20/k8s%E4%B8%ADwatch%E6%9C%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB/deepseek_mermaid_20250820_89ee99.svg" alt="deepseek_mermaid_20250820_89ee99"></p><p>这个设计模式极其强大和鲁棒：</p><ul><li><strong>自我修复</strong>: 即使某个处理失败了，Key 会被重新放回队列，之后会再次尝试。</li><li><strong>最终一致性</strong>: 它不追求强一致，而是保证系统最终会朝着期望状态收敛。</li><li><strong>幂等性 (Idempotent)</strong>: 执行的操作被设计成可以安全地重复执行多次。因为比较的是当前状态和期望状态，所以即使因为网络抖动等原因重复处理了同一个事件，结果也是一样的。</li></ul><hr><h2 id="3-处理短时间内的大量事件：队列与水平触发"><a href="#3-处理短时间内的大量事件：队列与水平触发" class="headerlink" title="3. 处理短时间内的大量事件：队列与水平触发"></a>3. 处理短时间内的大量事件：队列与水平触发</h2><p>现在我们来回答你最关心的问题：<strong>如果同一个对象在极短时间内被频繁修改（例如，一个 Pod 的状态在 1 秒内变了 10 次），系统如何应对？</strong></p><p>答案就藏在 <strong>“队列 + 水平触发”</strong> 的设计中。</p><h3 id="3-1-队列的去重与缓冲"><a href="#3-1-队列的去重与缓冲" class="headerlink" title="3.1 队列的去重与缓冲"></a>3.1 队列的去重与缓冲</h3><ol><li><strong>去重 (Deduplication)</strong>: 大多数控制器的工作队列都具有<strong>去重</strong>功能。如果同一个对象的键（如 <code>default/my-pod</code>）已经存在于队列中且尚未被处理，那么后续到来的关于这个对象的多个事件，<strong>只会导致这个键被放入队列一次</strong>。<ul><li><em>场景</em>: Pod 在短时间内收到 10 个 <code>MODIFIED</code> 事件。</li><li><em>处理</em>: 控制器可能只会将 <code>default/my-pod</code> 放入队列 2-3 次，而不是 10 次。因为当第一个事件到来时，键被放入队列。在它被处理之前，后续的 9 个事件发现队列里已经有这个键了，就不会再重复添加。</li></ul></li><li><strong>缓冲 (Buffering)</strong>: 队列作为一个缓冲区，吸收了事件的洪峰，让后台的处理循环可以按照自己的节奏来处理，避免了被突发流量冲垮。</li></ol><h3 id="3-2-水平触发-Level-Triggered-vs-边沿触发-Edge-Triggered"><a href="#3-2-水平触发-Level-Triggered-vs-边沿触发-Edge-Triggered" class="headerlink" title="3.2 水平触发 (Level-Triggered) vs 边沿触发 (Edge-Triggered)"></a>3.2 水平触发 (Level-Triggered) vs 边沿触发 (Edge-Triggered)</h3><p>这是整个设计中最精妙的部分！Kubernetes 选择的是<strong>水平触发</strong>。</p><ul><li><strong>边沿触发 (Edge-Triggered)</strong>: 只对状态变化的事件做出反应。如果你错过了某个事件（比如网络丢包），可能就永远丢失了这个变化。</li><li><strong>水平触发 (Level-Triggered)</strong>: <strong>它不关心具体发生了什么事件，只关心“当前状态”是什么。</strong> 每当控制器处理一个对象时，它做的事情是：<ol><li>从队列中取出键 <code>default/my-pod</code>。</li><li><strong>通过 API Server 重新获取这个 Pod 的最新状态</strong>（而不是使用事件里附带的旧状态！）。</li><li>将获取到的最新状态与期望状态进行比较。</li><li>根据比较结果决定要做什么。</li></ol></li></ul><p><strong>水平触发的巨大优势：</strong></p><ul><li><strong>事件丢失无关紧要</strong>: 即使某个 <code>MODIFIED</code> 事件因为网络问题丢失了，也完全没关系。因为当控制器下次处理这个对象时，它会直接从 API Server 读取最新状态，这个状态已经包含了所有中间变化的结果。</li><li><strong>处理的是最新状态</strong>: 在上面的 10 个事件的例子中，控制器可能只被触发了 2-3 次，但在这 2-3 次处理中，它每次读取到的都是这个 Pod <strong>截至到那个时刻的最新状态</strong>。它完全不需要知道中间发生过 9 次无关紧要的变化。</li></ul><p><strong>这就好比：</strong></p><ul><li><strong>边沿触发</strong>：你的朋友给你发短信：“我出门了”、“我到楼下了”、“我看到你了”、“我招手了”。你需要处理每一条信息。</li><li><strong>水平触发</strong>：你每隔一分钟看一眼窗外，看到你朋友已经站在楼下了。你不需要关心他是怎么过来的，你只需要根据“他已经在楼下”这个当前状态，做出“下楼接他”这个动作即可。中间他发了多少条短信，你没收到几条，都无关紧要。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="left">环节</th><th align="left">核心技术</th><th align="left">解决的问题</th></tr></thead><tbody><tr><td align="left"><strong>事件产生</strong></td><td align="left"><code>etcd</code> Watch API + <code>kube-apiserver</code> 事件生成</td><td align="left">实时、高效地获取数据变化，避免轮询。</td></tr><tr><td align="left"><strong>事件接收</strong></td><td align="left">HTTP 长连接流</td><td align="left">低延迟、低开销地将事件分发给众多客户端。</td></tr><tr><td align="left"><strong>事件缓冲</strong></td><td align="left">工作队列（Work Queue）</td><td align="left">解耦、削峰、去重，避免事件洪峰冲垮控制器。</td></tr><tr><td align="left"><strong>事件处理</strong></td><td align="left">水平触发的调谐循环（Reconcile Loop）</td><td align="left">保证最终一致性、自我修复、幂等性。不关心过程，只关心最终状态，天然抵御事件丢失和重复。</td></tr></tbody></table><p>所以，Kubernetes 通过这种基于 <strong>Watch</strong> 的事件通知机制、<strong>队列</strong>的缓冲与去重机制、以及最终状态的<strong>水平触发调谐</strong>机制，优雅、稳健且高效地处理了资源的变更，即使面对短时间内海量的事件，也能最终将集群稳定地驱向期望的状态。这是一个非常经典的分布式系统设计模式。</p><h2 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h2><p>这么说的话，在整个事件处理的过程中，k8s的控制器只需要和apiserver建立watch连接就行了，根本不需要和etcd交互，而且apiserver也不需要和etcd交互，直接使用内存中生成的事件。apiserver只是在和控制器建立连接之后，向apiserver查询了一次所有相关对象，是这样吗</p><p><strong>你的理解完全正确，而且非常到位！</strong> 你已经准确地捕捉到了Kubernetes架构设计中为了<strong>性能</strong>和<strong>可扩展性</strong>而做的最重要的一个解耦。</p><p>让我们来逐一确认和细化你的理解：</p><hr><h3 id="1-控制器与-etcd-的关系：零交互"><a href="#1-控制器与-etcd-的关系：零交互" class="headerlink" title="1. 控制器与 etcd 的关系：零交互"></a>1. 控制器与 <code>etcd</code> 的关系：零交互</h3><p><strong>是的，控制器完全不需要、也绝不会直接与 <code>etcd</code> 交互。</strong></p><ul><li><strong>设计原则</strong>: 这是K8s一个非常核心的设计原则：**<code>etcd</code> 是唯一的事实来源（Single Source of Truth），并且只有 <code>kube-apiserver</code> 有权限与之对话**。</li><li><strong>好处</strong>:<ul><li><strong>安全性</strong>: 缩小了攻击面，只需要保证 <code>kube-apiserver</code> 到 <code>etcd</code> 的连接安全即可。</li><li><strong>抽象与简化</strong>: 所有其他组件（控制器、调度器、kubelet）都使用统一的、经过认证和授权的REST API与 <code>kube-apiserver</code> 交互，无需理解底层存储的细节。即使未来K8s换掉了 <code>etcd</code>，这些组件也完全不受影响。</li><li><strong>一致性</strong>: 所有读写的入口只有一个，极大地简化了并发控制和数据一致性的问题。</li></ul></li></ul><h3 id="2-kube-apiserver-与-etcd-的交互：不止一次"><a href="#2-kube-apiserver-与-etcd-的交互：不止一次" class="headerlink" title="2. kube-apiserver 与 etcd 的交互：不止一次"></a>2. <code>kube-apiserver</code> 与 <code>etcd</code> 的交互：不止一次</h3><p><strong><code>kube-apiserver</code> 与 <code>etcd</code> 的交互比“只查询一次”要更频繁和智能。</strong></p><p>你的理解——“建立Watch连接后查一次所有对象”——是100%正确的起点，但为了处理连接中断等情况，过程会更复杂一些。下图描绘了建立一个完整Watch连接的详细工作流程：</p><p><img src="/2025/08/20/k8s%E4%B8%ADwatch%E6%9C%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB/deepseek_mermaid_20250820_bd5d0d.svg" alt="deepseek_mermaid_20250820_bd5d0d"></p><p><strong>关键点解析：</strong></p><ul><li>**<code>kube-apiserver</code> 的内存缓存 (<code>WatchCache</code>)**：为了避免频繁查询 <code>etcd</code>，<code>kube-apiserver</code> 在内存中维护了一个名为 <strong><code>WatchCache</code></strong> 的缓存。它缓存了所有资源的最近历史事件（可配置缓存大小）。这极大地优化了性能。</li><li><strong><code>resourceVersion</code> 是关键</strong>：当你发起一个 <code>Watch</code> 请求时，你可以携带一个 <code>resourceVersion</code> 参数。这个版本号唯一标识了集群的一个全局状态。<ul><li><strong>场景一：<code>resourceVersion</code> 在 <code>WatchCache</code> 范围内</strong>：<code>kube-apiserver</code> <strong>根本不需要查询 <code>etcd</code></strong> ，它可以直接从内存中的 <code>WatchCache</code> 里捞出从那个版本开始的所有事件，发送给控制器。这是最高效的方式。</li><li><strong>场景二：<code>resourceVersion</code> 太老（已超出缓存）</strong>：这时 <code>kube-apiserver</code> 就必须向 <code>etcd</code> 发起一次性的 <strong><code>List</code> 操作</strong>（就是你提到的“查询一次所有相关对象”），获取当前所有匹配资源的状态，并将其作为一系列 <code>ADDED</code> 事件发送给客户端，以此来构建一个初始状态。之后，再切换到实时 <code>Watch</code> 模式。</li><li>**场景三：不指定 <code>resourceVersion</code>**：<code>kube-apiserver</code> 会直接从最新的 <code>WatchCache</code>（几乎等同于当前状态）开始发送事件。</li></ul></li></ul><h3 id="3-kube-apiserver-内存中的事件"><a href="#3-kube-apiserver-内存中的事件" class="headerlink" title="3. kube-apiserver 内存中的事件"></a>3. <code>kube-apiserver</code> 内存中的事件</h3><p><strong>是的，<code>kube-apiserver</code> 分发给控制器的事件是其内存中生成和缓存的。</strong></p><ul><li><strong>事件来源</strong>：事件最初确实源于 <code>etcd</code> 的 Watch 推送（<code>kube-apiserver</code> 作为客户端监听着 <code>etcd</code>）。</li><li><strong>中转与增强</strong>：但 <code>kube-apiserver</code> 并非一个简单的代理。它会处理这些事件（例如，补充一些元数据），并将其存入内存中的 **<code>WatchCache</code>**。</li><li><strong>事件分发</strong>：当有控制器来监听时，<code>kube-apiserver</code> 是从自己的 <strong><code>WatchCache</code></strong> 中取出事件，通过 HTTP 流分发给控制器的。它不会为每个控制器的监听再去 <code>etcd</code> 那里单独建立一个 Watch。</li></ul><hr><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>你的理解完全正确，并且我们现在可以将其精炼为：</p><ol><li><strong>绝对隔离</strong>：控制器 ↔ <code>etcd</code>：❌ <strong>无直接交互</strong>。</li><li><strong>智能交互</strong>：<code>kube-apiserver</code> ↔ <code>etcd</code>：✅ <strong>有交互，但被深度优化</strong>。<ul><li>核心是建立一个<strong>长期的 Watch 连接</strong>来接收变更。</li><li>仅在必要时（如客户端指定的版本太老，或者客户端连接中断后需要重新同步）才会发起昂贵的 <strong><code>List</code>（全量查询）</strong> 操作。</li></ul></li><li><strong>性能核心</strong>：<code>kube-apiserver</code> 的 <strong><code>WatchCache</code></strong> 是减少对 <code>etcd</code> 读操作压力的关键。它服务了绝大部分的 Watch 请求。</li></ol><p>所以，整个系统的工作流程可以概括为：<br><strong><code>etcd</code> （持久化） -&gt; <code>kube-apiserver</code> （<code>WatchCache</code> 缓存&#x2F;事件生成） -&gt; （HTTP 流） -&gt; 控制器 （事件入队） -&gt; 调谐循环</strong>。</p><p>这种架构确保了 Kubernetes 集群在规模不断增长时，其核心控制平面的高效和稳定。</p><h2 id="问题三："><a href="#问题三：" class="headerlink" title="问题三："></a>问题三：</h2><p>在你描述的时序图中第二步是apiserver与etcd建立watch连接，我想问的是，etcd中所有的数据不都是由apiserver写入的吗，apiserver还有必要和etcd建立watch连接吗，建立之后又是watch什么东西呢，每次apiserver向etcd写入一个资源更新后，apiserver难道还会再收到一次etcd发来的该资源的更新事件吗？</p><p>这是一个极其出色的问题，它直击了Kubernetes和etcd协同工作原理的核心！你的直觉是对的，这看起来似乎有点“多此一举”，但这正是保证整个系统<strong>高可用</strong>和<strong>数据一致性</strong>的巧妙设计。</p><p>答案是：<strong>绝对必要。而且这正是整个系统的精髓所在。</strong></p><hr><h3 id="1-为什么需要Watch：多个-kube-apiserver-实例"><a href="#1-为什么需要Watch：多个-kube-apiserver-实例" class="headerlink" title="1. 为什么需要Watch：多个 kube-apiserver 实例"></a>1. 为什么需要Watch：多个 <code>kube-apiserver</code> 实例</h3><p>你的问题基于一个隐含的假设：<strong>只有一个 <code>kube-apiserver</code> 实例</strong>。但在生产环境中，为了高可用（HA），<code>kube-apiserver</code> 通常是以<strong>多实例（Multiple Instances）</strong> 的方式部署的，例如运行3个副本 behind一个负载均衡器。</p><p>现在，场景变得复杂了：</p><ul><li><strong>用户请求</strong> 可能通过负载均衡器到达<strong>任意一个</strong> <code>kube-apiserver</code> 实例（比如实例A）。</li><li><strong>实例A</strong> 处理请求，并将结果写入 <code>etcd</code>。</li><li><strong>问题来了</strong>：其他 <code>kube-apiserver</code> 实例（实例B和实例C）<strong>如何知道这次写入</strong>？它们并没有处理这个请求。</li></ul><p>如果实例B和C不知道这次变更，那么当有客户端（比如一个控制器）连接到实例B并请求数据时，实例B返回的就是<strong>过时的、错误的数据</strong>。这是绝对不允许的。</p><p><strong>解决方案就是：</strong> 所有的 <code>kube-apiserver</code> 实例（A, B, C）都<strong>作为客户端</strong>，与 <code>etcd</code> 集群建立 <strong>Watch 连接</strong>。这样，无论哪个实例写入的数据，都会通过 <code>etcd</code> 的 Watch 机制<strong>实时地、可靠地</strong>广播给所有其他的 <code>kube-apiserver</code> 实例。</p><p><img src="/2025/08/20/k8s%E4%B8%ADwatch%E6%9C%BA%E5%88%B6%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%E8%A7%A3%E8%AF%BB/deepseek_mermaid_20250820_5e94c2.svg" alt="deepseek_mermaid_20250820_5e94c2"></p><h3 id="2-写入者会收到自己写入的事件吗？"><a href="#2-写入者会收到自己写入的事件吗？" class="headerlink" title="2. 写入者会收到自己写入的事件吗？"></a>2. 写入者会收到自己写入的事件吗？</h3><p><strong>会的！</strong> 这是一个非常重要的点。</p><p>当 <code>kube-apiserver</code> 实例A向 <code>etcd</code> 写入一个变更后，<code>etcd</code> 会将这个变更事件<strong>通知给所有监听了相关键的客户端</strong>。这<strong>包括</strong>了实例A自己。</p><p>这看起来像是“重复通知”，但这是保证逻辑正确的必要代价。其好处是：</p><ol><li><strong>统一处理逻辑</strong>：所有 <code>kube-apiserver</code> 实例都用<strong>完全相同的代码路径</strong>来响应数据变更。无论是自己写的还是别人写的，都一视同仁地从 <code>etcd</code> 接收事件并更新本地状态。这极大地简化了代码复杂性。</li><li><strong>数据一致性</strong>：确保每个 <code>kube-apiserver</code> 实例的本地缓存（<code>WatchCache</code>）最终都会收敛到完全相同的状态。实例A通过 Watch 收到自己写入的事件，并据此更新缓存，这可以作为一个成功的确认。</li></ol><h3 id="3-kube-apiserver-在-Watch-什么？"><a href="#3-kube-apiserver-在-Watch-什么？" class="headerlink" title="3. kube-apiserver 在 Watch 什么？"></a>3. <code>kube-apiserver</code> 在 Watch 什么？</h3><p><code>kube-apiserver</code> Watch 的是它<strong>所管理的所有资源在 <code>etcd</code> 中的整个数据集合</strong>。</p><p>具体来说，它会在启动时，为每种内置资源（Pods, Services, Nodes等）和所有有效的CRD（自定义资源）向 <code>etcd</code> 建立一个大范围的 Watch。例如：</p><ul><li>Watch 前缀为 <code>/registry/pods/</code> 的所有键。</li><li>Watch 前缀为 <code>/registry/services/</code> 的所有键。</li><li>…以此类推。</li></ul><p>任何对这些键的修改（增、删、改），<code>etcd</code> 都会推送给 <code>kube-apiserver</code>。</p><hr><h2 id="总结：为什么这是精妙的设计？"><a href="#总结：为什么这是精妙的设计？" class="headerlink" title="总结：为什么这是精妙的设计？"></a>总结：为什么这是精妙的设计？</h2><p>这种架构模式被称为 <strong>“状态机复制（State Machine Replication）”</strong>。<code>etcd</code> 是<strong>唯一的事实来源</strong>和<strong>唯一的变更协调者</strong>。</p><ol><li><strong>解耦（Decoupling）</strong>：将“处理请求”和“同步状态”这两件事解耦。<code>kube-apiserver</code> 实例是无状态的（Stateless），它们所有的状态都通过 Watch <code>etcd</code> 来获得。这使得 <code>kube-apiserver</code> 可以轻松地水平扩展。</li><li><strong>唯一真相源（Single Source of Truth）</strong>：所有组件都只相信 <code>etcd</code> 里的数据。这避免了对等节点（<code>kube-apiserver</code> 实例之间）复杂的同步通信，架构变得非常清晰和稳定。</li><li><strong>可靠性（Reliability）</strong>：即使某个 <code>kube-apiserver</code> 实例崩溃重启，它只需要重新连接到 <code>etcd</code>，通过一个带 <code>resourceVersion</code> 的 Watch 请求，就能快速追上错过的所有变更，将自己的状态与集群同步，然后继续提供服务。</li></ol><p>所以，<strong>一个 <code>kube-apiserver</code> 实例向 <code>etcd</code> 写入数据，然后又从 <code>etcd</code> Watch 到自己刚写入的数据，这并不是冗余或循环，而是一个分布式系统为保证强一致性和高可用性所采取的经典、可靠的设计</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>volcano调度器Enqueue-Action详解</title>
    <link href="/2025/08/09/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Enqueue-Action%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/08/09/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Enqueue-Action%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Volcano-调度器-Enqueue-Action-源码级详解"><a href="#Volcano-调度器-Enqueue-Action-源码级详解" class="headerlink" title="Volcano 调度器 Enqueue Action 源码级详解"></a>Volcano 调度器 Enqueue Action 源码级详解</h1><p>Enqueue Action 是 Volcano 调度工作流中的第一个关键步骤，负责将符合条件的待调度作业(Job)加入调度队列（标记为 Inqueue 状态）。以下结合源码（v1.8.0）详细解析其实现机制：</p><h2 id="一、Enqueue-Action-入口函数"><a href="#一、Enqueue-Action-入口函数" class="headerlink" title="一、Enqueue Action 入口函数"></a>一、Enqueue Action 入口函数</h2><p><strong>源码位置</strong>：<code>pkg/scheduler/actions/enqueue/enqueue.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(enqueue *Action)</span></span> Execute(ssn *framework.Session) &#123;<br>    <span class="hljs-comment">// 1. 获取所有Pending状态的作业</span><br>    pendingJobs := jobsMap(ssn.Jobs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(job *api.JobInfo)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> job.IsPending()<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 2. 按队列分组并排序</span><br>    queueJobs := sortJobs(pendingJobs, ssn)<br>    <br>    <span class="hljs-comment">// 3. 遍历队列处理作业</span><br>    <span class="hljs-keyword">for</span> _, queue := <span class="hljs-keyword">range</span> ssn.Queues &#123;<br>        jobs, found := queueJobs[queue.UID]<br>        <span class="hljs-keyword">if</span> !found &#123; <span class="hljs-keyword">continue</span> &#125;<br>        <br>        <span class="hljs-comment">// 4. 按插件定义的顺序排序作业</span><br>        sort.Slice(jobs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">return</span> ssn.JobOrderFn(jobs[i], jobs[j]) || <br>                  (!ssn.JobOrderFn(jobs[j], jobs[i]) &amp;&amp; jobs[i].UID &lt; jobs[j].UID)<br>        &#125;)<br>        <br>        <span class="hljs-comment">// 5. 处理队列中的每个作业</span><br>        <span class="hljs-keyword">for</span> _, job := <span class="hljs-keyword">range</span> jobs &#123;<br>            <span class="hljs-comment">// 6. 执行入队检查</span><br>            <span class="hljs-keyword">if</span> status := enqueue.jobEnqueueable(job, ssn); !status.IsSuccess() &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 7. 更新作业状态</span><br>            job.PodGroup.Status.Phase = scheduling.PodGroupInqueue<br>            ssn.Jobs[job.UID] = job<br>            <br>            <span class="hljs-comment">// 8. 更新队列状态</span><br>            ssn.UpdateQueueStatus(job.Queue, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(status *api.QueueStatus)</span></span> &#123;<br>                status.Pending -= <span class="hljs-number">1</span><br>                status.Inqueue += <span class="hljs-number">1</span><br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、核心处理流程详解"><a href="#二、核心处理流程详解" class="headerlink" title="二、核心处理流程详解"></a>二、核心处理流程详解</h2><h3 id="1-作业筛选与分组"><a href="#1-作业筛选与分组" class="headerlink" title="1. 作业筛选与分组"></a>1. 作业筛选与分组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">pendingJobs := jobsMap(ssn.Jobs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(job *api.JobInfo)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> job.IsPending()<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>从 Session 缓存中筛选所有状态为 <code>Pending</code> 的作业</li><li><code>JobInfo</code> 结构体（<code>pkg/scheduler/api/job_info.go</code>）封装了作业的完整信息</li></ul><h3 id="2-队列排序机制"><a href="#2-队列排序机制" class="headerlink" title="2. 队列排序机制"></a>2. 队列排序机制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">queues := <span class="hljs-built_in">make</span>([]*api.QueueInfo, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(ssn.Queues))<br><span class="hljs-keyword">for</span> _, queue := <span class="hljs-keyword">range</span> ssn.Queues &#123;<br>    queues = <span class="hljs-built_in">append</span>(queues, queue)<br>&#125;<br>sort.Slice(queues, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> ssn.QueueOrderFn(queues[i], queues[j])<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>使用 <code>QueueOrderFn</code> 对队列排序（默认为 DRF 算法）</li><li>自定义排序可通过 <code>proportion</code> 插件实现（<code>pkg/scheduler/plugins/proportion</code>）</li></ul><h3 id="3-作业入队检查"><a href="#3-作业入队检查" class="headerlink" title="3. 作业入队检查"></a>3. 作业入队检查</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(enqueue *Action)</span></span> jobEnqueueable(job *api.JobInfo, ssn *framework.Session) *api.Status &#123;<br>    <span class="hljs-comment">// 调用所有注册的JobEnqueueable插件</span><br>    <span class="hljs-keyword">for</span> _, enqueueableFn := <span class="hljs-keyword">range</span> ssn.JobEnqueueableFns &#123;<br>        <span class="hljs-keyword">if</span> status := enqueueableFn(job); !status.IsSuccess() &#123;<br>            <span class="hljs-keyword">return</span> status<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> api.NewStatus(api.Success)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过插件链实现多条件检查</li><li>关键检查插件：<ul><li><strong>Gang 插件</strong>：检查 minAvailable 资源是否满足</li><li><strong>ResourceQuota 插件</strong>：检查队列配额</li><li><strong>SLA 插件</strong>：检查作业等待时间</li></ul></li></ul><h3 id="4-Gang-插件资源检查"><a href="#4-Gang-插件资源检查" class="headerlink" title="4. Gang 插件资源检查"></a>4. Gang 插件资源检查</h3><p><strong>源码位置</strong>：<code>pkg/scheduler/plugins/gang/gang.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(gp *Plugin)</span></span> JobEnqueueable(job *api.JobInfo) *api.Status &#123;<br>    <span class="hljs-comment">// 1. 检查minAvailable设置</span><br>    <span class="hljs-keyword">if</span> job.MinAvailable &gt; <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(job.Tasks)) &#123;<br>        <span class="hljs-keyword">return</span> api.NewStatus(api.Error, <span class="hljs-string">&quot;minAvailable &gt; task count&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 计算集群总资源</span><br>    total := gp.totalResources(job)<br>    <br>    <span class="hljs-comment">// 3. 检查作业资源需求</span><br>    <span class="hljs-keyword">if</span> job.PodGroup.Spec.MinResources != <span class="hljs-literal">nil</span> &#123;<br>        minReq := job.PodGroup.Spec.MinResources<br>        <span class="hljs-keyword">if</span> !api.Less(minReq, total) &#123;<br>            <span class="hljs-keyword">return</span> api.NewStatus(api.Unschedulable, <br>                <span class="hljs-string">&quot;not enough resources: requested %v &gt; cluster total %v&quot;</span>, <br>                minReq, total)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> api.NewStatus(api.Success)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-ResourceQuota-插件队列配额检查"><a href="#5-ResourceQuota-插件队列配额检查" class="headerlink" title="5. ResourceQuota 插件队列配额检查"></a>5. ResourceQuota 插件队列配额检查</h3><p><strong>源码位置</strong>：<code>pkg/scheduler/plugins/proportion/proportion.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pp *Plugin)</span></span> JobEnqueueable(job *api.JobInfo) *api.Status &#123;<br>    queue := pp.ssn.Queue(job.Queue)<br>    <span class="hljs-keyword">if</span> queue == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> api.NewStatus(api.Error, <span class="hljs-string">&quot;queue not found&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算作业资源需求</span><br>    jobReq := api.EmptyResource()<br>    <span class="hljs-keyword">if</span> job.PodGroup.Spec.MinResources != <span class="hljs-literal">nil</span> &#123;<br>        jobReq.Add(job.PodGroup.Spec.MinResources)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查队列剩余配额</span><br>    deserved := queue.Queue.Status.Deserved.Clone()<br>    used := queue.Queue.Status.Used.Clone()<br>    allocatable := deserved.Sub(used)<br>    <br>    <span class="hljs-keyword">if</span> allocatable.Less(jobReq) &#123;<br>        <span class="hljs-keyword">return</span> api.NewStatus(api.Unschedulable,<br>            <span class="hljs-string">&quot;insufficient queue quota: requested %v, available %v&quot;</span>,<br>            jobReq, allocatable)<br>    &#125;<br>    <span class="hljs-keyword">return</span> api.NewStatus(api.Success)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-SLA-插件超时处理"><a href="#6-SLA-插件超时处理" class="headerlink" title="6. SLA 插件超时处理"></a>6. SLA 插件超时处理</h3><p><strong>源码位置</strong>：<code>pkg/scheduler/plugins/sla/sla.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *slaPlugin)</span></span> JobEnqueueable(job *api.JobInfo) *api.Status &#123;<br>    <span class="hljs-comment">// 1. 获取SLA配置</span><br>    timeout, err := s.getSLATimeout(job)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> api.NewStatus(api.Error, err.Error())<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 检查是否超时</span><br>    now := time.Now()<br>    waitTime := now.Sub(job.PodGroup.CreationTimestamp.Time)<br>    <br>    <span class="hljs-keyword">if</span> waitTime &gt;= timeout &#123;<br>        <span class="hljs-comment">// 3. 超时作业强制入队</span><br>        <span class="hljs-keyword">return</span> api.NewStatus(api.Success, <span class="hljs-string">&quot;SLA timeout enforced&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 未超时作业正常检查</span><br>    <span class="hljs-keyword">return</span> api.NewStatus(api.Unschedulable, <br>        <span class="hljs-string">&quot;within SLA period: waited %v &lt; timeout %v&quot;</span>, waitTime, timeout)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、状态更新机制"><a href="#三、状态更新机制" class="headerlink" title="三、状态更新机制"></a>三、状态更新机制</h2><h3 id="1-作业状态更新"><a href="#1-作业状态更新" class="headerlink" title="1. 作业状态更新"></a>1. 作业状态更新</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">job.PodGroup.Status.Phase = scheduling.PodGroupInqueue<br></code></pre></td></tr></table></figure><ul><li>将 PodGroup 状态从 <code>Pending</code> 更新为 <code>Inqueue</code></li><li>更新后的状态会同步到 Kubernetes API Server</li></ul><h3 id="2-队列状态更新"><a href="#2-队列状态更新" class="headerlink" title="2. 队列状态更新"></a>2. 队列状态更新</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ssn.UpdateQueueStatus(job.Queue, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(status *api.QueueStatus)</span></span> &#123;<br>    status.Pending -= <span class="hljs-number">1</span><br>    status.Inqueue += <span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>更新队列的作业计数</li><li>资源配额更新由 proportion 插件在后续处理</li></ul><h2 id="四、Enqueue-Action-的插件扩展点"><a href="#四、Enqueue-Action-的插件扩展点" class="headerlink" title="四、Enqueue Action 的插件扩展点"></a>四、Enqueue Action 的插件扩展点</h2><table><thead><tr><th>扩展点</th><th>作用</th><th>默认实现</th></tr></thead><tbody><tr><td><code>QueueOrderFn</code></td><td>定义队列排序逻辑</td><td>proportion 插件</td></tr><tr><td><code>JobOrderFn</code></td><td>定义作业在队列内的排序逻辑</td><td>FIFO</td></tr><tr><td><code>JobEnqueueableFn</code></td><td>定义作业入队条件检查</td><td>gang&#x2F;resoucequota</td></tr><tr><td><code>JobReadyFn</code></td><td>定义作业是否准备好调度</td><td>gang 插件</td></tr></tbody></table><h2 id="五、Enqueue-流程时序图"><a href="#五、Enqueue-流程时序图" class="headerlink" title="五、Enqueue 流程时序图"></a>五、Enqueue 流程时序图</h2><pre><code class=" mermaid">sequenceDiagram    participant Scheduler    proportion-&gt;&gt;Scheduler: 提供QueueOrderFn    gang-&gt;&gt;Scheduler: 提供JobEnqueueableFn    sla-&gt;&gt;Scheduler: 提供JobEnqueueableFn        Scheduler-&gt;&gt;Cache: 获取Pending作业    Cache--&gt;&gt;Scheduler: 返回Job列表        loop 每个队列        Scheduler-&gt;&gt;proportion: 调用QueueOrderFn排序队列        proportion--&gt;&gt;Scheduler: 返回队列排序结果                loop 队列内作业            Scheduler-&gt;&gt;gang: 调用JobEnqueueableFn            gang--&gt;&gt;Scheduler: 返回资源检查结果            Scheduler-&gt;&gt;sla: 调用JobEnqueueableFn            sla--&gt;&gt;Scheduler: 返回超时检查结果                        alt 检查通过                Scheduler-&gt;&gt;API Server: 更新PodGroup状态(Inqueue)                Scheduler-&gt;&gt;Cache: 更新队列状态            else 检查失败                Scheduler-&gt;&gt;Log: 记录拒绝原因            end        end    end</code></pre><h2 id="六、设计要点分析"><a href="#六、设计要点分析" class="headerlink" title="六、设计要点分析"></a>六、设计要点分析</h2><ol><li><p><strong>插件化架构</strong>：</p><ul><li>所有核心逻辑通过插件接口实现</li><li>支持自定义扩展而不修改核心代码</li></ul></li><li><p><strong>两级排序机制</strong>：</p><ul><li>队列级排序：决定哪个队列优先调度</li><li>作业级排序：决定队列内作业的调度顺序</li></ul></li><li><p><strong>条件检查链</strong>：</p><ul><li>多个检查插件形成”与”逻辑关系</li><li>任一插件拒绝则作业不入队</li></ul></li><li><p><strong>状态原子更新</strong>：</p><ul><li>作业状态更新与队列计数更新同步进行</li><li>通过 Session 保证操作原子性</li></ul></li><li><p><strong>资源预留设计</strong>：</p><ul><li>入队时不立即占用资源</li><li>实际资源分配在 Allocate Action 进行</li></ul></li></ol><p>Enqueue Action 通过这种设计实现了高效的作业准入控制，为后续的资源分配阶段提供了合格的候选作业集合，同时保证了集群资源的合理利用和作业的公平调度。</p><pre><code class=" mermaid">sequenceDiagram  participant Scheduler  proportion-&gt;&gt;Scheduler: 提供QueueOrderFn  gang-&gt;&gt;Scheduler: 提供JobEnqueueableFn  sla-&gt;&gt;Scheduler: 提供JobEnqueueableFn    Scheduler-&gt;&gt;Cache: 获取Pending作业  Cache--&gt;&gt;Scheduler: 返回Job列表    loop 每个队列      Scheduler-&gt;&gt;proportion: 调用QueueOrderFn排序队列      proportion--&gt;&gt;Scheduler: 返回队列排序结果            loop 队列内作业          Scheduler-&gt;&gt;gang: 调用JobEnqueueableFn          gang--&gt;&gt;Scheduler: 返回资源检查结果          Scheduler-&gt;&gt;sla: 调用JobEnqueueableFn          sla--&gt;&gt;Scheduler: 返回超时检查结果                    alt 检查通过              Scheduler-&gt;&gt;API Server: 更新PodGroup状态(Inqueue)              Scheduler-&gt;&gt;Cache: 更新队列状态          else 检查失败              Scheduler-&gt;&gt;Log: 记录拒绝原因          end      end  end</code></pre><h1 id="讲解二"><a href="#讲解二" class="headerlink" title="讲解二"></a>讲解二</h1><p>结合最新版本的 Volcano 源码，我来为你详细解析 <strong>Enqueue Action</strong> 的具体流程。Enqueue Action 是 Volcano 调度器工作流中的第一个关键步骤，它决定了哪些作业（PodGroup）有资格进入调度队列，后续才能被分配资源。</p><h3 id="🧠-核心概念与作用"><a href="#🧠-核心概念与作用" class="headerlink" title="🧠 核心概念与作用"></a>🧠 核心概念与作用</h3><p>在深入了解代码之前，我们先明确 Enqueue Action 的核心使命：</p><ul><li><strong>“守门员”<strong>：它对所有处于 <code>Pending</code> 状态的 PodGroup（在调度器内部封装为 <code>JobInfo</code>）进行筛选。只有当集群</strong>当前可用的空闲资源</strong>能够满足一个 PodGroup 所声明的<strong>最小资源需求</strong>（即 <code>minAvailable</code>，通常代表该作业成功运行所需的最少 Pod 数量）时，这个 PodGroup 才会被允许进入队列（状态变为 <code>Inqueue</code>）。</li><li><strong>避免资源死锁与碎片化</strong>：这种“All or Nothing”的预检机制至关重要。它防止了因资源不足而仅调度部分 Pod，导致分布式任务无法完成的同时又占着资源不放的情况（资源死锁），同时也减少了大量无法调度的 Pending Pod 对 Kubernetes API Server 的压力和集群资源的碎片化。</li><li><strong>状态转换与 Pod 创建触发器</strong>：只有 PodGroup 状态变为 <code>Inqueue</code>，<code>volcano-controller-manager</code> 中的 job controller 才会为此 PodGroup 创建其关联的所有 Pod。这些 Pod 随后才会被调度器缓存并进入后续的调度环节（如 Allocate, Backfill 等）。</li></ul><h3 id="🔍-Enqueue-Action-详细工作流程"><a href="#🔍-Enqueue-Action-详细工作流程" class="headerlink" title="🔍 Enqueue Action 详细工作流程"></a>🔍 Enqueue Action 详细工作流程</h3><p>以下是 Enqueue Action 在一个调度周期（Session）中的详细工作步骤，结合了最新版本（如 v1.12.0）的源码逻辑：</p><ol><li><p><strong>调度周期开始</strong>：<br>Volcano Scheduler 的主循环 <code>scheduler.Run()</code> 会周期性地（由 <code>schedulePeriod</code> 定义，默认约 1 秒）调用 <code>scheduler.runOnce()</code> 或类似逻辑，从而开启一个新的调度会话 (<strong>Session</strong>)。</p></li><li><p><strong>收集待调度的 JobInfo</strong>：<br>在每个调度周期的开始，调度器会从它的缓存 (<code>SchedulerCache</code>) 中获取所有未被调度的 <code>JobInfo</code>（即其对应的 PodGroup 状态不是 <code>Inqueue</code> 或 <code>Running</code>）。这些 <code>JobInfo</code> 封装了 PodGroup 的信息以及其下的所有 Pod（<code>TaskInfo</code>）。</p></li><li><p><strong>执行 Enqueue Action</strong>：<br>调度器会根据配置（通常在 <code>volcano-scheduler-configmap</code> 中定义）依次执行一系列 Action。<code>Enqueue</code> 通常是第一个被执行的 Action。<br>在 <code>pkg/scheduler/actions/enqueue/enqueue.go</code> 的 <code>Execute()</code> 函数中，Enqueue Action 开始工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(enqueue *Action)</span></span> Execute(ss *scheduler.Session) &#123;<br>    <span class="hljs-comment">// 1. 准备需要入队的作业列表</span><br>    <span class="hljs-keyword">var</span> jobs []*api.JobInfo<br>    <span class="hljs-keyword">for</span> _, job := <span class="hljs-keyword">range</span> ss.Jobs &#123;<br>        <span class="hljs-keyword">if</span> job.IsPending() &#123; <span class="hljs-comment">// 检查Job状态是否为Pending</span><br>            jobs = <span class="hljs-built_in">append</span>(jobs, job)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 2. 使用配置的插件对作业进行排序（例如优先级插件）</span><br>    <span class="hljs-keyword">for</span> _, plugin := <span class="hljs-keyword">range</span> ss.Plugins &#123;<br>        <span class="hljs-keyword">if</span> enqueuePlugin, ok := plugin.(enqueueInterface); ok &#123;<br>            enqueuePlugin.SortJobs(jobs)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 3. 遍历所有Pending状态的作业，尝试将其入队</span><br>    <span class="hljs-keyword">for</span> _, job := <span class="hljs-keyword">range</span> jobs &#123;<br>        <span class="hljs-comment">// 调用所有注册插件的OnSessionOpen等方法进行全局计算（如Proportion插件计算队列应得资源）</span><br>        <span class="hljs-comment">// 使用Gang插件等检查集群资源是否满足该Job的minAvailable要求</span><br>        <span class="hljs-keyword">if</span> enqueue.jobReady(ss, job) &#123; <span class="hljs-comment">// 这是核心检查函数</span><br>            <span class="hljs-comment">// 4. 如果检查通过，将Job状态标记为Inqueue</span><br>            job.JobFitError = <span class="hljs-literal">nil</span><br>            <span class="hljs-comment">// 这个状态更新会反映到PodGroup的status上</span><br>            ss.UpdateJobCondition(job, api.JobCondition&#123;<br>                Type:   api.JobReady,<br>                Status: v1.ConditionTrue,<br>                Reason: <span class="hljs-string">&quot;Enqueued&quot;</span>,<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 资源不足，记录错误原因，Job保持Pending状态</span><br>            job.JobFitError = fmt.Errorf(<span class="hljs-string">&quot;not enough resources to schedule the job&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>核心检查：<code>jobReady</code> 与 Gang 插件</strong>：<br><code>jobReady</code> 函数（或类似逻辑）是决定性的环节。它通常会调用 <strong>Gang 插件</strong> 的 <code>OnSessionOpen</code> 或其他相关方法。Gang 插件会：</p><ul><li>获取该 <code>JobInfo</code> 的 <code>minAvailable</code> 值（源自 PodGroup 的 <code>spec.minAvailable</code>）。</li><li><strong>检查集群当前的空闲资源</strong>（<code>ss.Nodes</code> 中各个节点未分配的资源之和，可能还会考虑 Overcommitment 和队列权重<code>weight</code>计算后的应得资源<code>deserved</code>）是否能够<strong>同时满足</strong> <code>minAvailable</code> 个 Pod 的资源请求（<code>request</code>）。</li><li>这个检查是“模拟性”的，并不实际分配资源，旨在快速判断可行性。</li><li>如果空闲资源 &gt;&#x3D; <code>minAvailable</code> 个 Pod 的请求资源之和，则返回 <code>true</code>，否则返回 <code>false</code>。</li></ul></li><li><p><strong>状态更新与提交</strong>：</p><ul><li>对于通过检查的 Job，其状态会在 Session 中被更新为 <code>Inqueue</code>。</li><li>在 <strong>Session 结束</strong> (<code>CloseSession</code>) 时，所有通过 Enqueue Action 的决策（即 PodGroup 状态变更）会通过 <strong>API Server</strong> 提交并持久化到 etcd 中。</li></ul></li><li><p><strong>Controller 触发 Pod 创建</strong>：</p><ul><li><code>volcano-controller-manager</code> 一直监视着 PodGroup 的状态变化。当它观察到某个 PodGroup 的状态从 <code>Pending</code> 变为 <code>Inqueue</code> 后，会开始<strong>创建这个 PodGroup 所关联的所有 Pod</strong>（依据对应的 Volcano Job 中 <code>tasks</code> 模板定义）。</li><li>这些新创建的 Pod 会被 Volcano Scheduler 的缓存捕获，并在<strong>下一个调度周期</strong>中成为待调度的对象，进入后续的 Allocate, Backfill 等 Action。</li></ul></li></ol><h3 id="🔧-关键插件与协同"><a href="#🔧-关键插件与协同" class="headerlink" title="🔧 关键插件与协同"></a>🔧 关键插件与协同</h3><p>Enqueue Action 严重依赖其他插件来完成其决策：</p><ul><li><strong>Gang 插件</strong>：这是 Enqueue 的核心插件。它强制执行“All or Nothing”的调度策略，确保 <code>minAvailable</code> 得到满足。</li><li><strong>Priority 插件</strong>：用于对多个处于 Pending 状态的 Job 进行排序，决定 Enqueue 检查的先后顺序。</li><li><strong>Proportion 插件</strong>：负责计算和管理<strong>队列（Queue）</strong> 的资源权重（<code>weight</code>）、保障（<code>guarantee</code>）和上限（<code>capability</code>）。Enqueue Action 在检查集群可用资源时，可能会考虑队列的应得资源（<code>deserved</code>），而不仅仅是节点的全部空闲资源。<strong>需要注意的是</strong>，队列的 <code>guarantee</code> 和 <code>capability</code> 在 admission 阶段可能缺乏强验证，其最终效果依赖于 Proportion 插件的计算，实际使用中需注意。</li></ul><h3 id="⚠️-重要注意事项"><a href="#⚠️-重要注意事项" class="headerlink" title="⚠️ 重要注意事项"></a>⚠️ 重要注意事项</h3><ol><li><strong>与 Preempt&#x2F;Reclaim 的冲突</strong>：如果调度配置中<strong>同时启用</strong>了 <code>enqueue</code> 和 <code>preempt</code>&#x2F;<code>reclaim</code>，可能会产生逻辑冲突。因为 Enqueue 在资源不足时会阻止 PodGroup 入队，进而导致没有 Pod 被创建。而没有 Pending 状态的 Pod，<code>preempt</code> 和 <code>reclaim</code>  action 就找不到抢占或回收的对象，从而无法生效。配置调度策略时需要仔细考虑这一点。</li><li><strong>Queue 资源的考量</strong>：Enqueue 的决策会受到 PodGroup 所属队列的资源配额影响（通过 Proportion 插件）。但正如前文所述，队列配额的最终效果需要结合 Proportion 插件的具体实现和配置来评估。</li></ol><h3 id="📊-流程总结"><a href="#📊-流程总结" class="headerlink" title="📊 流程总结"></a>📊 流程总结</h3><p>为了更直观地理解整个流程，可以参考下面的序列图，它展示了从调度周期开始到 Pod 被创建的关键步骤和组件交互：</p><p><img src="/2025/08/09/volcano%E8%B0%83%E5%BA%A6%E5%99%A8Enqueue-Action%E8%AF%A6%E8%A7%A3/deepseek_mermaid_20250823_ae43ea.png" alt="deepseek_mermaid_20250823_ae43ea"></p><p>希望这份结合源码的详细解读能帮助你透彻地理解 Volcano Enqueue Action 的工作机制。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>apt-get理解</title>
    <link href="/2025/08/08/apt-get%E7%90%86%E8%A7%A3/"/>
    <url>/2025/08/08/apt-get%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="apt-get理解"><a href="#apt-get理解" class="headerlink" title="apt-get理解"></a>apt-get理解</h1><p>我们用生活化的比喻来解释 <code>apt-get</code>（或者说 <code>apt</code>）这个神奇的“软件管家”：</p><p><strong>想象一下，你的 Linux 电脑就像一个刚搬进去的新房子（空荡荡的操作系统）。</strong></p><ol><li><p><strong><code>apt</code> 是什么？</strong></p><ul><li><strong>它就是你的超级智能“装修管家”兼“采购经理”。</strong> 你想给房子里添置东西（安装软件），比如一张桌子（Firefox 浏览器）、一个书架（LibreOffice办公套件），你不用自己跑遍全城找零件、砍价、担心买错尺寸，你只需要告诉管家一声。</li></ul></li><li><p><strong>安装包在哪里？谁管理维护？</strong></p><ul><li><strong>巨大的“官方家具城”和“授权专卖店”（软件仓库）：</strong> 这些“商城”分散在世界各地（镜像服务器），里面堆满了各式各样打好包、经过严格质检的“家具”（软件包 <code>.deb</code> 文件）。</li><li><strong>谁开的商城？</strong><ul><li><strong>房子开发商开的旗舰店（官方 Main 仓库）：</strong> 由 Ubuntu 或 Debian 公司（其实就是背后的庞大开发团队）自己运营。里面的家具（软件）都是最主流、最稳定、质量最有保障的。他们有自己的设计师（打包者）把原始木材（源代码）加工成适合你家户型（系统）的标准家具，并有专门的维修队（安全团队）负责保修和升级。</li><li><strong>开发商合作的品牌店（Universe&#x2F;Contrib 等仓库）：</strong> 由很多有信誉的第三方品牌（社区开发者）供货和维护，放在开发商的商城里卖。质量也不错，选择更多样。</li><li><strong>某品牌的官方直营店（第三方仓库，如 Docker&#x2F;Google）：</strong> 像“宜家”、“苹果专卖店”这种。如果你想买特定品牌的独家产品（比如 Google Chrome, Docker），管家会带你去他们的专卖店买。这些店由品牌自己管理。</li><li><strong>个体手工作坊（PPA）：</strong> 一些有才华的个人或小团队（比如某个厉害的“木匠”）开的特色小店。里面可能有最新潮的设计（软件测试版）或者官方商城没有的独特家具（软件）。<strong>在这里买东西要更小心点</strong>，因为质检可能不如大商城严格，但有时能淘到宝贝。</li></ul></li></ul></li><li><p><strong><code>apt</code> 怎么工作的？（你想装个“桌子”-Firefox 浏览器）</strong></p><ul><li><strong>第一步：更新“商城导购手册” (<code>sudo apt update</code>)</strong><ul><li>管家（<code>apt</code>）先打电话给各个合作商城（仓库），问：“你们最近有什么新货？哪些货下架了？价格（版本）变了吗？”。</li><li>商城会把最新的<strong>商品目录清单</strong>（软件包索引）传真（下载）给管家。管家把这个清单放在手边（<code>/var/lib/apt/lists/</code>），这样就不用每次都打电话问有什么货了。<strong>这步很重要，确保管家知道最新的商品信息！</strong></li></ul></li><li><strong>第二步：下单采购 (<code>sudo apt install firefox</code>)</strong><ul><li>你告诉管家：“我要买张叫 <code>firefox</code> 的桌子！”</li><li><strong>管家查手册（依赖关系解析）：</strong><ul><li>管家翻看最新的导购手册（本地索引），找到 <code>firefox</code> 桌子。</li><li>手册上写着：这张桌子需要 4 条特定的桌腿（<code>libxxx1</code>）、一个特定型号的桌面（<code>libyyy2</code>）和一个加固支架（<code>libzzz3</code>）才能组装起来使用（依赖包）。</li><li>管家马上检查你家仓库（已安装软件）：哦，已经有 2 条桌腿（<code>libxxx1</code>）了，但型号有点旧，需要买新的；另外两条桌腿（另一个 <code>libxxx</code>）和支架（<code>libzzz3</code>）家里没有；桌面（<code>libyyy2</code>）倒是有个类似的，但不完全匹配，也得买新的。</li><li>管家<strong>自动</strong>计算出需要购买：新版 <code>firefox</code> 桌子、新版桌腿 x 4、新版桌面 x1、加固支架 x1。</li></ul></li><li><strong>管家去采购（下载包）：</strong><ul><li>管家开车（联网）去相应的商城（仓库），把需要的所有东西（软件包 <code>.deb</code> 文件）买回来，临时堆在你家车库（<code>/var/cache/apt/archives/</code>）。</li></ul></li></ul></li><li><strong>第三步：送货上门 &amp; 专业安装 (<code>dpkg</code> 登场)</strong><ul><li>管家不是光把家具扔给你就完事了。他带着专业的安装团队（底层工具 <code>dpkg</code>）一起来。</li><li><strong>拆包 (<code>dpkg -i</code>)：</strong> 安装团队把每个包裹（<code>.deb</code> 文件）拆开。</li><li><strong>精准摆放：</strong> 他们把桌腿（库文件）放到工具房（<code>/usr/lib/</code>），桌面（程序文件）放到客厅（<code>/usr/bin/</code>），说明书（文档）放到书房（<code>/usr/share/doc/</code>），安装图纸（配置文件）放到文件柜（<code>/etc/</code>）里。<strong>每个部件都放到系统规定好的位置。</strong></li><li><strong>组装调试（运行安装脚本）：</strong> 有些家具需要拧螺丝或者接电线（比如创建用户、更新菜单、启动后台服务）。安装团队按照包裹里的说明书（维护脚本 <code>preinst</code>, <code>postinst</code>）一步一步操作，确保桌子装好就能用。</li><li><strong>登记入库：</strong> 管家在家庭财产清单（软件包数据库 <code>/var/lib/dpkg/status</code>）上详细记录：今天安装了 <code>firefox</code> 桌子（版本号 x.x），同时安装了配套的桌腿、桌面、支架（依赖包）。这样以后维修、升级或者想卖掉（卸载）的时候，管家都知道家里有什么。</li></ul></li></ul></li><li><p><strong>其他重要功能：</strong></p><ul><li><strong>升级 (<code>sudo apt upgrade</code>)：</strong> 管家定期查看商城手册（<code>apt update</code>），发现你家的桌子（软件）出了新款或者安全加固版（安全更新）。他会告诉你，并帮你把旧桌子升级成新桌子（包括所有需要升级的桌腿配件）。</li><li><strong>卸载 (<code>sudo apt remove firefox</code>)：</strong> 你说：“这桌子我不想要了”。管家会根据财产清单，把 <code>firefox</code> 桌子和<strong>专门为它安装的配件</strong>（但不会删掉其他家具也需要的配件）拆掉拿走。如果你想连那些可能没用的配件也清理掉，可以用 <code>sudo apt autoremove</code>。</li><li><strong>清理车库 (<code>sudo apt clean</code>)：</strong> 管家把堆在车库（缓存目录）里那些已经安装好的家具包装盒（下载的 <code>.deb</code> 文件）都扔掉，腾出空间。<code>sudo apt autoclean</code> 则是只扔掉那些过时型号的包装盒（旧版本的包）。</li></ul></li></ol><p><strong>总结一下关键比喻：</strong></p><ul><li><strong><code>apt</code> &#x2F; <code>apt-get</code>：</strong> 你的智能装修管家兼采购经理。负责采购、解决配件依赖、指挥安装。</li><li><strong>软件包 (<code>.deb</code>)：</strong> 打包好的“家具”或“电器”。</li><li><strong>软件仓库：</strong> 官方的、第三方的“家具城”、“品牌专卖店”、“手工作坊”（PPA）。</li><li><strong><code>/etc/apt/sources.list</code>：</strong> 管家手里的“合作商城通讯录”。</li><li><strong><code>sudo apt update</code>：</strong> 管家打电话更新所有商城的“最新商品目录手册”。</li><li><strong>依赖关系：</strong> 安装一个“家具”（软件）所必需的“螺丝钉、木板、说明书”（其他库文件或程序）。</li><li><strong><code>dpkg</code>：</strong> 管家的专业“拆包安装团队”，按照说明书把东西放到精确位置并组装调试。</li><li><strong><code>/var/cache/apt/archives/</code>：</strong> 临时堆包装盒的“车库”。</li><li><strong><code>/var/lib/dpkg/status</code>：</strong> 家里的“财产登记清单”，记录所有已安装物品及其配件。</li></ul><p>所以，下次你用 <code>sudo apt install</code> 装软件时，心里就可以想：我的“管家”正在帮我从“官方商城”下单，自动配齐所有需要的“零件”，并指挥“安装队”精准无误地装好！你只需要动动嘴（输入命令）就行了，这就是 <code>apt</code> 带来的巨大便利。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>volcano调度器工作原理</title>
    <link href="/2025/08/06/volcano%E8%B0%83%E5%BA%A6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2025/08/06/volcano%E8%B0%83%E5%BA%A6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Volcano-调度器核心概念与工作原理详解"><a href="#Volcano-调度器核心概念与工作原理详解" class="headerlink" title="Volcano 调度器核心概念与工作原理详解"></a>Volcano 调度器核心概念与工作原理详解</h1><h2 id="一、核心概念全景图"><a href="#一、核心概念全景图" class="headerlink" title="一、核心概念全景图"></a>一、核心概念全景图</h2><h3 id="1-调度会话-Session"><a href="#1-调度会话-Session" class="headerlink" title="1. 调度会话 (Session)"></a>1. 调度会话 (Session)</h3><ul><li><strong>定义</strong>：调度器每次决策的完整周期</li><li><strong>生命周期</strong>：<pre><code class=" mermaid">graph LR  A[会话开始] --&gt; B[获取集群快照]  B --&gt; C[执行调度逻辑]  C --&gt; D[提交调度决策]  D --&gt; E[会话结束]</code></pre></li><li><strong>关键数据</strong>：包含集群状态（节点、作业、队列）的完整内存模型</li></ul><h3 id="2-调度单元-Scheduling-Units"><a href="#2-调度单元-Scheduling-Units" class="headerlink" title="2. 调度单元 (Scheduling Units)"></a>2. 调度单元 (Scheduling Units)</h3><table><thead><tr><th>概念</th><th>描述</th><th>K8s 原生对应</th></tr></thead><tbody><tr><td><strong>PodGroup</strong></td><td>原子调度单元（一组必须整体调度的Pod）</td><td>无</td></tr><tr><td><strong>VolcanoJob</strong></td><td>增强型Job（支持多任务模板）</td><td>Job</td></tr><tr><td><strong>Queue</strong></td><td>资源队列（多租户隔离）</td><td>Namespace ResourceQuota</td></tr><tr><td><strong>Task</strong></td><td>作业内部的任务单元</td><td>PodTemplate</td></tr></tbody></table><h3 id="3-调度策略插件-Plugins"><a href="#3-调度策略插件-Plugins" class="headerlink" title="3. 调度策略插件 (Plugins)"></a>3. 调度策略插件 (Plugins)</h3><table><thead><tr><th>插件名</th><th>功能</th><th>关键参数</th></tr></thead><tbody><tr><td><strong>Gang</strong></td><td>保证作业完整性</td><td><code>minAvailable</code></td></tr><tr><td><strong>DRF</strong></td><td>多资源公平调度</td><td><code>weight</code></td></tr><tr><td><strong>Binpack</strong></td><td>高密度装箱</td><td><code>binpack.resources</code></td></tr><tr><td><strong>Priority</strong></td><td>作业优先级</td><td><code>priorityClassName</code></td></tr><tr><td><strong>Topology</strong></td><td>拓扑感知调度</td><td><code>topologyPolicy</code></td></tr><tr><td><strong>Preempt</strong></td><td>抢占机制</td><td><code>preemptable</code></td></tr></tbody></table><h3 id="4-调度动作-Actions"><a href="#4-调度动作-Actions" class="headerlink" title="4. 调度动作 (Actions)"></a>4. 调度动作 (Actions)</h3><table><thead><tr><th>动作</th><th>执行顺序</th><th>功能</th></tr></thead><tbody><tr><td><strong>Enqueue</strong></td><td>1</td><td>作业入队（检查队列配额）</td></tr><tr><td><strong>Allocate</strong></td><td>2</td><td>核心资源分配</td></tr><tr><td><strong>Backfill</strong></td><td>3</td><td>碎片资源填充</td></tr><tr><td><strong>Preempt</strong></td><td>4</td><td>抢占低优先级作业</td></tr><tr><td><strong>Reclaim</strong></td><td>5</td><td>回收超额资源</td></tr></tbody></table><h2 id="二、调度器工作原理深度解析"><a href="#二、调度器工作原理深度解析" class="headerlink" title="二、调度器工作原理深度解析"></a>二、调度器工作原理深度解析</h2><h3 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1. 整体架构"></a>1. 整体架构</h3><pre><code class=" mermaid">graph TD    A[API Server] --&gt;|Watch| B(Volcano Scheduler)    B --&gt;|决策| C[Kubelet]    D[Volcano Controllers] --&gt;|管理| E[VCJob/PodGroup/Queue]    F[Plugin Registry] --&gt;|扩展| B    G[Metrics Server] --&gt;|监控| B        B --&gt;|插件链| H[Enqueue]    B --&gt;|插件链| I[Allocate]    B --&gt;|插件链| J[Backfill]</code></pre><h3 id="2-调度循环完整流程"><a href="#2-调度循环完整流程" class="headerlink" title="2. 调度循环完整流程"></a>2. 调度循环完整流程</h3><h4 id="步骤1：会话初始化-Session-Initialization"><a href="#步骤1：会话初始化-Session-Initialization" class="headerlink" title="步骤1：会话初始化 (Session Initialization)"></a>步骤1：会话初始化 (Session Initialization)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建新会话</span><br>session := NewSession(<br>    cache.GetNodes(),   <span class="hljs-comment">// 节点列表</span><br>    cache.GetJobs(),    <span class="hljs-comment">// 作业列表</span><br>    cache.GetQueues(),  <span class="hljs-comment">// 队列列表</span><br>)<br></code></pre></td></tr></table></figure><h4 id="步骤2：插件链执行-Plugin-Chain-Execution"><a href="#步骤2：插件链执行-Plugin-Chain-Execution" class="headerlink" title="步骤2：插件链执行 (Plugin Chain Execution)"></a>步骤2：插件链执行 (Plugin Chain Execution)</h4><pre><code class=" mermaid">sequenceDiagram    Scheduler-&gt;&gt;+Enqueue: 执行入队    Enqueue--&gt;&gt;-Scheduler: 返回可调度作业    Scheduler-&gt;&gt;+Allocate: 分配资源    Allocate--&gt;&gt;-Scheduler: 返回分配方案    Scheduler-&gt;&gt;+Backfill: 填充碎片    Backfill--&gt;&gt;-Scheduler: 返回填充结果</code></pre><h4 id="步骤3：核心调度算法-Allocate-Action"><a href="#步骤3：核心调度算法-Allocate-Action" class="headerlink" title="步骤3：核心调度算法 (Allocate Action)"></a>步骤3：核心调度算法 (Allocate Action)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">allocate</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-comment"># 1. 作业排序（优先级/提交时间）</span><br>    sorted_jobs = sort_jobs(session.jobs)<br>    <br>    <span class="hljs-keyword">for</span> job <span class="hljs-keyword">in</span> sorted_jobs:<br>        <span class="hljs-comment"># 2. 检查Gang条件</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> gang_plugin.check(job):<br>            <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 跳过不满足条件的作业</span><br>        <br>        <span class="hljs-comment"># 3. 任务排序（Chief优先）</span><br>        sorted_tasks = sort_tasks(job.tasks)<br>        <br>        <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> sorted_tasks:<br>            <span class="hljs-comment"># 4. 节点过滤（标签/污点）</span><br>            feasible_nodes = filter_nodes(task, session.nodes)<br>            <br>            <span class="hljs-comment"># 5. 节点评分（Binpack/Spread）</span><br>            scored_nodes = score_nodes(task, feasible_nodes)<br>            <br>            <span class="hljs-comment"># 6. 选择最优节点</span><br>            best_node = select_best_node(scored_nodes)<br>            <br>            <span class="hljs-comment"># 7. 临时绑定</span><br>            bind(task, best_node)<br>    <br>    <span class="hljs-comment"># 8. 提交绑定决策</span><br>    commit_bindings()<br></code></pre></td></tr></table></figure><h4 id="步骤4：决策提交-Decision-Commit"><a href="#步骤4：决策提交-Decision-Commit" class="headerlink" title="步骤4：决策提交 (Decision Commit)"></a>步骤4：决策提交 (Decision Commit)</h4><ul><li>原子性提交所有绑定操作</li><li>状态更新：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> all_bound &#123;<br>    podGroup.Status = Running<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    podGroup.Status = Pending<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="三、核心调度场景解析"><a href="#三、核心调度场景解析" class="headerlink" title="三、核心调度场景解析"></a>三、核心调度场景解析</h2><h3 id="1-Gang-Scheduling-实现"><a href="#1-Gang-Scheduling-实现" class="headerlink" title="1. Gang Scheduling 实现"></a>1. Gang Scheduling 实现</h3><p><strong>问题</strong>：如何保证分布式作业的所有Pod同时启动？</p><p><strong>解决方案</strong>：</p><pre><code class=" mermaid">sequenceDiagram    participant S as Scheduler    participant C as Cluster    S-&gt;&gt;C: 检查minAvailable资源    alt 资源充足        S-&gt;&gt;C: 预留所有资源        S-&gt;&gt;C: 原子绑定所有Pod        C--&gt;&gt;S: 绑定成功    else 资源不足        S-&gt;&gt;C: 不绑定任何Pod        C--&gt;&gt;S: 保持Pending状态    end</code></pre><p><strong>关键代码</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *gangPlugin)</span></span> OnSessionOpen(ssn *framework.Session) &#123;<br>    ssn.AddJobReadyFn(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>        job := obj.(*api.JobInfo)<br>        ready := <span class="hljs-built_in">len</span>(job.ReadyTasks) &gt;= job.MinAvailable<br>        <span class="hljs-keyword">return</span> ready<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-抢占式调度-Preemption"><a href="#2-抢占式调度-Preemption" class="headerlink" title="2. 抢占式调度 (Preemption)"></a>2. 抢占式调度 (Preemption)</h3><p><strong>场景</strong>：高优先级作业需要资源时</p><p><strong>工作流程</strong>：</p><pre><code class=" mermaid">graph TD    A[新作业提交] --&gt; B&#123;资源不足&#125;    B --&gt;|是| C[选择牺牲者]    C --&gt; D[驱逐低优先级Pod]    D --&gt; E[释放资源]    E --&gt; F[调度新作业]</code></pre><p><strong>牺牲者选择策略</strong>：</p><ol><li>最低优先级作业</li><li>最小进度损失（可恢复作业优先）</li><li>最少Pod数量</li></ol><h3 id="3-拓扑感知调度-Topology-Awareness"><a href="#3-拓扑感知调度-Topology-Awareness" class="headerlink" title="3. 拓扑感知调度 (Topology Awareness)"></a>3. 拓扑感知调度 (Topology Awareness)</h3><p><strong>GPU训练场景优化</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">plugins:</span><br>  <span class="hljs-attr">topology:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">policies:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">device:</span> <span class="hljs-string">GPU</span><br>        <span class="hljs-attr">gpuPolicy:</span> <span class="hljs-string">dgx-2</span> <span class="hljs-comment"># NVLink拓扑策略</span><br></code></pre></td></tr></table></figure><p><strong>调度器行为</strong>：</p><ol><li>过滤具有NVLink的节点</li><li>选择同一物理机上的GPU</li><li>确保GPU通过高速互联</li></ol><h2 id="四、调度器高级特性"><a href="#四、调度器高级特性" class="headerlink" title="四、调度器高级特性"></a>四、调度器高级特性</h2><h3 id="1-批调度优化"><a href="#1-批调度优化" class="headerlink" title="1. 批调度优化"></a>1. 批调度优化</h3><table><thead><tr><th>策略</th><th>描述</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>Binpack</strong></td><td>紧密装箱减少碎片</td><td>资源紧张环境</td></tr><tr><td><strong>Spread</strong></td><td>分散部署提高可用性</td><td>高可用需求</td></tr><tr><td><strong>DRF</strong></td><td>多资源公平分配</td><td>多租户环境</td></tr></tbody></table><h3 id="2-弹性资源管理"><a href="#2-弹性资源管理" class="headerlink" title="2. 弹性资源管理"></a>2. 弹性资源管理</h3><pre><code class=" mermaid">graph LR    A[资源监控] --&gt; B&#123;资源不足&#125;    B --&gt;|是| C[驱逐离线作业]    B --&gt;|否| D[恢复离线作业]    D --&gt; E[从检查点继续]</code></pre><h3 id="3-任务依赖-DAG"><a href="#3-任务依赖-DAG" class="headerlink" title="3. 任务依赖 (DAG)"></a>3. 任务依赖 (DAG)</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">preprocess</span><br>    <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">training</span><br>    <span class="hljs-attr">replicas:</span> <span class="hljs-number">4</span><br>    <span class="hljs-attr">dependsOn:</span> [<span class="hljs-string">preprocess</span>] <span class="hljs-comment"># 依赖前置任务</span><br></code></pre></td></tr></table></figure><h2 id="五、调度器内部状态机"><a href="#五、调度器内部状态机" class="headerlink" title="五、调度器内部状态机"></a>五、调度器内部状态机</h2><h3 id="PodGroup-状态流转"><a href="#PodGroup-状态流转" class="headerlink" title="PodGroup 状态流转"></a>PodGroup 状态流转</h3><pre><code class=" mermaid">stateDiagram-v2    [*] --&gt; Pending 创建    Pending --&gt; Running 资源满足    Running --&gt; Completed 所有任务成功    Running --&gt; Failed 任务失败    Pending --&gt; Failed 超时/配置错误    Failed --&gt; Pending 重试（maxRetry）</code></pre><h3 id="调度决策状态"><a href="#调度决策状态" class="headerlink" title="调度决策状态"></a>调度决策状态</h3><table><thead><tr><th>状态</th><th>描述</th><th>常见原因</th></tr></thead><tbody><tr><td><strong>Unschedulable</strong></td><td>无法调度</td><td>资源不足&#x2F;约束冲突</td></tr><tr><td><strong>Wait</strong></td><td>等待依赖</td><td>DAG前置任务未完成</td></tr><tr><td><strong>Pending</strong></td><td>排队中</td><td>队列配额不足</td></tr><tr><td><strong>Scheduled</strong></td><td>已调度</td><td>成功分配节点</td></tr></tbody></table><h2 id="六、实操：调度器问题诊断"><a href="#六、实操：调度器问题诊断" class="headerlink" title="六、实操：调度器问题诊断"></a>六、实操：调度器问题诊断</h2><h3 id="1-PodGroup-长期-Pending"><a href="#1-PodGroup-长期-Pending" class="headerlink" title="1. PodGroup 长期 Pending"></a>1. PodGroup 长期 Pending</h3><p><strong>诊断命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看事件</span><br>kubectl describe podgroup &lt;name&gt;<br><br><span class="hljs-comment"># 检查调度器日志</span><br>kubectl logs -n volcano-system volcano-scheduler-xxx | grep &lt;job-name&gt;<br></code></pre></td></tr></table></figure><p><strong>常见原因</strong>：</p><ul><li><code>minAvailable</code> &gt; 可用资源</li><li>节点选择器&#x2F;污点不匹配</li><li>队列资源配额不足</li></ul><h3 id="2-调度性能优化"><a href="#2-调度性能优化" class="headerlink" title="2. 调度性能优化"></a>2. 调度性能优化</h3><p><strong>配置示例</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># volcano-scheduler-configmap.yaml</span><br><span class="hljs-attr">actions:</span> <span class="hljs-string">&quot;enqueue, allocate, backfill&quot;</span><br><span class="hljs-attr">arguments:</span><br>  <span class="hljs-attr">allocate.nodeorder.binpack:</span> <span class="hljs-string">&quot;cpu,memory&quot;</span><br>  <span class="hljs-attr">batch.scheduler.timeout:</span> <span class="hljs-string">&quot;10s&quot;</span><br></code></pre></td></tr></table></figure><p><strong>调优参数</strong>：</p><ul><li><code>batch.scheduler.timeout</code>：会话超时时间</li><li><code>cache.workers</code>：并发处理数</li><li><code>profiling.enable</code>：启用性能分析</li></ul><h2 id="七、学习路径建议"><a href="#七、学习路径建议" class="headerlink" title="七、学习路径建议"></a>七、学习路径建议</h2><h3 id="1-概念理解顺序"><a href="#1-概念理解顺序" class="headerlink" title="1. 概念理解顺序"></a>1. 概念理解顺序</h3><pre><code class=" mermaid">graph LR    A[PodGroup] --&gt; B[VolcanoJob]    B --&gt; C[Queue]    C --&gt; D[调度会话]    D --&gt; E[调度动作]    E --&gt; F[调度插件]</code></pre><h3 id="2-实践路线"><a href="#2-实践路线" class="headerlink" title="2. 实践路线"></a>2. 实践路线</h3><ol><li>部署Volcano集群</li><li>提交基础VolcanoJob</li><li>观察Gang调度行为</li><li>配置多优先级队列</li><li>实现任务依赖DAG</li><li>开发自定义插件</li></ol><blockquote><p><strong>深度理解建议</strong>：阅读源码核心路径：</p><ul><li>调度入口：<code>pkg/scheduler/scheduler.go</code> </li><li>Gang插件：<code>pkg/plugins/gang</code></li><li>分配逻辑：<code>pkg/scheduler/actions/allocate</code> </li><li>会话管理：<code>pkg/scheduler/framework</code></li></ul></blockquote><p>通过结合理论学习和实践操作，你将全面掌握Volcano调度器的核心机制和工作原理。</p><h2 id="八、具体场景分析"><a href="#八、具体场景分析" class="headerlink" title="八、具体场景分析"></a>八、具体场景分析</h2><h3 id="1-podgroup在首次session调度和后续session调度中的行为"><a href="#1-podgroup在首次session调度和后续session调度中的行为" class="headerlink" title="1. podgroup在首次session调度和后续session调度中的行为"></a>1. podgroup在首次session调度和后续session调度中的行为</h3><p>在 PodGroup 进入 Running 状态后，<strong>Volcano 调度器在新一轮 Session 中仍然会尝试批量调度剩余 Pod，而不是严格的一个一个调度</strong>。但这种”批量”行为与初始调度有本质区别，下面详细解析：</p><h4 id="调度机制详解"><a href="#调度机制详解" class="headerlink" title="调度机制详解"></a>调度机制详解</h4><pre><code class=" mermaid">graph TD    A[Session开始] --&gt; B&#123;PodGroup状态&#125;    B --&gt;|Running| C[收集所有未调度Pods]    C --&gt; D[按优先级排序Pods]    D --&gt; E[批量尝试分配]    E --&gt; F&#123;资源足够?&#125;    F --&gt;|是| G[批量绑定多个Pod]    F --&gt;|否| H[尝试分配部分Pod]    H --&gt; I&#123;至少分配1个?&#125;    I --&gt;|是| J[绑定成功Pod]    I --&gt;|否| K[结束Session]    J --&gt; K</code></pre><h4 id="关键特性说明"><a href="#关键特性说明" class="headerlink" title="关键特性说明"></a>关键特性说明</h4><ol><li><p><strong>批量尝试，但非原子性</strong></p><ul><li>调度器会<strong>同时考虑所有未调度Pod</strong>的资源需求</li><li>但不再要求”全有或全无”，可以部分成功</li><li>示例：剩余5个Pod，可能一次调度3个，下次再调度2个</li></ul></li><li><p><strong>分配策略变化</strong></p><ul><li>初始调度：严格按资源请求量排序（大资源优先）</li><li>后续调度：默认按 <strong>Pod 创建时间排序</strong>（FIFO），除非配置优先级<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 伪代码：排序逻辑</span><br><span class="hljs-keyword">if</span> pg.Status.Running &gt;= pg.Spec.MinAvailable &#123;<br>    pods = SortByCreationTime(unscheduledPods) <span class="hljs-comment">// 后续调度排序</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    pods = SortByResourceRequest(unscheduledPods) <span class="hljs-comment">// 初始调度排序</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>资源分配方式</strong></p><ul><li><strong>并行预选</strong>：同时检查所有节点对剩余Pod的适配性</li><li><strong>顺序绑定</strong>：实际绑定时按排序顺序逐个提交API请求<pre><code class=" mermaid">sequenceDiagram    调度器-&gt;&gt;API Server: 批量提交Node预选请求（并行）    API Server--&gt;&gt;调度器: 返回可行节点列表    调度器-&gt;&gt;调度器: 为每个Pod选择最优节点（按排序顺序）    循环 每个Pod:        调度器-&gt;&gt;API Server: 提交绑定请求（顺序）</code></pre></li></ul></li></ol><h4 id="与初始调度的核心区别"><a href="#与初始调度的核心区别" class="headerlink" title="与初始调度的核心区别"></a>与初始调度的核心区别</h4><table><thead><tr><th><strong>特性</strong></th><th>初始调度 (Pending状态)</th><th>后续调度 (Running状态)</th></tr></thead><tbody><tr><td><strong>调度单位</strong></td><td>整个PodGroup（原子性）</td><td>剩余Pod集合</td></tr><tr><td><strong>资源检查</strong></td><td>必须满足minAvailable对应资源</td><td>按实际剩余Pod需求</td></tr><tr><td><strong>分配策略</strong></td><td>大资源Pod优先</td><td>FIFO（默认）或按优先级</td></tr><tr><td><strong>结果要求</strong></td><td>全有或全无</td><td>能调多少调多少</td></tr><tr><td><strong>资源锁定</strong></td><td>预留整个minAvailable资源</td><td>仅预留实际分配资源</td></tr><tr><td><strong>重试机制</strong></td><td>整个组重试</td><td>单个Pod独立重试</td></tr></tbody></table><h4 id="实际调度流程示例"><a href="#实际调度流程示例" class="headerlink" title="实际调度流程示例"></a>实际调度流程示例</h4><p><strong>场景</strong>：</p><ul><li>剩余5个Pod：P1(需要8CPU), P2(需要1CPU), P3(需要1CPU), P4(需要1CPU), P5(需要1CPU)</li><li>集群空闲资源：10 CPU</li></ul><p><strong>Session过程</strong>：</p><ol><li>收集未调度Pods: [P1, P2, P3, P4, P5]（按创建时间排序）</li><li>批量检查节点资源：<ul><li>发现节点A有10 CPU空闲</li></ul></li><li>尝试分配：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试分配P1（需8CPU）-&gt; 成功，剩余资源：2 CPU</span><br><span class="hljs-comment"># 尝试分配P2（需1CPU）-&gt; 成功，剩余资源：1 CPU</span><br><span class="hljs-comment"># 尝试分配P3（需1CPU）-&gt; 成功，剩余资源：0 CPU</span><br><span class="hljs-comment"># P4,P5无法分配</span><br></code></pre></td></tr></table></figure></li><li>批量绑定P1,P2,P3</li><li>更新状态：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">running:</span> <span class="hljs-number">13</span>  <span class="hljs-comment"># 原10+新3</span><br><span class="hljs-attr">pending:</span> <span class="hljs-number">2</span>   <span class="hljs-comment"># P4,P5</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="高级控制：如何改变调度行为"><a href="#高级控制：如何改变调度行为" class="headerlink" title="高级控制：如何改变调度行为"></a>高级控制：如何改变调度行为</h4><h4 id="1-启用Backfill（回填）插件"><a href="#1-启用Backfill（回填）插件" class="headerlink" title="1. 启用Backfill（回填）插件"></a>1. 启用Backfill（回填）插件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch.volcano.sh/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">plugins:</span><br>    <span class="hljs-attr">backfill:</span> &#123;&#125;  <span class="hljs-comment"># 允许小资源优先</span><br></code></pre></td></tr></table></figure><p>行为变化：小资源Pod会优先于大资源Pod调度</p><h4 id="2-自定义优先级"><a href="#2-自定义优先级" class="headerlink" title="2. 自定义优先级"></a>2. 自定义优先级</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">important-task</span><br>    <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">metadata:</span><br>        <span class="hljs-attr">annotations:</span><br>          <span class="hljs-comment"># 设置高优先级</span><br>          <span class="hljs-attr">volcano.sh/priority-class:</span> <span class="hljs-string">&quot;high&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">normal-task</span><br>    <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">template:</span><br>      <span class="hljs-attr">metadata:</span><br>        <span class="hljs-attr">annotations:</span><br>          <span class="hljs-attr">volcano.sh/priority-class:</span> <span class="hljs-string">&quot;medium&quot;</span><br></code></pre></td></tr></table></figure><p>排序规则：高优先级 &gt; 中优先级 &gt; 创建时间</p><h4 id="3-分批次调度策略"><a href="#3-分批次调度策略" class="headerlink" title="3. 分批次调度策略"></a>3. 分批次调度策略</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">worker</span><br>    <span class="hljs-attr">replicas:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">policies:</span><br>      <span class="hljs-comment"># 每完成2个Pod再调度下一批</span><br>      <span class="hljs-attr">event:</span> <span class="hljs-string">TaskCompleted</span> <br>      <span class="hljs-attr">action:</span> <span class="hljs-string">Create</span><br>      <span class="hljs-attr">count:</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="诊断技巧：验证调度行为"><a href="#诊断技巧：验证调度行为" class="headerlink" title="诊断技巧：验证调度行为"></a>诊断技巧：验证调度行为</h3><h4 id="1-查看调度器决策日志"><a href="#1-查看调度器决策日志" class="headerlink" title="1. 查看调度器决策日志"></a>1. 查看调度器决策日志</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl logs -n volcano-system volcano-scheduler-xxx | grep <span class="hljs-string">&quot;Allocating remaining&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 典型输出</span><br><span class="hljs-attribute">Allocating</span> <span class="hljs-number">5</span> remaining pods for pg/job-demo<span class="hljs-meta"> [phase=Running]</span><br><span class="hljs-attribute">Pod</span> scheduling order:<span class="hljs-meta"> [pod1, pod2, pod3, pod4, pod5] </span><br><span class="hljs-meta">Successfully allocated 3 pods</span><br></code></pre></td></tr></table></figure><h4 id="2-监控调度指标"><a href="#2-监控调度指标" class="headerlink" title="2. 监控调度指标"></a>2. 监控调度指标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs promql"># 查看批量分配大小<br>volcano_session_pods_allocated_count&#123;phase=&quot;incremental&quot;&#125;<br><br># 查看分配延迟<br>volcano_pod_scheduling_duration_seconds_bucket&#123;phase=&quot;post_start&quot;&#125;<br></code></pre></td></tr></table></figure><h4 id="3-跟踪Pod事件"><a href="#3-跟踪Pod事件" class="headerlink" title="3. 跟踪Pod事件"></a>3. 跟踪Pod事件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe pod pending-pod-name<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Events:</span><br>  <span class="hljs-string">Type</span>     <span class="hljs-string">Reason</span>            <span class="hljs-string">Age</span>   <span class="hljs-string">From</span>                 <span class="hljs-string">Message</span><br>  <span class="hljs-string">Normal</span>   <span class="hljs-string">Scheduled</span>         <span class="hljs-string">10s</span>   <span class="hljs-string">volcano-scheduler</span>    <span class="hljs-string">Successfully</span> <span class="hljs-string">assigned</span> <span class="hljs-string">pod</span> <span class="hljs-string">(batch</span> <span class="hljs-number">2</span><span class="hljs-string">/3)</span><br>  <span class="hljs-string">Warning</span>  <span class="hljs-string">FailedScheduling</span>  <span class="hljs-string">2s</span>    <span class="hljs-string">volcano-scheduler</span>    <span class="hljs-string">not</span> <span class="hljs-string">enough</span> <span class="hljs-string">cpu</span> <span class="hljs-string">for</span> <span class="hljs-number">1</span> <span class="hljs-string">pods</span> <span class="hljs-string">in</span> <span class="hljs-string">batch</span><br></code></pre></td></tr></table></figure><h3 id="为什么不是严格的一个一个调度？"><a href="#为什么不是严格的一个一个调度？" class="headerlink" title="为什么不是严格的一个一个调度？"></a>为什么不是严格的一个一个调度？</h3><ol><li><p><strong>性能优化</strong>：</p><ul><li>批量处理减少API Server压力</li><li>单次Session完成更多工作</li></ul></li><li><p><strong>资源利用率</strong>：</p><ul><li>批量考虑所有Pod可做更优放置决策</li><li>避免碎片化（如多个小Pod可填满节点）</li></ul></li><li><p><strong>原子性退化但不消失</strong>：</p><ul><li>对具有亲和性的Pod组仍需要批量处理<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">affinity:</span><br>  <span class="hljs-attr">podAffinity:</span><br>    <span class="hljs-attr">requiredDuringSchedulingIgnoredDuringExecution:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">labelSelector:</span><br>          <span class="hljs-attr">matchLabels:</span><br>            <span class="hljs-attr">app:</span> <span class="hljs-string">my-job</span><br>        <span class="hljs-attr">topologyKey:</span> <span class="hljs-string">kubernetes.io/hostname</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>在PodGroup进入Running状态后，Volcano采用了 <strong>“尽力而为的批量调度”</strong> 策略：  </p><ul><li>批量评估所有剩余Pod  </li><li>按顺序尝试分配  </li><li>批量绑定成功项<br>这既保留了批量调度的效率优势，又避免了初始调度的原子性约束。</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>volcano核心概念入门</title>
    <link href="/2025/07/26/volcano%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/"/>
    <url>/2025/07/26/volcano%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Volcano-核心概念入门学习讲义"><a href="#Volcano-核心概念入门学习讲义" class="headerlink" title="Volcano 核心概念入门学习讲义"></a>Volcano 核心概念入门学习讲义</h1><h2 id="一、Volcano-的定位与解决的问题（1小时）"><a href="#一、Volcano-的定位与解决的问题（1小时）" class="headerlink" title="一、Volcano 的定位与解决的问题（1小时）"></a>一、Volcano 的定位与解决的问题（1小时）</h2><h3 id="1-1-Kubernetes-原生调度器的局限"><a href="#1-1-Kubernetes-原生调度器的局限" class="headerlink" title="1.1 Kubernetes 原生调度器的局限"></a>1.1 Kubernetes 原生调度器的局限</h3><ul><li><strong>原子性调度缺失</strong>：无法保证批量作业的所有 Pod 同时启动</li><li><strong>资源碎片问题</strong>：无法全局优化资源分配，导致资源浪费</li><li><strong>作业级调度缺失</strong>：缺乏作业级别的优先级、公平调度和队列管理</li><li><strong>高级调度策略不足</strong>：缺乏拓扑调度、任务依赖等批处理场景特性</li></ul><h3 id="1-2-Volcano-的核心价值"><a href="#1-2-Volcano-的核心价值" class="headerlink" title="1.2 Volcano 的核心价值"></a>1.2 Volcano 的核心价值</h3><ul><li><strong>批处理场景优化</strong>：专为 AI&#x2F;大数据&#x2F;HPC 工作负载设计</li><li><strong>增强调度能力</strong>：<ul><li>Gang Scheduling（All-or-Nothing）</li><li>公平调度（DRF）</li><li>队列管理</li><li>任务依赖（DAG）</li><li>拓扑感知调度</li></ul></li><li><strong>Kubernetes 原生集成</strong>：通过 CRD 扩展 Kubernetes API</li></ul><h3 id="1-3-典型应用场景"><a href="#1-3-典型应用场景" class="headerlink" title="1.3 典型应用场景"></a>1.3 典型应用场景</h3><table><thead><tr><th>场景</th><th>问题</th><th>Volcano 解决方案</th></tr></thead><tbody><tr><td>TensorFlow 分布式训练</td><td>需要所有 Worker 同时启动</td><td>Gang Scheduling</td></tr><tr><td>Spark 批处理作业</td><td>资源碎片导致部分 Executor 无法启动</td><td>Binpack 资源装箱</td></tr><tr><td>多租户环境</td><td>团队间资源争抢</td><td>队列配额管理</td></tr><tr><td>MPI 高性能计算</td><td>跨节点网络拓扑要求</td><td>拓扑感知调度</td></tr><tr><td>Kubeflow 流水线</td><td>任务间依赖关系</td><td>DAG 工作流支持</td></tr></tbody></table><h2 id="二、Volcano-核心概念详解（2小时）"><a href="#二、Volcano-核心概念详解（2小时）" class="headerlink" title="二、Volcano 核心概念详解（2小时）"></a>二、Volcano 核心概念详解（2小时）</h2><h3 id="2-1-PodGroup：调度原子单位"><a href="#2-1-PodGroup：调度原子单位" class="headerlink" title="2.1 PodGroup：调度原子单位"></a>2.1 PodGroup：调度原子单位</h3><p><strong>概念</strong>：</p><ul><li>一组必须作为一个整体调度的 Pod 集合</li><li>实现 Gang Scheduling 的基础抽象</li></ul><p><strong>核心字段</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">scheduling.volcano.sh/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PodGroup</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tf-mnist-group</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">minMember:</span> <span class="hljs-number">4</span>  <span class="hljs-comment"># 最小就绪成员数</span><br>  <span class="hljs-attr">minResources:</span> <span class="hljs-comment"># 最小资源需求</span><br>    <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;8&quot;</span><br>    <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;32Gi&quot;</span><br>  <span class="hljs-attr">queue:</span> <span class="hljs-string">default</span> <span class="hljs-comment"># 所属队列</span><br>  <span class="hljs-attr">priorityClassName:</span> <span class="hljs-string">high-priority</span><br></code></pre></td></tr></table></figure><p><strong>关键特性</strong>：</p><ul><li><code>minMember</code>：确保指定数量的 Pod 同时就绪</li><li>状态机：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Pending</span> → Running（资源满足）→ Completed/Failed<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-VolcanoJob：扩展的作业定义"><a href="#2-2-VolcanoJob：扩展的作业定义" class="headerlink" title="2.2 VolcanoJob：扩展的作业定义"></a>2.2 VolcanoJob：扩展的作业定义</h3><p><strong>概念</strong>：</p><ul><li>扩展 Kubernetes 原生 Job</li><li>支持多任务模板（如 Master&#x2F;Worker 角色）</li></ul><p><strong>核心结构</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch.volcano.sh/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tf-mnist</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">minAvailable:</span> <span class="hljs-number">4</span>  <span class="hljs-comment"># 等效于 PodGroup.minMember</span><br>  <span class="hljs-attr">schedulerName:</span> <span class="hljs-string">volcano</span><br>  <span class="hljs-attr">queue:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ps</span>  <span class="hljs-comment"># 任务1：参数服务器</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">containers:</span> [ <span class="hljs-string">...</span> ]<br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">worker</span>  <span class="hljs-comment"># 任务2：计算节点</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">containers:</span> [ <span class="hljs-string">...</span> ]<br></code></pre></td></tr></table></figure><p><strong>任务类型</strong>：</p><ol><li><strong>主任务</strong>（如 Chief）：通常只有 1 个副本</li><li><strong>工作节点</strong>（Worker）：多个副本并行计算</li><li><strong>参数服务器</strong>（PS）：存储模型参数（可选）</li><li><strong>辅助任务</strong>：数据预处理、日志收集等</li></ol><h3 id="2-3-Queue：资源队列与多租户管理"><a href="#2-3-Queue：资源队列与多租户管理" class="headerlink" title="2.3 Queue：资源队列与多租户管理"></a>2.3 Queue：资源队列与多租户管理</h3><p><strong>概念</strong>：</p><ul><li>资源分配的逻辑容器</li><li>实现多租户资源隔离和优先级控制</li></ul><p><strong>核心配置</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">scheduling.volcano.sh/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Queue</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ai-team</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">weight:</span> <span class="hljs-number">10</span>  <span class="hljs-comment"># 队列权重（越高优先级越高）</span><br>  <span class="hljs-attr">capability:</span>  <span class="hljs-comment"># 资源上限</span><br>    <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;100&quot;</span><br>    <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;400Gi&quot;</span><br>    <span class="hljs-attr">nvidia.com/gpu:</span> <span class="hljs-number">16</span><br>  <span class="hljs-attr">reclaimable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 是否允许资源回收</span><br>  <span class="hljs-attr">state:</span> <span class="hljs-string">Open</span>  <span class="hljs-comment"># Open/Closed/Draining</span><br></code></pre></td></tr></table></figure><p><strong>队列特性</strong>：</p><ul><li><strong>权重分配</strong>：DRF（主导资源公平）算法分配资源</li><li><strong>资源回收</strong>：低优先级作业可被抢占</li><li><strong>状态管理</strong>：<ul><li>Open：接受新作业</li><li>Closed：停止接受新作业</li><li>Draining：排空现有作业</li></ul></li></ul><h3 id="2-4-核心概念关系"><a href="#2-4-核心概念关系" class="headerlink" title="2.4 核心概念关系"></a>2.4 核心概念关系</h3><p><strong>职责分离（Separation of Concerns）</strong></p><table><thead><tr><th align="left"><strong>对象</strong></th><th align="left"><strong>职责</strong></th><th align="left"><strong>Queue的操作目标</strong></th></tr></thead><tbody><tr><td align="left">Volcano Job</td><td align="left">描述业务逻辑（如Task&#x2F;Pod定义）</td><td align="left">不直接参与资源调度</td></tr><tr><td align="left">PodGroup</td><td align="left">抽象调度需求（如minAvailable）</td><td align="left">资源分配的计算单元</td></tr><tr><td align="left">Queue</td><td align="left">管理资源配额（如权重&#x2F;容量）</td><td align="left">以PodGroup为单位分配资源</td></tr></tbody></table><img src="/2025/07/26/volcano%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/deepseek_mermaid_20250812_8ad055.svg" alt="deepseek_mermaid_20250812_8ad055"><p><strong>关键路径</strong>：</p><ol><li>用户定义 Job 的 <code>minAvailable</code> 和 <code>queue</code> →</li><li>Volcano 自动创建同名的 PodGroup →</li><li>调度器基于 PodGroup 信息 + Queue 资源约束做原子调度 →</li><li>组内所有 Pod 统一绑定节点。</li></ol><p><strong>调度流程中的关联关系</strong></p><ul><li><p><strong>Queue的关联对象</strong>：</p><ul><li><strong>直接关联</strong>：PodGroup（通过<code>.spec.queue</code>字段绑定）</li><li><strong>间接关联</strong>：Volcano Job（通过PodGroup桥接）</li></ul></li><li><p><strong>关键结论</strong>：</p><blockquote><p>✅ <strong>Queue内部只感知PodGroup</strong>，不会直接处理Volcano Job对象。<br>❌ <strong>Volcano Job从不进入Queue</strong>，它只是PodGroup的创建者。</p></blockquote></li></ul><p><strong>为什么不直接调度job，而是使用一个新的CRD podgroup</strong></p><p>解耦调度单元与业务单元</p><ul><li><p><strong>Job 的局限性</strong>：</p><ul><li>本质是业务描述（如 Task 配置、镜像、命令），包含过多与<strong>调度无关</strong>的字段（如容器环境变量）。</li><li>若直接调度，调度器需过滤大量无关数据 → <strong>性能下降</strong>。</li></ul></li><li><p><strong>PodGroup 的优势</strong>：</p><ul><li><p><strong>轻量化调度上下文</strong>：仅保留调度关键字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">scheduling.volcano.sh/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">PodGroup</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">minMember:</span> <span class="hljs-number">3</span>    <span class="hljs-comment"># 最小调度单元数</span><br>  <span class="hljs-attr">priority:</span> <span class="hljs-number">10</span>     <span class="hljs-comment"># 优先级</span><br>  <span class="hljs-attr">queue:</span> <span class="hljs-string">default</span>   <span class="hljs-comment"># 所属队列</span><br></code></pre></td></tr></table></figure></li><li><p>调度器只需关注 PodGroup 而非整个 Job → <strong>决策效率提升</strong>。</p></li></ul></li></ul><h2 id="三、调度核心原理解析（1小时）"><a href="#三、调度核心原理解析（1小时）" class="headerlink" title="三、调度核心原理解析（1小时）"></a>三、调度核心原理解析（1小时）</h2><h3 id="3-1-Gang-Scheduling-工作流程"><a href="#3-1-Gang-Scheduling-工作流程" class="headerlink" title="3.1 Gang Scheduling 工作流程"></a>3.1 Gang Scheduling 工作流程</h3><ol><li><strong>作业提交</strong>：创建 VolcanoJob 和关联的 PodGroup</li><li><strong>资源检查</strong>：调度器验证集群是否满足 minAvailable 要求</li><li><strong>资源预留</strong>：锁定所需资源（防止被其他作业占用）</li><li><strong>原子绑定</strong>：同时绑定所有 Pod 到节点</li><li><strong>状态更新</strong>：<ul><li>成功：PodGroup 状态 → Running</li><li>失败：PodGroup 状态 → Pending（持续重试）</li></ul></li></ol><h3 id="3-2-调度关键决策点"><a href="#3-2-调度关键决策点" class="headerlink" title="3.2 调度关键决策点"></a>3.2 调度关键决策点</h3><ol><li><strong>队列选择</strong>：根据权重分配队列资源配额</li><li><strong>作业排序</strong>：基于优先级&#x2F;提交时间排序待调度作业</li><li><strong>节点过滤</strong>：排除不满足要求的节点</li><li><strong>任务优先级</strong>：同一作业内任务排序（如先调度 Chief）</li><li><strong>资源分配</strong>：使用 Binpack&#x2F;Spread 算法分配节点</li></ol><h3 id="3-3-调度器插件体系"><a href="#3-3-调度器插件体系" class="headerlink" title="3.3 调度器插件体系"></a>3.3 调度器插件体系</h3><p>Volcano 通过插件实现调度策略：</p><ul><li><strong>Enqueue</strong>：作业入队决策</li><li><strong>Allocate</strong>：资源分配决策</li><li><strong>Preempt</strong>：抢占策略</li><li><strong>Reclaim</strong>：资源回收</li><li><strong>Overcommit</strong>：超卖策略</li></ul><h2 id="四、实战练习（1小时）"><a href="#四、实战练习（1小时）" class="headerlink" title="四、实战练习（1小时）"></a>四、实战练习（1小时）</h2><h3 id="4-1-环境准备"><a href="#4-1-环境准备" class="headerlink" title="4.1 环境准备"></a>4.1 环境准备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建测试集群</span><br>kind create cluster --name volcano-lab<br><br><span class="hljs-comment"># 安装 Volcano</span><br>kubectl apply -f https://raw.githubusercontent.com/volcano-sh/volcano/master/installer/volcano-development.yaml<br></code></pre></td></tr></table></figure><h3 id="4-2-创建队列"><a href="#4-2-创建队列" class="headerlink" title="4.2 创建队列"></a>4.2 创建队列</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># queue.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">scheduling.volcano.sh/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Queue</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">weight:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">capability:</span><br>    <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;10&quot;</span><br>    <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;20Gi&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-提交-VolcanoJob"><a href="#4-3-提交-VolcanoJob" class="headerlink" title="4.3 提交 VolcanoJob"></a>4.3 提交 VolcanoJob</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># gang-demo.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch.volcano.sh/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">gang-demo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">minAvailable:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">schedulerName:</span> <span class="hljs-string">volcano</span><br>  <span class="hljs-attr">queue:</span> <span class="hljs-string">default</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">task</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">containers:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">busybox</span><br>              <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>              <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;sleep&quot;</span>, <span class="hljs-string">&quot;300&quot;</span>]<br>          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br></code></pre></td></tr></table></figure><h3 id="4-4-观察调度行为"><a href="#4-4-观察调度行为" class="headerlink" title="4.4 观察调度行为"></a>4.4 观察调度行为</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 观察 PodGroup 状态</span><br>kubectl get podgroups.scheduling.volcano.sh<br><br><span class="hljs-comment"># 查看调度器决策日志</span><br>kubectl logs -n volcano-system -l app=volcano-scheduler --<span class="hljs-built_in">tail</span>=50<br></code></pre></td></tr></table></figure><h3 id="4-5-实验练习"><a href="#4-5-实验练习" class="headerlink" title="4.5 实验练习"></a>4.5 实验练习</h3><ol><li>提交 minAvailable&#x3D;4 的作业（集群资源不足）</li><li>观察 PodGroup 状态变化</li><li>扩容集群后观察自动调度</li><li>创建高优先级作业测试抢占功能</li></ol><h2 id="五、概念对比表"><a href="#五、概念对比表" class="headerlink" title="五、概念对比表"></a>五、概念对比表</h2><table><thead><tr><th>概念</th><th>原生 Kubernetes</th><th>Volcano</th><th>解决的问题</th></tr></thead><tbody><tr><td>调度单元</td><td>Pod</td><td>PodGroup</td><td>原子性调度</td></tr><tr><td>作业定义</td><td>Job</td><td>VolcanoJob</td><td>多任务模板支持</td></tr><tr><td>资源队列</td><td>Namespace Quota</td><td>Queue</td><td>作业级优先级&#x2F;公平调度</td></tr><tr><td>调度策略</td><td>简单优先级</td><td>DRF&#x2F;Binpack&#x2F;拓扑调度</td><td>复杂资源分配</td></tr><tr><td>任务依赖</td><td>无</td><td>DAG 支持</td><td>工作流调度</td></tr></tbody></table><h2 id="六、学习检查点"><a href="#六、学习检查点" class="headerlink" title="六、学习检查点"></a>六、学习检查点</h2><ol><li>解释 PodGroup 如何解决 Gang Scheduling 问题</li><li>编写一个包含 Chief&#x2F;Worker 角色的 VolcanoJob</li><li>描述 DRF 算法的基本思想</li><li>解释队列权重如何影响资源分配</li><li>诊断 PodGroup 处于 Pending 状态的可能原因</li></ol><h2 id="七、扩展学习资源"><a href="#七、扩展学习资源" class="headerlink" title="七、扩展学习资源"></a>七、扩展学习资源</h2><ol><li><a href="https://volcano.sh/zh/docs/">Volcano 官方文档</a></li><li><a href="https://www.usenix.org/conference/atc19/presentation/yu">核心论文：Kubernetes Native Batch System</a></li><li><a href="https://github.com/volcano-sh/volcano/tree/master/example">GitHub 示例目录</a></li><li><a href="https://volcano.sh/zh/docs/configuration/">调度器配置参考</a></li></ol><blockquote><p><strong>学习提示</strong>：在阶段2的学习中，重点理解三个核心概念（PodGroup&#x2F;VolcanoJob&#x2F;Queue）的关系和作用。动手实践时，通过修改<code>minAvailable</code>值并观察系统行为，可直观体会Gang Scheduling的工作原理。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么需要分布式训练</title>
    <link href="/2025/07/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/"/>
    <url>/2025/07/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式训练的由来"><a href="#分布式训练的由来" class="headerlink" title="分布式训练的由来"></a>分布式训练的由来</h1><p>好的，我们来彻底解析一下 <strong>分布式训练的原理</strong>，并以 <strong>MNIST手写数字识别</strong> 为例，详细解释为什么需要那4个Pod（Chief, PS, Worker）。理解这个，你就能明白Volcano这类调度器的必要性了。</p><hr><h3 id="一、为什么需要分布式训练？"><a href="#一、为什么需要分布式训练？" class="headerlink" title="一、为什么需要分布式训练？"></a>一、为什么需要分布式训练？</h3><p>想象你要训练一个识别手写数字的模型（MNIST）：</p><ul><li><strong>单机训练：</strong> 你有一台强大的服务器，上面有8块GPU。你把所有训练数据（6万张图片）扔进去，模型在8块GPU上并行计算（数据并行），速度很快。</li><li><strong>现实限制：</strong><ul><li>模型越来越大（如GPT-3），参数达到千亿级别，单台机器装不下。</li><li>训练数据量爆炸（TB&#x2F;PB级），单机读取和处理太慢。</li><li>单台机器的GPU数量有上限（比如8块、16块），无法满足超大规模训练需求。</li></ul></li><li><strong>解决方案：分布式训练！</strong> 把计算任务（模型、数据）拆分到<strong>多台机器（多个Pod）</strong> 上协同工作，共同完成训练。</li></ul><hr><h3 id="二、分布式训练的核心原理：分而治之"><a href="#二、分布式训练的核心原理：分而治之" class="headerlink" title="二、分布式训练的核心原理：分而治之"></a>二、分布式训练的核心原理：分而治之</h3><p>核心思想是将<strong>模型参数（Parameters）</strong> 和<strong>训练数据（Training Data）</strong> 的存储与计算分散到多个节点上，并通过<strong>网络通信</strong>来协调它们。主要有两种主流架构：</p><h4 id="1-Parameter-Server-PS-架构-TensorFlow-早期常用"><a href="#1-Parameter-Server-PS-架构-TensorFlow-早期常用" class="headerlink" title="1. Parameter Server (PS) 架构 (TensorFlow 早期常用)"></a>1. Parameter Server (PS) 架构 (TensorFlow 早期常用)</h4>   <pre><code class=" mermaid">graph LR  Client[Chief/Client] --&gt;|协调| PS[Parameter Server]  PS --&gt;|分发参数/收集梯度| Worker1[Worker 1]  PS --&gt;|分发参数/收集梯度| Worker2[Worker 2]  PS --&gt;|...| WorkerN[Worker N]</code></pre><ul><li><strong>Parameter Server (PS):</strong><ul><li><strong>角色：</strong> 中央仓库。</li><li><strong>职责：</strong> 存储模型的<strong>所有参数（Weights, Biases）</strong>。</li><li><strong>工作流程：</strong><ol><li>接收来自Workers计算得到的<strong>梯度（Gradients）</strong>。</li><li>聚合所有Workers的梯度（通常是求平均）。</li><li>根据聚合后的梯度<strong>更新自己存储的模型参数</strong>。</li><li>将更新后的参数<strong>分发</strong>给所有Workers。</li></ol></li></ul></li><li><strong>Worker:</strong><ul><li><strong>角色：</strong> 计算工人。</li><li><strong>职责：</strong><ol><li>从PS获取<strong>当前最新的模型参数</strong>。</li><li>分配到自己的一小批<strong>训练数据（Batch）</strong>。</li><li>用数据和参数进行<strong>前向传播（Forward Pass）</strong> 计算预测值。</li><li>计算<strong>损失（Loss）</strong>。</li><li>进行<strong>反向传播（Backward Pass）</strong> 计算<strong>梯度（Gradients）</strong>。</li><li>将计算出的梯度<strong>发送</strong>给PS。</li></ol></li></ul></li><li><strong>Chief &#x2F; Master &#x2F; Client (有时与某个Worker合并):</strong><ul><li><strong>角色：</strong> 工头&#x2F;管理员。</li><li><strong>职责：</strong><ul><li>初始化模型参数（通常放在PS上）。</li><li>管理训练流程（开始、停止、设置epoch数等）。</li><li>协调Worker和PS的工作（非绝对必要，但常见）。</li><li>负责做<strong>评估（Evaluation）</strong>、保存<strong>检查点（Checkpoint）</strong>、写<strong>日志（Logging）</strong> 等管理任务。</li></ul></li></ul></li><li><strong>关键点：</strong><ul><li>PS 是瓶颈：所有梯度汇聚和参数更新都经过它，网络和计算压力大。</li><li>需要<strong>同步（Synchronous）</strong>：通常等所有Worker都完成一个Batch的计算并发送梯度给PS后，PS才进行更新和分发。这保证了所有Worker在同一时间点用的是<strong>相同版本的参数</strong>。</li><li><strong>“All-or-Nothing” 需求：</strong> 如果任何一个Worker或PS挂掉，整个训练过程就会卡住或出错，因为梯度聚合不完整或参数无法更新分发。这就是为什么需要Gang Scheduling保证它们同时启动。</li></ul></li></ul><h4 id="2-All-Reduce-架构-PyTorch-DDP-Horovod-TensorFlow-MirroredStrategy-常用"><a href="#2-All-Reduce-架构-PyTorch-DDP-Horovod-TensorFlow-MirroredStrategy-常用" class="headerlink" title="2. All-Reduce 架构 (PyTorch DDP, Horovod, TensorFlow MirroredStrategy 常用)"></a>2. All-Reduce 架构 (PyTorch DDP, Horovod, TensorFlow MirroredStrategy 常用)</h4>   <pre><code class=" mermaid">graph LR  Worker1[Worker 1] -- 梯度 --&gt; Ring  Worker2[Worker 2] -- 梯度 --&gt; Ring  Worker3[Worker 3] -- 梯度 --&gt; Ring  WorkerN[Worker N] -- 梯度 --&gt; Ring  Ring[通信环 All-Reduce]</code></pre><ul><li><strong>核心思想：</strong> 消除中心化的PS。<strong>每个Worker</strong>都存储<strong>一份完整的模型副本</strong>。</li><li><strong>工作流程：</strong><ol><li>每个Worker用自己的Batch数据独立进行<strong>前向传播</strong>和<strong>反向传播</strong>，计算出<strong>本地梯度</strong>。</li><li>所有Worker使用高效的<strong>All-Reduce</strong>通信原语（如Ring-AllReduce）进行通信。<ul><li><strong>目标：</strong> 让<strong>每个Worker</strong>都得到<strong>所有Worker梯度的平均值</strong>。</li></ul></li><li>每个Worker<strong>独立地用这个平均梯度更新自己本地的模型参数</strong>。</li></ol></li><li><strong>优势：</strong><ul><li>消除了PS瓶颈，通信负载更均衡地分散到所有Worker节点上。</li><li>通常比PS架构具有更好的扩展性和性能，尤其在高带宽网络环境下。</li></ul></li><li><strong>关键点：</strong><ul><li>仍然需要<strong>同步：</strong> All-Reduce操作需要所有Worker都参与才能完成。</li><li><strong>“All-or-Nothing” 需求依然存在：</strong> 如果一个Worker挂掉，All-Reduce操作就无法完成，整个训练就会卡住。</li><li><strong>Chief&#x2F;Master角色：</strong> 通常仍然需要一个节点（或指定一个Worker兼任）来负责全局协调（启动、监控、保存Checkpoint等）。</li></ul></li></ul><hr><h3 id="三、聚焦MNIST：为什么需要4个Pod？"><a href="#三、聚焦MNIST：为什么需要4个Pod？" class="headerlink" title="三、聚焦MNIST：为什么需要4个Pod？"></a>三、聚焦MNIST：为什么需要4个Pod？</h3><p>现在回到你看到的MNIST分布式TensorFlow训练例子（假设使用的是PS架构）：</p><ol><li><p><strong><code>1 x Chief Pod</code>：</strong></p><ul><li><strong>职责：</strong> 这是训练的总指挥。它负责：<ul><li>定义模型结构。</li><li>初始化全局参数（并告诉PS初始值是什么）。</li><li>启动训练任务。</li><li>监控训练进度（如计算全局Loss，虽然Loss计算通常也分布在Worker上）。</li><li>保存训练好的模型检查点（Checkpoint）。</li><li>负责最终的模型评估（如果需要）。</li></ul></li><li><strong>资源：</strong> 可能不需要GPU，或者只需要少量资源用于管理任务。</li></ul></li><li><p><strong><code>1 x Parameter Server (PS) Pod</code>：</strong></p><ul><li><strong>职责：</strong> 这是模型的中央仓库。它只做一件事：<ul><li>存储模型的所有参数（权重W和偏置b）。</li><li>接收来自Workers的梯度。</li><li>聚合梯度（求平均）。</li><li>用聚合后的梯度更新参数。</li><li>把更新后的参数发送给Workers。</li></ul></li><li><strong>资源：</strong> 对计算能力要求不高（主要是存储和网络IO），但需要足够内存存储模型参数。对于MNIST这种小模型，CPU足够；对于大模型，PS也可能需要高内存。</li></ul></li><li><p><strong><code>2 x Worker Pod</code>：</strong></p><ul><li><strong>职责：</strong> 这是干重活的计算单元。每个Worker：<ul><li>从PS获取最新的模型参数。</li><li>分配到自己的<strong>一部分MNIST训练数据</strong>（比如总6万张图，Worker1拿前3万张的一个Batch，Worker2拿后3万张的一个Batch）。</li><li>用自己的数据和参数进行<strong>前向传播</strong>（计算预测值）。</li><li>计算<strong>损失</strong>（预测值 vs 真实标签）。</li><li>进行<strong>反向传播</strong>（计算梯度：模型参数应该如何调整才能减少损失）。</li><li>将计算出的梯度发送给PS。</li></ul></li><li><strong>资源：</strong> 需要主要的计算资源（GPU）来进行前向和反向传播。MNIST模型小，1个Worker也能跑，但2个Worker演示了并行。实际大规模训练可能需要几十上百个Worker。</li></ul></li></ol><hr><h3 id="四、为什么这4个Pod必须“同生共死”（Gang-Scheduling）？"><a href="#四、为什么这4个Pod必须“同生共死”（Gang-Scheduling）？" class="headerlink" title="四、为什么这4个Pod必须“同生共死”（Gang Scheduling）？"></a>四、为什么这4个Pod必须“同生共死”（Gang Scheduling）？</h3><ol><li><p><strong>同步需求：</strong></p><ul><li><strong>PS架构：</strong> PS需要收集<strong>所有Worker</strong>的梯度才能进行参数更新。如果Worker2没启动，Worker1的梯度发到PS，PS会一直等待Worker2的梯度（或者超时失败）。训练无法进行。</li><li><strong>All-Reduce架构：</strong> All-Reduce操作需要<strong>所有Worker</strong>参与通信。少一个Worker，通信环就断了，操作无法完成。训练卡死。</li><li><strong>Chief的协调：</strong> Chief需要知道所有Worker和PS的状态来管理整个训练生命周期。如果部分节点缺失，Chief无法正确启动或监控训练。</li></ul></li><li><p><strong>资源死锁：</strong></p><ul><li>假设集群资源紧张。如果允许部分启动：<ul><li>Chief和PS先启动了。</li><li>Worker1启动了，占用了最后一块空闲GPU。</li><li>Worker2因为没GPU卡在Pending。</li></ul></li><li>结果：Chief、PS、Worker1在运行，但它们<strong>什么有用的训练都做不了</strong>（因为Worker2缺失导致同步失败）。它们占着资源（尤其是Worker1的GPU）却无法完成工作。Worker2在等GPU，GPU被一个无法工作的Worker1占着。这就是<strong>资源死锁</strong>。</li></ul></li><li><p><strong>浪费资源：</strong></p><ul><li>如上所述，部分启动的Pod消耗着CPU、内存、GPU、网络带宽，却无法推进训练任务，纯粹是浪费钱（云环境）或计算资源。</li></ul></li><li><p><strong>框架逻辑：</strong></p><ul><li>TensorFlow&#x2F;PyTorch等分布式训练框架的设计逻辑就是基于所有节点都可用。它们内部的通信库（如gRPC, NCCL）会尝试连接配置中的所有节点。节点缺失会导致连接失败、超时、异常，最终导致训练作业失败。</li></ul></li></ol><hr><h3 id="五、总结：分布式训练与Volcano的完美契合"><a href="#五、总结：分布式训练与Volcano的完美契合" class="headerlink" title="五、总结：分布式训练与Volcano的完美契合"></a>五、总结：分布式训练与Volcano的完美契合</h3><ul><li><strong>分布式训练的本质</strong> 是将大型模型&#x2F;数据的计算任务拆分到多个节点协同完成，核心是<strong>同步</strong>（参数&#x2F;梯度一致性）。</li><li><strong>PS或All-Reduce架构</strong> 是实现同步的不同方式，但都<strong>强依赖所有计算节点（Worker）同时在线工作</strong>。管理节点（Chief）和存储节点（PS，如果存在）也至关重要。</li><li><strong>MNIST的4个Pod示例</strong> 清晰地展示了分布式训练中角色的划分（Chief管理， PS存储， Worker计算）和最小的并行规模（2 Workers）。</li><li><strong>“All-or-Nothing”需求</strong> 是分布式训练内在特性导致的：部分成功等于整体失败，还会导致资源死锁和浪费。</li><li><strong>Volcano的价值</strong> 正是通过<code>PodGroup</code>和<code>minAvailable</code>等机制，实现<strong>Gang Scheduling</strong>，确保分布式训练作业所需的所有Pod作为一个整体，要么全部成功调度并启动，要么都不启动。这完美解决了原生Kubernetes调度器在批量调度和原子性保障上的缺陷，为AI&#x2F;大数据等分布式工作负载提供了可靠高效的调度基础。</li></ul><p><strong>理解了这个原理，你再回头看Volcano的调度策略（如预留资源、一次性绑定、优先级&#x2F;抢占为完整作业服务等），就会豁然开朗：它的每一个核心设计几乎都是为了解决分布式训练（以及类似批处理作业）的这些独特挑战而生的。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么需要批量调度</title>
    <link href="/2025/07/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%89%B9%E9%87%8F%E8%B0%83%E5%BA%A6/"/>
    <url>/2025/07/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%89%B9%E9%87%8F%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么需要批量调度？以-MNIST-手写体数字识别项目为例"><a href="#为什么需要批量调度？以-MNIST-手写体数字识别项目为例" class="headerlink" title="为什么需要批量调度？以 MNIST 手写体数字识别项目为例"></a>为什么需要批量调度？以 MNIST 手写体数字识别项目为例</h3><p>让我们以经典的 <strong>MNIST 手写体数字识别项目</strong>（使用 TensorFlow 分布式训练）为例，说明为什么需要专门的批量调度器。这是一个典型的机器学习训练场景，能清晰展示原生 Kubernetes 调度器的局限。</p><hr><h3 id="场景描述：分布式-TensorFlow-MNIST-训练"><a href="#场景描述：分布式-TensorFlow-MNIST-训练" class="headerlink" title="场景描述：分布式 TensorFlow MNIST 训练"></a>场景描述：分布式 TensorFlow MNIST 训练</h3><p>假设我们需要训练一个识别手写数字的模型：</p><ul><li><strong>任务组成</strong>：<ul><li>1个 <strong>Chief 节点</strong>（负责协调训练）</li><li>1个 <strong>Parameter Server</strong>（存储模型参数）</li><li>2个 <strong>Worker 节点</strong>（执行计算任务）</li></ul></li><li><strong>资源需求</strong>：每个 Pod 需要 1 块 GPU</li><li><strong>关键要求</strong>：<strong>所有 4 个 Pod 必须同时启动</strong>，任何一个失败都会导致整个训练失败</li></ul><pre><code class=" mermaid">graph LR    Chief[Chief节点] --&gt;|协调| PS[Parameter Server]    PS --&gt;|参数同步| Worker1[Worker 1]    PS --&gt;|参数同步| Worker2[Worker 2]</code></pre><hr><h3 id="原生-Kubernetes-调度器的问题"><a href="#原生-Kubernetes-调度器的问题" class="headerlink" title="原生 Kubernetes 调度器的问题"></a>原生 Kubernetes 调度器的问题</h3><h4 id="场景-1：资源不足时的部分启动（最危险的情况）"><a href="#场景-1：资源不足时的部分启动（最危险的情况）" class="headerlink" title="场景 1：资源不足时的部分启动（最危险的情况）"></a>场景 1：资源不足时的部分启动（最危险的情况）</h4><p>假设集群有 3 个 GPU 节点，但每个节点<strong>只剩 1 块空闲 GPU</strong>：</p><ol><li>提交包含 4 个 Pod 的 Job</li><li>原生调度器行为：<ul><li>Pod1 (Chief) → 调度到 Node1 ✅</li><li>Pod2 (PS) → 调度到 Node2 ✅</li><li>Pod3 (Worker1) → 调度到 Node3 ✅</li><li>Pod4 (Worker2) → <strong>无可用资源，卡在 Pending</strong> ❌</li></ul></li></ol><p><strong>灾难性后果</strong>：</p><ul><li>已启动的 3 个 Pod 会不断尝试连接缺失的 Worker2</li><li>5-10 分钟后超时失败（TensorFlow 的 gRPC 连接超时）</li><li><strong>浪费了 3 块 GPU 的计算资源</strong>（按 $0.5&#x2F;GPU小时 计，损失约 $0.025）</li></ul><blockquote><p>💡 <strong>这就是 Gang Scheduling 要解决的 “All-or-Nothing” 问题</strong></p></blockquote><h4 id="场景-2：资源碎片导致的死锁"><a href="#场景-2：资源碎片导致的死锁" class="headerlink" title="场景 2：资源碎片导致的死锁"></a>场景 2：资源碎片导致的死锁</h4><p>假设集群有 4 个节点：</p><ul><li>Node1：剩 2 块 GPU</li><li>Node2：剩 1 块 GPU</li><li>Node3：剩 1 块 GPU</li><li>Node4：剩 0 块 GPU</li></ul><p>同时提交两个 MNIST 作业：</p><ul><li><strong>JobA</strong>：需要 2 个 Worker（共需 3 GPU：Chief+PS+2Worker）</li><li><strong>JobB</strong>：同样需要 3 GPU</li></ul><p>原生调度器可能的调度顺序：</p><ol><li>JobA-Chief → Node1（占用 1 GPU）</li><li>JobB-Chief → Node2（占用 1 GPU）</li><li>JobA-PS → Node3（占用 1 GPU）</li><li>JobB-PS → <strong>无节点满足（需 1 GPU，但 Node1 只剩 1 GPU 不满足 PS+Worker 的同节点要求）</strong> ❌</li><li>JobA-Worker1 → Node1（占用最后 1 GPU）</li><li>JobA-Worker2 → <strong>无资源</strong> ❌</li></ol><p><strong>结果</strong>：</p><ul><li>JobA：缺少 1 Worker</li><li>JobB：缺少 PS 和 Worker</li><li><strong>两个作业都部分运行但无法完成 → 资源死锁</strong></li></ul><hr><h3 id="Volcano-如何解决这些问题"><a href="#Volcano-如何解决这些问题" class="headerlink" title="Volcano 如何解决这些问题"></a>Volcano 如何解决这些问题</h3><h4 id="解决方案-1：Gang-Scheduling（原子性调度）"><a href="#解决方案-1：Gang-Scheduling（原子性调度）" class="headerlink" title="解决方案 1：Gang Scheduling（原子性调度）"></a>解决方案 1：Gang Scheduling（原子性调度）</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Volcano 的 Job 定义</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch.volcano.sh/v1alpha1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">minAvailable:</span> <span class="hljs-number">4</span>  <span class="hljs-comment"># 关键参数！</span><br>  <span class="hljs-attr">tasks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">chief</span>  <span class="hljs-comment"># Chief 节点</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">template:</span> &#123; <span class="hljs-string">...</span> &#125;<br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ps</span>     <span class="hljs-comment"># Parameter Server</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">template:</span> &#123; <span class="hljs-string">...</span> &#125;<br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">worker</span> <span class="hljs-comment"># Workers</span><br>      <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>      <span class="hljs-attr">template:</span> &#123; <span class="hljs-string">...</span> &#125;<br></code></pre></td></tr></table></figure><p><strong>调度过程</strong>：</p><ol><li>调度器检查集群是否有 <strong>4 块可用 GPU</strong></li><li>如果不足 → <strong>整个作业不启动</strong>（避免部分启动）</li><li>如果充足 → <strong>一次性绑定所有 4 个 Pod</strong></li></ol><h4 id="解决方案-2：资源预留-智能分配"><a href="#解决方案-2：资源预留-智能分配" class="headerlink" title="解决方案 2：资源预留 + 智能分配"></a>解决方案 2：资源预留 + 智能分配</h4><p>当多个作业竞争时：</p><ol><li>Volcano 检测到 JobA 和 JobB 都需要 3 GPU</li><li><strong>根据队列优先级</strong>（如 JobA 优先级更高）：<ul><li>为 JobA <strong>预留</strong> Node1(2GPU) + Node3(1GPU)</li><li>一次性启动 JobA 所有 Pod</li></ul></li><li>JobB 等待资源释放</li><li>避免资源碎片死锁</li></ol><hr><h3 id="批量调度的核心价值"><a href="#批量调度的核心价值" class="headerlink" title="批量调度的核心价值"></a>批量调度的核心价值</h3><ol><li><p><strong>避免资源浪费</strong>  </p><ul><li>部分启动的 GPU 作业消耗电力但不产生价值</li><li>按云厂商计费标准：1 块 V100 GPU ≈ $0.5&#x2F;小时<br>→ 部分启动 1 小时 &#x3D; 浪费 $1.5</li></ul></li><li><p><strong>防止分布式系统死锁</strong>  </p><ul><li>TensorFlow&#x2F;PyTorch&#x2F;Spark 等框架要求所有节点同时就绪</li><li>缺失节点会导致整个作业阻塞（而非降级运行）</li></ul></li><li><p><strong>提高集群利用率</strong>  </p><ul><li>通过 Binpack 算法将 Pod 紧密分配到少数节点</li><li>减少资源碎片（如案例中的 “1 GPU 碎片”）</li></ul></li><li><p><strong>支持复杂依赖关系</strong>  </p><pre><code class=" mermaid">graph TD  A[数据预处理] --&gt; B[模型训练]  B --&gt; C[模型验证]  C --&gt; D[模型导出]</code></pre><ul><li>Volcano 支持 DAG 工作流调度，确保任务按顺序执行</li></ul></li></ol><hr><h3 id="MNIST-场景中的进阶需求"><a href="#MNIST-场景中的进阶需求" class="headerlink" title="MNIST 场景中的进阶需求"></a>MNIST 场景中的进阶需求</h3><ol><li><p><strong>GPU 拓扑感知调度</strong>  </p><ul><li>当 Worker 需要多 GPU 时：确保 GPU 通过 NVLink 互联</li><li>Volcano 支持根据节点标签调度：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">topologyPolicy:</span> <span class="hljs-string">BestEffort</span><br><span class="hljs-attr">policies:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">device:</span> <span class="hljs-string">GPU</span><br>    <span class="hljs-attr">gpuPolicy:</span> <span class="hljs-string">dgx-2</span>  <span class="hljs-comment"># 识别DGX服务器的NVLink拓扑</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>弹性资源分配</strong>  </p><ul><li>训练中途动态扩展 Worker 数量</li><li>Volcano 支持作业运行时调整 <code>replicas</code></li></ul></li><li><p><strong>队列优先级</strong>  </p><ul><li>生产环境训练任务优先于研发测试任务</li><li>Volcano 的多级队列确保高优先级作业优先获取资源</li></ul></li></ol><hr><h3 id="关键结论：为什么批量调度不可或缺"><a href="#关键结论：为什么批量调度不可或缺" class="headerlink" title="关键结论：为什么批量调度不可或缺"></a>关键结论：为什么批量调度不可或缺</h3><blockquote><p><strong>“在分布式训练中，部分成功就是整体失败”</strong></p></blockquote><p>MNIST 示例揭示了：</p><ul><li>机器学习训练是 <strong>协同作战</strong>，不是单兵作战</li><li>原生调度器的 <strong>“近视眼”决策</strong>（只看单个 Pod）不适合批处理场景</li><li>Volcano 的 <strong>会话式调度</strong>（全局视图）是解决这一问题的本质创新</li></ul><p><strong>学习建议</strong>：理解 Volcano 时，始终问自己：”这个特性如何防止 MNIST 训练中的部分启动问题？” 这将帮助你抓住设计精髓。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在go中比较两个struct</title>
    <link href="/2025/07/25/%E5%9C%A8go%E4%B8%AD%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAstruct/"/>
    <url>/2025/07/25/%E5%9C%A8go%E4%B8%AD%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAstruct/</url>
    
    <content type="html"><![CDATA[<h1 id="在Go中比较两个Struct"><a href="#在Go中比较两个Struct" class="headerlink" title="在Go中比较两个Struct"></a>在Go中比较两个Struct</h1><p>在Go语言中，两个struct是否可以用<code>==</code>操作符进行比较取决于struct的组成。</p><h2 id="可比较的情况"><a href="#可比较的情况" class="headerlink" title="可比较的情况"></a>可比较的情况</h2><p>当struct满足以下条件时，可以直接用<code>==</code>比较：</p><ol><li><p><strong>所有字段都是可比较的类型</strong>：</p><ul><li>基本类型（int, float, string等）</li><li>指针</li><li>数组（元素类型可比较）</li><li>其他可比较的struct</li><li>channel</li></ul></li><li><p><strong>不包含不可比较的字段</strong>：</p><ul><li>slice</li><li>map</li><li>function</li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-type">string</span><br>    Age  <span class="hljs-type">int</span><br>&#125;<br><br>p1 := Person&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>&#125;<br>p2 := Person&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>&#125;<br>fmt.Println(p1 == p2) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="不可比较的情况"><a href="#不可比较的情况" class="headerlink" title="不可比较的情况"></a>不可比较的情况</h2><p>如果struct包含不可比较的字段（如slice、map或function），则不能用<code>==</code>比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Data <span class="hljs-keyword">struct</span> &#123;<br>    Values []<span class="hljs-type">int</span><br>&#125;<br><br>d1 := Data&#123;[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;<br>d2 := Data&#123;[]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;&#125;<br><span class="hljs-comment">// fmt.Println(d1 == d2) // 编译错误：invalid operation</span><br></code></pre></td></tr></table></figure><h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>对于不可比较的struct，可以使用：</p><ol><li><p><code>reflect.DeepEqual()</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(reflect.DeepEqual(d1, d2)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>自定义比较函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Data)</span></span> Equal(other Data) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(d.Values) != <span class="hljs-built_in">len</span>(other.Values) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> d.Values &#123;<br>        <span class="hljs-keyword">if</span> v != other.Values[i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="指针比较"><a href="#指针比较" class="headerlink" title="指针比较"></a>指针比较</h2><p>比较struct指针时，比较的是指针值（内存地址）而不是内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p3 := &amp;Person&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>&#125;<br>p4 := &amp;Person&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">25</span>&#125;<br>fmt.Println(p3 == p4) <span class="hljs-comment">// false，因为指向不同内存地址</span><br></code></pre></td></tr></table></figure><p>总结：只有当struct的所有字段都是可比较类型时，才能直接用<code>==</code>比较两个struct。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s网络隔离策略</title>
    <link href="/2025/07/25/k8s%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB%E7%AD%96%E7%95%A5/"/>
    <url>/2025/07/25/k8s%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s网络隔离策略"><a href="#k8s网络隔离策略" class="headerlink" title="k8s网络隔离策略"></a>k8s网络隔离策略</h1><p>在 Kubernetes 中，默认情况下，<strong>所有命名空间（Namespace）中的 Pod 可以通过网络直接互通</strong>，除非配置了 <strong>NetworkPolicy</strong> 显式限制流量。如果您的集群已经启用了网络插件（如 Calico、Cilium 等），并且需要 <strong>明确允许 <code>ns-a</code> 和 <code>ns-b</code> 互通</strong>，可以按以下步骤操作：</p><hr><h3 id="方法-1：允许特定命名空间之间的流量"><a href="#方法-1：允许特定命名空间之间的流量" class="headerlink" title="方法 1：允许特定命名空间之间的流量"></a><strong>方法 1：允许特定命名空间之间的流量</strong></h3><h4 id="1-创建-NetworkPolicy（允许-ns-a-访问-ns-b）"><a href="#1-创建-NetworkPolicy（允许-ns-a-访问-ns-b）" class="headerlink" title="1. 创建 NetworkPolicy（允许 ns-a 访问 ns-b）"></a><strong>1. 创建 NetworkPolicy（允许 <code>ns-a</code> 访问 <code>ns-b</code>）</strong></h4><p>以下策略允许 <code>ns-a</code> 中的 Pod 访问 <code>ns-b</code> 中的 Pod：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># allow-ns-a-to-ns-b.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">allow-ns-a-to-ns-b</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ns-b</span>  <span class="hljs-comment"># 作用在 ns-b 上，控制入站流量</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span> &#123;&#125;  <span class="hljs-comment"># 匹配 ns-b 中的所有 Pod</span><br>  <span class="hljs-attr">policyTypes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ingress</span><br>  <span class="hljs-attr">ingress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">kubernetes.io/metadata.name:</span> <span class="hljs-string">ns-a</span>  <span class="hljs-comment"># 允许来自 ns-a 的流量</span><br></code></pre></td></tr></table></figure><h4 id="2-创建反向策略（允许-ns-b-访问-ns-a）"><a href="#2-创建反向策略（允许-ns-b-访问-ns-a）" class="headerlink" title="2. 创建反向策略（允许 ns-b 访问 ns-a）"></a><strong>2. 创建反向策略（允许 <code>ns-b</code> 访问 <code>ns-a</code>）</strong></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># allow-ns-b-to-ns-a.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">allow-ns-b-to-ns-a</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ns-a</span>  <span class="hljs-comment"># 作用在 ns-a 上</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span> &#123;&#125;  <span class="hljs-comment"># 匹配 ns-a 中的所有 Pod</span><br>  <span class="hljs-attr">policyTypes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ingress</span><br>  <span class="hljs-attr">ingress:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>        <span class="hljs-attr">matchLabels:</span><br>          <span class="hljs-attr">kubernetes.io/metadata.name:</span> <span class="hljs-string">ns-b</span>  <span class="hljs-comment"># 允许来自 ns-b 的流量</span><br></code></pre></td></tr></table></figure><h4 id="3-应用策略"><a href="#3-应用策略" class="headerlink" title="3. 应用策略"></a><strong>3. 应用策略</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f allow-ns-a-to-ns-b.yaml<br>kubectl apply -f allow-ns-b-to-ns-a.yaml<br></code></pre></td></tr></table></figure><hr><h3 id="方法-2：更精细的-Pod-选择器"><a href="#方法-2：更精细的-Pod-选择器" class="headerlink" title="方法 2：更精细的 Pod 选择器"></a><strong>方法 2：更精细的 Pod 选择器</strong></h3><p>如果只需要允许特定 Pod 互通（而非整个命名空间），可以通过 <code>podSelector</code> 进一步限制：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ingress:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">namespaceSelector:</span><br>      <span class="hljs-attr">matchLabels:</span><br>        <span class="hljs-attr">kubernetes.io/metadata.name:</span> <span class="hljs-string">ns-a</span><br>    <span class="hljs-attr">podSelector:</span><br>      <span class="hljs-attr">matchLabels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">backend</span>  <span class="hljs-comment"># 仅允许 ns-a 中带有 `app=backend` 标签的 Pod</span><br></code></pre></td></tr></table></figure><hr><h3 id="验证互通性"><a href="#验证互通性" class="headerlink" title="验证互通性"></a><strong>验证互通性</strong></h3><ol><li>在 <code>ns-a</code> 和 <code>ns-b</code> 中分别启动一个测试 Pod：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl run test-pod -n ns-a --image=alpine -- <span class="hljs-built_in">sleep</span> 3600<br>kubectl run test-pod -n ns-b --image=alpine -- <span class="hljs-built_in">sleep</span> 3600<br></code></pre></td></tr></table></figure></li><li>测试网络连通性：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl <span class="hljs-built_in">exec</span> -n ns-a test-pod -- ping &lt;ns-b-test-pod-IP&gt;<br>kubectl <span class="hljs-built_in">exec</span> -n ns-b test-pod -- ping &lt;ns-a-test-pod-IP&gt;<br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a><strong>关键注意事项</strong></h3><ol><li><strong>网络插件支持</strong>：确保集群已安装支持 <code>NetworkPolicy</code> 的 CNI 插件（如 Calico、Cilium、WeaveNet）。</li><li><strong>默认拒绝策略</strong>：如果集群配置了默认拒绝所有流量的策略（如 <code>default-deny</code>），则必须显式允许 <code>ns-a</code> 和 <code>ns-b</code> 的互通。</li><li><strong>标签匹配</strong>：Kubernetes 自动为命名空间添加 <code>kubernetes.io/metadata.name</code> 标签，可直接用于 <code>namespaceSelector</code>。</li></ol><hr><h3 id="补充：完全隔离其他命名空间"><a href="#补充：完全隔离其他命名空间" class="headerlink" title="补充：完全隔离其他命名空间"></a><strong>补充：完全隔离其他命名空间</strong></h3><p>如果希望 <strong>仅允许 <code>ns-a</code> 和 <code>ns-b</code> 互通，并拒绝其他命名空间</strong>，可以在两个命名空间中添加以下策略：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># default-deny.yaml（分别在 ns-a 和 ns-b 中创建）</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">NetworkPolicy</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">default-deny</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">ns-a</span>  <span class="hljs-comment"># 或 ns-b</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">podSelector:</span> &#123;&#125;<br>  <span class="hljs-attr">policyTypes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ingress</span><br>  <span class="hljs-attr">ingress:</span> []  <span class="hljs-comment"># 显式拒绝所有入站流量（后续再通过允许策略放行）</span><br></code></pre></td></tr></table></figure><p>然后通过前面的策略允许 <code>ns-a</code> 和 <code>ns-b</code> 之间的流量。</p><hr><p>通过以上配置，您可以灵活控制命名空间之间的网络互通性。根据实际需求选择是否细化到 Pod 标签或端口级别。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>list-watch在网络中断后的恢复机制</title>
    <link href="/2025/07/25/list-watch%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/07/25/list-watch%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="list-watch在网络中断后的恢复机制"><a href="#list-watch在网络中断后的恢复机制" class="headerlink" title="list-watch在网络中断后的恢复机制"></a>list-watch在网络中断后的恢复机制</h1><p>在 Kubernetes 中，<code>List-Watch</code> 机制是客户端（如 kube-apiserver 的客户端）监听资源变化的核心机制。当网络中断后重新连接时，<code>List-Watch</code> 会通过以下方式恢复状态，确保不丢失事件并保持数据一致性：</p><hr><h3 id="1-初始阶段：全量-List"><a href="#1-初始阶段：全量-List" class="headerlink" title="1. 初始阶段：全量 List"></a>1. <strong>初始阶段：全量 List</strong></h3><ul><li>客户端首次启动或需要全量同步时，会先调用 <code>List</code> 获取资源的当前全量状态（所有对象的最新版本），并缓存在本地。</li><li>此时会记录资源的 <code>ResourceVersion</code>（一个全局递增的版本号，表示 etcd 中资源的当前版本）。</li></ul><hr><h3 id="2-监听阶段：增量-Watch"><a href="#2-监听阶段：增量-Watch" class="headerlink" title="2. 监听阶段：增量 Watch"></a>2. <strong>监听阶段：增量 Watch</strong></h3><ul><li>客户端基于 <code>List</code> 返回的 <code>ResourceVersion</code> 发起 <code>Watch</code> 请求，监听该资源从此版本之后的所有变更（<code>ADDED</code>&#x2F;<code>MODIFIED</code>&#x2F;<code>DELETED</code> 事件）。</li><li><code>Watch</code> 是一个长连接，apiserver 会持续推送事件。</li></ul><hr><h3 id="3-网络中断后的恢复机制"><a href="#3-网络中断后的恢复机制" class="headerlink" title="3. 网络中断后的恢复机制"></a>3. <strong>网络中断后的恢复机制</strong></h3><p>当网络中断导致 <code>Watch</code> 连接断开时，客户端会按以下步骤恢复：</p><h4 id="（1）自动重连"><a href="#（1）自动重连" class="headerlink" title="（1）自动重连"></a>（1）<strong>自动重连</strong></h4><ul><li>客户端库（如 client-go）会自动尝试重新建立与 apiserver 的连接。</li></ul><h4 id="（2）基于最新-ResourceVersion-重新-Watch"><a href="#（2）基于最新-ResourceVersion-重新-Watch" class="headerlink" title="（2）基于最新 ResourceVersion 重新 Watch"></a>（2）<strong>基于最新 ResourceVersion 重新 Watch</strong></h4><ul><li>客户端会使用**最后一次收到的事件的 <code>ResourceVersion</code>**（本地缓存中最新的版本号）发起新的 <code>Watch</code> 请求。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">watchOpts := metav1.ListOptions&#123;<br>    ResourceVersion: lastObservedRV, <span class="hljs-comment">// 上次记录的版本号</span><br>&#125;<br>watcher, err := client.Watch(ctx, watchOpts)<br></code></pre></td></tr></table></figure></li><li>这样 apiserver 会返回从该 <code>ResourceVersion</code> 之后的所有变更事件，确保不丢失任何事件。</li></ul><h4 id="（3）处理历史事件压缩（Compact）"><a href="#（3）处理历史事件压缩（Compact）" class="headerlink" title="（3）处理历史事件压缩（Compact）"></a>（3）<strong>处理历史事件压缩（Compact）</strong></h4><ul><li>如果网络中断时间过长，apiserver 可能已清理（compact）过老的 <code>ResourceVersion</code>（etcd 的默认历史窗口为 5 分钟）。</li><li>此时重新 <code>Watch</code> 会返回 <code>410 Gone</code> 错误，表示请求的 <code>ResourceVersion</code> 已不可用。</li><li>客户端需要<strong>重新全量 <code>List</code></strong> 并更新本地缓存，然后基于新的 <code>ResourceVersion</code> 启动 <code>Watch</code>。</li></ul><h4 id="（4）幂等处理"><a href="#（4）幂等处理" class="headerlink" title="（4）幂等处理"></a>（4）<strong>幂等处理</strong></h4><ul><li>客户端需要处理重复事件（如因重连导致的事件重复推送），通常通过比较 <code>ResourceVersion</code> 去重。</li></ul><hr><h3 id="4-关键设计保障"><a href="#4-关键设计保障" class="headerlink" title="4. 关键设计保障"></a>4. <strong>关键设计保障</strong></h3><ul><li><strong>ResourceVersion 的全局有序性</strong>：所有资源的变更均按 <code>ResourceVersion</code> 严格排序，确保客户端可以精确断点续传。</li><li><strong>事件持久化</strong>：apiserver 从 etcd 读取事件并缓存，即使客户端断开连接，事件也不会丢失。</li><li><strong>错误处理标准化</strong>：通过 <code>410 Gone</code> 明确通知客户端需要全量同步。</li></ul><hr><h3 id="5-客户端实现（以-client-go-为例"><a href="#5-客户端实现（以-client-go-为例" class="headerlink" title="5. 客户端实现（以 client-go 为例"></a>5. <strong>客户端实现（以 client-go 为例</strong></h3><ul><li><strong>Informer 机制</strong> 封装了 <code>List-Watch</code> 的容错逻辑：<ol><li>首次启动时全量 <code>List</code>。</li><li><code>Watch</code> 断开后自动用最新 <code>ResourceVersion</code> 重连。</li><li>收到 <code>410</code> 错误时触发 <code>List</code> 全量同步。</li><li>通过 <code>Delta FIFO</code> 队列处理事件，确保顺序和去重。</li></ol></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>网络中断恢复的核心是通过 <code>ResourceVersion</code> 实现的断点续传：  </p><ol><li>短期中断：基于缓存的 <code>ResourceVersion</code> 重新 <code>Watch</code>，获取中断期间的事件。  </li><li>长期中断：触发全量 <code>List</code> 后重新 <code>Watch</code>。<br>这种机制保证了最终一致性和可靠性，是 Kubernetes 声明式 API 的基础。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-全</title>
    <link href="/2025/07/25/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%85%A8/"/>
    <url>/2025/07/25/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Go算法题-一"><a href="#Go算法题-一" class="headerlink" title="Go算法题-一"></a>Go算法题-一</h1><p>按出现频率大小递减排序（参考<a href="https://codetop.cc/home%EF%BC%89%EF%BC%9A">https://codetop.cc/home）：</a></p><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>(1) leetcode 3. 给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>解答：</strong></p><p> 方法点：</p><ol><li>使用map记录字符，用来判断是否重复</li><li>如果当前字符与前面某字符重复，可以直接跳到重复字符后面，继续比较</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// //外层循环扩展右边界，内层循环扩展左边界</span><br><span class="hljs-comment">// for (int l = 0, r = 0 ; r &lt; n ; r++) &#123;</span><br><span class="hljs-comment">// //当前考虑的元素</span><br><span class="hljs-comment">// while (l &lt;= r &amp;&amp; check()) &#123;//区间[left,right]不符合题意</span><br><span class="hljs-comment">//         //扩展左边界</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//     //区间[left,right]符合题意，统计相关信息</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    l := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> r:=<span class="hljs-number">0</span>, r&lt;n; r++ &#123;<br>        <span class="hljs-comment">// 如果重复，一直跳到重复元素的下一位</span><br>        <span class="hljs-keyword">for</span> m[s[r]] != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">delete</span>(m, s[l])<br>            l++<br>        &#125;<br>        m[s[r]] = <span class="hljs-number">1</span><br>        res = max(res, r-l+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）</p><h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><p>leetcode 146. 请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><p><strong>解答：</strong></p><ol><li>使用map来保存cache数据</li><li>使用双向链表来保存访问频率，最近访问的放在链表头部。（双向链表方便尾部删除节点）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    size <span class="hljs-type">int</span><br>    capacity <span class="hljs-type">int</span><br>    cache <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkedNode<br>    head *DLinkedNode<br>    tail *DLinkedNode<br>&#125;<br><br><span class="hljs-keyword">type</span> DLinkedNode <span class="hljs-keyword">struct</span> &#123;<br>    key <span class="hljs-type">int</span><br>    value <span class="hljs-type">int</span><br>    prev *DLinkedNode<br>    next *DLinkedNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initDLinkedNode</span><span class="hljs-params">(key, value <span class="hljs-type">int</span>)</span></span> *DLinkedNode &#123;<br>    <span class="hljs-keyword">return</span> &amp;DLinkedNode&#123;<br>        key: key,<br>        value: value,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    l := LRUCache&#123;<br>        cache: <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkedNode&#123;&#125;,<br>        head: initDLinkedNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        tail: initDLinkedNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        capacity: capacity,<br>    &#125;<br>    l.head.next = l.tail<br>    l.tail.prev = l.head<br>    <span class="hljs-keyword">return</span> l<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    node, ok := this.cache[key]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    this.moveToHead(node)<br>    <span class="hljs-keyword">return</span> node.value<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>    node, ok := this.cache[key]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        node := initDLinkedNode(key, value)<br>        this.cache[key] = node<br>        this.addToHead(node)<br>        this.size++<br>        <span class="hljs-keyword">if</span> this.size &gt; this.capacity &#123;<br>            removed := this.removeTail()<br>            <span class="hljs-built_in">delete</span>(this.cache, removed.key)<br>            this.size--<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node.value = value<br>        this.moveToHead(node)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode) &#123;<br>    node.prev = this.head<br>    node.next = this.head.next<br>    <span class="hljs-comment">// 以下两行顺序不能反</span><br>    this.head.next.prev = node<br>    this.head.next = node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;<br>    node.prev.next = node.next<br>    node.next.prev = node.prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode) &#123;<br>    this.removeNode(node)<br>    this.addToHead(node)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeTail() *DLinkedNode &#123;<br>    node := this.tail.prev<br>    this.removeNode(node)<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(capacity);</span><br><span class="hljs-comment"> * param_1 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>(3) </p><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>解答：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 迭代解法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br><br><span class="hljs-comment">// 递归解法，不好理解</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    newHead := reverseList(head.Next)<br>    head.Next.Next = head<br>    head.Next = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">return</span> newHead<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;Next: head&#125;<br>    <br>    <span class="hljs-comment">// 记录每一段的前驱节点</span><br>    pre := dummy<br><br>    <span class="hljs-comment">// 每次循环处理k个</span><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 找到第k个节点，作为tail</span><br>        tail := pre<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>            tail = tail.Next<br>            <span class="hljs-comment">// 如果还没有到k个，已经到了结尾，则整体反转已完成，返回头节点</span><br>            <span class="hljs-keyword">if</span> tail == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> dummy.Next<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 记录下一段链表的开头节点</span><br>        next := tail.Next<br><br>        <span class="hljs-comment">// 反转当前链表段，获取到新的head和tail</span><br>        head, tail = reverse(head, tail)<br><br>        <span class="hljs-comment">// 将head连接到上一段链表</span><br>        pre.Next = head<br><br>        <span class="hljs-comment">// 将tail连接到下一段链表</span><br>        tail.Next = next<br><br>        <span class="hljs-comment">// 本段的末尾记录为下一段的前驱</span><br>        pre = tail<br><br>        <span class="hljs-comment">// head重置为下一段的开头</span><br>        head = tail.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head, tail *ListNode)</span></span> (*ListNode, *ListNode) &#123;<br>    <span class="hljs-comment">// pre用于记录前驱节点</span><br>    <span class="hljs-keyword">var</span> pre *ListNode<br><br>    <span class="hljs-comment">// 从head节点开始处理</span><br>    curr := head<br><br>    <span class="hljs-comment">// 一直循环到pre指向最后一个节点</span><br>    <span class="hljs-keyword">for</span> pre != tail &#123;<br>        <span class="hljs-comment">// 先记录当前节点的下一个节点</span><br>        nex := curr.Next <br>        <span class="hljs-comment">// 将当前节点指向前驱节点</span><br>        curr.Next = pre<br>        <span class="hljs-comment">// pre后移</span><br>        pre = curr<br>        <span class="hljs-comment">// curr后移</span><br>        curr = nex<br>    &#125;<br>    <span class="hljs-comment">// 反转完成，tail成为新的头，head成为新的尾</span><br>    <span class="hljs-keyword">return</span> tail, head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 先排序，不然没法做</span><br>    slices.Sort(nums)<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>]&#123;<br>        <span class="hljs-comment">// 当前元素和上一个元素相同，则跳过</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i<span class="hljs-number">-1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 当前元素和后两个元素相加已经大于0，则此后所有循环肯定都大于0，直接退出</span><br>        <span class="hljs-keyword">if</span> x+nums[i+<span class="hljs-number">1</span>] + nums[i+<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-comment">// 当前元素和最后两个元素相加仍然小于0，则本轮循环中的和均小于0，跳过本轮循环</span><br>        <span class="hljs-keyword">if</span> x + nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>] + nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// j从当前元素的后一个元素开始</span><br>        j := i+<span class="hljs-number">1</span><br>        <span class="hljs-comment">// k从最后一个元素开始</span><br>        k := <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>        <br>        <span class="hljs-keyword">for</span> j &lt; k &#123;<br>            s := x + nums[j] + nums[k]<br>            <span class="hljs-comment">// 如果小于0，则增大j</span><br>            <span class="hljs-keyword">if</span> s &lt; <span class="hljs-number">0</span> &#123;<br>                j++<br>            <span class="hljs-comment">// 如果大于0，则减小k</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">0</span> &#123;<br>                k--<br>            <span class="hljs-comment">// 等于0，则找到了一个答案</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;x, nums[j], nums[k]&#125;)<br>                <span class="hljs-keyword">for</span> j++; j &lt; k &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]; j++ &#123;&#125; <span class="hljs-comment">// 跳过重复数字</span><br>                <span class="hljs-keyword">for</span> k--; k &gt; j &amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>]; k-- &#123;&#125; <span class="hljs-comment">// 跳过重复数字</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// sums[i]值的含义是，以nums[i]为结尾的所有连续子数组的最大和</span><br>    sums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-comment">// 初始时，以nums[0]为结尾的子数组就是它本身</span><br>    sums[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// ans用来记录整体最大和</span><br>    ans := sums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 从nums[1]开始遍历</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 关键代码</span><br>        <span class="hljs-comment">// 1. sums[i-1]保存了所有以nums[i-1]为结尾元素的连续子数组的最大和</span><br>        <span class="hljs-comment">// 2. nums[i]要么加入到前面的连续子数组，要么自己单独作为一个子数组</span><br>        sums[i] = max(sums[i<span class="hljs-number">-1</span>] + nums[i], nums[i])<br>        ans = max(ans, sums[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p := dummy<br>    <span class="hljs-keyword">for</span> list1 != <span class="hljs-literal">nil</span> &amp;&amp; list2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>            p.Next = list1<br>            list1 = list1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = list2<br>            list2 = list2.Next<br>        &#125;<br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = list1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        p.Next = list2<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list2<br>    &#125;<br>    <span class="hljs-keyword">if</span> list2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>        list1.Next = mergeTwoLists(list1.Next, list2)<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    list2.Next = mergeTwoLists(list2.Next, list1)<br>    <span class="hljs-keyword">return</span> list2<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br><br>    <span class="hljs-comment">// 用于记录最长回文串长度及起始位置</span><br>    maxLen := <span class="hljs-number">1</span><br>    begin := <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">// 初始化dp数组，并将dp[i][i]置为true（每个元素都可以认为是一个回文串）</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> n &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        dp[i][i] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 外层长度循环，遍历所有长度的子串</span><br>    <span class="hljs-keyword">for</span> l := <span class="hljs-number">2</span>; l &lt; n + <span class="hljs-number">1</span>; l++ &#123;<br>        <span class="hljs-comment">// 内层对起始位置进行循环，遍历所有的起始位置</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> n &#123;<br>            <span class="hljs-comment">// 计算结束位置</span><br>            j := i + l <span class="hljs-number">-1</span><br><br>            <span class="hljs-comment">// 若结束位置不合法，则直接退出本轮循环</span><br>            <span class="hljs-keyword">if</span> j &gt;= n &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br><br>            <span class="hljs-comment">// 核心代码，dp[i][j]是否为回文串，取决于</span><br>            <span class="hljs-comment">// 1. 内层dp[i+1][j-1]是回文串</span><br>            <span class="hljs-comment">// 2. s[i] == s[j]</span><br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">2</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 实时更新最长子串长度及起始位置</span><br>            <span class="hljs-keyword">if</span> dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen &#123;<br>                maxLen = j - i + <span class="hljs-number">1</span><br>                begin = i<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回最终结果</span><br>    <span class="hljs-keyword">return</span> s[begin:begin+maxLen]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 定义返回值</span><br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-comment">// q用于保存待遍历的元素</span><br>    q := []*TreeNode&#123;root&#125;<br>    <span class="hljs-comment">// q中保存的始终是同一层的元素</span><br>    <span class="hljs-comment">// 每次循环中把q中所有元素都取出，都取出后再填入下一层的元素</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>; i++ &#123;<br>        res = <span class="hljs-built_in">append</span>(res, []<span class="hljs-type">int</span>&#123;&#125;)<br>        <span class="hljs-comment">// 关键点，用临时的p来保存下层元素，待本层元素处理完后，用p替换q</span><br>        p := []*TreeNode&#123;&#125;<br>        <span class="hljs-comment">// 将q中元素全部遍历，过程中将下层子节点加入p</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(q); j++ &#123;<br>            node := q[j]<br>            res[i] = <span class="hljs-built_in">append</span>(res[i], node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 用p替换q，进入新一轮循环</span><br>        q = p<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> idx, ok := m[target-v]; ok &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;i, idx&#125;<br>        &#125;<br>        m[v] = i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    l := <span class="hljs-number">0</span><br>    r := n - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 总体是二分查找</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        <span class="hljs-comment">// 获取中间位置</span><br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-comment">// 如果命中，则返回</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-comment">// 如果左边是升序</span><br>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= nums[mid] &#123;<br>            <span class="hljs-comment">// 并且target在左边</span><br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;<br>                r = mid - <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span><br>            &#125;<br>        <span class="hljs-comment">// 如果右边是升序</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 并且target在右边</span><br>            <span class="hljs-keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="hljs-number">-1</span>] &#123;<br>                l = mid + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 深度优先搜索</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, r, c <span class="hljs-type">int</span>)</span></span> &#123;<br>    nr := <span class="hljs-built_in">len</span>(grid)<br>    nc := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 先将遍历到的元素置为0</span><br>    grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span><br>    <span class="hljs-comment">// 向上下左右都走一步，如果值为1，则往下搜索</span><br>    <span class="hljs-keyword">if</span> r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r<span class="hljs-number">-1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r<span class="hljs-number">-1</span>, c)<br>    &#125;<br>    <span class="hljs-keyword">if</span> r + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[r+<span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r+<span class="hljs-number">1</span>, c)<br>    &#125;<br>    <span class="hljs-keyword">if</span> c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r, c<span class="hljs-number">-1</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r, c+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    nr := <span class="hljs-built_in">len</span>(grid)<br>    <span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    nc := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> nc == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">var</span> numIslands <span class="hljs-type">int</span><br>    <span class="hljs-comment">// 将所有元素遍历一遍，如果遇到1就深度优先搜索</span><br>    <span class="hljs-comment">// 在深度优先搜索中，会将遍历到的元素置为0</span><br>    <span class="hljs-comment">// 最终执行的搜索次数即为岛屿数量</span><br>    <span class="hljs-keyword">for</span> r := <span class="hljs-number">0</span>; r &lt; nr; r++ &#123;<br>        <span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; nc; c++ &#123;<br>            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                numIslands++<br>                dfs(grid, r, c)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> numIslands<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 回溯法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    <span class="hljs-comment">// 对pos这个位置，使用待排列的所有数字尝试一遍</span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pos <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 如果索引到了n，则说明得到了一个全排列，将结果加入到结果集中</span><br>        <span class="hljs-keyword">if</span> pos == n &#123;<br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, nums...))<br>        &#125;<br>        <span class="hljs-comment">// 对pos这个位置尝试所有待使用元素</span><br>        <span class="hljs-keyword">for</span> i := pos; i &lt; n; i++ &#123;<br>            <span class="hljs-comment">// 把第i个位置的元素放到pos位置上</span><br>            nums[pos], nums[i] = nums[i], nums[pos]<br>            <span class="hljs-comment">// 得到pos后面所有字符的结果集</span><br>            backtrack(pos+<span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 恢复pos和i元素的初始位置，以便下一次循环使用另外的元素</span><br>            nums[pos], nums[i] = nums[i], nums[pos]<br>        &#125;<br>    &#125;<br><br>    backtrack(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-comment">// 如果字符是奇数个，则肯定不能完全匹配</span><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 记录右括号对应的左括号</span><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">byte</span>&#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-type">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果拿到了一个右括号</span><br>        <span class="hljs-keyword">if</span> v, ok := pairs[s[i]]; ok &#123;<br>            <span class="hljs-comment">// 如果栈为空，或者栈顶元素与当前右括号不匹配，就直接返回false</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != v &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            <span class="hljs-comment">// 如果匹配就把栈顶元素出栈</span><br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        <span class="hljs-comment">// 如果拿到的是左括号，就压栈</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 栈中剩余元素就是没有匹配成功的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 核心思想：第i天卖出得到的最大利润，买入价格一定是前i-1天中的最低价格</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// 记录“历史”最低价格</span><br>    minPrice := prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 记录最大利润</span><br>    maxProfit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-comment">// 更新最大利润</span><br>        maxProfit = max(maxProfit, price - minPrice)<br>        <span class="hljs-comment">// 更新历史最低价格</span><br>        minPrice = min(minPrice, price)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxProfit<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, m <span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 从后向前遍历</span><br>    <span class="hljs-comment">// p1指向nums1待排元素，p2指向nums2待排元素，tail指向要放入的位置</span><br>    <span class="hljs-keyword">for</span> p1, p2, tail := m<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>, m+n<span class="hljs-number">-1</span>; p1 &gt;=<span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>; tail-- &#123;<br>        <span class="hljs-comment">// 当前要处理的元素是什么</span><br>        <span class="hljs-keyword">var</span> cur <span class="hljs-type">int</span><br>        <span class="hljs-comment">// 如果nums1已经遍历完了</span><br>        <span class="hljs-keyword">if</span> p1 == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-comment">// 从nums2中取</span><br>            cur = nums2[p2]<br>            p2--<br>        <span class="hljs-comment">// 如果nums2已经遍历完了</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p2 == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-comment">// 从nums1中取</span><br>            cur = nums1[p1]<br>            p1--<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums1[p1] &gt; nums2[p2] &#123;<br>            cur = nums1[p1]<br>            p1--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = nums2[p2]<br>            p2--<br>        &#125;<br>        nums1[tail] = cur<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-comment">// 辅助层序遍历</span><br>    queue := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> level := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>; level++ &#123;<br>        vals := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-comment">// q接收本层元素，用于遍历，queue保存下层元素</span><br>        q := queue<br>        queue = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> q &#123;<br>            vals = <span class="hljs-built_in">append</span>(vals, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果本层为奇数层，将得到的遍历结果反转，再加入结果集</span><br>        <span class="hljs-keyword">if</span> level % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            n := <span class="hljs-built_in">len</span>(vals)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br>                vals[i], vals[n<span class="hljs-number">-1</span>-i] = vals[n<span class="hljs-number">-1</span>-i], vals[i]<br>            &#125;<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, vals)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 哈希表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    seen := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _, ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        seen[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        head = head.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 快慢指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// 慢指针每次走一步，快指针每次走两步</span><br>    <span class="hljs-comment">// 每次移动快慢指针之间的距离会加1，如果有环的话，快慢指针终会相遇</span><br>    slow, fast := head, head.Next<br>    <span class="hljs-keyword">for</span> slow != fast &#123;<br>        <span class="hljs-keyword">if</span> fast == <span class="hljs-literal">nil</span> || fast.Next == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 找到最近公共祖先 or 找到p/q本身</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// 如果已经到达底部，直接返回</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前节点是p或者q，返回该节点</span><br>    <span class="hljs-keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    <span class="hljs-comment">// 在左子树中找到最近公共祖先 或 在左子树中找到p/q</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br><br>    <span class="hljs-comment">// 在右子树中找到最近公共祖先 或 在右子树中找到p/q</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <br>    <span class="hljs-comment">// 左子树中找到了p/q，右子树中也找到了p/q</span><br>    <span class="hljs-comment">// 则当前节点为最近公共祖先（只有最近公共祖先满足该条件）</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    <span class="hljs-comment">// 如果只是找到了一个，则返回找到的那个，表示从该节点往下有一个p/q</span><br>    <span class="hljs-comment">// 如果都没找到，返回nil</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 头插法一次遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 设置dummy节点是此类问题的一般做法</span><br>    dummy := &amp;ListNode&#123;Next: head&#125;<br>    pre := dummy<br><br>    <span class="hljs-comment">// 找到left的前一个节点，作为pre</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++ &#123;<br>        pre = pre.Next<br>    &#125;<br><br>    <span class="hljs-comment">// left节点作为cur</span><br>    cur := pre.Next<br><br>    <span class="hljs-comment">// 从left开始遍历，每次循环把当前节点的后一个节点插入到pre后面（该段链表的头部）</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; right-left; i++ &#123;<br>        next := cur.Next<br>        cur.Next = next.Next<br>        next.Next = pre.Next<br>        pre.Next = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// dp[i]为组成数量为i的金额所需的最小硬币数</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 为dp[i]赋初始值</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++ &#123;<br>        <span class="hljs-comment">// 这里的amount+1并没有实际意义，仅仅是为了方便判断是否有解，任何一个大于amount的数均可</span><br>        <span class="hljs-comment">// 因为组成amount所需的硬币数量在任何情况下都不会大于amount</span><br>        dp[i] = amount + <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(coins); j++ &#123;<br>            <span class="hljs-keyword">if</span> coins[j] &lt;= i &#123;<br>                <span class="hljs-comment">// 组成i-coins[j]的最小硬币数，加上本次的一个硬币</span><br>                dp[i] = min(dp[i], dp[i-coins[j]] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> dp[amount] &gt; amount &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br><br>    rows, cols := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    order := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, rows * cols)<br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 记录边界</span><br>    left, right, top, bottom := <span class="hljs-number">0</span>, cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">// 在边界范围内移动</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &amp;&amp; top &lt;= bottom &#123;<br>        <span class="hljs-comment">// 从左往右移动，从最左端left开始，一直到最右端right</span><br>        <span class="hljs-keyword">for</span> col := left; col &lt;= right; col++ &#123;<br>            order[index] = matrix[top][col]<br>            index++<br>        &#125;<br>        <span class="hljs-comment">// 从上往下移动，从最上面的下一个元素开始，到最下端</span><br>        <span class="hljs-keyword">for</span> row := top + <span class="hljs-number">1</span>; row &lt;= bottom; row++ &#123;<br>            order[index] = matrix[row][right]<br>            index++<br>        &#125;<br>        <span class="hljs-comment">// 因为需要始终满足col &gt; left和row &gt; top，这里要保证数组访问不越界</span><br>        <span class="hljs-keyword">if</span> left &lt; right &amp;&amp; top &lt; bottom &#123;<br>            <span class="hljs-comment">// 从右往左移动</span><br>            <span class="hljs-keyword">for</span> col := right - <span class="hljs-number">1</span>; col &gt; left; col-- &#123;<br>                order[index] = matrix[bottom][col]<br>                index++<br>            &#125;<br>            <span class="hljs-comment">// 从下往上移动</span><br>            <span class="hljs-keyword">for</span> row := bottom; row &gt; top; row-- &#123;<br>                order[index] = matrix[row][left]<br>                index++<br>            &#125;<br>        &#125;<br>        left++<br>        right--<br>        top++<br>        bottom--<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> order<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    d := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">len</span> := <span class="hljs-number">1</span><br>    d[<span class="hljs-built_in">len</span>] = nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num &gt; d[<span class="hljs-built_in">len</span>] &#123;<br>            <span class="hljs-built_in">len</span>++<br>            d[<span class="hljs-built_in">len</span>] = num<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l := <span class="hljs-number">1</span><br>            r := <span class="hljs-built_in">len</span><br>            pos := <span class="hljs-number">0</span><br>            <span class="hljs-comment">// 找到比num小的最大的数</span><br>            <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>                mid := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> d[mid] &lt; num &#123;<br>                    pos = mid<br>                    l = mid + <span class="hljs-number">1</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>            d[pos+<span class="hljs-number">1</span>] = num<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lists)<span class="hljs-number">-1</span>)<br>&#125;<br><span class="hljs-comment">// 递归执行，将数组拆成左右两部分，分别合并为一个链表，最终再将两个链表合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(lists []*ListNode, l, r <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> l == r &#123;<br>        <span class="hljs-keyword">return</span> lists[l]<br>    &#125;<br>    <span class="hljs-keyword">if</span> l &gt; r &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (l + r) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid+<span class="hljs-number">1</span>, r))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(a, b *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    dummy := &amp;ListNode&#123;&#125;<br>    tail := dummy<br>    pa := a<br>    pb := b<br>    <span class="hljs-keyword">for</span> pa != <span class="hljs-literal">nil</span> &amp;&amp; pb != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> pa.Val &lt; pb.Val &#123;<br>            tail.Next = pa<br>            pa = pa.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.Next = pb<br>            pb = pb.Next<br>        &#125;<br>        tail = tail.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> pa != <span class="hljs-literal">nil</span> &#123;<br>        tail.Next = pa<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tail.Next = pb<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(head *ListNode)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    mid := middleNode(head)<br>    l1 := head<br>    l2 := mid.Next<br>    mid.Next = <span class="hljs-literal">nil</span><br><br>    l2 = reverseList(l2)<br><br>    mergeList(l1, l2)<br>&#125;<br><br><span class="hljs-comment">// 快慢指针找中点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleNode</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> pre, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br><span class="hljs-comment">// 交替合并链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(l1, l2 *ListNode)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> &amp;&amp; l2 != <span class="hljs-literal">nil</span> &#123;<br>        l1Next := l1.Next<br>        l2Next := l2.Next<br><br>        l1.Next = l2<br>        l1 = l1Next<br><br>        l2.Next = l1<br>        l2 = l2Next<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addStrings</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    add := <span class="hljs-number">0</span><br>    ans := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-built_in">len</span>(num1) - <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(num2) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add != <span class="hljs-number">0</span>; i, j = i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>            x = <span class="hljs-type">int</span>(num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> &#123;<br>            y = <span class="hljs-type">int</span>(num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        result := x + y + add<br>        <span class="hljs-comment">// result % 10 为当前位</span><br>        ans = strconv.Itoa(result % <span class="hljs-number">10</span>) + ans<br>        <span class="hljs-comment">// 向下一位的进位</span><br>        add = result / <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 哈希表存储</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    vis := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> p := headA; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>        vis[p] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> p := headB; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>        <span class="hljs-keyword">if</span> vis[p] &#123;<br>            <span class="hljs-keyword">return</span> p<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 双指针分别从两个链表头部开始遍历，遍历完后转到另一条链表头部遍历</span><br><span class="hljs-comment">// 若存在相交节点，则必定相遇（因为会走过相同距离x1+y+x2）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    pa, pb := headA, headB<br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = headB<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pa = pa.Next<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = headA<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pb = pb.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 先按照左端点进行排序</span><br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br><br>    <span class="hljs-comment">// 用于保存结果</span><br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 遍历排序后的区间</span><br>    <span class="hljs-keyword">for</span> _, interval := <span class="hljs-keyword">range</span> intervals &#123;<br>        n := <span class="hljs-built_in">len</span>(res)<br>        <span class="hljs-comment">// 没有重合：res中最后一个区间的右端点小于当前区间左端点</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>] &#123;<br>            res = <span class="hljs-built_in">append</span>(res, interval)<br>        <span class="hljs-comment">// 有重合，就拓展res中最后一个区间的右边界</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// leftMax[i]的含义是，从i这个位置往左看，最高的高度</span><br>    leftMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        leftMax[i] = max(leftMax[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br><br>    <span class="hljs-comment">// rightMax[i]的含义是，从i这个位置往右看，最高的高度</span><br>    rightMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    rightMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        rightMax[i] = max(rightMax[i+<span class="hljs-number">1</span>], height[i])<br>    &#125;<br><br>    res := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i, h := <span class="hljs-keyword">range</span> height &#123;<br>        res += min(leftMax[i], rightMax[i]) - h<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSum := math.MinInt32<br>    <span class="hljs-keyword">var</span> maxGain <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span> <span class="hljs-type">int</span><br>    maxGain = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br><br>        leftGain := max(maxGain(node.Left), <span class="hljs-number">0</span>)<br>        rightGain := max(maxGain(node.Right), <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment">// 将左子树路径-当前节点-右子树路径 连接起来组成新的一条路径</span><br>        <span class="hljs-comment">// 计算这条路径的和</span><br>        newPathPrice := node.Val + leftGain + rightGain<br><br>        <span class="hljs-comment">// 更新答案</span><br>        maxSum = max(maxSum, newPathPrice)<br><br>        <span class="hljs-comment">// 返回节点的最大贡献值。路径只向一个子树上延申</span><br>        <span class="hljs-keyword">return</span> node.Val + max(leftGain, rightGain)<br>    &#125;<br><br>    maxGain(root)<br><br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>)<br><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _, ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> head<br>        &#125;<br>        seen[head] = <span class="hljs-literal">true</span><br>        head = head.Next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>    <span class="hljs-comment">// dp[i][j]含义：以text1[i-1]结尾的字符串，和以text2[j-1]结尾的字符串之间的最长公共子序列长度</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, c1 := <span class="hljs-keyword">range</span> text1 &#123;<br>        <span class="hljs-keyword">for</span> j, c2 := <span class="hljs-keyword">range</span> text2 &#123;<br>            <span class="hljs-keyword">if</span> c1 == c2 &#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = max(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> SEG_COUNT = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">var</span> (<br>    ans []<span class="hljs-type">string</span><br>    segments []<span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    segments = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, SEG_COUNT)<br>    ans = []<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, segId, segStart <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// segId从0开始的，等于SEG_COUNT说明已经找到了4段</span><br>    <span class="hljs-comment">// segStart从0开始的，等于len(s)说明字符串已经遍历完了</span><br>    <span class="hljs-keyword">if</span> segId == SEG_COUNT &#123;<br>        <span class="hljs-keyword">if</span> segStart == <span class="hljs-built_in">len</span>(s) &#123;<br>            <span class="hljs-comment">// 将dfs过程中保存的segments数组转化成真正的ip字符串</span><br>            ipAddr := <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; SEG_COUNT; i++ &#123;<br>                ipAddr += strconv.Itoa(segments[i])<br>                <span class="hljs-keyword">if</span> i != SEG_COUNT - <span class="hljs-number">1</span> &#123;<br>                    ipAddr += <span class="hljs-string">&quot;.&quot;</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将ip字符串加入到结果集中</span><br>            ans = <span class="hljs-built_in">append</span>(ans, ipAddr)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果还没有找到4段，但字符串已经遍历完了，说明本次尝试无功而返，什么也不做，直接返回</span><br>    <span class="hljs-keyword">if</span> segStart == <span class="hljs-built_in">len</span>(s) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前段，遇到的第一个数字就是0，那么本段也只能为0。保存本段的0，然后开启向下的搜索</span><br>    <span class="hljs-keyword">if</span> s[segStart] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>        segments[segId] = <span class="hljs-number">0</span><br>        dfs(s, segId + <span class="hljs-number">1</span>, segStart + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 一般情况，枚举每一种可能性，并向下递归</span><br>    addr := <span class="hljs-number">0</span> <span class="hljs-comment">// 用来保存本段ip地址数值</span><br>    <span class="hljs-comment">// 从segStart开始尝试，i的总体限制是小于len(s)，但在前期遍历过程中达不到len(s) addr就超过255了</span><br>    <span class="hljs-comment">// 所以这里的for循环并不一定会遍历到len(s)，超过255退出即可，所有可能的结果都会在dfs过程中遍历到</span><br>    <span class="hljs-keyword">for</span> i := segStart; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        addr = addr * <span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-comment">// 如果本轮循环得到的addr数值符合要求，那么就找到了本段的一个解，记录之后向下递归寻找之后几段的解</span><br>        <span class="hljs-keyword">if</span> addr &gt; <span class="hljs-number">0</span> &amp;&amp; addr &lt;= <span class="hljs-number">0xFF</span> &#123;<br>            segments[segId] = addr<br>            dfs(s, segId + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 双指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br>    first, second := head, dummy<br>    <span class="hljs-comment">// first先往前走n步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br>    <span class="hljs-comment">// first和second同时往前走</span><br>    <span class="hljs-keyword">for</span> ; first != <span class="hljs-literal">nil</span>; first = first.Next &#123;<br>        second = second.Next<br>    &#125;<br>    second.Next = second.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br><br>    cur := dummy<br>    <span class="hljs-comment">// 每次都是对比当前节点的后两个节点</span><br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果后两个节点相等</span><br>        <span class="hljs-keyword">if</span> cur.Next.Val == cur.Next.Next.Val &#123;<br>            <span class="hljs-comment">// 记录相等节点的值</span><br>            x := cur.Next.Val<br>            <span class="hljs-comment">// 不停的跳过值为x的节点，注意这里cur是一直没变的，变化的是cur的下一个节点，</span><br>            <span class="hljs-comment">// 也就是说如果cur的下一个节点值为x，那么它就会被跳过</span><br>            <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Val == x &#123;<br>                cur.Next = cur.Next.Next<br>            &#125;<br>        <span class="hljs-comment">// 后两个节点不相等的情况下，cur才往后移动一位</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 层序遍历，右子树先入队，每层保留最右侧节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    q := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        p := []*TreeNode&#123;&#125;<br>        res = <span class="hljs-built_in">append</span>(res, q[<span class="hljs-number">0</span>].Val)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(q); j++ &#123;<br>            node := q[j]<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Left)<br>            &#125;<br>        &#125;<br>        q = p<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> inorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    inorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node * TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        inorder(node.Left)<br>        res = <span class="hljs-built_in">append</span>(res, node.Val)<br>        inorder(node.Right)<br>    &#125;<br><br>    inorder(root)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    l := <span class="hljs-number">0</span><br>    r := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>            l = mid + <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            r = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>    inStack, outStack []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br>    <span class="hljs-keyword">return</span> MyQueue&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>    q.inStack = <span class="hljs-built_in">append</span>(q.inStack, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> in2out() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.inStack) &gt; <span class="hljs-number">0</span> &#123;<br>        q.outStack = <span class="hljs-built_in">append</span>(q.outStack, q.inStack[<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>])<br>        q.inStack = q.inStack[:<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;<br>        q.in2out()<br>    &#125;<br>    x := q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>    q.outStack = q.outStack[:<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;<br>        q.in2out()<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.inStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 归并排序两个有序链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(head1, head2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p, p1, p2 := dummy, head1, head2<br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1.Val &lt; p2.Val &#123;<br>            p.Next = p1<br>            p1 = p1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = p2<br>            p2 = p2.Next<br>        &#125;<br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> p1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p1<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p2 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p2<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-comment">// 拆分一个链表，分别递归排序，将排好序的两个链表合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(head, tail *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    <br>    <span class="hljs-comment">// 丢弃尾部节点，避免重复</span><br>    <span class="hljs-keyword">if</span> head.Next == tail &#123;<br>        head.Next = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != tail &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>        <span class="hljs-keyword">if</span> fast != tail &#123;<br>            fast = fast.Next<br>        &#125;<br>    &#125;<br><br>    mid := slow<br>    <span class="hljs-comment">// 这里将mid分别作为头和尾递归传递，但作为尾部的mid最终会被丢弃，不会出现mid节点重复的问题</span><br>    <span class="hljs-keyword">return</span> merge(sort(head, mid), sort(mid, tail))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> sort(head, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 用于保存结果集</span><br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 用于保存每一步的结果</span><br>    tmp := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 回溯法，每个位置上要么放左括号，要么放右括号</span><br>    <span class="hljs-comment">// 放的时候校验下合不合法</span><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leftCount, rightCount <span class="hljs-type">int</span>)</span></span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leftCount, rightCount <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 长度达到2n，找到一个答案，加入结果集</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp) == <span class="hljs-number">2</span>*n &#123;<br>            res = <span class="hljs-built_in">append</span>(res, strings.Join(tmp, <span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 只要左括号数量小于n，当前位置放左括号就是合法的</span><br>        <span class="hljs-keyword">if</span> leftCount &lt; n &#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-string">&quot;(&quot;</span>)<br>            backtrack(leftCount+<span class="hljs-number">1</span>, rightCount)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// 只要右括号数量小于左括号，当前位置放右括号就是合法的</span><br>        <span class="hljs-keyword">if</span> rightCount &lt; leftCount &#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-string">&quot;)&quot;</span>)<br>            backtrack(leftCount, rightCount+<span class="hljs-number">1</span>)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 唉，背诵题，原理看题解吧</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    i := n - <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>] &#123;<br>        i--<br>    &#125;<br>    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        j := n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j] &#123;<br>            j--<br>        &#125;<br>        nums[i], nums[j] = nums[j], nums[i]<br>    &#125;<br>    reverse(nums[i+<span class="hljs-number">1</span>:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a); i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br>        a[i], a[n<span class="hljs-number">-1</span>-i] = a[n<span class="hljs-number">-1</span>-i], a[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    v1 := strings.Split(version1, <span class="hljs-string">&quot;.&quot;</span>)<br>    v2 := strings.Split(version2, <span class="hljs-string">&quot;.&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(v1) || i &lt; <span class="hljs-built_in">len</span>(v2); i++ &#123;<br>        x, y := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(v1) &#123;<br>            x, _ = strconv.Atoi(v1[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(v2) &#123;<br>            y, _ = strconv.Atoi(v2[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> x &gt; y &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> x &lt; y &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, x<br>    ans := <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> mid * mid &lt;= x &#123;<br>            ans = mid<br>            l = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 去除前导空格</span><br>s = strings.TrimLeft(s, <span class="hljs-string">&quot; &quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 处理符号</span><br>sign := <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>sign = <span class="hljs-number">-1</span><br>s = s[<span class="hljs-number">1</span>:]<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> &#123;<br>s = s[<span class="hljs-number">1</span>:]<br>&#125;<br><br><span class="hljs-keyword">var</span> result <span class="hljs-type">int64</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-comment">// 遇到非数字字符则停止</span><br><span class="hljs-keyword">if</span> ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br>digit := <span class="hljs-type">int64</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>)<br>result = result*<span class="hljs-number">10</span> + digit<br><br><span class="hljs-comment">// 检查溢出</span><br><span class="hljs-keyword">if</span> sign == <span class="hljs-number">1</span> &amp;&amp; result &gt; math.MaxInt32 &#123;<br><span class="hljs-keyword">return</span> math.MaxInt32<br>&#125;<br><span class="hljs-keyword">if</span> sign == <span class="hljs-number">-1</span> &amp;&amp; -result &lt; math.MinInt32 &#123;<br><span class="hljs-keyword">return</span> math.MinInt32<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 应用符号</span><br>final := <span class="hljs-type">int64</span>(sign) * result<br><br><span class="hljs-comment">// 确保结果在32位整数范围内</span><br><span class="hljs-keyword">if</span> final &gt; math.MaxInt32 &#123;<br><span class="hljs-keyword">return</span> math.MaxInt32<br>&#125;<br><span class="hljs-keyword">if</span> final &lt; math.MinInt32 &#123;<br><span class="hljs-keyword">return</span> math.MinInt32<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(final)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p := dummy<br>    digit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> || l2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">var</span> v1, v2 <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> l1 != <span class="hljs-literal">nil</span> &#123;<br>            v1 = l1.Val<br>            l1 = l1.Next<br>        &#125;<br>        <span class="hljs-keyword">if</span> l2 != <span class="hljs-literal">nil</span> &#123;<br>            v2 = l2.Val<br>            l2 = l2.Next<br>        &#125;<br><br>        sum := v1 + v2 + digit<br>        <br>        val := sum % <span class="hljs-number">10</span><br><br>        node := &amp;ListNode&#123;Val: val&#125;<br>        p.Next = node<br>        p = p.Next<br><br>        digit = sum / <span class="hljs-number">10</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> digit != <span class="hljs-number">0</span> &#123;<br>        p.Next = &amp;ListNode&#123;Val: digit&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 用于保存最终结果</span><br>    res := <span class="hljs-number">0</span><br>    <br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-comment">// 为了初始时方便，提前压入-1</span><br>    stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-comment">// 如果是左括号，就压入栈中</span><br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, i)<br>        <span class="hljs-comment">// 如果是右括号，就将栈顶元素出栈（除了栈底元素，栈中肯定全部都是左括号。栈底元素是遍历过的最后的没有被匹配的右括号）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            <span class="hljs-comment">// 如果出栈后栈空了，就说明栈底的右括号被出栈了，那么当前的右括号就成了新的不能被匹配的右括号，压入栈中成为新的栈底</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, i)<br>            <span class="hljs-comment">// 实时更新最长的匹配长度</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res = max(res, i - stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt; n + <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    root := &amp;TreeNode&#123;preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br><br>    <span class="hljs-comment">// 找到中序遍历中的根节点</span><br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 中序遍历根节点左边的节点为左子树，右边的节点为右子树</span><br>    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>], inorder[:i])<br>    root.Right = buildTree(preorder[<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>:], inorder[i+<span class="hljs-number">1</span>:])<br><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    set := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cur <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 如果长度已经超过了nums长度，说明已经得到了一个结果</span><br>        <span class="hljs-keyword">if</span> cur == <span class="hljs-built_in">len</span>(nums) &#123;<br>            <span class="hljs-comment">// 这里要注意，不要把set直接append到结果集中，因为后面还要对set进行修改，引用传递，会受影响</span><br>            <span class="hljs-comment">// 创建一个新的数组，加入结果集中</span><br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, set...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 选择当前元素</span><br>        set = <span class="hljs-built_in">append</span>(set, nums[cur])<br>        dfs(cur+<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment">// 不选择当前元素</span><br>        set = set[:<span class="hljs-built_in">len</span>(set)<span class="hljs-number">-1</span>]<br>        dfs(cur+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 去除两端空格</span><br>    s = strings.Trim(s, <span class="hljs-string">&quot; &quot;</span>)<br><br>    <span class="hljs-comment">// 双指针</span><br>    i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    j := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 从后向前遍历</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 搜索首个空格</span><br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            i -= <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-comment">// 记录单词</span><br>        res = <span class="hljs-built_in">append</span>(res, s[i+<span class="hljs-number">1</span>:j+<span class="hljs-number">1</span>])<br>        <span class="hljs-comment">// 跳过单词间空格</span><br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            i -= <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-comment">// j指向下个单词的尾字符</span><br>        j = i<br>    &#125;<br><br>    <span class="hljs-comment">// 拼接返回</span><br>    <span class="hljs-keyword">return</span> strings.Join(res, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 思路：使用一个辅助栈，每次压栈时同步往辅助栈中压入当前最小值，出栈时也是同步出栈。</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-type">int</span><br>    minStack []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        stack: []<span class="hljs-type">int</span>&#123;&#125;,<br>        minStack: []<span class="hljs-type">int</span>&#123;math.MaxInt64&#125;,<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    this.stack = <span class="hljs-built_in">append</span>(this.stack, val)<br>    top := this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>    this.minStack = <span class="hljs-built_in">append</span>(this.minStack, min(val, top))<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop()  &#123;<br>    this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>    this.minStack = this.minStack[:<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用单个栈的解法，通过向栈中压入差值实现</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-type">int</span><br>    minValue <span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        stack: []<span class="hljs-type">int</span>&#123;&#125;,<br>        minValue: <span class="hljs-number">-1</span>,<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        this.stack = <span class="hljs-built_in">append</span>(this.stack, <span class="hljs-number">0</span>)<br>        this.minValue = val<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        diff := val - this.minValue<br>        this.stack = <span class="hljs-built_in">append</span>(this.stack, diff)<br>        <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> &#123;<br>            this.minValue = val<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop()  &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    diff := this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>    this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br><br>    <span class="hljs-comment">// 如果diff小于0，则当前最小值就是栈顶的原始元素</span><br>    <span class="hljs-comment">// 并且，当前最小值 - diff就是上一次的最小值（参考push中的逻辑）</span><br>    <span class="hljs-comment">// 这里相当于在出栈时恢复上一次的最小值，是关键的一步</span><br>    <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> &#123;<br>        this.minValue = this.minValue - diff<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> this.minValue<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>] + this.minValue<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> this.minValue<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, prevSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum := prevSum * <span class="hljs-number">10</span> + root.Val<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(root.Left, sum) + dfs(root.Right, sum)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> check(root.Left, root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(p, q *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> || q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// lowerBound 返回最小的满足 nums[i] &gt;= target 的下标 i</span><br><span class="hljs-comment">// 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)</span><br><span class="hljs-comment">// 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> <span class="hljs-comment">// 闭区间 [left, right]</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left-1] &lt; target</span><br>        <span class="hljs-comment">// nums[right+1] &gt;= target</span><br>        mid := left + (right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;<br>            right = mid - <span class="hljs-number">1</span> <span class="hljs-comment">// 范围缩小到 [left, mid-1]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span> <span class="hljs-comment">// 范围缩小到 [mid+1, right]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束后 left = right+1</span><br>    <span class="hljs-comment">// 此时 nums[left-1] &lt; target 而 nums[left] = nums[right+1] &gt;= target</span><br>    <span class="hljs-comment">// 所以 left 就是第一个 &gt;= target 的元素下标</span><br>    <span class="hljs-keyword">return</span> left<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    start := lowerBound(nums, target)<br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) || nums[start] != target &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125; <span class="hljs-comment">// nums 中没有 target</span><br>    &#125;<br>    <span class="hljs-comment">// 如果 start 存在，那么 end 必定存在</span><br>    end := lowerBound(nums, target+<span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;start, end&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> preorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><br>    preorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, root.Val)<br>        preorder(root.Left)<br>        preorder(root.Right)<br>    &#125;<br>    preorder(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    comb := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 当前索引超过了数组总长度</span><br>        <span class="hljs-keyword">if</span> idx == <span class="hljs-built_in">len</span>(candidates) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// target减到了0，说明找到了一个答案</span><br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, comb...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 考虑选择当前元素</span><br>        <span class="hljs-keyword">if</span> target - candidates[idx] &gt;= <span class="hljs-number">0</span> &#123;<br>            comb = <span class="hljs-built_in">append</span>(comb, candidates[idx])<br>            dfs(target-candidates[idx], idx)<br>            comb = comb[:<span class="hljs-built_in">len</span>(comb)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// 不考虑当前元素</span><br>        dfs(target, idx+<span class="hljs-number">1</span>)<br>    &#125;<br>    dfs(target, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    stack := []<span class="hljs-type">string</span>&#123;&#125;<br>    p := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> p &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        cur := s[p]<br>        <span class="hljs-comment">// 如果遍历到数字，就取出所有的后续数字，得到整数字符串后，将其压入栈中</span><br>        <span class="hljs-keyword">if</span> cur &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>            digits := getDigits(s, &amp;p)<br>            stack = <span class="hljs-built_in">append</span>(stack, digits)<br>        <span class="hljs-comment">// 如果遇到字符或左括号，直接压栈</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || cur &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || cur == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-type">string</span>(cur))<br>            p++<br>        <span class="hljs-comment">// 如果遇到右括号</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 持续出栈字符，直到遇到左括号，此时sub中保存了所有的出栈字符</span><br>            sub := []<span class="hljs-type">string</span>&#123;&#125;<br>            <span class="hljs-keyword">for</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != <span class="hljs-string">&quot;[&quot;</span> &#123;<br>                sub = <span class="hljs-built_in">append</span>(sub, stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            &#125;<br>            <span class="hljs-comment">// 将sub中的字符反转，得到正常的字符顺序</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sub)/<span class="hljs-number">2</span>; i++ &#123;<br>                sub[i], sub[<span class="hljs-built_in">len</span>(sub)<span class="hljs-number">-1</span>-i] = sub[<span class="hljs-built_in">len</span>(sub)<span class="hljs-number">-1</span>-i], sub[i]<br>            &#125;<br><br>            <span class="hljs-comment">// 将左括号出栈</span><br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br><br>            <span class="hljs-comment">// 此时栈顶保存的是整数，将此整数出栈，并进行重复处理</span><br>            repTime, _ := strconv.Atoi(stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            t := strings.Repeat(getString(sub), repTime)<br>            <span class="hljs-comment">// 重点，将重复后的字符串重新压入栈中</span><br>            stack = <span class="hljs-built_in">append</span>(stack, t)<br><br>            <span class="hljs-comment">// 继续判断下一个字符</span><br>            p++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> getString(stack)<br>&#125;<br><br><span class="hljs-comment">// 取出所有的后续数字，组成一个整数字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getDigits</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> ; s[*p] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[*p] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; *p++ &#123;<br>        res += <span class="hljs-type">string</span>(s[*p])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getString</span><span class="hljs-params">(v []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> v &#123;<br>        res += s<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> abs(height(root.Left) - height(root.Right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">height</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(height(root.Left), height(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> * x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    rows := <span class="hljs-built_in">len</span>(grid)<br>    cols := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, rows)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dp); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, cols)<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; rows; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; cols; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][j]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; rows; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; cols; j++ &#123;<br>            dp[i][j] = min(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]) + grid[i][j]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[rows<span class="hljs-number">-1</span>][cols<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h2 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a href="https://leetcode.cn/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        row := rand7()<br>        col := rand7()<br>        idx := (row<span class="hljs-number">-1</span>)*<span class="hljs-number">7</span> + col<br>        <span class="hljs-keyword">if</span> idx &lt;= <span class="hljs-number">40</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + (idx<span class="hljs-number">-1</span>)%<span class="hljs-number">10</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(matrix)<br>    n := <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    x := <span class="hljs-number">0</span><br>    y := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> matrix[x][y] == target &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">// 如果当前元素大，就往小了走，往小了走就是往左移动</span><br>        <span class="hljs-keyword">if</span> matrix[x][y] &gt; target &#123;<br>            y--<br>        <span class="hljs-comment">// 如果当前元素小，就往大了走，往大了走就是往下走</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(root *TreeNode, lower, upper <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> depth <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span><br>    depth = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        l := depth(root.Left)<br>        r := depth(root.Right)<br><br>        res = max(res, l + r + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">return</span> max(l, r) + <span class="hljs-number">1</span><br>    &#125;<br><br>    depth(root)<br><br>    <span class="hljs-keyword">return</span> res - <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSide := <span class="hljs-number">0</span><br><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix[i]))<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            dp[i][j] = <span class="hljs-type">int</span>(matrix[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                maxSide = <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                dp[i][j] = min(min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> dp[i][j] &gt; maxSide &#123;<br>                    maxSide = dp[i][j]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSide * maxSide<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    numSet := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        numSet[num] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    maxLength := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> numSet &#123;<br>        <span class="hljs-keyword">if</span> !numSet[num<span class="hljs-number">-1</span>] &#123;<br>            curNum := num<br>            curLength := <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> numSet[curNum+<span class="hljs-number">1</span>] &#123;<br>                curNum++<br>                curLength++<br>            &#125;<br>            <span class="hljs-keyword">if</span> curLength &gt; maxLength &#123;<br>                maxLength = curLength<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLength<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 贪心法，只能用于计算最大利润</span><br><span class="hljs-comment">// 思想：所有的利润都要有，所有的亏损都不要。即：只要后一天比前一天价格高，这部分差价就是利润</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        res += max(<span class="hljs-number">0</span>, prices[i]-prices[i<span class="hljs-number">-1</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// // 递归，本质是利用栈</span><br><span class="hljs-comment">// func isPalindrome(head *ListNode) bool &#123;</span><br><span class="hljs-comment">//     // 递归函数外指针，指向链表头部</span><br><span class="hljs-comment">//     p := head</span><br><br><span class="hljs-comment">//     var check func(*ListNode) bool</span><br><span class="hljs-comment">//     check = func(node *ListNode) bool &#123;</span><br><span class="hljs-comment">//         if node != nil &#123;</span><br><span class="hljs-comment">//             // 一开始就进入递归，实际效果上会把当前节点压入函数栈中，并且会一直压到最后一个节点</span><br><span class="hljs-comment">//             // 当开始出栈时，实际就是从最后一个节点往前遍历了</span><br><span class="hljs-comment">//             if !check(node.Next) &#123;</span><br><span class="hljs-comment">//                 return false</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//             // 判断递归外指针与当前节点的值</span><br><span class="hljs-comment">//             if node.Val != p.Val &#123;</span><br><span class="hljs-comment">//                 return false</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//             // 外指针向后移动一位</span><br><span class="hljs-comment">//             p = p.Next</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//         return true</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-comment">//     return check(head)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 快慢指针找中点 + 反转链表 + 遍历对比</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> prev, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        nextTmp := cur.Next<br>        cur.Next = prev<br>        prev = cur<br>        cur = nextTmp<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">endOfFirstHalf</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    fast := head<br>    slow := head<br>    <span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 找到前半部分链表的尾节点并反转后半部分链表</span><br>    firstHalfEnd := endOfFirstHalf(head)<br>    secondHalfStart := reverseList(firstHalfEnd.Next)<br><br>    <span class="hljs-comment">// 判断是否回文</span><br>    p1 := head<br>    p2 := secondHalfStart<br>    result := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> result &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1.Val != p2.Val &#123;<br>            result = <span class="hljs-literal">false</span><br>        &#125;<br>        p1 = p1.Next<br>        p2 = p2.Next<br>    &#125;<br><br>    <span class="hljs-comment">// 还原链表并返回结果</span><br>    firstHalfEnd.Next = reverseList(secondHalfStart)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 利用性质 + 每次二分丢弃一半选项</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-comment">// 辅助函数，输入下标 i，返回 nums[i] 的值</span><br>    <span class="hljs-comment">// 方便处理 nums[-1] 以及 nums[n] 的边界情况</span><br>    get := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> || i == n &#123;<br>            <span class="hljs-keyword">return</span> math.MinInt64<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[i]<br>    &#125;<br><br>    left := <span class="hljs-number">0</span><br>    right := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> get(mid<span class="hljs-number">-1</span>) &lt; get(mid) &amp;&amp; get(mid) &gt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-keyword">if</span> get(mid) &lt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<br>            res = max(dfs(grid, i, j), res)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == <span class="hljs-built_in">len</span>(grid) || j == <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) || grid[i][j] != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    grid[i][j] = <span class="hljs-number">0</span><br>    area := <span class="hljs-number">1</span><br>    di := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;<br>    dj := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(di); k++ &#123;<br>        area += dfs(grid, i+di[k], j+dj[k])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> area<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    nodes := []<span class="hljs-type">int</span>&#123;&#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        nodes = <span class="hljs-built_in">append</span>(nodes, node.Val)<br>        sum += node.Val<br>        <span class="hljs-keyword">if</span> sum == targetSum &#123;<br>            <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>                res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, nodes...))<br>            &#125;<br>        &#125;<br>        dfs(node.Left)<br>        dfs(node.Right)<br>        sum -= node.Val<br>        nodes = nodes[:<span class="hljs-built_in">len</span>(nodes)<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    dfs(root)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 广度优先搜索 + 二叉树节点编号性质</span><br><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span> &#123;<br>    node *TreeNode<br>    index <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    q := []pair&#123;&#123;root, <span class="hljs-number">1</span>&#125;&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        res = max(res, q[<span class="hljs-built_in">len</span>(q)<span class="hljs-number">-1</span>].index - q[<span class="hljs-number">0</span>].index + <span class="hljs-number">1</span>)<br>        tmp := []pair&#123;&#125;<br>        <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> q &#123;<br>            <span class="hljs-keyword">if</span> p.node.Left != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, pair&#123;p.node.Left, p.index * <span class="hljs-number">2</span>&#125;)<br>            &#125;<br>            <span class="hljs-keyword">if</span> p.node.Right != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, pair&#123;p.node.Right, p.index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125;)<br>            &#125;<br>        &#125;<br>        q = tmp<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := nums[<span class="hljs-number">0</span>]<br>    mx := nums[<span class="hljs-number">0</span>]<br>    mn := nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// 这里mx，mn的计算互不干扰，均使用上一次的结果计算</span><br>        mx, mn = max(nums[i], max(mx * nums[i], mn * nums[i])), min(nums[i], min(mx * nums[i], mn * nums[i]))<br>        res = max(res, mx)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> targetSum == root.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 如果只有一间房，则偷取该间房</span><br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 如果有两间房，则偷取金额大的那一间</span><br>    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果偷取第i间房，则到达i位置时的总金额为，前i-2间房偷到的数额加上第i间房</span><br>        <span class="hljs-comment">// 如果不偷第i间房，则到达i位置时的总金额为，前i-1间房偷到的总数额</span><br>        dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 记录最终结果</span><br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 记录从开头到当前位置的和</span><br>    pre := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// key：前缀和，value：个数</span><br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        pre += nums[i]<br>        <span class="hljs-keyword">if</span> _, ok := m[pre-k]; ok &#123;<br>            count += m[pre-k]<br>        &#125;<br>        m[pre] += <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 摩尔投票法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-number">0</span><br>    candidate := nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> &#123;<br>            candidate = num<br>        &#125;<br>        <span class="hljs-keyword">if</span> num == candidate &#123;<br>            count += <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count -= <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> candidate<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    preSign := <span class="hljs-string">&#x27;+&#x27;</span><br>    num := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s &#123;<br>        isDigit := <span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span><br>        <span class="hljs-keyword">if</span> isDigit &#123;<br>            num = num*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(ch-<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> !isDigit &amp;&amp; ch != <span class="hljs-string">&#x27; &#x27;</span> || i == <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">switch</span> preSign &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    stack = <span class="hljs-built_in">append</span>(stack, num)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    stack = <span class="hljs-built_in">append</span>(stack, -num)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] *= num<br>                <span class="hljs-keyword">default</span>:<br>                    stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] /= num<br>            &#125;<br>            preSign = ch<br>            num = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> stack &#123;<br>        res += v<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    cur := head<br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> cur.Val == cur.Next.Val &#123;<br>            cur.Next = cur.Next.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums1)<br>    m := <span class="hljs-built_in">len</span>(nums2)<br><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// dp[i][j]含义：nums1[:i+1]和nums2[:j+1]的最长公共后缀</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>        <span class="hljs-keyword">if</span> nums1[i] == nums2[<span class="hljs-number">0</span>] &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>        <span class="hljs-keyword">if</span> nums1[<span class="hljs-number">0</span>] == nums2[j] &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; m; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i] == nums2[j] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>                res = max(res, dp[i][j])<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span>  &#123;<br>    k = k % <span class="hljs-built_in">len</span>(nums)<br>    reverse(nums)<br>    reverse(nums[:k])<br>    reverse(nums[k:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a); i &lt; n / <span class="hljs-number">2</span>; i ++ &#123;<br>        a[i], a[n<span class="hljs-number">-1</span>-i] = a[n<span class="hljs-number">-1</span>-i], a[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;<br>    row := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(matrix))<br>    col := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> matrix &#123;<br>        <span class="hljs-keyword">for</span> j, v := <span class="hljs-keyword">range</span> r &#123;<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>                row[i] = <span class="hljs-literal">true</span><br>                col[j] = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> matrix &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> r &#123;<br>            <span class="hljs-keyword">if</span> row[i] || col[j] &#123;<br>                r[j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *Node</span><br><span class="hljs-comment"> *     Random *Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> cachedNode <span class="hljs-keyword">map</span>[*Node]*Node<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deepCopy</span><span class="hljs-params">(node *Node)</span></span> *Node &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n, has := cachedNode[node]; has &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    newNode := &amp;Node&#123;Val: node.Val&#125;<br>    cachedNode[node] = newNode<br>    newNode.Next = deepCopy(node.Next)<br>    newNode.Random = deepCopy(node.Random)<br>    <span class="hljs-keyword">return</span> newNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span></span> *Node &#123;<br>    cachedNode = <span class="hljs-keyword">map</span>[*Node]*Node&#123;&#125;<br>    <span class="hljs-keyword">return</span> deepCopy(head)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, left, right <span class="hljs-type">int</span>)</span></span> * TreeNode &#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right) / <span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>    root.Left = helper(nums, left, mid<span class="hljs-number">-1</span>)<br>    root.Right = helper(nums, mid+<span class="hljs-number">1</span>, right)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    list := preorderTraversal(root)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>        prev, curr := list[i<span class="hljs-number">-1</span>], list[i]<br>        prev.Left, prev.Right = <span class="hljs-literal">nil</span>, curr<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []*TreeNode &#123;<br>    list := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        list = <span class="hljs-built_in">append</span>(list, root)<br>        list = <span class="hljs-built_in">append</span>(list, preorderTraversal(root.Left)...)<br>        list = <span class="hljs-built_in">append</span>(list, preorderTraversal(root.Right)...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    ans := <span class="hljs-number">0</span><br>    preSum := <span class="hljs-keyword">map</span>[<span class="hljs-type">int64</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>&#125;<br>    <br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode, <span class="hljs-type">int64</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, curr <span class="hljs-type">int64</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        curr += <span class="hljs-type">int64</span>(node.Val)<br>        ans += preSum[curr-<span class="hljs-type">int64</span>(targetSum)]<br>        preSum[curr]++<br>        dfs(node.Left, curr)<br>        dfs(node.Right, curr)<br>        preSum[curr]--<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    dfs(root, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 总行数</span><br>    R := <span class="hljs-built_in">len</span>(grid)<br>    <span class="hljs-comment">// 总列数</span><br>    C := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 上下左右四个方向</span><br>    dr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>    dc := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br><br>    <span class="hljs-comment">// 用于辅助层次遍历</span><br>    queue := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 用于记录到达每个点位对应的深度</span><br>    depth := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 记录首层点位，深度均为0</span><br>    <span class="hljs-keyword">for</span> r := <span class="hljs-number">0</span>; r &lt; R; r++ &#123;<br>        <span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; C; c++ &#123;<br>            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-number">2</span> &#123;<br>                code := r * C + c<br>                queue = <span class="hljs-built_in">append</span>(queue, code)<br>                depth[code] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 进行层序遍历</span><br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        code := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        r := code / C<br>        c := code % C<br>        <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++ &#123;<br>            nr := r + dr[k]<br>            nc := c + dc[k]<br>            <span class="hljs-keyword">if</span> nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="hljs-number">1</span> &#123;<br>                grid[nr][nc] = <span class="hljs-number">2</span><br>                ncode := nr * C + nc<br>                queue = <span class="hljs-built_in">append</span>(queue, ncode)<br>                depth[ncode] = depth[code] + <span class="hljs-number">1</span><br>                <span class="hljs-comment">// 每次进入该if条件，则意味着到达了一个新鲜橘子，深度加1</span><br>                ans = depth[ncode]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否还有新鲜橘子</span><br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 记录所有节点的边，edges[i]含义为第i个节点所指向的所有节点</span><br>    edges := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-comment">// 记录每个节点的入度，即有多少个节点指向它</span><br>    indeg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-comment">// 记录拓扑排序，如果所有节点存在拓扑排序，则课程能正常修完</span><br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 保存所有节点的边和入度</span><br>    <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        edges[info[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(edges[info[<span class="hljs-number">1</span>]], info[<span class="hljs-number">0</span>])<br>        indeg[info[<span class="hljs-number">0</span>]]++<br>    &#125;<br><br>    <span class="hljs-comment">// 先将入度为0的节点入队</span><br>    q := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>        <span class="hljs-keyword">if</span> indeg[i] == <span class="hljs-number">0</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, i)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 广度优先搜索</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        u := q[<span class="hljs-number">0</span>]<br>        q = q[<span class="hljs-number">1</span>:]<br>        result = <span class="hljs-built_in">append</span>(result, u)<br>        <span class="hljs-comment">// 将u入队后，检查u指向的所有节点，将其入度减1</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> edges[u] &#123;<br>            indeg[v]--<br>            <span class="hljs-keyword">if</span> indeg[v] == <span class="hljs-number">0</span> &#123;<br>                q = <span class="hljs-built_in">append</span>(q, v)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(result) == numCourses<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>    children [<span class="hljs-number">26</span>]*Trie<br>    isEnd <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;<br>    <span class="hljs-keyword">return</span> Trie&#123;&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  &#123;<br>    node := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>        ch -= <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[ch] == <span class="hljs-literal">nil</span> &#123;<br>            node.children[ch] = &amp;Trie&#123;&#125;<br>        &#125;<br>        node = node.children[ch]<br>    &#125;<br>    node.isEnd = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> SearchPrefix(prefix <span class="hljs-type">string</span>) *Trie &#123;<br>    node := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> prefix &#123;<br>        ch -= <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[ch] == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        node = node.children[ch]<br>    &#125;<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    node := this.SearchPrefix(word)<br>    <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nil</span> &amp;&amp; node.isEnd<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> this.SearchPrefix(prefix) != <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Insert(word);</span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123;<br>    x <span class="hljs-type">int</span><br>    y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> directions = []pair&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    R := <span class="hljs-built_in">len</span>(board)<br>    C := <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, R)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> visit &#123;<br>        visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, C)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> check <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br>    check = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">if</span> board[i][j] != word[k] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        visit[i][j] = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            visit[i][j] = <span class="hljs-literal">false</span><br>        &#125;()<br><br>        <span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> directions &#123;<br>            newI := i + dir.x<br>            newJ := j + dir.y<br>            <span class="hljs-keyword">if</span> newI &gt;= <span class="hljs-number">0</span> &amp;&amp; newI &lt; R &amp;&amp; newJ &gt;= <span class="hljs-number">0</span> &amp;&amp; newJ &lt; C &amp;&amp; !visit[newI][newJ] &#123;<br>                <span class="hljs-keyword">if</span> check(newI, newJ, k+<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> board &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> check(i, j, <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    f := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f &#123;<br>        f[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> f[i] &#123;<br>            f[i][j] = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            f[i][j] = s[i] == s[j] &amp;&amp; f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    ans := [][]<span class="hljs-type">string</span>&#123;&#125;<br><br>    splits := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> i == n &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, <span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>), splits...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> f[i][j] &#123;<br>                splits = <span class="hljs-built_in">append</span>(splits, s[i:j+<span class="hljs-number">1</span>])<br>                dfs(j+<span class="hljs-number">1</span>)<br>                <span class="hljs-comment">// 放弃当前拆分方案，回退到原状</span><br>                splits = splits[:<span class="hljs-built_in">len</span>(splits)<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> solutions [][]<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 保存最终结果</span><br>    solutions = [][]<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录每一行的皇后放置在哪一列</span><br>    queens := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        queens[i] = <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-comment">// 记录哪些列已经放置了皇后</span><br>    columns := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录哪些对角已经放置了皇后</span><br>    diagonals1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    diagonals2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br><br>    backtrack(queens, n, <span class="hljs-number">0</span>, columns, diagonals1, diagonals2)<br><br>    <span class="hljs-keyword">return</span> solutions<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, n, row <span class="hljs-type">int</span>, columns, diagonals1, diagonals2 <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 如果row == n 说明已经产生了一个正确答案</span><br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        board := generateBoard(queens, n)<br>        solutions = <span class="hljs-built_in">append</span>(solutions, board)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 针对当前第row行，枚举每个列的位置，判断时候能放置皇后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果该列已经放置了皇后，继续下一列</span><br>        <span class="hljs-keyword">if</span> columns[i] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 如果对角已经放置了皇后，继续下一列</span><br>        diag1 := row - i<br>        <span class="hljs-keyword">if</span> diagonals1[diag1] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        diag2 := row + i<br>        <span class="hljs-keyword">if</span> diagonals2[diag2] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 记录第row行的皇后放置位置</span><br>        queens[row] = i<br>        <span class="hljs-comment">// 标记第i列已经放置皇后</span><br>        columns[i] = <span class="hljs-literal">true</span><br>        <span class="hljs-comment">// 标记对应的对角已经放置了皇后</span><br>        diagonals1[diag1] = <span class="hljs-literal">true</span><br>        diagonals2[diag2] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 在第row行放置了一个位置之后，继续进行下一行判断</span><br>        backtrack(queens, n, row+<span class="hljs-number">1</span>, columns, diagonals1, diagonals2)<br><br>        <span class="hljs-comment">// 恢复原本状态，继续寻找第row行的下一个解</span><br>        queens[row] = <span class="hljs-number">-1</span><br>        <span class="hljs-built_in">delete</span>(columns, i)<br>        <span class="hljs-built_in">delete</span>(diagonals1, diag1)<br>        <span class="hljs-built_in">delete</span>(diagonals2, diag2)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateBoard</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    board := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        row := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            row[j] = <span class="hljs-string">&#x27;.&#x27;</span><br>        &#125;<br>        row[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>        board = <span class="hljs-built_in">append</span>(board, <span class="hljs-type">string</span>(row))<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> board<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 核心思想：如果右半边升序，则最小值一定在左半边</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    low := <span class="hljs-number">0</span><br>    high := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        mid := (low + high) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[high] &#123;<br>            high = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[low]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(temperatures)<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        t := temperatures[i]<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; t &gt; temperatures[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &#123;<br>            idx := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            ans[idx] = i - idx<br>        &#125;<br>        stack = <span class="hljs-built_in">append</span>(stack, i)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    occur := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        occur[num]++<br>    &#125;<br><br>    h := &amp;IHeap&#123;&#125;<br>    heap.Init(h)<br><br>    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> occur &#123;<br>        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key, value&#125;)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123;<br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br>    ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        ret[k-i<span class="hljs-number">-1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-keyword">type</span> IHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>] &lt; h[j][<span class="hljs-number">1</span>]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;h[i], h[j] = h[j], h[i]&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>: n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MedianFinder <span class="hljs-keyword">struct</span> &#123;<br>    maxHeap *MaxHeap <span class="hljs-comment">// 存储较小的一半数字</span><br>    minHeap *MinHeap <span class="hljs-comment">// 存储较大的一半数字</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MedianFinder &#123;<br>    mf := MedianFinder&#123;<br>        maxHeap: &amp;MaxHeap&#123;&#125;,<br>        minHeap: &amp;MinHeap&#123;&#125;,<br>    &#125;<br>    heap.Init(mf.maxHeap)<br>    heap.Init(mf.minHeap)<br>    <span class="hljs-keyword">return</span> mf<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> AddNum(num <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-comment">// 总是先加入最大堆</span><br>    heap.Push(this.maxHeap, num)<br><br>    <span class="hljs-comment">// 将最大堆的最大值移到最小堆</span><br>    heap.Push(this.minHeap, heap.Pop(this.maxHeap))<br><br>    <span class="hljs-comment">// 如果最大堆的大小小于最小堆，平衡两个堆</span><br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() &lt; this.minHeap.Len() &#123;<br>        heap.Push(this.maxHeap, heap.Pop(this.minHeap))<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> FindMedian() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 或者根据需求返回其他默认值</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() &gt; this.minHeap.Len() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>((*this.maxHeap)[<span class="hljs-number">0</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">float64</span>((*this.maxHeap)[<span class="hljs-number">0</span>]) + <span class="hljs-type">float64</span>((*this.minHeap)[<span class="hljs-number">0</span>])) / <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-comment">// 最大堆（存储较小的一半数字）</span><br><span class="hljs-keyword">type</span> MaxHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &gt; h[j]&#125; <span class="hljs-comment">// 注意这里是 &gt;，实现最大堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Push(x any) &#123;*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Pop() any &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// 最小堆（存储较大的一半数字）</span><br><span class="hljs-keyword">type</span> MinHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &lt; h[j]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MinHeap)</span></span> Push(x any) &#123;*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MinHeap)</span></span> Pop() any &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.AddNum(num);</span><br><span class="hljs-comment"> * param_2 := obj.FindMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        dp[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang协程练习题</title>
    <link href="/2025/07/24/golang%E5%8D%8F%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2025/07/24/golang%E5%8D%8F%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="交替打印"><a href="#交替打印" class="headerlink" title="交替打印"></a>交替打印</h1><p>启动三个协程，交替打印1、2、3、3、2、1、1、2、3…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql</title>
    <link href="/2025/07/17/mysql/"/>
    <url>/2025/07/17/mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql学习笔记"><a href="#mysql学习笔记" class="headerlink" title="mysql学习笔记"></a>mysql学习笔记</h1><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="/2025/07/17/mysql/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png" alt="查询语句执行流程"></p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><h3 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">mysql -h$ip -u$<span class="hljs-keyword">user</span> <span class="hljs-title">-p</span><br></code></pre></td></tr></table></figure><p>连接的过程需要先经过 TCP 三次握手</p><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>连接上之后，连接器就会获取到用户的权限，然后保存起来，后续该用户在此连接里的任何操作都会基于开始时读到的权限进行判断，若管理员中途修改了权限，也不会影响已经存在的连接，只会影响新建立的连接。</p><h3 id="查看mysql服务被多少个客户端连接"><a href="#查看mysql服务被多少个客户端连接" class="headerlink" title="查看mysql服务被多少个客户端连接"></a>查看mysql服务被多少个客户端连接</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">show <span class="hljs-built_in">processlist</span><br></code></pre></td></tr></table></figure><h3 id="空闲连接会一直占用吗"><a href="#空闲连接会一直占用吗" class="headerlink" title="空闲连接会一直占用吗"></a>空闲连接会一直占用吗</h3><p>不是，由wait_timeout参数控制，默认8小时</p><h3 id="手动断开连接"><a href="#手动断开连接" class="headerlink" title="手动断开连接"></a>手动断开连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> connection +<span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><h3 id="连接数有限制吗"><a href="#连接数有限制吗" class="headerlink" title="连接数有限制吗"></a>连接数有限制吗</h3><p>有，由max_connections 参数控制，默认151个</p><h3 id="短连接、长连接"><a href="#短连接、长连接" class="headerlink" title="短连接、长连接"></a>短连接、长连接</h3><p>推荐使用长连接，减少连接的握手开销</p><p>mysql使用内存管理连接，连接数量过多会消耗内存空间，服务有可能被强制杀死</p><h3 id="怎么解决长连接占用内存问题"><a href="#怎么解决长连接占用内存问题" class="headerlink" title="怎么解决长连接占用内存问题"></a>怎么解决长连接占用内存问题</h3><p>定期断开长连接</p><p>客户端主动重置连接，会将连接重置为刚创建时的状态，释放多余的内存。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>只有select语句才会去查询缓存，缓存是以key，value的形式保存在内存中的，key为sql查询语句，value为sql语句的查询结果</p><p>当数据库中有更新操作时，会清空查询缓存</p><p>mysql在8.0版本去掉了查询缓存</p><h2 id="解析SQL"><a href="#解析SQL" class="headerlink" title="解析SQL"></a>解析SQL</h2><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>识别关键字和非关键字</p><table><thead><tr><th>关键字</th><th>非关键字</th><th>关键字</th><th>非关键字</th></tr></thead><tbody><tr><td>select</td><td>username</td><td>from</td><td>userinfo</td></tr></tbody></table><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>建立语法树，方便后续模块获取sql类型，表名，字段名</p><p><img src="/2025/07/17/mysql/db-mysql-sql-parser-2.png" alt="img"></p><h2 id="执行sql"><a href="#执行sql" class="headerlink" title="执行sql"></a>执行sql</h2><p>三个阶段</p><p>prepare，预处理</p><p>optimize，优化</p><p>execute，执行</p><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><ul><li>检查sql查询语句中的表或者字段是否存在</li><li>将select *中的星号扩展为表上的所有列</li></ul><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器负责确定执行方案，比如具体使用哪个索引</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>执行器调用存储引擎的接口查询数据，每接收到一条存储引擎发来的数据后都会判断是否符合条件，符合的话就发送给客户端，然后再向存储引擎查询下一条数据。</p><p>三种执行方式：</p><p>主键索引查询</p><p>全表扫描</p><p>索引下推：存储引擎在二级索引中进行查询时，定位到一条数据后，先不执行回表操作，而是判断一下该二级索引的b+树中包含的其他索引条件是否满足，若不满足，则没有必要回表查询了，直接跳过。</p><h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><p>原子性：要么全部成功，要么全部失败</p><p>一致性：事务完成时，所有数据要保持一致的状态</p><p>隔离性：在独立环境下运行，不受外部并发操作的影响</p><p>持久性：事务一旦提交或回滚，对数据库中的数据的改变是永久的</p><h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><p>脏读：一个事务读到另一个事务还没提交的数据</p><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同</p><p>幻读：一个事务按照条件查询数据的时候，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了幻影</p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>为了解决并发事务出现的问题，系统支持的隔离级别。级别越高，数据安全性越高，并发事务问题越少，性能越低。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read（默认）</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-六</title>
    <link href="/2025/06/12/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%85%AD/"/>
    <url>/2025/06/12/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="Go算法题-六"><a href="#Go算法题-六" class="headerlink" title="Go算法题-六"></a>Go算法题-六</h1><h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span>  &#123;<br>    k = k % <span class="hljs-built_in">len</span>(nums)<br>    reverse(nums)<br>    reverse(nums[:k])<br>    reverse(nums[k:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a); i &lt; n / <span class="hljs-number">2</span>; i ++ &#123;<br>        a[i], a[n<span class="hljs-number">-1</span>-i] = a[n<span class="hljs-number">-1</span>-i], a[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;<br>    row := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(matrix))<br>    col := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> matrix &#123;<br>        <span class="hljs-keyword">for</span> j, v := <span class="hljs-keyword">range</span> r &#123;<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>                row[i] = <span class="hljs-literal">true</span><br>                col[j] = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> matrix &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> r &#123;<br>            <span class="hljs-keyword">if</span> row[i] || col[j] &#123;<br>                r[j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *Node</span><br><span class="hljs-comment"> *     Random *Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> cachedNode <span class="hljs-keyword">map</span>[*Node]*Node<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deepCopy</span><span class="hljs-params">(node *Node)</span></span> *Node &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n, has := cachedNode[node]; has &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    newNode := &amp;Node&#123;Val: node.Val&#125;<br>    cachedNode[node] = newNode<br>    newNode.Next = deepCopy(node.Next)<br>    newNode.Random = deepCopy(node.Random)<br>    <span class="hljs-keyword">return</span> newNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span></span> *Node &#123;<br>    cachedNode = <span class="hljs-keyword">map</span>[*Node]*Node&#123;&#125;<br>    <span class="hljs-keyword">return</span> deepCopy(head)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, left, right <span class="hljs-type">int</span>)</span></span> * TreeNode &#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right) / <span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>    root.Left = helper(nums, left, mid<span class="hljs-number">-1</span>)<br>    root.Right = helper(nums, mid+<span class="hljs-number">1</span>, right)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    list := preorderTraversal(root)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>        prev, curr := list[i<span class="hljs-number">-1</span>], list[i]<br>        prev.Left, prev.Right = <span class="hljs-literal">nil</span>, curr<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []*TreeNode &#123;<br>    list := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        list = <span class="hljs-built_in">append</span>(list, root)<br>        list = <span class="hljs-built_in">append</span>(list, preorderTraversal(root.Left)...)<br>        list = <span class="hljs-built_in">append</span>(list, preorderTraversal(root.Right)...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    ans := <span class="hljs-number">0</span><br>    preSum := <span class="hljs-keyword">map</span>[<span class="hljs-type">int64</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>&#125;<br>    <br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode, <span class="hljs-type">int64</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, curr <span class="hljs-type">int64</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        curr += <span class="hljs-type">int64</span>(node.Val)<br>        ans += preSum[curr-<span class="hljs-type">int64</span>(targetSum)]<br>        preSum[curr]++<br>        dfs(node.Left, curr)<br>        dfs(node.Right, curr)<br>        preSum[curr]--<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    dfs(root, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 总行数</span><br>    R := <span class="hljs-built_in">len</span>(grid)<br>    <span class="hljs-comment">// 总列数</span><br>    C := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 上下左右四个方向</span><br>    dr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>    dc := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br><br>    <span class="hljs-comment">// 用于辅助层次遍历</span><br>    queue := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 用于记录到达每个点位对应的深度</span><br>    depth := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 记录首层点位，深度均为0</span><br>    <span class="hljs-keyword">for</span> r := <span class="hljs-number">0</span>; r &lt; R; r++ &#123;<br>        <span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; C; c++ &#123;<br>            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-number">2</span> &#123;<br>                code := r * C + c<br>                queue = <span class="hljs-built_in">append</span>(queue, code)<br>                depth[code] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 进行层序遍历</span><br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        code := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        r := code / C<br>        c := code % C<br>        <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++ &#123;<br>            nr := r + dr[k]<br>            nc := c + dc[k]<br>            <span class="hljs-keyword">if</span> nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="hljs-number">1</span> &#123;<br>                grid[nr][nc] = <span class="hljs-number">2</span><br>                ncode := nr * C + nc<br>                queue = <span class="hljs-built_in">append</span>(queue, ncode)<br>                depth[ncode] = depth[code] + <span class="hljs-number">1</span><br>                <span class="hljs-comment">// 每次进入该if条件，则意味着到达了一个新鲜橘子，深度加1</span><br>                ans = depth[ncode]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否还有新鲜橘子</span><br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 记录所有节点的边，edges[i]含义为第i个节点所指向的所有节点</span><br>    edges := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-comment">// 记录每个节点的入度，即有多少个节点指向它</span><br>    indeg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-comment">// 记录拓扑排序，如果所有节点存在拓扑排序，则课程能正常修完</span><br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 保存所有节点的边和入度</span><br>    <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        edges[info[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(edges[info[<span class="hljs-number">1</span>]], info[<span class="hljs-number">0</span>])<br>        indeg[info[<span class="hljs-number">0</span>]]++<br>    &#125;<br><br>    <span class="hljs-comment">// 先将入度为0的节点入队</span><br>    q := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>        <span class="hljs-keyword">if</span> indeg[i] == <span class="hljs-number">0</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, i)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 广度优先搜索</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        u := q[<span class="hljs-number">0</span>]<br>        q = q[<span class="hljs-number">1</span>:]<br>        result = <span class="hljs-built_in">append</span>(result, u)<br>        <span class="hljs-comment">// 将u入队后，检查u指向的所有节点，将其入度减1</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> edges[u] &#123;<br>            indeg[v]--<br>            <span class="hljs-keyword">if</span> indeg[v] == <span class="hljs-number">0</span> &#123;<br>                q = <span class="hljs-built_in">append</span>(q, v)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(result) == numCourses<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>    children [<span class="hljs-number">26</span>]*Trie<br>    isEnd <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;<br>    <span class="hljs-keyword">return</span> Trie&#123;&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  &#123;<br>    node := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>        ch -= <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[ch] == <span class="hljs-literal">nil</span> &#123;<br>            node.children[ch] = &amp;Trie&#123;&#125;<br>        &#125;<br>        node = node.children[ch]<br>    &#125;<br>    node.isEnd = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> SearchPrefix(prefix <span class="hljs-type">string</span>) *Trie &#123;<br>    node := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> prefix &#123;<br>        ch -= <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[ch] == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        node = node.children[ch]<br>    &#125;<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    node := this.SearchPrefix(word)<br>    <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nil</span> &amp;&amp; node.isEnd<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> this.SearchPrefix(prefix) != <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Insert(word);</span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123;<br>    x <span class="hljs-type">int</span><br>    y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> directions = []pair&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    R := <span class="hljs-built_in">len</span>(board)<br>    C := <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, R)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> visit &#123;<br>        visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, C)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> check <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br>    check = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">if</span> board[i][j] != word[k] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        visit[i][j] = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            visit[i][j] = <span class="hljs-literal">false</span><br>        &#125;()<br><br>        <span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> directions &#123;<br>            newI := i + dir.x<br>            newJ := j + dir.y<br>            <span class="hljs-keyword">if</span> newI &gt;= <span class="hljs-number">0</span> &amp;&amp; newI &lt; R &amp;&amp; newJ &gt;= <span class="hljs-number">0</span> &amp;&amp; newJ &lt; C &amp;&amp; !visit[newI][newJ] &#123;<br>                <span class="hljs-keyword">if</span> check(newI, newJ, k+<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> board &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> check(i, j, <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    f := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f &#123;<br>        f[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> f[i] &#123;<br>            f[i][j] = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            f[i][j] = s[i] == s[j] &amp;&amp; f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    ans := [][]<span class="hljs-type">string</span>&#123;&#125;<br><br>    splits := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> i == n &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, <span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>), splits...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> f[i][j] &#123;<br>                splits = <span class="hljs-built_in">append</span>(splits, s[i:j+<span class="hljs-number">1</span>])<br>                dfs(j+<span class="hljs-number">1</span>)<br>                <span class="hljs-comment">// 放弃当前拆分方案，回退到原状</span><br>                splits = splits[:<span class="hljs-built_in">len</span>(splits)<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> solutions [][]<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 保存最终结果</span><br>    solutions = [][]<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录每一行的皇后放置在哪一列</span><br>    queens := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        queens[i] = <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-comment">// 记录哪些列已经放置了皇后</span><br>    columns := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录哪些对角已经放置了皇后</span><br>    diagonals1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    diagonals2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br><br>    backtrack(queens, n, <span class="hljs-number">0</span>, columns, diagonals1, diagonals2)<br><br>    <span class="hljs-keyword">return</span> solutions<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, n, row <span class="hljs-type">int</span>, columns, diagonals1, diagonals2 <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 如果row == n 说明已经产生了一个正确答案</span><br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        board := generateBoard(queens, n)<br>        solutions = <span class="hljs-built_in">append</span>(solutions, board)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 针对当前第row行，枚举每个列的位置，判断时候能放置皇后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果该列已经放置了皇后，继续下一列</span><br>        <span class="hljs-keyword">if</span> columns[i] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 如果对角已经放置了皇后，继续下一列</span><br>        diag1 := row - i<br>        <span class="hljs-keyword">if</span> diagonals1[diag1] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        diag2 := row + i<br>        <span class="hljs-keyword">if</span> diagonals2[diag2] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 记录第row行的皇后放置位置</span><br>        queens[row] = i<br>        <span class="hljs-comment">// 标记第i列已经放置皇后</span><br>        columns[i] = <span class="hljs-literal">true</span><br>        <span class="hljs-comment">// 标记对应的对角已经放置了皇后</span><br>        diagonals1[diag1] = <span class="hljs-literal">true</span><br>        diagonals2[diag2] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 在第row行放置了一个位置之后，继续进行下一行判断</span><br>        backtrack(queens, n, row+<span class="hljs-number">1</span>, columns, diagonals1, diagonals2)<br><br>        <span class="hljs-comment">// 恢复原本状态，继续寻找第row行的下一个解</span><br>        queens[row] = <span class="hljs-number">-1</span><br>        <span class="hljs-built_in">delete</span>(columns, i)<br>        <span class="hljs-built_in">delete</span>(diagonals1, diag1)<br>        <span class="hljs-built_in">delete</span>(diagonals2, diag2)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateBoard</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    board := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        row := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            row[j] = <span class="hljs-string">&#x27;.&#x27;</span><br>        &#125;<br>        row[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>        board = <span class="hljs-built_in">append</span>(board, <span class="hljs-type">string</span>(row))<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> board<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 核心思想：如果右半边升序，则最小值一定在左半边</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    low := <span class="hljs-number">0</span><br>    high := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        mid := (low + high) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[high] &#123;<br>            high = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[low]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(temperatures)<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        t := temperatures[i]<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; t &gt; temperatures[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &#123;<br>            idx := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            ans[idx] = i - idx<br>        &#125;<br>        stack = <span class="hljs-built_in">append</span>(stack, i)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    occur := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        occur[num]++<br>    &#125;<br><br>    h := &amp;IHeap&#123;&#125;<br>    heap.Init(h)<br><br>    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> occur &#123;<br>        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key, value&#125;)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123;<br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br>    ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        ret[k-i<span class="hljs-number">-1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-keyword">type</span> IHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>] &lt; h[j][<span class="hljs-number">1</span>]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;h[i], h[j] = h[j], h[i]&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>: n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MedianFinder <span class="hljs-keyword">struct</span> &#123;<br>    maxHeap *MaxHeap <span class="hljs-comment">// 存储较小的一半数字</span><br>    minHeap *MinHeap <span class="hljs-comment">// 存储较大的一半数字</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MedianFinder &#123;<br>    mf := MedianFinder&#123;<br>        maxHeap: &amp;MaxHeap&#123;&#125;,<br>        minHeap: &amp;MinHeap&#123;&#125;,<br>    &#125;<br>    heap.Init(mf.maxHeap)<br>    heap.Init(mf.minHeap)<br>    <span class="hljs-keyword">return</span> mf<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> AddNum(num <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-comment">// 总是先加入最大堆</span><br>    heap.Push(this.maxHeap, num)<br><br>    <span class="hljs-comment">// 将最大堆的最大值移到最小堆</span><br>    heap.Push(this.minHeap, heap.Pop(this.maxHeap))<br><br>    <span class="hljs-comment">// 如果最大堆的大小小于最小堆，平衡两个堆</span><br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() &lt; this.minHeap.Len() &#123;<br>        heap.Push(this.maxHeap, heap.Pop(this.minHeap))<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> FindMedian() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 或者根据需求返回其他默认值</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() &gt; this.minHeap.Len() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>((*this.maxHeap)[<span class="hljs-number">0</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">float64</span>((*this.maxHeap)[<span class="hljs-number">0</span>]) + <span class="hljs-type">float64</span>((*this.minHeap)[<span class="hljs-number">0</span>])) / <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-comment">// 最大堆（存储较小的一半数字）</span><br><span class="hljs-keyword">type</span> MaxHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &gt; h[j]&#125; <span class="hljs-comment">// 注意这里是 &gt;，实现最大堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Push(x any) &#123;*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Pop() any &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// 最小堆（存储较大的一半数字）</span><br><span class="hljs-keyword">type</span> MinHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &lt; h[j]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MinHeap)</span></span> Push(x any) &#123;*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MinHeap)</span></span> Pop() any &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.AddNum(num);</span><br><span class="hljs-comment"> * param_2 := obj.FindMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        dp[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下查看日志常用命令</title>
    <link href="/2025/05/25/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/05/25/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux查看日志常用命令"><a href="#Linux查看日志常用命令" class="headerlink" title="Linux查看日志常用命令"></a>Linux查看日志常用命令</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>-f 实时监控</p><p>-n 指定行数</p><p>-c 指定字符数</p><p><code>tail test.log</code> 默认显示最后10行</p><p><code>tail -n +20 test.log</code> 显示从第20行至末尾。</p><p><code>tail -f test.log</code> 默认显示最后10行，并实时监控，若有新增加的行则继续显示，直到退出程序。</p><p><code>tail -c 10 notes.log</code> 显示最后10个字符</p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>与tail相反</p><p><code>head test.log</code> 默认显示开头10行</p><p><code>head -n 20 test.log</code> 显示开头20行</p><p><code>head -c 20 test.log</code> 显示开头20个字符</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-5</title>
    <link href="/2025/05/21/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%94/"/>
    <url>/2025/05/21/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 利用性质 + 每次二分丢弃一半选项</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-comment">// 辅助函数，输入下标 i，返回 nums[i] 的值</span><br>    <span class="hljs-comment">// 方便处理 nums[-1] 以及 nums[n] 的边界情况</span><br>    get := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> || i == n &#123;<br>            <span class="hljs-keyword">return</span> math.MinInt64<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[i]<br>    &#125;<br><br>    left := <span class="hljs-number">0</span><br>    right := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> get(mid<span class="hljs-number">-1</span>) &lt; get(mid) &amp;&amp; get(mid) &gt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-keyword">if</span> get(mid) &lt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<br>            res = max(dfs(grid, i, j), res)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == <span class="hljs-built_in">len</span>(grid) || j == <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) || grid[i][j] != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    grid[i][j] = <span class="hljs-number">0</span><br>    area := <span class="hljs-number">1</span><br>    di := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;<br>    dj := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(di); k++ &#123;<br>        area += dfs(grid, i+di[k], j+dj[k])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> area<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    nodes := []<span class="hljs-type">int</span>&#123;&#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        nodes = <span class="hljs-built_in">append</span>(nodes, node.Val)<br>        sum += node.Val<br>        <span class="hljs-keyword">if</span> sum == targetSum &#123;<br>            <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>                res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, nodes...))<br>            &#125;<br>        &#125;<br>        dfs(node.Left)<br>        dfs(node.Right)<br>        sum -= node.Val<br>        nodes = nodes[:<span class="hljs-built_in">len</span>(nodes)<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    dfs(root)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 广度优先搜索 + 二叉树节点编号性质</span><br><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span> &#123;<br>    node *TreeNode<br>    index <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    q := []pair&#123;&#123;root, <span class="hljs-number">1</span>&#125;&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        res = max(res, q[<span class="hljs-built_in">len</span>(q)<span class="hljs-number">-1</span>].index - q[<span class="hljs-number">0</span>].index + <span class="hljs-number">1</span>)<br>        tmp := []pair&#123;&#125;<br>        <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> q &#123;<br>            <span class="hljs-keyword">if</span> p.node.Left != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, pair&#123;p.node.Left, p.index * <span class="hljs-number">2</span>&#125;)<br>            &#125;<br>            <span class="hljs-keyword">if</span> p.node.Right != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, pair&#123;p.node.Right, p.index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125;)<br>            &#125;<br>        &#125;<br>        q = tmp<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := nums[<span class="hljs-number">0</span>]<br>    mx := nums[<span class="hljs-number">0</span>]<br>    mn := nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// 这里mx，mn的计算互不干扰，均使用上一次的结果计算</span><br>        mx, mn = max(nums[i], max(mx * nums[i], mn * nums[i])), min(nums[i], min(mx * nums[i], mn * nums[i]))<br>        res = max(res, mx)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> targetSum == root.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 如果只有一间房，则偷取该间房</span><br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 如果有两间房，则偷取金额大的那一间</span><br>    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果偷取第i间房，则到达i位置时的总金额为，前i-2间房偷到的数额加上第i间房</span><br>        <span class="hljs-comment">// 如果不偷第i间房，则到达i位置时的总金额为，前i-1间房偷到的总数额</span><br>        dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 记录最终结果</span><br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 记录从开头到当前位置的和</span><br>    pre := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// key：前缀和，value：个数</span><br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        pre += nums[i]<br>        <span class="hljs-keyword">if</span> _, ok := m[pre-k]; ok &#123;<br>            count += m[pre-k]<br>        &#125;<br>        m[pre] += <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 摩尔投票法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-number">0</span><br>    candidate := nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> &#123;<br>            candidate = num<br>        &#125;<br>        <span class="hljs-keyword">if</span> num == candidate &#123;<br>            count += <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count -= <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> candidate<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    preSign := <span class="hljs-string">&#x27;+&#x27;</span><br>    num := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s &#123;<br>        isDigit := <span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span><br>        <span class="hljs-keyword">if</span> isDigit &#123;<br>            num = num*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(ch-<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> !isDigit &amp;&amp; ch != <span class="hljs-string">&#x27; &#x27;</span> || i == <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">switch</span> preSign &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    stack = <span class="hljs-built_in">append</span>(stack, num)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    stack = <span class="hljs-built_in">append</span>(stack, -num)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] *= num<br>                <span class="hljs-keyword">default</span>:<br>                    stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] /= num<br>            &#125;<br>            preSign = ch<br>            num = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> stack &#123;<br>        res += v<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    cur := head<br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> cur.Val == cur.Next.Val &#123;<br>            cur.Next = cur.Next.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums1)<br>    m := <span class="hljs-built_in">len</span>(nums2)<br><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// dp[i][j]含义：nums1[:i+1]和nums2[:j+1]的最长公共后缀</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>        <span class="hljs-keyword">if</span> nums1[i] == nums2[<span class="hljs-number">0</span>] &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>        <span class="hljs-keyword">if</span> nums1[<span class="hljs-number">0</span>] == nums2[j] &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; m; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i] == nums2[j] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>                res = max(res, dp[i][j])<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-四</title>
    <link href="/2025/05/19/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%9B%9B/"/>
    <url>/2025/05/19/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    comb := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 当前索引超过了数组总长度</span><br>        <span class="hljs-keyword">if</span> idx == <span class="hljs-built_in">len</span>(candidates) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// target减到了0，说明找到了一个答案</span><br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, comb...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 考虑选择当前元素</span><br>        <span class="hljs-keyword">if</span> target - candidates[idx] &gt;= <span class="hljs-number">0</span> &#123;<br>            comb = <span class="hljs-built_in">append</span>(comb, candidates[idx])<br>            dfs(target-candidates[idx], idx)<br>            comb = comb[:<span class="hljs-built_in">len</span>(comb)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// 不考虑当前元素</span><br>        dfs(target, idx+<span class="hljs-number">1</span>)<br>    &#125;<br>    dfs(target, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    stack := []<span class="hljs-type">string</span>&#123;&#125;<br>    p := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> p &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        cur := s[p]<br>        <span class="hljs-comment">// 如果遍历到数字，就取出所有的后续数字，得到整数字符串后，将其压入栈中</span><br>        <span class="hljs-keyword">if</span> cur &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>            digits := getDigits(s, &amp;p)<br>            stack = <span class="hljs-built_in">append</span>(stack, digits)<br>        <span class="hljs-comment">// 如果遇到字符或左括号，直接压栈</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || cur &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || cur == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-type">string</span>(cur))<br>            p++<br>        <span class="hljs-comment">// 如果遇到右括号</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 持续出栈字符，直到遇到左括号，此时sub中保存了所有的出栈字符</span><br>            sub := []<span class="hljs-type">string</span>&#123;&#125;<br>            <span class="hljs-keyword">for</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != <span class="hljs-string">&quot;[&quot;</span> &#123;<br>                sub = <span class="hljs-built_in">append</span>(sub, stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            &#125;<br>            <span class="hljs-comment">// 将sub中的字符反转，得到正常的字符顺序</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sub)/<span class="hljs-number">2</span>; i++ &#123;<br>                sub[i], sub[<span class="hljs-built_in">len</span>(sub)<span class="hljs-number">-1</span>-i] = sub[<span class="hljs-built_in">len</span>(sub)<span class="hljs-number">-1</span>-i], sub[i]<br>            &#125;<br><br>            <span class="hljs-comment">// 将左括号出栈</span><br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br><br>            <span class="hljs-comment">// 此时栈顶保存的是整数，将此整数出栈，并进行重复处理</span><br>            repTime, _ := strconv.Atoi(stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            t := strings.Repeat(getString(sub), repTime)<br>            <span class="hljs-comment">// 重点，将重复后的字符串重新压入栈中</span><br>            stack = <span class="hljs-built_in">append</span>(stack, t)<br><br>            <span class="hljs-comment">// 继续判断下一个字符</span><br>            p++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> getString(stack)<br>&#125;<br><br><span class="hljs-comment">// 取出所有的后续数字，组成一个整数字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getDigits</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> ; s[*p] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[*p] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; *p++ &#123;<br>        res += <span class="hljs-type">string</span>(s[*p])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getString</span><span class="hljs-params">(v []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> v &#123;<br>        res += s<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> abs(height(root.Left) - height(root.Right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">height</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(height(root.Left), height(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> * x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    rows := <span class="hljs-built_in">len</span>(grid)<br>    cols := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, rows)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dp); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, cols)<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; rows; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; cols; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][j]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; rows; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; cols; j++ &#123;<br>            dp[i][j] = min(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]) + grid[i][j]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[rows<span class="hljs-number">-1</span>][cols<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">## [470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/)</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        row := rand7()<br>        col := rand7()<br>        idx := (row<span class="hljs-number">-1</span>)*<span class="hljs-number">7</span> + col<br>        <span class="hljs-keyword">if</span> idx &lt;= <span class="hljs-number">40</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + (idx<span class="hljs-number">-1</span>)%<span class="hljs-number">10</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(matrix)<br>    n := <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    x := <span class="hljs-number">0</span><br>    y := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> matrix[x][y] == target &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">// 如果当前元素大，就往小了走，往小了走就是往左移动</span><br>        <span class="hljs-keyword">if</span> matrix[x][y] &gt; target &#123;<br>            y--<br>        <span class="hljs-comment">// 如果当前元素小，就往大了走，往大了走就是往下走</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(root *TreeNode, lower, upper <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> depth <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span><br>    depth = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        l := depth(root.Left)<br>        r := depth(root.Right)<br><br>        res = max(res, l + r + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">return</span> max(l, r) + <span class="hljs-number">1</span><br>    &#125;<br><br>    depth(root)<br><br>    <span class="hljs-keyword">return</span> res - <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSide := <span class="hljs-number">0</span><br><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix[i]))<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            dp[i][j] = <span class="hljs-type">int</span>(matrix[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                maxSide = <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                dp[i][j] = min(min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> dp[i][j] &gt; maxSide &#123;<br>                    maxSide = dp[i][j]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSide * maxSide<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    numSet := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        numSet[num] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    maxLength := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> numSet &#123;<br>        <span class="hljs-keyword">if</span> !numSet[num<span class="hljs-number">-1</span>] &#123;<br>            curNum := num<br>            curLength := <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> numSet[curNum+<span class="hljs-number">1</span>] &#123;<br>                curNum++<br>                curLength++<br>            &#125;<br>            <span class="hljs-keyword">if</span> curLength &gt; maxLength &#123;<br>                maxLength = curLength<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLength<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 贪心法，只能用于计算最大利润</span><br><span class="hljs-comment">// 思想：所有的利润都要有，所有的亏损都不要。即：只要后一天比前一天价格高，这部分差价就是利润</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        res += max(<span class="hljs-number">0</span>, prices[i]-prices[i<span class="hljs-number">-1</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// // 递归，本质是利用栈</span><br><span class="hljs-comment">// func isPalindrome(head *ListNode) bool &#123;</span><br><span class="hljs-comment">//     // 递归函数外指针，指向链表头部</span><br><span class="hljs-comment">//     p := head</span><br><br><span class="hljs-comment">//     var check func(*ListNode) bool</span><br><span class="hljs-comment">//     check = func(node *ListNode) bool &#123;</span><br><span class="hljs-comment">//         if node != nil &#123;</span><br><span class="hljs-comment">//             // 一开始就进入递归，实际效果上会把当前节点压入函数栈中，并且会一直压到最后一个节点</span><br><span class="hljs-comment">//             // 当开始出栈时，实际就是从最后一个节点往前遍历了</span><br><span class="hljs-comment">//             if !check(node.Next) &#123;</span><br><span class="hljs-comment">//                 return false</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//             // 判断递归外指针与当前节点的值</span><br><span class="hljs-comment">//             if node.Val != p.Val &#123;</span><br><span class="hljs-comment">//                 return false</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//             // 外指针向后移动一位</span><br><span class="hljs-comment">//             p = p.Next</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//         return true</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-comment">//     return check(head)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 快慢指针找中点 + 反转链表 + 遍历对比</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> prev, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        nextTmp := cur.Next<br>        cur.Next = prev<br>        prev = cur<br>        cur = nextTmp<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">endOfFirstHalf</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    fast := head<br>    slow := head<br>    <span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 找到前半部分链表的尾节点并反转后半部分链表</span><br>    firstHalfEnd := endOfFirstHalf(head)<br>    secondHalfStart := reverseList(firstHalfEnd.Next)<br><br>    <span class="hljs-comment">// 判断是否回文</span><br>    p1 := head<br>    p2 := secondHalfStart<br>    result := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> result &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1.Val != p2.Val &#123;<br>            result = <span class="hljs-literal">false</span><br>        &#125;<br>        p1 = p1.Next<br>        p2 = p2.Next<br>    &#125;<br><br>    <span class="hljs-comment">// 还原链表并返回结果</span><br>    firstHalfEnd.Next = reverseList(secondHalfStart)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-三</title>
    <link href="/2025/05/13/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%89/"/>
    <url>/2025/05/13/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    l := <span class="hljs-number">0</span><br>    r := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>            l = mid + <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            r = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>    inStack, outStack []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br>    <span class="hljs-keyword">return</span> MyQueue&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>    q.inStack = <span class="hljs-built_in">append</span>(q.inStack, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> in2out() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.inStack) &gt; <span class="hljs-number">0</span> &#123;<br>        q.outStack = <span class="hljs-built_in">append</span>(q.outStack, q.inStack[<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>])<br>        q.inStack = q.inStack[:<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;<br>        q.in2out()<br>    &#125;<br>    x := q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>    q.outStack = q.outStack[:<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;<br>        q.in2out()<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.inStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 归并排序两个有序链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(head1, head2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p, p1, p2 := dummy, head1, head2<br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1.Val &lt; p2.Val &#123;<br>            p.Next = p1<br>            p1 = p1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = p2<br>            p2 = p2.Next<br>        &#125;<br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> p1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p1<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p2 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p2<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-comment">// 拆分一个链表，分别递归排序，将排好序的两个链表合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(head, tail *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    <br>    <span class="hljs-comment">// 丢弃尾部节点，避免重复</span><br>    <span class="hljs-keyword">if</span> head.Next == tail &#123;<br>        head.Next = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != tail &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>        <span class="hljs-keyword">if</span> fast != tail &#123;<br>            fast = fast.Next<br>        &#125;<br>    &#125;<br><br>    mid := slow<br>    <span class="hljs-comment">// 这里将mid分别作为头和尾递归传递，但作为尾部的mid最终会被丢弃，不会出现mid节点重复的问题</span><br>    <span class="hljs-keyword">return</span> merge(sort(head, mid), sort(mid, tail))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> sort(head, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 用于保存结果集</span><br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 用于保存每一步的结果</span><br>    tmp := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 回溯法，每个位置上要么放左括号，要么放右括号</span><br>    <span class="hljs-comment">// 放的时候校验下合不合法</span><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leftCount, rightCount <span class="hljs-type">int</span>)</span></span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leftCount, rightCount <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 长度达到2n，找到一个答案，加入结果集</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp) == <span class="hljs-number">2</span>*n &#123;<br>            res = <span class="hljs-built_in">append</span>(res, strings.Join(tmp, <span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 只要左括号数量小于n，当前位置放左括号就是合法的</span><br>        <span class="hljs-keyword">if</span> leftCount &lt; n &#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-string">&quot;(&quot;</span>)<br>            backtrack(leftCount+<span class="hljs-number">1</span>, rightCount)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// 只要右括号数量小于左括号，当前位置放右括号就是合法的</span><br>        <span class="hljs-keyword">if</span> rightCount &lt; leftCount &#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-string">&quot;)&quot;</span>)<br>            backtrack(leftCount, rightCount+<span class="hljs-number">1</span>)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 唉，背诵题，原理看题解吧</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    i := n - <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>] &#123;<br>        i--<br>    &#125;<br>    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        j := n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j] &#123;<br>            j--<br>        &#125;<br>        nums[i], nums[j] = nums[j], nums[i]<br>    &#125;<br>    reverse(nums[i+<span class="hljs-number">1</span>:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a); i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br>        a[i], a[n<span class="hljs-number">-1</span>-i] = a[n<span class="hljs-number">-1</span>-i], a[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    v1 := strings.Split(version1, <span class="hljs-string">&quot;.&quot;</span>)<br>    v2 := strings.Split(version2, <span class="hljs-string">&quot;.&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(v1) || i &lt; <span class="hljs-built_in">len</span>(v2); i++ &#123;<br>        x, y := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(v1) &#123;<br>            x, _ = strconv.Atoi(v1[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(v2) &#123;<br>            y, _ = strconv.Atoi(v2[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> x &gt; y &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> x &lt; y &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, x<br>    ans := <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> mid * mid &lt;= x &#123;<br>            ans = mid<br>            l = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 去除前导空格</span><br>s = strings.TrimLeft(s, <span class="hljs-string">&quot; &quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 处理符号</span><br>sign := <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>sign = <span class="hljs-number">-1</span><br>s = s[<span class="hljs-number">1</span>:]<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> &#123;<br>s = s[<span class="hljs-number">1</span>:]<br>&#125;<br><br><span class="hljs-keyword">var</span> result <span class="hljs-type">int64</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-comment">// 遇到非数字字符则停止</span><br><span class="hljs-keyword">if</span> ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br>digit := <span class="hljs-type">int64</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>)<br>result = result*<span class="hljs-number">10</span> + digit<br><br><span class="hljs-comment">// 检查溢出</span><br><span class="hljs-keyword">if</span> sign == <span class="hljs-number">1</span> &amp;&amp; result &gt; math.MaxInt32 &#123;<br><span class="hljs-keyword">return</span> math.MaxInt32<br>&#125;<br><span class="hljs-keyword">if</span> sign == <span class="hljs-number">-1</span> &amp;&amp; -result &lt; math.MinInt32 &#123;<br><span class="hljs-keyword">return</span> math.MinInt32<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 应用符号</span><br>final := <span class="hljs-type">int64</span>(sign) * result<br><br><span class="hljs-comment">// 确保结果在32位整数范围内</span><br><span class="hljs-keyword">if</span> final &gt; math.MaxInt32 &#123;<br><span class="hljs-keyword">return</span> math.MaxInt32<br>&#125;<br><span class="hljs-keyword">if</span> final &lt; math.MinInt32 &#123;<br><span class="hljs-keyword">return</span> math.MinInt32<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(final)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p := dummy<br>    digit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> || l2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">var</span> v1, v2 <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> l1 != <span class="hljs-literal">nil</span> &#123;<br>            v1 = l1.Val<br>            l1 = l1.Next<br>        &#125;<br>        <span class="hljs-keyword">if</span> l2 != <span class="hljs-literal">nil</span> &#123;<br>            v2 = l2.Val<br>            l2 = l2.Next<br>        &#125;<br><br>        sum := v1 + v2 + digit<br>        <br>        val := sum % <span class="hljs-number">10</span><br><br>        node := &amp;ListNode&#123;Val: val&#125;<br>        p.Next = node<br>        p = p.Next<br><br>        digit = sum / <span class="hljs-number">10</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> digit != <span class="hljs-number">0</span> &#123;<br>        p.Next = &amp;ListNode&#123;Val: digit&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 用于保存最终结果</span><br>    res := <span class="hljs-number">0</span><br>    <br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-comment">// 为了初始时方便，提前压入-1</span><br>    stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-comment">// 如果是左括号，就压入栈中</span><br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, i)<br>        <span class="hljs-comment">// 如果是右括号，就将栈顶元素出栈（除了栈底元素，栈中肯定全部都是左括号。栈底元素是遍历过的最后的没有被匹配的右括号）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            <span class="hljs-comment">// 如果出栈后栈空了，就说明栈底的右括号被出栈了，那么当前的右括号就成了新的不能被匹配的右括号，压入栈中成为新的栈底</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, i)<br>            <span class="hljs-comment">// 实时更新最长的匹配长度</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res = max(res, i - stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt; n + <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    root := &amp;TreeNode&#123;preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br><br>    <span class="hljs-comment">// 找到中序遍历中的根节点</span><br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 中序遍历根节点左边的节点为左子树，右边的节点为右子树</span><br>    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>], inorder[:i])<br>    root.Right = buildTree(preorder[<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>:], inorder[i+<span class="hljs-number">1</span>:])<br><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    set := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cur <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 如果长度已经超过了nums长度，说明已经得到了一个结果</span><br>        <span class="hljs-keyword">if</span> cur == <span class="hljs-built_in">len</span>(nums) &#123;<br>            <span class="hljs-comment">// 这里要注意，不要把set直接append到结果集中，因为后面还要对set进行修改，引用传递，会受影响</span><br>            <span class="hljs-comment">// 创建一个新的数组，加入结果集中</span><br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, set...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 选择当前元素</span><br>        set = <span class="hljs-built_in">append</span>(set, nums[cur])<br>        dfs(cur+<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment">// 不选择当前元素</span><br>        set = set[:<span class="hljs-built_in">len</span>(set)<span class="hljs-number">-1</span>]<br>        dfs(cur+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 去除两端空格</span><br>    s = strings.Trim(s, <span class="hljs-string">&quot; &quot;</span>)<br><br>    <span class="hljs-comment">// 双指针</span><br>    i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    j := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 从后向前遍历</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 搜索首个空格</span><br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            i -= <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-comment">// 记录单词</span><br>        res = <span class="hljs-built_in">append</span>(res, s[i+<span class="hljs-number">1</span>:j+<span class="hljs-number">1</span>])<br>        <span class="hljs-comment">// 跳过单词间空格</span><br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            i -= <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-comment">// j指向下个单词的尾字符</span><br>        j = i<br>    &#125;<br><br>    <span class="hljs-comment">// 拼接返回</span><br>    <span class="hljs-keyword">return</span> strings.Join(res, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 思路：使用一个辅助栈，每次压栈时同步往辅助栈中压入当前最小值，出栈时也是同步出栈。</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-type">int</span><br>    minStack []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        stack: []<span class="hljs-type">int</span>&#123;&#125;,<br>        minStack: []<span class="hljs-type">int</span>&#123;math.MaxInt64&#125;,<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    this.stack = <span class="hljs-built_in">append</span>(this.stack, val)<br>    top := this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>    this.minStack = <span class="hljs-built_in">append</span>(this.minStack, min(val, top))<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop()  &#123;<br>    this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>    this.minStack = this.minStack[:<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用单个栈的解法，通过向栈中压入差值实现</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-type">int</span><br>    minValue <span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        stack: []<span class="hljs-type">int</span>&#123;&#125;,<br>        minValue: <span class="hljs-number">-1</span>,<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        this.stack = <span class="hljs-built_in">append</span>(this.stack, <span class="hljs-number">0</span>)<br>        this.minValue = val<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        diff := val - this.minValue<br>        this.stack = <span class="hljs-built_in">append</span>(this.stack, diff)<br>        <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> &#123;<br>            this.minValue = val<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop()  &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    diff := this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>    this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br><br>    <span class="hljs-comment">// 如果diff小于0，则当前最小值就是栈顶的原始元素</span><br>    <span class="hljs-comment">// 并且，当前最小值 - diff就是上一次的最小值（参考push中的逻辑）</span><br>    <span class="hljs-comment">// 这里相当于在出栈时恢复上一次的最小值，是关键的一步</span><br>    <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> &#123;<br>        this.minValue = this.minValue - diff<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> this.minValue<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>] + this.minValue<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> this.minValue<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, prevSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum := prevSum * <span class="hljs-number">10</span> + root.Val<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(root.Left, sum) + dfs(root.Right, sum)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> check(root.Left, root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(p, q *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> || q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// lowerBound 返回最小的满足 nums[i] &gt;= target 的下标 i</span><br><span class="hljs-comment">// 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)</span><br><span class="hljs-comment">// 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> <span class="hljs-comment">// 闭区间 [left, right]</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left-1] &lt; target</span><br>        <span class="hljs-comment">// nums[right+1] &gt;= target</span><br>        mid := left + (right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;<br>            right = mid - <span class="hljs-number">1</span> <span class="hljs-comment">// 范围缩小到 [left, mid-1]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span> <span class="hljs-comment">// 范围缩小到 [mid+1, right]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束后 left = right+1</span><br>    <span class="hljs-comment">// 此时 nums[left-1] &lt; target 而 nums[left] = nums[right+1] &gt;= target</span><br>    <span class="hljs-comment">// 所以 left 就是第一个 &gt;= target 的元素下标</span><br>    <span class="hljs-keyword">return</span> left<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    start := lowerBound(nums, target)<br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) || nums[start] != target &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125; <span class="hljs-comment">// nums 中没有 target</span><br>    &#125;<br>    <span class="hljs-comment">// 如果 start 存在，那么 end 必定存在</span><br>    end := lowerBound(nums, target+<span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;start, end&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> preorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><br>    preorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, root.Val)<br>        preorder(root.Left)<br>        preorder(root.Right)<br>    &#125;<br>    preorder(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>apply之后的流程</title>
    <link href="/2025/04/28/apply%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2025/04/28/apply%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="kubectl-apply-f-xxxx-yaml之后的过程"><a href="#kubectl-apply-f-xxxx-yaml之后的过程" class="headerlink" title="kubectl apply -f xxxx.yaml之后的过程"></a>kubectl apply -f xxxx.yaml之后的过程</h1><p>整个过程首先从kubectl发起，以kubelet生成相应的pod为结束。</p><ul><li>kubectl<ol><li>验证和生成器</li><li>API 版本协商与 API 组</li><li>发送http请求到apiserver</li></ol></li><li>apiserver<ol><li>客户端身份认证</li><li>授权</li><li>准入控制</li><li>数据反序列化，存入etcd</li></ol></li><li>etcd<ol><li>获得数据</li><li>同步数据</li><li>保存数据</li></ol></li><li>controller-manager<ol><li>deploy-controller</li><li>ReplicaSet-controller</li><li>pod-controller</li></ol></li><li>scheduler<ol><li>预选策略</li><li>优选策略</li><li>绑定节点</li></ol></li><li>kubelet<ol><li>pod数据同步</li><li>初始化，资源，卷</li><li>CRI和pause容器</li><li>CNI和pod网络</li><li>容器启动过程</li></ol></li></ul><p><img src="/2025/04/28/apply%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/what-happens-when-k8s-c0b581cfa122439e84f0e697060fde49.svg" alt="whathappenswhenk8s.svg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go排序包sort</title>
    <link href="/2025/04/23/Go%E6%8E%92%E5%BA%8F%E5%8C%85sort/"/>
    <url>/2025/04/23/Go%E6%8E%92%E5%BA%8F%E5%8C%85sort/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-sort包"><a href="#Go-sort包" class="headerlink" title="Go sort包"></a>Go sort包</h1><p>参考：<a href="https://juejin.cn/post/7140873783362977828">https://juejin.cn/post/7140873783362977828</a></p><h2 id="三种基本类型升序排序"><a href="#三种基本类型升序排序" class="headerlink" title="三种基本类型升序排序"></a>三种基本类型升序排序</h2><p>如果要排序的切片是<code>int64, float64, string</code>类型，且是升序排序，可以使用下面三个函数进行排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Ints(x []<span class="hljs-type">int</span>)<br>sort.Float64s(x []<span class="hljs-type">float64</span>)<br>sort.Strings(x []<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><h2 id="sort-Sort-data-Interface"><a href="#sort-Sort-data-Interface" class="headerlink" title="sort.Sort(data Interface)"></a>sort.Sort(data Interface)</h2><p>这个函数可以对自定义类型的切片进行排序，前提是这种自定义类型得实现<code>Interface</code>接口.</p><p>任何实现了以下接口的类型，都可以调用<code>sort.Sort()</code>进行排序</p><p><strong>Interface</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>Len() <span class="hljs-type">int</span><br>Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br>Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>int类型举例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sortInt []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr sortInt)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(arr)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr sortInt)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> arr[i] &lt; arr[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr sortInt)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>arr[i], arr[j] = arr[j], arr[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>&#125;<br><span class="hljs-keyword">var</span> _arr sortInt = arr<br>sort.Sort(_arr)<br>sort.Sort(sort.Reverse(_arr))  <span class="hljs-comment">// 逆序排序</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>struct类型举例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> 代码解读复制代码<span class="hljs-keyword">type</span> Students []Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Students)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Students)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i].score &lt; s[j].score<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Students)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>s[i], s[j] = s[j], s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> students Students<br>students = []Student&#123;<br>Student&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">89</span>&#125;,<br>Student&#123;<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">98</span>&#125;,<br>Student&#123;<span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-number">78</span>&#125;,<br>&#125;<br>sort.Sort(students)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sort-Slice-x-interface-less-func-i-j-int-bool"><a href="#sort-Slice-x-interface-less-func-i-j-int-bool" class="headerlink" title="sort.Slice(x interface{}, less func(i, j int) bool)"></a>sort.Slice(x interface{}, less func(i, j int) bool)</h2><p>只需要传入一个自定义的比较函数就可以对切片进行排序，方便快捷。</p><p><strong>int类型举例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>&#125;<br>sort.Slice(arr, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> arr[i] &gt; arr[j]<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>struct类型举例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">students := []Student&#123;<br>Student&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">89</span>&#125;,<br>Student&#123;<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">98</span>&#125;,<br>Student&#123;<span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-number">78</span>&#125;,<br>&#125;<br>sort.Slice(students, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> students[i].score &gt; students[j].score<br>&#125;)<br>fmt.Println(students)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-二</title>
    <link href="/2025/04/21/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C/"/>
    <url>/2025/04/21/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 找到最近公共祖先 or 找到p/q本身</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// 如果已经到达底部，直接返回</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前节点是p或者q，返回该节点</span><br>    <span class="hljs-keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    <span class="hljs-comment">// 在左子树中找到最近公共祖先 或 在左子树中找到p/q</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br><br>    <span class="hljs-comment">// 在右子树中找到最近公共祖先 或 在右子树中找到p/q</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <br>    <span class="hljs-comment">// 左子树中找到了p/q，右子树中也找到了p/q</span><br>    <span class="hljs-comment">// 则当前节点为最近公共祖先（只有最近公共祖先满足该条件）</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    <span class="hljs-comment">// 如果只是找到了一个，则返回找到的那个，表示从该节点往下有一个p/q</span><br>    <span class="hljs-comment">// 如果都没找到，返回nil</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 头插法一次遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 设置dummy节点是此类问题的一般做法</span><br>    dummy := &amp;ListNode&#123;Next: head&#125;<br>    pre := dummy<br><br>    <span class="hljs-comment">// 找到left的前一个节点，作为pre</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++ &#123;<br>        pre = pre.Next<br>    &#125;<br><br>    <span class="hljs-comment">// left节点作为cur</span><br>    cur := pre.Next<br><br>    <span class="hljs-comment">// 从left开始遍历，每次循环把当前节点的后一个节点插入到pre后面（该段链表的头部）</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; right-left; i++ &#123;<br>        next := cur.Next<br>        cur.Next = next.Next<br>        next.Next = pre.Next<br>        pre.Next = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// dp[i]为组成数量为i的金额所需的最小硬币数</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 为dp[i]赋初始值</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++ &#123;<br>        <span class="hljs-comment">// 这里的amount+1并没有实际意义，仅仅是为了方便判断是否有解，任何一个大于amount的数均可</span><br>        <span class="hljs-comment">// 因为组成amount所需的硬币数量在任何情况下都不会大于amount</span><br>        dp[i] = amount + <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(coins); j++ &#123;<br>            <span class="hljs-keyword">if</span> coins[j] &lt;= i &#123;<br>                <span class="hljs-comment">// 组成i-coins[j]的最小硬币数，加上本次的一个硬币</span><br>                dp[i] = min(dp[i], dp[i-coins[j]] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> dp[amount] &gt; amount &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br><br>    rows, cols := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    order := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, rows * cols)<br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 记录边界</span><br>    left, right, top, bottom := <span class="hljs-number">0</span>, cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">// 在边界范围内移动</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &amp;&amp; top &lt;= bottom &#123;<br>        <span class="hljs-comment">// 从左往右移动，从最左端left开始，一直到最右端right</span><br>        <span class="hljs-keyword">for</span> col := left; col &lt;= right; col++ &#123;<br>            order[index] = matrix[top][col]<br>            index++<br>        &#125;<br>        <span class="hljs-comment">// 从上往下移动，从最上面的下一个元素开始，到最下端</span><br>        <span class="hljs-keyword">for</span> row := top + <span class="hljs-number">1</span>; row &lt;= bottom; row++ &#123;<br>            order[index] = matrix[row][right]<br>            index++<br>        &#125;<br>        <span class="hljs-comment">// 因为需要始终满足col &gt; left和row &gt; top，这里要保证数组访问不越界</span><br>        <span class="hljs-keyword">if</span> left &lt; right &amp;&amp; top &lt; bottom &#123;<br>            <span class="hljs-comment">// 从右往左移动</span><br>            <span class="hljs-keyword">for</span> col := right - <span class="hljs-number">1</span>; col &gt; left; col-- &#123;<br>                order[index] = matrix[bottom][col]<br>                index++<br>            &#125;<br>            <span class="hljs-comment">// 从下往上移动</span><br>            <span class="hljs-keyword">for</span> row := bottom; row &gt; top; row-- &#123;<br>                order[index] = matrix[row][left]<br>                index++<br>            &#125;<br>        &#125;<br>        left++<br>        right--<br>        top++<br>        bottom--<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> order<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    d := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">len</span> := <span class="hljs-number">1</span><br>    d[<span class="hljs-built_in">len</span>] = nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num &gt; d[<span class="hljs-built_in">len</span>] &#123;<br>            <span class="hljs-built_in">len</span>++<br>            d[<span class="hljs-built_in">len</span>] = num<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l := <span class="hljs-number">1</span><br>            r := <span class="hljs-built_in">len</span><br>            pos := <span class="hljs-number">0</span><br>            <span class="hljs-comment">// 找到比num小的最大的数</span><br>            <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>                mid := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> d[mid] &lt; num &#123;<br>                    pos = mid<br>                    l = mid + <span class="hljs-number">1</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>            d[pos+<span class="hljs-number">1</span>] = num<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lists)<span class="hljs-number">-1</span>)<br>&#125;<br><span class="hljs-comment">// 递归执行，将数组拆成左右两部分，分别合并为一个链表，最终再将两个链表合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(lists []*ListNode, l, r <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> l == r &#123;<br>        <span class="hljs-keyword">return</span> lists[l]<br>    &#125;<br>    <span class="hljs-keyword">if</span> l &gt; r &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (l + r) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid+<span class="hljs-number">1</span>, r))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(a, b *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    dummy := &amp;ListNode&#123;&#125;<br>    tail := dummy<br>    pa := a<br>    pb := b<br>    <span class="hljs-keyword">for</span> pa != <span class="hljs-literal">nil</span> &amp;&amp; pb != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> pa.Val &lt; pb.Val &#123;<br>            tail.Next = pa<br>            pa = pa.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.Next = pb<br>            pb = pb.Next<br>        &#125;<br>        tail = tail.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> pa != <span class="hljs-literal">nil</span> &#123;<br>        tail.Next = pa<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tail.Next = pb<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(head *ListNode)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    mid := middleNode(head)<br>    l1 := head<br>    l2 := mid.Next<br>    mid.Next = <span class="hljs-literal">nil</span><br><br>    l2 = reverseList(l2)<br><br>    mergeList(l1, l2)<br>&#125;<br><br><span class="hljs-comment">// 快慢指针找中点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleNode</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> pre, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br><span class="hljs-comment">// 交替合并链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(l1, l2 *ListNode)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> &amp;&amp; l2 != <span class="hljs-literal">nil</span> &#123;<br>        l1Next := l1.Next<br>        l2Next := l2.Next<br><br>        l1.Next = l2<br>        l1 = l1Next<br><br>        l2.Next = l1<br>        l2 = l2Next<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addStrings</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    add := <span class="hljs-number">0</span><br>    ans := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-built_in">len</span>(num1) - <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(num2) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add != <span class="hljs-number">0</span>; i, j = i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>            x = <span class="hljs-type">int</span>(num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> &#123;<br>            y = <span class="hljs-type">int</span>(num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        result := x + y + add<br>        <span class="hljs-comment">// result % 10 为当前位</span><br>        ans = strconv.Itoa(result % <span class="hljs-number">10</span>) + ans<br>        <span class="hljs-comment">// 向下一位的进位</span><br>        add = result / <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 哈希表存储</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    vis := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> p := headA; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>        vis[p] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> p := headB; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>        <span class="hljs-keyword">if</span> vis[p] &#123;<br>            <span class="hljs-keyword">return</span> p<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 双指针分别从两个链表头部开始遍历，遍历完后转到另一条链表头部遍历</span><br><span class="hljs-comment">// 若存在相交节点，则必定相遇（因为会走过相同距离x1+y+x2）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    pa, pb := headA, headB<br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = headB<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pa = pa.Next<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = headA<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pb = pb.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 先按照左端点进行排序</span><br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br><br>    <span class="hljs-comment">// 用于保存结果</span><br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 遍历排序后的区间</span><br>    <span class="hljs-keyword">for</span> _, interval := <span class="hljs-keyword">range</span> intervals &#123;<br>        n := <span class="hljs-built_in">len</span>(res)<br>        <span class="hljs-comment">// 没有重合：res中最后一个区间的右端点小于当前区间左端点</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>] &#123;<br>            res = <span class="hljs-built_in">append</span>(res, interval)<br>        <span class="hljs-comment">// 有重合，就拓展res中最后一个区间的右边界</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// leftMax[i]的含义是，从i这个位置往左看，最高的高度</span><br>    leftMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        leftMax[i] = max(leftMax[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br><br>    <span class="hljs-comment">// rightMax[i]的含义是，从i这个位置往右看，最高的高度</span><br>    rightMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    rightMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        rightMax[i] = max(rightMax[i+<span class="hljs-number">1</span>], height[i])<br>    &#125;<br><br>    res := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i, h := <span class="hljs-keyword">range</span> height &#123;<br>        res += min(leftMax[i], rightMax[i]) - h<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSum := math.MinInt32<br>    <span class="hljs-keyword">var</span> maxGain <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span> <span class="hljs-type">int</span><br>    maxGain = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br><br>        leftGain := max(maxGain(node.Left), <span class="hljs-number">0</span>)<br>        rightGain := max(maxGain(node.Right), <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment">// 将左子树路径-当前节点-右子树路径 连接起来组成新的一条路径</span><br>        <span class="hljs-comment">// 计算这条路径的和</span><br>        newPathPrice := node.Val + leftGain + rightGain<br><br>        <span class="hljs-comment">// 更新答案</span><br>        maxSum = max(maxSum, newPathPrice)<br><br>        <span class="hljs-comment">// 返回节点的最大贡献值。路径只向一个子树上延申</span><br>        <span class="hljs-keyword">return</span> node.Val + max(leftGain, rightGain)<br>    &#125;<br><br>    maxGain(root)<br><br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>)<br><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _, ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> head<br>        &#125;<br>        seen[head] = <span class="hljs-literal">true</span><br>        head = head.Next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>    <span class="hljs-comment">// dp[i][j]含义：以text1[i-1]结尾的字符串，和以text2[j-1]结尾的字符串之间的最长公共子序列长度</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, c1 := <span class="hljs-keyword">range</span> text1 &#123;<br>        <span class="hljs-keyword">for</span> j, c2 := <span class="hljs-keyword">range</span> text2 &#123;<br>            <span class="hljs-keyword">if</span> c1 == c2 &#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = max(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> SEG_COUNT = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">var</span> (<br>    ans []<span class="hljs-type">string</span><br>    segments []<span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    segments = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, SEG_COUNT)<br>    ans = []<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, segId, segStart <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// segId从0开始的，等于SEG_COUNT说明已经找到了4段</span><br>    <span class="hljs-comment">// segStart从0开始的，等于len(s)说明字符串已经遍历完了</span><br>    <span class="hljs-keyword">if</span> segId == SEG_COUNT &#123;<br>        <span class="hljs-keyword">if</span> segStart == <span class="hljs-built_in">len</span>(s) &#123;<br>            <span class="hljs-comment">// 将dfs过程中保存的segments数组转化成真正的ip字符串</span><br>            ipAddr := <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; SEG_COUNT; i++ &#123;<br>                ipAddr += strconv.Itoa(segments[i])<br>                <span class="hljs-keyword">if</span> i != SEG_COUNT - <span class="hljs-number">1</span> &#123;<br>                    ipAddr += <span class="hljs-string">&quot;.&quot;</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将ip字符串加入到结果集中</span><br>            ans = <span class="hljs-built_in">append</span>(ans, ipAddr)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果还没有找到4段，但字符串已经遍历完了，说明本次尝试无功而返，什么也不做，直接返回</span><br>    <span class="hljs-keyword">if</span> segStart == <span class="hljs-built_in">len</span>(s) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前段，遇到的第一个数字就是0，那么本段也只能为0。保存本段的0，然后开启向下的搜索</span><br>    <span class="hljs-keyword">if</span> s[segStart] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>        segments[segId] = <span class="hljs-number">0</span><br>        dfs(s, segId + <span class="hljs-number">1</span>, segStart + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 一般情况，枚举每一种可能性，并向下递归</span><br>    addr := <span class="hljs-number">0</span> <span class="hljs-comment">// 用来保存本段ip地址数值</span><br>    <span class="hljs-comment">// 从segStart开始尝试，i的总体限制是小于len(s)，但在前期遍历过程中达不到len(s) addr就超过255了</span><br>    <span class="hljs-comment">// 所以这里的for循环并不一定会遍历到len(s)，超过255退出即可，所有可能的结果都会在dfs过程中遍历到</span><br>    <span class="hljs-keyword">for</span> i := segStart; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        addr = addr * <span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-comment">// 如果本轮循环得到的addr数值符合要求，那么就找到了本段的一个解，记录之后向下递归寻找之后几段的解</span><br>        <span class="hljs-keyword">if</span> addr &gt; <span class="hljs-number">0</span> &amp;&amp; addr &lt;= <span class="hljs-number">0xFF</span> &#123;<br>            segments[segId] = addr<br>            dfs(s, segId + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 双指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br>    first, second := head, dummy<br>    <span class="hljs-comment">// first先往前走n步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br>    <span class="hljs-comment">// first和second同时往前走</span><br>    <span class="hljs-keyword">for</span> ; first != <span class="hljs-literal">nil</span>; first = first.Next &#123;<br>        second = second.Next<br>    &#125;<br>    second.Next = second.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br><br>    cur := dummy<br>    <span class="hljs-comment">// 每次都是对比当前节点的后两个节点</span><br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果后两个节点相等</span><br>        <span class="hljs-keyword">if</span> cur.Next.Val == cur.Next.Next.Val &#123;<br>            <span class="hljs-comment">// 记录相等节点的值</span><br>            x := cur.Next.Val<br>            <span class="hljs-comment">// 不停的跳过值为x的节点，注意这里cur是一直没变的，变化的是cur的下一个节点，</span><br>            <span class="hljs-comment">// 也就是说如果cur的下一个节点值为x，那么它就会被跳过</span><br>            <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Val == x &#123;<br>                cur.Next = cur.Next.Next<br>            &#125;<br>        <span class="hljs-comment">// 后两个节点不相等的情况下，cur才往后移动一位</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 层序遍历，右子树先入队，每层保留最右侧节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    q := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        p := []*TreeNode&#123;&#125;<br>        res = <span class="hljs-built_in">append</span>(res, q[<span class="hljs-number">0</span>].Val)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(q); j++ &#123;<br>            node := q[j]<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Left)<br>            &#125;<br>        &#125;<br>        q = p<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> inorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    inorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node * TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        inorder(node.Left)<br>        res = <span class="hljs-built_in">append</span>(res, node.Val)<br>        inorder(node.Right)<br>    &#125;<br><br>    inorder(root)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法题理论</title>
    <link href="/2025/04/20/%E7%AE%97%E6%B3%95%E9%A2%98%E7%90%86%E8%AE%BA/"/>
    <url>/2025/04/20/%E7%AE%97%E6%B3%95%E9%A2%98%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="算法题理论"><a href="#算法题理论" class="headerlink" title="算法题理论"></a>算法题理论</h1><h2 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h2><p>定义：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。</p><p>性质：（根节点为第1层，高度为k, 从1开始编号）</p><ol><li>总节点数：2^(k+1) -1, k&gt;&#x3D;0</li><li>编号为i的节点，i&gt;&#x3D;0，左子节点编号为：2i+1，右子节点编号为：2i+2，父节点：(i-1) &#x2F; 2</li></ol><h2 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h2><p>定义：以满二叉树为基础，最后一层右侧缺失部分节点的二叉树。</p><p>若一个数组代表完全二叉树层序遍历后的结果，则第一个非叶子节点的编号为：arr.length&#x2F;2-1</p><p><img src="/2025/04/20/%E7%AE%97%E6%B3%95%E9%A2%98%E7%90%86%E8%AE%BA/image-20250419181304984.png" alt="image-20250419181304984"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>b站视频：<a href="https://www.bilibili.com/video/BV1Eb41147dK?spm_id_from=333.788.recommend_more_video.1&vd_source=387dd3d1bd16faa43e7a57664d7939b8">https://www.bilibili.com/video/BV1Eb41147dK?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=387dd3d1bd16faa43e7a57664d7939b8</a></p><p>从最后一个非叶子节点开始建堆，一直进行到根节点，最后根节点的数值为整体最大值</p><p>交换最大值与末尾节点值，去除最后一个节点，重新调整堆</p><p>循环上一步，直到堆只剩一个元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    tmp := arr[i]<br>    arr[i] = arr[j]<br>    arr[j] = tmp<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapify</span><span class="hljs-params">(tree []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> i &gt;= n &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    c1 := <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span><br>    c2 := <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span><br>    max := i<br>    <span class="hljs-keyword">if</span> c1 &lt; n &amp;&amp; tree[c1] &gt; tree[max] &#123;<br>        max = c1<br>    &#125;<br>    <span class="hljs-keyword">if</span> c2 &lt; n &amp;&amp; tree[c2] &gt; tree[max] &#123;<br>        max = c2<br>    &#125;<br>    <span class="hljs-keyword">if</span> max != i &#123;<br>        swap(tree, max, i)<br>        heapify(tree, n, max)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(tree []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> &#123;<br>    lastNode := n <span class="hljs-number">-1</span><br>    parent := (lastNode - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i := parent; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        heapify(tree, n, i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(tree []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> &#123;<br>    buildHeap(tree, n)<br>    <span class="hljs-keyword">for</span> i := n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        swap(tree, i, <span class="hljs-number">0</span>)<br>        heapify(tree, i, <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    tree := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>&#125;<br>    n := <span class="hljs-number">6</span><br>    heapSort(tree, n)<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> tree &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>假设所有元素均为正数，若有负数，则通过每个元素都加上一个固定值，把所有元素都变成正数</p><ol><li>先遍历一遍数组，找出数组中最大值m</li><li>设置m个桶</li><li>遍历数组，将元素放到对应的桶上，桶的下标即为元素值本身</li><li>遍历桶，取出桶中元素并按次序排列好</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 找到最大值</span><br>    max := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num &gt; max &#123;<br>            max = num<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置计数桶</span><br>    buckets := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, max+<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment">// 将元素放入桶中</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        buckets[num] += <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历计数桶，取出元素排序</span><br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> elem, elemCount := <span class="hljs-keyword">range</span> buckets &#123;<br>        <span class="hljs-keyword">for</span> elemCount &gt; <span class="hljs-number">0</span> &#123;<br>            nums[index] = elem<br>            elemCount--<br>            index++<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;<br>    countingSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的变种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 找到最大值和最小值</span><br>    max := nums[<span class="hljs-number">0</span>]<br>    min := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num &gt; max &#123;<br>            max = num<br>        &#125;<br>        <span class="hljs-keyword">if</span> num &lt; min &#123;<br>            min = num<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置桶</span><br>    defaultBucketSize := <span class="hljs-number">2</span><br>    bucketCount := (max - min) / defaultBucketSize + <span class="hljs-number">1</span><br>    buckets := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, bucketCount)<br>    <br>    <span class="hljs-comment">// 遍历数组，将元素放入桶中</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        i := (num - min) / defaultBucketSize<br>        buckets[i] = <span class="hljs-built_in">append</span>(buckets[i], num)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历桶，取出元素排序</span><br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, bucket := <span class="hljs-keyword">range</span> buckets &#123;<br>        <span class="hljs-comment">// 桶内部排序</span><br>        sort.Slice(bucket, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">return</span> bucket[i] &lt; bucket[j]<br>        &#125;)<br>        <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> bucket &#123;<br>            nums[index] = num<br>            index++<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">100</span>, <span class="hljs-number">49</span>, <span class="hljs-number">50</span>, <span class="hljs-number">98</span>, <span class="hljs-number">34</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>&#125;<br>    bucketSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, l, r <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> l &lt; r &#123;<br>    index := partition(nums, l, r)<br>    fmt.Println(index)<br>    quickSort(nums, l, index<span class="hljs-number">-1</span>)<br>    quickSort(nums, index+<span class="hljs-number">1</span>, r)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, l, r <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>pivot := nums[l]<br><span class="hljs-keyword">for</span> l &lt; r &#123;<br><span class="hljs-keyword">for</span> l &lt; r &amp;&amp; nums[r] &gt; pivot &#123;<br>r--<br>&#125;<br>nums[l] = nums[r]<br><span class="hljs-keyword">for</span> l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123;<br>l++<br>&#125;<br>nums[r] = nums[l]<br>&#125;<br>nums[l] = pivot<br><span class="hljs-keyword">return</span> l<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>&#125;<br>quickSort(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    value <span class="hljs-type">int</span><br>    next  *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Queue <span class="hljs-keyword">struct</span> &#123;<br>    head *Node<br>    tail *Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewQueue</span><span class="hljs-params">()</span></span> *Queue &#123;<br>    <span class="hljs-keyword">return</span> &amp;Queue&#123;<br>        head: <span class="hljs-literal">nil</span>,<br>        tail: <span class="hljs-literal">nil</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Enqueue(val <span class="hljs-type">int</span>) &#123;<br>    newNode := &amp;Node&#123;value: val&#125;<br>    <span class="hljs-keyword">if</span> q.tail == <span class="hljs-literal">nil</span> &#123;<br>        q.head = newNode<br>        q.tail = newNode<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        q.tail.next = newNode<br>        q.tail = newNode<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Dequeue() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> q.head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>    &#125;<br>    val := q.head.value<br>    q.head = q.head.next<br>    <span class="hljs-keyword">if</span> q.head == <span class="hljs-literal">nil</span> &#123;<br>        q.tail = <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> IsEmpty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> q.head == <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DFS</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(root.Val)<br>    <br>    DFS(root.Left)<br>    DFS(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BFS</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    q := []*TreeNode<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        node := q[<span class="hljs-number">0</span>]<br>        q = q[<span class="hljs-number">1</span>:]<br>        <br>        fmt.Println(node.Val)<br>        <br>        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, node.Left)<br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, node.Right)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题</title>
    <link href="/2025/04/20/Go%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2025/04/20/Go%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Go算法题-一"><a href="#Go算法题-一" class="headerlink" title="Go算法题-一"></a>Go算法题-一</h1><p>按出现频率大小递减排序（参考<a href="https://codetop.cc/home%EF%BC%89%EF%BC%9A">https://codetop.cc/home）：</a></p><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>(1) leetcode 3. 给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>解答：</strong></p><p> 方法点：</p><ol><li>使用map记录字符，用来判断是否重复</li><li>如果当前字符与前面某字符重复，可以直接跳到重复字符后面，继续比较</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// //外层循环扩展右边界，内层循环扩展左边界</span><br><span class="hljs-comment">// for (int l = 0, r = 0 ; r &lt; n ; r++) &#123;</span><br><span class="hljs-comment">// //当前考虑的元素</span><br><span class="hljs-comment">// while (l &lt;= r &amp;&amp; check()) &#123;//区间[left,right]不符合题意</span><br><span class="hljs-comment">//         //扩展左边界</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//     //区间[left,right]符合题意，统计相关信息</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    l := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> r:=<span class="hljs-number">0</span>, r&lt;n; r++ &#123;<br>        <span class="hljs-comment">// 如果重复，一直跳到重复元素的下一位</span><br>        <span class="hljs-keyword">for</span> m[s[r]] != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">delete</span>(m, s[l])<br>            l++<br>        &#125;<br>        m[s[r]] = <span class="hljs-number">1</span><br>        res = max(res, r-l+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）</p><h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><p>leetcode 146. 请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><p><strong>解答：</strong></p><ol><li>使用map来保存cache数据</li><li>使用双向链表来保存访问频率，最近访问的放在链表头部。（双向链表方便尾部删除节点）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    size <span class="hljs-type">int</span><br>    capacity <span class="hljs-type">int</span><br>    cache <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkedNode<br>    head *DLinkedNode<br>    tail *DLinkedNode<br>&#125;<br><br><span class="hljs-keyword">type</span> DLinkedNode <span class="hljs-keyword">struct</span> &#123;<br>    key <span class="hljs-type">int</span><br>    value <span class="hljs-type">int</span><br>    prev *DLinkedNode<br>    next *DLinkedNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initDLinkedNode</span><span class="hljs-params">(key, value <span class="hljs-type">int</span>)</span></span> *DLinkedNode &#123;<br>    <span class="hljs-keyword">return</span> &amp;DLinkedNode&#123;<br>        key: key,<br>        value: value,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    l := LRUCache&#123;<br>        cache: <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkedNode&#123;&#125;,<br>        head: initDLinkedNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        tail: initDLinkedNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        capacity: capacity,<br>    &#125;<br>    l.head.next = l.tail<br>    l.tail.prev = l.head<br>    <span class="hljs-keyword">return</span> l<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    node, ok := this.cache[key]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    this.moveToHead(node)<br>    <span class="hljs-keyword">return</span> node.value<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>    node, ok := this.cache[key]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        node := initDLinkedNode(key, value)<br>        this.cache[key] = node<br>        this.addToHead(node)<br>        this.size++<br>        <span class="hljs-keyword">if</span> this.size &gt; this.capacity &#123;<br>            removed := this.removeTail()<br>            <span class="hljs-built_in">delete</span>(this.cache, removed.key)<br>            this.size--<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node.value = value<br>        this.moveToHead(node)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode) &#123;<br>    node.prev = this.head<br>    node.next = this.head.next<br>    <span class="hljs-comment">// 以下两行顺序不能反</span><br>    this.head.next.prev = node<br>    this.head.next = node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;<br>    node.prev.next = node.next<br>    node.next.prev = node.prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode) &#123;<br>    this.removeNode(node)<br>    this.addToHead(node)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeTail() *DLinkedNode &#123;<br>    node := this.tail.prev<br>    this.removeNode(node)<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(capacity);</span><br><span class="hljs-comment"> * param_1 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>(3) </p><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>解答：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 迭代解法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br><br><span class="hljs-comment">// 递归解法，不好理解</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    newHead := reverseList(head.Next)<br>    head.Next.Next = head<br>    head.Next = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">return</span> newHead<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;Next: head&#125;<br>    <br>    <span class="hljs-comment">// 记录每一段的前驱节点</span><br>    pre := dummy<br><br>    <span class="hljs-comment">// 每次循环处理k个</span><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 找到第k个节点，作为tail</span><br>        tail := pre<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>            tail = tail.Next<br>            <span class="hljs-comment">// 如果还没有到k个，已经到了结尾，则整体反转已完成，返回头节点</span><br>            <span class="hljs-keyword">if</span> tail == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> dummy.Next<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 记录下一段链表的开头节点</span><br>        next := tail.Next<br><br>        <span class="hljs-comment">// 反转当前链表段，获取到新的head和tail</span><br>        head, tail = reverse(head, tail)<br><br>        <span class="hljs-comment">// 将head连接到上一段链表</span><br>        pre.Next = head<br><br>        <span class="hljs-comment">// 将tail连接到下一段链表</span><br>        tail.Next = next<br><br>        <span class="hljs-comment">// 本段的末尾记录为下一段的前驱</span><br>        pre = tail<br><br>        <span class="hljs-comment">// head重置为下一段的开头</span><br>        head = tail.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head, tail *ListNode)</span></span> (*ListNode, *ListNode) &#123;<br>    <span class="hljs-comment">// pre用于记录前驱节点</span><br>    <span class="hljs-keyword">var</span> pre *ListNode<br><br>    <span class="hljs-comment">// 从head节点开始处理</span><br>    curr := head<br><br>    <span class="hljs-comment">// 一直循环到pre指向最后一个节点</span><br>    <span class="hljs-keyword">for</span> pre != tail &#123;<br>        <span class="hljs-comment">// 先记录当前节点的下一个节点</span><br>        nex := curr.Next <br>        <span class="hljs-comment">// 将当前节点指向前驱节点</span><br>        curr.Next = pre<br>        <span class="hljs-comment">// pre后移</span><br>        pre = curr<br>        <span class="hljs-comment">// curr后移</span><br>        curr = nex<br>    &#125;<br>    <span class="hljs-comment">// 反转完成，tail成为新的头，head成为新的尾</span><br>    <span class="hljs-keyword">return</span> tail, head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 先排序，不然没法做</span><br>    slices.Sort(nums)<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>]&#123;<br>        <span class="hljs-comment">// 当前元素和上一个元素相同，则跳过</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i<span class="hljs-number">-1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 当前元素和后两个元素相加已经大于0，则此后所有循环肯定都大于0，直接退出</span><br>        <span class="hljs-keyword">if</span> x+nums[i+<span class="hljs-number">1</span>] + nums[i+<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-comment">// 当前元素和最后两个元素相加仍然小于0，则本轮循环中的和均小于0，跳过本轮循环</span><br>        <span class="hljs-keyword">if</span> x + nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>] + nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// j从当前元素的后一个元素开始</span><br>        j := i+<span class="hljs-number">1</span><br>        <span class="hljs-comment">// k从最后一个元素开始</span><br>        k := <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>        <br>        <span class="hljs-keyword">for</span> j &lt; k &#123;<br>            s := x + nums[j] + nums[k]<br>            <span class="hljs-comment">// 如果小于0，则增大j</span><br>            <span class="hljs-keyword">if</span> s &lt; <span class="hljs-number">0</span> &#123;<br>                j++<br>            <span class="hljs-comment">// 如果大于0，则减小k</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">0</span> &#123;<br>                k--<br>            <span class="hljs-comment">// 等于0，则找到了一个答案</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;x, nums[j], nums[k]&#125;)<br>                <span class="hljs-keyword">for</span> j++; j &lt; k &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]; j++ &#123;&#125; <span class="hljs-comment">// 跳过重复数字</span><br>                <span class="hljs-keyword">for</span> k--; k &gt; j &amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>]; k-- &#123;&#125; <span class="hljs-comment">// 跳过重复数字</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// sums[i]值的含义是，以nums[i]为结尾的所有连续子数组的最大和</span><br>    sums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-comment">// 初始时，以nums[0]为结尾的子数组就是它本身</span><br>    sums[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// ans用来记录整体最大和</span><br>    ans := sums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 从nums[1]开始遍历</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 关键代码</span><br>        <span class="hljs-comment">// 1. sums[i-1]保存了所有以nums[i-1]为结尾元素的连续子数组的最大和</span><br>        <span class="hljs-comment">// 2. nums[i]要么加入到前面的连续子数组，要么自己单独作为一个子数组</span><br>        sums[i] = max(sums[i<span class="hljs-number">-1</span>] + nums[i], nums[i])<br>        ans = max(ans, sums[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p := dummy<br>    <span class="hljs-keyword">for</span> list1 != <span class="hljs-literal">nil</span> &amp;&amp; list2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>            p.Next = list1<br>            list1 = list1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = list2<br>            list2 = list2.Next<br>        &#125;<br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = list1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        p.Next = list2<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list2<br>    &#125;<br>    <span class="hljs-keyword">if</span> list2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>        list1.Next = mergeTwoLists(list1.Next, list2)<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    list2.Next = mergeTwoLists(list2.Next, list1)<br>    <span class="hljs-keyword">return</span> list2<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br><br>    <span class="hljs-comment">// 用于记录最长回文串长度及起始位置</span><br>    maxLen := <span class="hljs-number">1</span><br>    begin := <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">// 初始化dp数组，并将dp[i][i]置为true（每个元素都可以认为是一个回文串）</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> n &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        dp[i][i] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 外层长度循环，遍历所有长度的子串</span><br>    <span class="hljs-keyword">for</span> l := <span class="hljs-number">2</span>; l &lt; n + <span class="hljs-number">1</span>; l++ &#123;<br>        <span class="hljs-comment">// 内层对起始位置进行循环，遍历所有的起始位置</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> n &#123;<br>            <span class="hljs-comment">// 计算结束位置</span><br>            j := i + l <span class="hljs-number">-1</span><br><br>            <span class="hljs-comment">// 若结束位置不合法，则直接退出本轮循环</span><br>            <span class="hljs-keyword">if</span> j &gt;= n &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br><br>            <span class="hljs-comment">// 核心代码，dp[i][j]是否为回文串，取决于</span><br>            <span class="hljs-comment">// 1. 内层dp[i+1][j-1]是回文串</span><br>            <span class="hljs-comment">// 2. s[i] == s[j]</span><br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">2</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 实时更新最长子串长度及起始位置</span><br>            <span class="hljs-keyword">if</span> dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen &#123;<br>                maxLen = j - i + <span class="hljs-number">1</span><br>                begin = i<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回最终结果</span><br>    <span class="hljs-keyword">return</span> s[begin:begin+maxLen]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 定义返回值</span><br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-comment">// q用于保存待遍历的元素</span><br>    q := []*TreeNode&#123;root&#125;<br>    <span class="hljs-comment">// q中保存的始终是同一层的元素</span><br>    <span class="hljs-comment">// 每次循环中把q中所有元素都取出，都取出后再填入下一层的元素</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>; i++ &#123;<br>        res = <span class="hljs-built_in">append</span>(res, []<span class="hljs-type">int</span>&#123;&#125;)<br>        <span class="hljs-comment">// 关键点，用临时的p来保存下层元素，待本层元素处理完后，用p替换q</span><br>        p := []*TreeNode&#123;&#125;<br>        <span class="hljs-comment">// 将q中元素全部遍历，过程中将下层子节点加入p</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(q); j++ &#123;<br>            node := q[j]<br>            res[i] = <span class="hljs-built_in">append</span>(res[i], node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 用p替换q，进入新一轮循环</span><br>        q = p<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> idx, ok := m[target-v]; ok &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;i, idx&#125;<br>        &#125;<br>        m[v] = i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    l := <span class="hljs-number">0</span><br>    r := n - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 总体是二分查找</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        <span class="hljs-comment">// 获取中间位置</span><br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-comment">// 如果命中，则返回</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-comment">// 如果左边是升序</span><br>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= nums[mid] &#123;<br>            <span class="hljs-comment">// 并且target在左边</span><br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;<br>                r = mid - <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span><br>            &#125;<br>        <span class="hljs-comment">// 如果右边是升序</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 并且target在右边</span><br>            <span class="hljs-keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="hljs-number">-1</span>] &#123;<br>                l = mid + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 深度优先搜索</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, r, c <span class="hljs-type">int</span>)</span></span> &#123;<br>    nr := <span class="hljs-built_in">len</span>(grid)<br>    nc := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 先将遍历到的元素置为0</span><br>    grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span><br>    <span class="hljs-comment">// 向上下左右都走一步，如果值为1，则往下搜索</span><br>    <span class="hljs-keyword">if</span> r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r<span class="hljs-number">-1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r<span class="hljs-number">-1</span>, c)<br>    &#125;<br>    <span class="hljs-keyword">if</span> r + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[r+<span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r+<span class="hljs-number">1</span>, c)<br>    &#125;<br>    <span class="hljs-keyword">if</span> c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r, c<span class="hljs-number">-1</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r, c+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    nr := <span class="hljs-built_in">len</span>(grid)<br>    <span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    nc := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> nc == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">var</span> numIslands <span class="hljs-type">int</span><br>    <span class="hljs-comment">// 将所有元素遍历一遍，如果遇到1就深度优先搜索</span><br>    <span class="hljs-comment">// 在深度优先搜索中，会将遍历到的元素置为0</span><br>    <span class="hljs-comment">// 最终执行的搜索次数即为岛屿数量</span><br>    <span class="hljs-keyword">for</span> r := <span class="hljs-number">0</span>; r &lt; nr; r++ &#123;<br>        <span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; nc; c++ &#123;<br>            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                numIslands++<br>                dfs(grid, r, c)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> numIslands<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 回溯法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    <span class="hljs-comment">// 对pos这个位置，使用待排列的所有数字尝试一遍</span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pos <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 如果索引到了n，则说明得到了一个全排列，将结果加入到结果集中</span><br>        <span class="hljs-keyword">if</span> pos == n &#123;<br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, nums...))<br>        &#125;<br>        <span class="hljs-comment">// 对pos这个位置尝试所有待使用元素</span><br>        <span class="hljs-keyword">for</span> i := pos; i &lt; n; i++ &#123;<br>            <span class="hljs-comment">// 把第i个位置的元素放到pos位置上</span><br>            nums[pos], nums[i] = nums[i], nums[pos]<br>            <span class="hljs-comment">// 得到pos后面所有字符的结果集</span><br>            backtrack(pos+<span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 恢复pos和i元素的初始位置，以便下一次循环使用另外的元素</span><br>            nums[pos], nums[i] = nums[i], nums[pos]<br>        &#125;<br>    &#125;<br><br>    backtrack(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-comment">// 如果字符是奇数个，则肯定不能完全匹配</span><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 记录右括号对应的左括号</span><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">byte</span>&#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-type">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果拿到了一个右括号</span><br>        <span class="hljs-keyword">if</span> v, ok := pairs[s[i]]; ok &#123;<br>            <span class="hljs-comment">// 如果栈为空，或者栈顶元素与当前右括号不匹配，就直接返回false</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != v &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            <span class="hljs-comment">// 如果匹配就把栈顶元素出栈</span><br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        <span class="hljs-comment">// 如果拿到的是左括号，就压栈</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 栈中剩余元素就是没有匹配成功的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 核心思想：第i天卖出得到的最大利润，买入价格一定是前i-1天中的最低价格</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// 记录“历史”最低价格</span><br>    minPrice := prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 记录最大利润</span><br>    maxProfit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-comment">// 更新最大利润</span><br>        maxProfit = max(maxProfit, price - minPrice)<br>        <span class="hljs-comment">// 更新历史最低价格</span><br>        minPrice = min(minPrice, price)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxProfit<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, m <span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 从后向前遍历</span><br>    <span class="hljs-comment">// p1指向nums1待排元素，p2指向nums2待排元素，tail指向要放入的位置</span><br>    <span class="hljs-keyword">for</span> p1, p2, tail := m<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>, m+n<span class="hljs-number">-1</span>; p1 &gt;=<span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>; tail-- &#123;<br>        <span class="hljs-comment">// 当前要处理的元素是什么</span><br>        <span class="hljs-keyword">var</span> cur <span class="hljs-type">int</span><br>        <span class="hljs-comment">// 如果nums1已经遍历完了</span><br>        <span class="hljs-keyword">if</span> p1 == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-comment">// 从nums2中取</span><br>            cur = nums2[p2]<br>            p2--<br>        <span class="hljs-comment">// 如果nums2已经遍历完了</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p2 == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-comment">// 从nums1中取</span><br>            cur = nums1[p1]<br>            p1--<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums1[p1] &gt; nums2[p2] &#123;<br>            cur = nums1[p1]<br>            p1--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = nums2[p2]<br>            p2--<br>        &#125;<br>        nums1[tail] = cur<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-comment">// 辅助层序遍历</span><br>    queue := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> level := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>; level++ &#123;<br>        vals := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-comment">// q接收本层元素，用于遍历，queue保存下层元素</span><br>        q := queue<br>        queue = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> q &#123;<br>            vals = <span class="hljs-built_in">append</span>(vals, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果本层为奇数层，将得到的遍历结果反转，再加入结果集</span><br>        <span class="hljs-keyword">if</span> level % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            n := <span class="hljs-built_in">len</span>(vals)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br>                vals[i], vals[n<span class="hljs-number">-1</span>-i] = vals[n<span class="hljs-number">-1</span>-i], vals[i]<br>            &#125;<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, vals)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 哈希表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    seen := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _, ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        seen[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        head = head.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 快慢指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// 慢指针每次走一步，快指针每次走两步</span><br>    <span class="hljs-comment">// 每次移动快慢指针之间的距离会加1，如果有环的话，快慢指针终会相遇</span><br>    slow, fast := head, head.Next<br>    <span class="hljs-keyword">for</span> slow != fast &#123;<br>        <span class="hljs-keyword">if</span> fast == <span class="hljs-literal">nil</span> || fast.Next == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>metrics-server源码解读</title>
    <link href="/2025/04/08/metrics-server%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/2025/04/08/metrics-server%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="metrics-server源码解读"><a href="#metrics-server源码解读" class="headerlink" title="metrics-server源码解读"></a>metrics-server源码解读</h1><p>转自：<a href="https://yost.top/2020/05/17/about-metric-server/">https://yost.top/2020/05/17/about-metric-server/</a></p><h3 id="1、项目概况"><a href="#1、项目概况" class="headerlink" title="1、项目概况"></a>1、项目概况</h3><p>项目地址：<a href="https://github.com/kubernetes-sigs/metrics-server">https://github.com/kubernetes-sigs/metrics-server</a></p><p>在<code>k8s</code>集群中，如果你想要去做弹性伸缩，或者想要使用<code>kubectl top</code>命令，那么<code>metric-server</code>是你绕不开的组件。<code>metric-server</code>主要用来通过<code>aggregate api</code>向其它组件提供集群中的<code>pod</code>和<code>node</code>的<code>cpu</code>和<code>memory</code>的监控指标，弹性伸缩中的<code>podautoscaler</code>就是通过调用这个接口来查看pod的当前资源使用量来进行pod的扩缩容的。</p><p>需要注意的是：</p><ul><li><code>metric-server</code>提供的是实时的指标（实际是最近一次采集的数据，保存在内存中），并没有数据库来存储</li><li>这些数据指标并非由<code>metric-server</code>本身采集，而是由每个节点上的<code>cadvisor</code>采集，<code>metric-server</code>只是发请求给<code>cadvisor</code>并将<code>metric</code>格式的数据转换成<code>aggregate api</code></li><li>由于需要通过<code>aggregate api</code>来提供接口，需要集群中的<code>kube-apiserver</code>开启该功能（开启方法可以参考官方社区的文档）</li></ul><h3 id="2、部署方法"><a href="#2、部署方法" class="headerlink" title="2、部署方法"></a>2、部署方法</h3><p><code>metric-server</code>最佳的安装方法是通过<code>deployment</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.6/components.yaml<br></code></pre></td></tr></table></figure><p>该<code>yaml</code>中主要的<code>deployment</code>参数如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-server</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">metrics-server</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">metrics-server</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-server</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">metrics-server</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">metrics-server</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment"># mount in tmp so we can safely use from-scratch images and/or read-only containers</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp-dir</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-server</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/metrics-server-amd64:v0.3.6</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">args:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">--cert-dir=/tmp</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">--secure-port=4443</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main-port</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">4443</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">readOnlyRootFilesystem:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">runAsNonRoot:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp-dir</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>      <span class="hljs-attr">nodeSelector:</span><br>        <span class="hljs-attr">kubernetes.io/os:</span> <span class="hljs-string">linux</span><br>        <span class="hljs-attr">kubernetes.io/arch:</span> <span class="hljs-string">&quot;amd64&quot;</span><br></code></pre></td></tr></table></figure><p>其中还有一个值得注意的资源是一个<code>APIService</code>，这个资源主要就是将<code>metrics-server</code>注册到<code>aggregate api</code>中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apiregistration.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">APIService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">v1beta1.metrics.k8s.io</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-server</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">group:</span> <span class="hljs-string">metrics.k8s.io</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">v1beta1</span><br>  <span class="hljs-attr">insecureSkipTLSVerify:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">groupPriorityMinimum:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">versionPriority:</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="3、启动参数"><a href="#3、启动参数" class="headerlink" title="3、启动参数"></a>3、启动参数</h3><table><thead><tr><th align="left">参数名称</th><th align="left">参数解释</th></tr></thead><tbody><tr><td align="left">metric-resolution</td><td align="left">周期性调用接口获取metric原始数据的时间间隔，默认60s</td></tr><tr><td align="left">kubelet-insecure-tls</td><td align="left">访问kubelet时不对其证书进行ca校验，仅测试时使用</td></tr><tr><td align="left">kubelet-port</td><td align="left">调用节点上的kubelet获取metric的端口，默认10250端口</td></tr><tr><td align="left">kubeconfig</td><td align="left">调用kube-apiserver和kubelet使用的kubeconfig文件路径</td></tr><tr><td align="left">kubelet-preferred-address-types</td><td align="left">调用kubelet使用的ip地址优先级</td></tr><tr><td align="left">kubelet-certificate-authority</td><td align="left">访问kubelet使用的ca证书</td></tr><tr><td align="left">deprecated-kubelet-completely-insecure</td><td align="left">使用非安全方式访问kubelet（即将废弃）</td></tr></tbody></table><h3 id="4、代码分析"><a href="#4、代码分析" class="headerlink" title="4、代码分析"></a>4、代码分析</h3><p>在开始走读<code>metrics-server</code>的代码之前，我们先来根据其功能来猜测一下它的代码逻辑。我们知道，通过节点上的<code>cadvisor</code>接口获取到的数据一般是这样的，包含的信息太多：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node1 ~]# curl -k https://172.17.8.101:10250/stats/summary?only_cpu_and_memory=true<br>&#123;<br>  &quot;node&quot;: &#123;<br>    &quot;nodeName&quot;: &quot;node1&quot;,<br>    &quot;systemContainers&quot;: [<br>      &#123;<br>        &quot;name&quot;: &quot;kubelet&quot;,<br>        &quot;startTime&quot;: &quot;2020-05-24T12:54:13Z&quot;,<br>        &quot;cpu&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:31Z&quot;,<br>          &quot;usageNanoCores&quot;: 20686133,<br>          &quot;usageCoreNanoSeconds&quot;: 156089526198<br>        &#125;,<br>        &quot;memory&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:31Z&quot;,<br>          &quot;usageBytes&quot;: 170590208,<br>          &quot;workingSetBytes&quot;: 122531840,<br>          &quot;rssBytes&quot;: 66949120,<br>          &quot;pageFaults&quot;: 763727,<br>          &quot;majorPageFaults&quot;: 85<br>        &#125;,<br>        &quot;userDefinedMetrics&quot;: null<br>      &#125;,<br>      &#123;<br>        &quot;name&quot;: &quot;runtime&quot;,<br>        &quot;startTime&quot;: &quot;2020-05-24T12:54:13Z&quot;,<br>        &quot;cpu&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:31Z&quot;,<br>          &quot;usageNanoCores&quot;: 20686133,<br>          &quot;usageCoreNanoSeconds&quot;: 156089526198<br>        &#125;,<br>        &quot;memory&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:31Z&quot;,<br>          &quot;usageBytes&quot;: 170590208,<br>          &quot;workingSetBytes&quot;: 122531840,<br>          &quot;rssBytes&quot;: 66949120,<br>          &quot;pageFaults&quot;: 763727,<br>          &quot;majorPageFaults&quot;: 85<br>        &#125;,<br>        &quot;userDefinedMetrics&quot;: null<br>      &#125;,<br>      &#123;<br>        &quot;name&quot;: &quot;pods&quot;,<br>        &quot;startTime&quot;: &quot;2020-05-24T12:54:13Z&quot;,<br>        &quot;cpu&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:39Z&quot;,<br>          &quot;usageNanoCores&quot;: 0,<br>          &quot;usageCoreNanoSeconds&quot;: 42207538504<br>        &#125;,<br>        &quot;memory&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:39Z&quot;,<br>          &quot;availableBytes&quot;: 1910824960,<br>          &quot;usageBytes&quot;: 33480704,<br>          &quot;workingSetBytes&quot;: 16498688,<br>          &quot;rssBytes&quot;: 36864,<br>          &quot;pageFaults&quot;: 0,<br>          &quot;majorPageFaults&quot;: 0<br>        &#125;,<br>        &quot;userDefinedMetrics&quot;: null<br>      &#125;<br>    ],<br>    &quot;startTime&quot;: &quot;2020-05-24T12:52:24Z&quot;,<br>    &quot;cpu&quot;: &#123;<br>      &quot;time&quot;: &quot;2020-05-24T14:12:39Z&quot;,<br>      &quot;usageNanoCores&quot;: 888521168,<br>      &quot;usageCoreNanoSeconds&quot;: 776524490477<br>    &#125;,<br>    &quot;memory&quot;: &#123;<br>      &quot;time&quot;: &quot;2020-05-24T14:12:39Z&quot;,<br>      &quot;availableBytes&quot;: 891166720,<br>      &quot;usageBytes&quot;: 1627074560,<br>      &quot;workingSetBytes&quot;: 1036156928,<br>      &quot;rssBytes&quot;: 359944192,<br>      &quot;pageFaults&quot;: 1850284,<br>      &quot;majorPageFaults&quot;: 1987<br>    &#125;<br>  &#125;,<br>  &quot;pods&quot;: [<br>    &#123;<br>      &quot;podRef&quot;: &#123;<br>        &quot;name&quot;: &quot;metrics-server-7668599459-2jxq5&quot;,<br>        &quot;namespace&quot;: &quot;kube-system&quot;,<br>        &quot;uid&quot;: &quot;f5af876f-03de-43e5-902b-79bece68c508&quot;<br>      &#125;,<br>      &quot;startTime&quot;: &quot;2020-05-24T13:27:42Z&quot;,<br>      &quot;containers&quot;: null,<br>      &quot;cpu&quot;: &#123;<br>        &quot;time&quot;: &quot;2020-05-24T14:12:36Z&quot;,<br>        &quot;usageNanoCores&quot;: 0,<br>        &quot;usageCoreNanoSeconds&quot;: 6297886<br>      &#125;,<br>      &quot;memory&quot;: &#123;<br>        &quot;time&quot;: &quot;2020-05-24T14:12:36Z&quot;,<br>        &quot;usageBytes&quot;: 434176,<br>        &quot;workingSetBytes&quot;: 249856,<br>        &quot;rssBytes&quot;: 36864,<br>        &quot;pageFaults&quot;: 0,<br>        &quot;majorPageFaults&quot;: 0<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>而我们通过<code>metrics-server</code>获得的数据则是这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node1 ~]# curl http://172.17.8.101:8080/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/metrics-server-7668599459-2jxq5<br>&#123;<br>  &quot;kind&quot;: &quot;PodMetrics&quot;,<br>  &quot;apiVersion&quot;: &quot;metrics.k8s.io/v1beta1&quot;,<br>  &quot;metadata&quot;: &#123;<br>    &quot;name&quot;: &quot;metrics-server-7668599459-2jxq5&quot;,<br>    &quot;namespace&quot;: &quot;kube-system&quot;,<br>    &quot;selfLink&quot;: &quot;/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/metrics-server-7668599459-2jxq5&quot;,<br>    &quot;creationTimestamp&quot;: &quot;2020-05-24T13:27:42Z&quot;<br>  &#125;,<br>  &quot;timeStamp&quot;: &quot;2020-05-24T13:27:42Z&quot;,<br>  &quot;window&quot;: &quot;30s&quot;,<br>  &quot;containers&quot;: [<br>    &#123;<br>      &quot;name&quot;: &quot;metrics-server&quot;,<br>      &quot;usage&quot;: &#123;<br>        &quot;cpu&quot;: &quot;0&quot;,<br>        &quot;memory&quot;: &quot;424Ki&quot;<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，本质上<code>metrics-server</code>相当于做了一次数据的转换，把<code>cadvisor</code>格式的数据转换成了<code>k8s</code>的<code>api</code>的<code>json</code>格式。由此我们不难猜测，<code>metrics-server</code>的代码中必然存在这种先从metric中获取接口中的所有信息，再解析出其中的数据的过程。除此之外，我们可能也会有一个疑惑，那就是：我们给<code>metric-server</code>发送请求时，<code>metric-server</code>是马上向<code>cadvisor</code>发送请求然后解析请求中的数据再返回回来，还是<code>metrics-server</code>中已经定期从中<code>cadvisor</code>获取好数据了（可能缓存在内存中），当请求发过来时直接返回缓存中的数据。我们可以带着这个疑问直接去看源码。</p><h4 id="4-1、启动程序"><a href="#4-1、启动程序" class="headerlink" title="4.1、启动程序"></a>4.1、启动程序</h4><p><code>metric-server</code>的启动流程使用的也是<code>github.com/spf13/cobra</code>框架，对这个库感兴趣的可以去<a href="https://github.com/spf13/cobra"><code>github</code></a>上了解一下，该框架实际执行的是<code>MetricsServerOptions</code>实现的Run函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// cmd/metrics-server/app/start.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o MetricsServerOptions)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 1、生成metric-server自己的server端配置</span><br>config, err := o.Config()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>config.GenericConfig.EnableMetrics = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 2、生成metric-server自己的client端配置</span><br>    <span class="hljs-comment">// 包含对kube-apiserver的client（获取集群node信息）和对cadvisor的client（获取原始监控数据）</span><br><span class="hljs-keyword">var</span> clientConfig *rest.Config<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(o.Kubeconfig) &gt; <span class="hljs-number">0</span> &#123;<br>loadingRules := &amp;clientcmd.ClientConfigLoadingRules&#123;ExplicitPath: o.Kubeconfig&#125;<br>loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &amp;clientcmd.ConfigOverrides&#123;&#125;)<br>clientConfig, err = loader.ClientConfig()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>clientConfig, err = rest.InClusterConfig()<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to construct lister client config: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// Use protobufs for communication with apiserver</span><br>clientConfig.ContentType = <span class="hljs-string">&quot;application/vnd.kubernetes.protobuf&quot;</span><br><br><span class="hljs-comment">// 2.1、通过刚才的client配置参数创建kube-apiserver的client</span><br>kubeClient, err := kubernetes.NewForConfig(clientConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to construct lister client: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 根据client创建对应的informer，到这里与kuber-apiserver通信的部分就设置好了</span><br>informerFactory := informers.NewSharedInformerFactory(kubeClient, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 2.2、这里开始创建与节点上的metric接口相关的client</span><br>kubeletRestCfg := rest.CopyConfig(clientConfig)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(o.KubeletCAFile) &gt; <span class="hljs-number">0</span> &#123;<br>kubeletRestCfg.TLSClientConfig.CAFile = o.KubeletCAFile<br>kubeletRestCfg.TLSClientConfig.CAData = <span class="hljs-literal">nil</span><br>&#125;<br>kubeletConfig := summary.GetKubeletConfig(kubeletRestCfg, o.KubeletPort, o.InsecureKubeletTLS, o.DeprecatedCompletelyInsecureKubelet)<br>kubeletClient, err := summary.KubeletClientFor(kubeletConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to construct a client to connect to the kubelets: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 设置访问node的ip的优先级（node中保存有各种address，包括InternalIP、ExternalIP等）</span><br>addrPriority := <span class="hljs-built_in">make</span>([]corev1.NodeAddressType, <span class="hljs-built_in">len</span>(o.KubeletPreferredAddressTypes))<br><span class="hljs-keyword">for</span> i, addrType := <span class="hljs-keyword">range</span> o.KubeletPreferredAddressTypes &#123;<br>addrPriority[i] = corev1.NodeAddressType(addrType)<br>&#125;<br>addrResolver := summary.NewPriorityNodeAddressResolver(addrPriority)<br>    <span class="hljs-comment">// sourceProvider是将前面的两个client合并到一起从cadvisor抓取数据</span><br>    <span class="hljs-comment">// informer负责获取集群中的节点相关的信息，kubeletClient则调用这些节点上的cadvisor接口</span><br>    <span class="hljs-comment">// 注意这里只传入了NodeLister，也就是是说只需要list node相关的信息就可以了</span><br>sourceProvider := summary.NewSummaryProvider(informerFactory.Core().V1().Nodes().Lister(), kubeletClient, addrResolver)<br>scrapeTimeout := time.Duration(<span class="hljs-type">float64</span>(o.MetricResolution) * <span class="hljs-number">0.90</span>) <span class="hljs-comment">// scrape timeout is 90% of the scrape interval</span><br>    <span class="hljs-comment">// 将抓取时间间隔放到本server的metric接口中，并创建一个sourceManager</span><br>sources.RegisterDurationMetrics(scrapeTimeout)<br>sourceManager := sources.NewSourceManager(sourceProvider, scrapeTimeout)<br><br><span class="hljs-comment">// 3、创建metricSink用来保存获取并解析出来的监控数据（仅保存在内存中）</span><br>    <span class="hljs-comment">//    需要注意的是，这里的metricSink和metricsProvider是同一个sinkMetricsProvider实例</span><br>metricSink, metricsProvider := sink.NewSinkProvider()<br><br><span class="hljs-comment">// 4、创建一个Manager用来将前面的sourceProvider和metricSink管理起来，前者抓数据，后者存数据</span><br>manager.RegisterDurationMetrics(o.MetricResolution)<br>mgr := manager.NewManager(sourceManager, metricSink, o.MetricResolution)<br><br><span class="hljs-comment">// 1.1、将刚才的metricSink传入到server的配置中去，这样http server直接从metricSink中获取数据，然后直接返回给client就可以了，不需要再去调用cadvisor查metric数据</span><br>config.ProviderConfig.Node = metricsProvider<br>config.ProviderConfig.Pod = metricsProvider<br><br><span class="hljs-comment">// 1.2、通过config给将要启动的server做一些初始化的动作，同时也将informerFactory传进去</span><br>server, err := config.Complete(informerFactory).New()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// add health checks</span><br>server.AddHealthzChecks(healthz.NamedCheck(<span class="hljs-string">&quot;healthz&quot;</span>, mgr.CheckHealth))<br><br><span class="hljs-comment">// 5、将刚才的manager运行起来（调用cadvisor的接口获取并解析数据，然后存到metricSink中）</span><br>mgr.RunUntil(stopCh)<br>    <span class="hljs-comment">// 1.3、根据1中的配置将metric-server启动起来</span><br><span class="hljs-keyword">return</span> server.GenericAPIServer.PrepareRun().Run(stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><p>从这段代码中可以看出来，数据的抓取和缓存与<code>server</code>是两个不同的处理流程，他们之间通过共享内存来配合，数据定期抓取完之后缓存到<code>metricSink</code>（其实也就是<code>metricsProvider</code>）中，而<code>server</code>收到请求时从<code>metricSink</code>中读取数据并返回给<code>client</code>。这个过程也正好回答了我们之前的问题，<code>metrics-server</code>中已经定期从中<code>cadvisor</code>获取好数据了，当请求发过来时直接返回缓存中的数据。</p><h4 id="4-2、数据抓取与缓存"><a href="#4-2、数据抓取与缓存" class="headerlink" title="4.2、数据抓取与缓存"></a>4.2、数据抓取与缓存</h4><p>4.1章节代码注释中的2&#x2F;3&#x2F;4&#x2F;5小节就是<code>metric-server</code>的数据抓取流程的启动过程，我们暂且称之为<code>manager</code>，我们看到这其中主要是起了两个<code>client</code>，一个是<code>kube-apiserver</code>的<code>client</code>用来获取集群中<code>node</code>资源，另一个client则是调用节点上<code>cadvisor</code>的接口获取节点和<code>pod</code>的<code>cpu</code>和<code>memory</code>监控数据，同时也创建了一个<code>metricSink</code>用来保存获取的监控数据。话不多说，我们来看一下这个<code>manager</code>是如何运转的。</p><p>我们将4.1章节代码注释中的4和5连在一起就是<code>manager</code>的启动过程，创建一个<code>manager</code>然后运行起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">manager.RegisterDurationMetrics(o.MetricResolution)<br>mgr := manager.NewManager(sourceManager, metricSink, o.MetricResolution)<br><br>mgr.RunUntil(stopCh)<br></code></pre></td></tr></table></figure><p>上面的启动过程实际如下，创建好的<code>manager</code>运行是其实就是周期性地执行其<code>Collect</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/manager/manager.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewManager</span><span class="hljs-params">(metricSrc sources.MetricSource, metricSink sink.MetricSink, resolution time.Duration)</span></span> *Manager &#123;<br>manager := Manager&#123;<br>source:     metricSrc, <span class="hljs-comment">// 抓取metric的interface，需要实现Collect</span><br>sink:       metricSink, <span class="hljs-comment">// 保存抓取数据的接收器，需要实现Receive</span><br>resolution: resolution, <span class="hljs-comment">// 抓取metric的时间间隔</span><br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;manager<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rm *Manager)</span></span> RunUntil(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 创建一个周期性的定时器</span><br>ticker := time.NewTicker(rm.resolution)<br><span class="hljs-keyword">defer</span> ticker.Stop()<br>rm.Collect(time.Now())<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-comment">// 周期性执行Collect</span><br><span class="hljs-keyword">case</span> startTime := &lt;-ticker.C:<br>rm.Collect(startTime) <span class="hljs-comment">// 实际周期性执行的是这里的Collect函数</span><br><span class="hljs-keyword">case</span> &lt;-stopCh:<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看<code>Collect</code>函数中的逻辑就很简介明了了，主要做了两件事件：</p><ul><li>调用sourceManager实现的Collect函数获取metric数据</li><li>将获取到的原始metric数据解析成pod和node的数值并保存metricSink中去</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rm *Manager)</span></span> Collect(startTime time.Time) &#123;<br>rm.healthMu.Lock()<br>rm.lastTickStart = startTime<br>rm.healthMu.Unlock()<br><br>healthyTick := <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 给发request的context中设置超时时间为manager的检查周期</span><br>ctx, cancelTimeout := context.WithTimeout(context.Background(), rm.resolution)<br><span class="hljs-keyword">defer</span> cancelTimeout()<br><br>klog.V(<span class="hljs-number">6</span>).Infof(<span class="hljs-string">&quot;Beginning cycle, collecting metrics...&quot;</span>)<br>    <span class="hljs-comment">// 1、执行sourceManager实现的Collect函数获取metric数据</span><br>data, collectErr := rm.source.Collect(ctx)<br>    <br>    <span class="hljs-comment">// 省略异常处理的逻辑</span><br><br>klog.V(<span class="hljs-number">6</span>).Infof(<span class="hljs-string">&quot;...Storing metrics...&quot;</span>)<br>    <span class="hljs-comment">// 2、将获取到的原始metric数据保存到metricSink中去</span><br>recvErr := rm.sink.Receive(data)<br>    <br>    <span class="hljs-comment">// 省略异常处理的逻辑</span><br><br>    <span class="hljs-comment">// 将实际的collect处理时间放到自己的metric接口中</span><br>collectTime := time.Since(startTime)<br>tickDuration.Observe(<span class="hljs-type">float64</span>(collectTime) / <span class="hljs-type">float64</span>(time.Second))<br>klog.V(<span class="hljs-number">6</span>).Infof(<span class="hljs-string">&quot;...Cycle complete&quot;</span>)<br><br>rm.healthMu.Lock()<br>rm.lastOk = healthyTick<br>rm.healthMu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-1、获取metric数据（rm-source-Collect-ctx-）"><a href="#4-2-1、获取metric数据（rm-source-Collect-ctx-）" class="headerlink" title="4.2.1、获取metric数据（rm.source.Collect(ctx)）"></a>4.2.1、获取<code>metric</code>数据（<code>rm.source.Collect(ctx)</code>）</h5><p>获取<code>metric</code>数据本质上就是调接口获取第4章节开头说的<code>/metric</code>格式的数据，而这个接口本质上就是k8s集群中节点上的<code>cadvisor</code>（实际由<code>kubelet</code>暴露），因此这部分的逻辑就是围绕这个思路展开。</p><ul><li>首先需要知道这个集群中有哪些节点，并获取这些节点上获取<code>metric</code>的<code>ip</code>和端口</li><li>分别调用这些节点上的<code>metric</code>接口并解析其中<code>node</code>和<code>pod</code>的<code>cpu</code>和<code>memory</code>数值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/manager.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *sourceManager)</span></span> Collect(baseCtx context.Context) (*MetricsBatch, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 1、获取需要抓取数据的所有源头，即集群中节点上的cadvisor接口</span><br>sources, err := m.srcProv.GetMetricSources()<br><span class="hljs-keyword">var</span> errs []<span class="hljs-type">error</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>errs = <span class="hljs-built_in">append</span>(errs, err)<br>&#125;<br>klog.V(<span class="hljs-number">1</span>).Infof(<span class="hljs-string">&quot;Scraping metrics from %v sources&quot;</span>, <span class="hljs-built_in">len</span>(sources))<br>    <span class="hljs-comment">// 创建接受数据和错误的channel</span><br>responseChannel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *MetricsBatch, <span class="hljs-built_in">len</span>(sources))<br>errChannel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-built_in">len</span>(sources))<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(responseChannel)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(errChannel)<br>startTime := time.Now()<br>delayMs := delayPerSourceMs * <span class="hljs-built_in">len</span>(sources)<br><span class="hljs-keyword">if</span> delayMs &gt; maxDelayMs &#123;<br>delayMs = maxDelayMs<br>&#125;<br><span class="hljs-keyword">for</span> _, source := <span class="hljs-keyword">range</span> sources &#123;<br>        <span class="hljs-comment">// 2、分别起一个协程去调每个source的接口抓取数据，并写入到channel中</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(source MetricSource)</span></span> &#123;<br>            <span class="hljs-comment">// 每个协程中随机sleep一段时间，防止几个协程同时发请求造成网络拥塞</span><br>sleepDuration := time.Duration(rand.Intn(delayMs)) * time.Millisecond<br>time.Sleep(sleepDuration)<br><span class="hljs-comment">// 超时时间减去刚才sleep的时间</span><br>ctx, cancelTimeout := context.WithTimeout(baseCtx, m.scrapeTimeout-sleepDuration)<br><span class="hljs-keyword">defer</span> cancelTimeout()<br>klog.V(<span class="hljs-number">2</span>).Infof(<span class="hljs-string">&quot;Querying source: %s&quot;</span>, source)<br>            <span class="hljs-comment">// 抓取数据</span><br>metrics, err := scrapeWithMetrics(ctx, source)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>err = fmt.Errorf(<span class="hljs-string">&quot;unable to fully scrape metrics from source %s: %v&quot;</span>, source.Name(), err)<br>&#125;<br>responseChannel &lt;- metrics<br>errChannel &lt;- err<br>&#125;(source)<br>&#125;<br>res := &amp;MetricsBatch&#123;&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> sources &#123;<br>        <span class="hljs-comment">// 将抓取的数据分成node和pod的保存下来并返回</span><br>err := &lt;-errChannel<br>srcBatch := &lt;-responseChannel<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>errs = <span class="hljs-built_in">append</span>(errs, err)<br>&#125;<br><span class="hljs-keyword">if</span> srcBatch == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>res.Nodes = <span class="hljs-built_in">append</span>(res.Nodes, srcBatch.Nodes...)<br>res.Pods = <span class="hljs-built_in">append</span>(res.Pods, srcBatch.Pods...)<br>&#125;<br><br>klog.V(<span class="hljs-number">1</span>).Infof(<span class="hljs-string">&quot;ScrapeMetrics: time: %s, nodes: %v, pods: %v&quot;</span>, time.Since(startTime), <span class="hljs-built_in">len</span>(res.Nodes), <span class="hljs-built_in">len</span>(res.Pods))<br><span class="hljs-keyword">return</span> res, utilerrors.NewAggregate(errs)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到上述两个关键点的细节都封装起来了，我们一个一个来看：</p><ol><li><h6 id="获取源头m-srcProv-GetMetricSources"><a href="#获取源头m-srcProv-GetMetricSources" class="headerlink" title="获取源头m.srcProv.GetMetricSources()"></a>获取源头<code>m.srcProv.GetMetricSources()</code></h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/summary/summary.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *summaryProvider)</span></span> GetMetricSources() ([]sources.MetricSource, <span class="hljs-type">error</span>) &#123;<br>sources := []sources.MetricSource&#123;&#125;<br>    <span class="hljs-comment">// 调用k8s接口List所有节点的信息</span><br>nodes, err := p.nodeLister.List(labels.Everything())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unable to list nodes: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">var</span> errs []<span class="hljs-type">error</span><br><span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> nodes &#123;<br>        <span class="hljs-comment">// 从节点的结构体中获取这个节点的IP和name，并和kubeletClient一起组装到source中去</span><br>        <span class="hljs-comment">// 注意节点的IP时根据启动参数kubelet-preferred-address-types优先级来获取的</span><br>info, err := p.getNodeInfo(node)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>errs = <span class="hljs-built_in">append</span>(errs, fmt.Errorf(<span class="hljs-string">&quot;unable to extract connection information for node %q: %v&quot;</span>, node.Name, err))<br><span class="hljs-keyword">continue</span><br>&#125;<br>        <span class="hljs-comment">// 注意所有source的kubeletClient是共用的，端口都是一样，区别是IP不同</span><br>sources = <span class="hljs-built_in">append</span>(sources, NewSummaryMetricsSource(info, p.kubeletClient))<br>&#125;<br><span class="hljs-keyword">return</span> sources, utilerrors.NewAggregate(errs)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSummaryMetricsSource</span><span class="hljs-params">(node NodeInfo, client KubeletInterface)</span></span> sources.MetricSource &#123;<br><span class="hljs-keyword">return</span> &amp;summaryMetricsSource&#123;<br>node:          node,<br>kubeletClient: client,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h6 id="抓取数据并解析数据scrapeWithMetrics-ctx-source"><a href="#抓取数据并解析数据scrapeWithMetrics-ctx-source" class="headerlink" title="抓取数据并解析数据scrapeWithMetrics(ctx, source)"></a>抓取数据并解析数据<code>scrapeWithMetrics(ctx, source)</code></h6></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/manager.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scrapeWithMetrics</span><span class="hljs-params">(ctx context.Context, s MetricSource)</span></span> (*MetricsBatch, <span class="hljs-type">error</span>) &#123;<br>sourceName := s.Name()<br>startTime := time.Now()<br><span class="hljs-keyword">defer</span> lastScrapeTimestamp.<br>WithLabelValues(sourceName).<br>Set(<span class="hljs-type">float64</span>(time.Now().Unix()))<br><span class="hljs-keyword">defer</span> scraperDuration.<br>WithLabelValues(sourceName).<br>Observe(<span class="hljs-type">float64</span>(time.Since(startTime)) / <span class="hljs-type">float64</span>(time.Second))<br>    <span class="hljs-comment">// 实际调用MetricSource的Collect接口</span><br><span class="hljs-keyword">return</span> s.Collect(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>s.Collect(ctx)</code>实际上就是步骤1中<code>NewSummaryMetricsSource</code>创建出来的<code>MetricSource</code>的<code>Collect</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/summary/summary.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(src *summaryMetricsSource)</span></span> Collect(ctx context.Context) (*sources.MetricsBatch, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 关键逻辑，通过当前source的kubeletClient获取节点上的metric数据，并解析到summary中</span><br>    <span class="hljs-comment">// 这里之所以把这段逻辑协程闭包是为了在GetSummary执行完之后就马上执行defer中的逻辑</span><br>summary, err := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (*stats.Summary, <span class="hljs-type">error</span>) &#123;<br>startTime := time.Now()<br><span class="hljs-keyword">defer</span> summaryRequestLatency.WithLabelValues(src.node.Name).Observe(<span class="hljs-type">float64</span>(time.Since(startTime)) / <span class="hljs-type">float64</span>(time.Second))  <span class="hljs-comment">// 马上将执行时间写入自己的metric中</span><br><span class="hljs-keyword">return</span> src.kubeletClient.GetSummary(ctx, src.node.ConnectAddress)<br>&#125;()<br>    <span class="hljs-comment">// 部分省略</span><br>res := &amp;sources.MetricsBatch&#123;<br>Nodes: <span class="hljs-built_in">make</span>([]sources.NodeMetricsPoint, <span class="hljs-number">1</span>),<br>Pods:  <span class="hljs-built_in">make</span>([]sources.PodMetricsPoint, <span class="hljs-built_in">len</span>(summary.Pods)),<br>&#125;<br>    <br>    <span class="hljs-comment">// 省略部分解析summary中node和pod数据的逻辑</span><br><br><span class="hljs-keyword">return</span> res, utilerrors.NewAggregate(errs)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Collect</code>的逻辑本质上是执行了<code>GetSummary</code>，这里起了一个<code>http client</code>，然后给<code>https://&#123;node ip&#125;:&#123;port&#125;/stats/summary?only_cpu_and_memory=true</code>发了一个<code>GET</code>请求并获取了返回的<code>body</code>体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/summary/client.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kc *kubeletClient)</span></span> GetSummary(ctx context.Context, host <span class="hljs-type">string</span>) (*stats.Summary, <span class="hljs-type">error</span>) &#123;<br>scheme := <span class="hljs-string">&quot;https&quot;</span><br><span class="hljs-keyword">if</span> kc.deprecatedNoTLS &#123;<br>scheme = <span class="hljs-string">&quot;http&quot;</span><br>&#125;<br>url := url.URL&#123;<br>Scheme:   scheme,<br>Host:     net.JoinHostPort(host, strconv.Itoa(kc.port)),<br>Path:     <span class="hljs-string">&quot;/stats/summary&quot;</span>,<br>RawQuery: <span class="hljs-string">&quot;only_cpu_and_memory=true&quot;</span>,<br>&#125;<br><br>req, err := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, url.String(), <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>summary := &amp;stats.Summary&#123;&#125;<br>client := kc.client<br><span class="hljs-keyword">if</span> client == <span class="hljs-literal">nil</span> &#123;<br>client = http.DefaultClient<br>&#125;<br>    <span class="hljs-comment">// 执行req并将response中的body体保存到summary中</span><br>err = kc.makeRequestAndGetValue(client, req.WithContext(ctx), summary)<br><span class="hljs-keyword">return</span> summary, err<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6></li></ol><p>通过4.2.1中的代码分析我们印证之前的过程，获取<code>metric</code>数据本质上就是调用<code>cadvisor</code>的接口来获取数据而已。这里我们有必要来看一下之前我们忽略掉的关键数据结构<code>MetricsBatch</code>，这是最终解析出来的包含了<code>node</code>和<code>pod</code>的<code>cpu</code>和<code>memory</code>信息的对象，也是传递给<code>metricSink</code>的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/interfaces.go</span><br><span class="hljs-comment">// MetricsBatch是所有node和所有pod的metric数据</span><br><span class="hljs-keyword">type</span> MetricsBatch <span class="hljs-keyword">struct</span> &#123;<br>Nodes []NodeMetricsPoint<br>Pods  []PodMetricsPoint<br>&#125;<br><span class="hljs-comment">// NodeMetricsPoint包含这个节点的metric数据</span><br><span class="hljs-keyword">type</span> NodeMetricsPoint <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>MetricsPoint<br>&#125;<br><span class="hljs-comment">// PodMetricsPoint包含了这个pod所有容器的metric数据</span><br><span class="hljs-keyword">type</span> PodMetricsPoint <span class="hljs-keyword">struct</span> &#123;<br>Name      <span class="hljs-type">string</span><br>Namespace <span class="hljs-type">string</span><br>Containers []ContainerMetricsPoint<br>&#125;<br><span class="hljs-comment">// ContainerMetricsPoint包含这个容器的metric数据</span><br><span class="hljs-keyword">type</span> ContainerMetricsPoint <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>MetricsPoint<br>&#125;<br><span class="hljs-comment">// MetricsPoint是node和容器metric数据的基本单位，其中包含了cpu和memory度量</span><br><span class="hljs-keyword">type</span> MetricsPoint <span class="hljs-keyword">struct</span> &#123;<br>Timestamp time.Time<br><span class="hljs-comment">// CpuUsage is the CPU usage rate, in cores</span><br>CpuUsage resource.Quantity<br><span class="hljs-comment">// MemoryUsage is the working set size, in bytes.</span><br>MemoryUsage resource.Quantity<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-2、保存metric数据（rm-sink-Receive-data-）"><a href="#4-2-2、保存metric数据（rm-sink-Receive-data-）" class="headerlink" title="4.2.2、保存metric数据（rm.sink.Receive(data)）"></a>4.2.2、保存<code>metric</code>数据（<code>rm.sink.Receive(data)</code>）</h5><p>4.2.1中已经调用集群中所有节点的<code>cadvisor</code>接口并获取了所有节点和<code>pod</code>的<code>metric</code>数据，接下来就是保存到缓存中了。前面已经将获取到的数据存在了<code>data</code>（本质上就是4.2.1总结时说到的<code>MetricsBatch</code>）变量中，接下来就时对这个变量进行处理了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/provider/sink/sinkprov.go</span><br><span class="hljs-comment">// sinkMetricsProvider既实现了provider.MetricsProvider（提供server时使用）也实现了sink.MetricSink（抓取后缓存数据用）</span><br><span class="hljs-comment">// sinkMetricsProvider本质上就是两个map，一个保存node，一个保存pod</span><br><span class="hljs-keyword">type</span> sinkMetricsProvider <span class="hljs-keyword">struct</span> &#123;<br>mu    sync.RWMutex<br>nodes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]sources.NodeMetricsPoint<br>pods  <span class="hljs-keyword">map</span>[apitypes.NamespacedName]sources.PodMetricsPoint<br>&#125;<br><span class="hljs-comment">// metric-server收到node的GET请求调用这个函数来获取metric数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sinkMetricsProvider)</span></span> GetNodeMetrics(nodes ...<span class="hljs-type">string</span>) ([]provider.TimeInfo, []corev1.ResourceList, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 代码逻辑略</span><br>&#125;<br><span class="hljs-comment">// metric-server收到pod的GET请求调用这个函数来获取metric数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sinkMetricsProvider)</span></span> GetContainerMetrics(pods ...apitypes.NamespacedName) ([]provider.TimeInfo, [][]metrics.ContainerMetrics, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 代码逻辑略，4.3节的metric-server再讲</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sinkMetricsProvider)</span></span> Receive(batch *sources.MetricsBatch) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 创建一个新的node的map，并将数据去重写入</span><br>newNodes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]sources.NodeMetricsPoint, <span class="hljs-built_in">len</span>(batch.Nodes))<br><span class="hljs-keyword">for</span> _, nodePoint := <span class="hljs-keyword">range</span> batch.Nodes &#123;<br><span class="hljs-keyword">if</span> _, exists := newNodes[nodePoint.Name]; exists &#123;<br>klog.Errorf(<span class="hljs-string">&quot;duplicate node %s received&quot;</span>, nodePoint.Name)<br><span class="hljs-keyword">continue</span><br>&#125;<br>newNodes[nodePoint.Name] = nodePoint<br>&#125;<br>    <span class="hljs-comment">// 创建一个新的pod的map，并将数据去重写入</span><br>newPods := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[apitypes.NamespacedName]sources.PodMetricsPoint, <span class="hljs-built_in">len</span>(batch.Pods))<br><span class="hljs-keyword">for</span> _, podPoint := <span class="hljs-keyword">range</span> batch.Pods &#123;<br>podIdent := apitypes.NamespacedName&#123;Name: podPoint.Name, Namespace: podPoint.Namespace&#125;<br><span class="hljs-keyword">if</span> _, exists := newPods[podIdent]; exists &#123;<br>klog.Errorf(<span class="hljs-string">&quot;duplicate pod %s received&quot;</span>, podIdent)<br><span class="hljs-keyword">continue</span><br>&#125;<br>newPods[podIdent] = podPoint<br>&#125;<br><br>p.mu.Lock()<br><span class="hljs-keyword">defer</span> p.mu.Unlock()<br>    <span class="hljs-comment">// 将刚创建的新map赋值给provider，注意之前的旧map就直接回收了</span><br>p.nodes = newNodes<br>p.pods = newPods<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>sinkMetricsProvider</code>数据的结构体本质上就是两个<code>map</code>而已，而保存的逻辑也非常简单，直接创建两个新map并赋值过去就可以，并不需要处理之前的旧数据，简单粗暴。</p><h4 id="4-3、metric-server"><a href="#4-3、metric-server" class="headerlink" title="4.3、metric-server"></a>4.3、<code>metric-server</code></h4><p>在4.1节的启动程序中已经说明了<code>metric-server</code>的启动过程，经过4.2.2的代码分析之后，我们可以猜测<code>metric-server</code>本质上就是收到请求之后到<code>sinkMetricsProvider</code>的两个<code>map</code>中读取数据并返回而已。</p><p>我们回到启动程序中，这里包含了两个步骤，一个是创建好一个<code>server</code>（本质上是<code>k8s.io/apiserver</code>库的一个<code>GenericAPIServer</code>），另一个则是直接将这个<code>server</code>运行起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 关键逻辑：通过配置文件创建好对应的GenericAPIServer</span><br>server, err := config.Complete(informerFactory).New()<br><span class="hljs-comment">// 将GenericAPIServer运行起来</span><br><span class="hljs-keyword">return</span> server.GenericAPIServer.PrepareRun().Run(stopCh)<br></code></pre></td></tr></table></figure><p>由于<code>k8s.io/apiserver</code>库的原理比较复杂，暂且不表，我们只讲创建<code>GenericAPIServer</code>的创建流程并说明<code>server</code>是如何使用的。对于<code>metric-server</code>而言，需要先创建一个<code>GenericAPIServer</code>，然后将<code>metric-server</code>自己的<code>API</code>与对应的处理<code>handler</code>注册进来即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/apiserver/config.go</span><br><span class="hljs-keyword">type</span> MetricsServer <span class="hljs-keyword">struct</span> &#123;<br>*genericapiserver.GenericAPIServer<br>&#125;<br><span class="hljs-comment">// New returns a new instance of MetricsServer from the given config.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c completedConfig)</span></span> New() (*MetricsServer, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 创建一个名为&quot;metrics-server&quot;的genericServer</span><br>genericServer, err := c.CompletedConfig.New(<span class="hljs-string">&quot;metrics-server&quot;</span>, genericapiserver.NewEmptyDelegate()) <span class="hljs-comment">// completion is done in Complete, no need for a second time</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>    <span class="hljs-comment">// 关键逻辑：将metric-server的处理实体注册到genericServer中，下文继续讲解</span><br><span class="hljs-keyword">if</span> err := generic.InstallStorage(c.ProviderConfig, c.SharedInformerFactory.Core().V1(), genericServer); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;MetricsServer&#123;<br>GenericAPIServer: genericServer,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在注册<code>metric-server</code>自己的<code>API</code>时，需要先创建一个<code>APIGroup</code>（即<code>metrics.k8s.io</code>），然后将这个<code>Group</code>下面的各个资源（例如这里的<code>&quot;nodes&quot;</code>和<code>&quot;pods&quot;</code>）的<code>Storage</code>注册到<code>VersionedResourcesStorageMap</code>中，这里面最关键的就是每个资源的<code>Storage</code>需要实现处理请求的rest接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/apiserver/generic/storage.go</span><br><span class="hljs-comment">// InstallStorage构造一个metrics.k8s.io的apiGroup并注册到genericServer中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InstallStorage</span><span class="hljs-params">(providers *ProviderConfig, informers coreinf.Interface, server *genericapiserver.GenericAPIServer)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 创建一个APIGroup</span><br>info := BuildStorage(providers, informers)<br>    <span class="hljs-comment">// 将这个APIGroup注册到GenericAPIServer中</span><br><span class="hljs-keyword">return</span> server.InstallAPIGroup(&amp;info)<br>&#125;<br><br><span class="hljs-comment">// BuildStorage构造一个名为&quot;metrics.k8s.io&quot;的apiGroup</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildStorage</span><span class="hljs-params">(providers *ProviderConfig, informers coreinf.Interface)</span></span> genericapiserver.APIGroupInfo &#123;<br>    <span class="hljs-comment">// 创建一个名为&quot;metrics.k8s.io&quot;的apiGroup</span><br>apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(metrics.GroupName, Scheme, metav1.ParameterCodec, Codecs)<br>    <span class="hljs-comment">// 创建node的storage，这个storage跟pod的类似，下文以pod为例</span><br>nodemetricsStorage := nodemetricsstorage.NewStorage(metrics.Resource(<span class="hljs-string">&quot;nodemetrics&quot;</span>), providers.Node, informers.Nodes().Lister())<br>    <span class="hljs-comment">// 创建pod的storage，这个storage中实现了收到请求之后的处理逻辑，下文继续讲解</span><br>podmetricsStorage := podmetricsstorage.NewStorage(metrics.Resource(<span class="hljs-string">&quot;podmetrics&quot;</span>), providers.Pod, informers.Pods().Lister())<br>    <span class="hljs-comment">// 将node和pod的Storage存放到map中</span><br>metricsServerResources := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]rest.Storage&#123;<br><span class="hljs-string">&quot;nodes&quot;</span>: nodemetricsStorage,<br><span class="hljs-string">&quot;pods&quot;</span>:  podmetricsStorage,<br>&#125;<br>    <span class="hljs-comment">// 在&quot;metrics.k8s.io&quot;这个apiGroup中注册&quot;v1beta1&quot;这个version的Storage处理map</span><br>apiGroupInfo.VersionedResourcesStorageMap[v1beta1.SchemeGroupVersion.Version] = metricsServerResources<br><span class="hljs-keyword">return</span> apiGroupInfo<br>&#125;<br></code></pre></td></tr></table></figure><p>这里以<code>pod</code>的<code>MetricStorage</code>的<code>Getter</code>接口为例，这里实现的<code>Get</code>函数就是当<code>metric-server</code>收到获取某个<code>pod</code>的<code>metric</code>的请求时处理该请求的Handler。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/storage/podmetrics/reststorage.go</span><br><span class="hljs-keyword">type</span> MetricStorage <span class="hljs-keyword">struct</span> &#123;<br>groupResource schema.GroupResource<br>prov          provider.PodMetricsProvider<br>podLister     v1listers.PodLister<br>&#125;<br><span class="hljs-comment">// 用来检查MetricStorage已经实现了rest的这4个接口</span><br><span class="hljs-keyword">var</span> _ rest.KindProvider = &amp;MetricStorage&#123;&#125;<br><span class="hljs-keyword">var</span> _ rest.Storage = &amp;MetricStorage&#123;&#125;<br><span class="hljs-keyword">var</span> _ rest.Getter = &amp;MetricStorage&#123;&#125;<br><span class="hljs-keyword">var</span> _ rest.Lister = &amp;MetricStorage&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStorage</span><span class="hljs-params">(groupResource schema.GroupResource, prov provider.PodMetricsProvider, podLister v1listers.PodLister)</span></span> *MetricStorage &#123;<br><span class="hljs-keyword">return</span> &amp;MetricStorage&#123;<br>groupResource: groupResource,<br>prov:          prov,<br>podLister:     podLister,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实现rest.Getter接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MetricStorage)</span></span> Get(ctx context.Context, name <span class="hljs-type">string</span>, opts *metav1.GetOptions) (runtime.Object, <span class="hljs-type">error</span>) &#123;<br>namespace := genericapirequest.NamespaceValue(ctx)<br>    <span class="hljs-comment">// 从k8s的client缓存中获取pod信息</span><br>pod, err := m.podLister.Pods(namespace).Get(name)<br>    <br>    <span class="hljs-comment">// 省略异常处理的逻辑</span><br>    <br>    <span class="hljs-comment">// 从之前的sinkMetric缓存中获取这个pod的</span><br>podMetrics, err := m.getPodMetrics(pod)<br>    <br>    <span class="hljs-comment">// 省略异常处理的逻辑</span><br>    <br><span class="hljs-keyword">return</span> &amp;podMetrics[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MetricStorage)</span></span> getPodMetrics(pods ...*v1.Pod) ([]metrics.PodMetrics, <span class="hljs-type">error</span>) &#123;<br>namespacedNames := <span class="hljs-built_in">make</span>([]apitypes.NamespacedName, <span class="hljs-built_in">len</span>(pods))<br><span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>namespacedNames[i] = apitypes.NamespacedName&#123;<br>Name:      pod.Name,<br>Namespace: pod.Namespace,<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 从缓存中获取pod的metric数据，这其实就是调用的4.2.2节中的GetContainerMetrics</span><br>timestamps, containerMetrics, err := m.prov.GetContainerMetrics(namespacedNames...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>res := <span class="hljs-built_in">make</span>([]metrics.PodMetrics, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(pods))<br><span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        <span class="hljs-comment">// 省略pod状态不为Running和metric数据为空的continue逻辑</span><br><br>        <span class="hljs-comment">// 创建返回体的内容</span><br>res = <span class="hljs-built_in">append</span>(res, metrics.PodMetrics&#123;<br>ObjectMeta: metav1.ObjectMeta&#123;<br>Name:              pod.Name,<br>Namespace:         pod.Namespace,<br>CreationTimestamp: metav1.NewTime(time.Now()),<br>&#125;,<br>Timestamp:  metav1.NewTime(timestamps[i].Timestamp),<br>Window:     metav1.Duration&#123;Duration: timestamps[i].Window&#125;,<br>Containers: containerMetrics[i],<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们终于又回到了4.2.2中的<code>sinkMetricsProvider</code>，这不过这次是从其<code>map</code>中读取数据。在此数据抓取和<code>metric-server</code>这两部分就连到一起了，我们其实也可以把这两部分当成一个生产者消费者模式，前者负责生产数据，后者则读取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/provider/sink/sinkprov.go</span><br><span class="hljs-comment">// metric-server收到pod的GET请求调用这个函数来获取metric数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sinkMetricsProvider)</span></span> GetContainerMetrics(pods ...apitypes.NamespacedName) ([]provider.TimeInfo, [][]metrics.ContainerMetrics, <span class="hljs-type">error</span>) &#123;<br>p.mu.RLock()<br><span class="hljs-keyword">defer</span> p.mu.RUnlock()<br><br>timestamps := <span class="hljs-built_in">make</span>([]provider.TimeInfo, <span class="hljs-built_in">len</span>(pods))<br>resMetrics := <span class="hljs-built_in">make</span>([][]metrics.ContainerMetrics, <span class="hljs-built_in">len</span>(pods))<br><br><span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        <span class="hljs-comment">// 从pod的map中获取metric数据</span><br>metricPoint, present := p.pods[pod]<br><span class="hljs-keyword">if</span> !present &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 省略中间的处理逻辑</span><br>resMetrics[i] = contMetrics<br>&#125;<br><span class="hljs-keyword">return</span> timestamps, resMetrics, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-sync包介绍</title>
    <link href="/2025/04/06/Go-sync%E5%8C%85%E4%BB%8B%E7%BB%8D/"/>
    <url>/2025/04/06/Go-sync%E5%8C%85%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-sync包介绍"><a href="#Go-sync包介绍" class="headerlink" title="Go sync包介绍"></a>Go sync包介绍</h1><p>转自：<a href="https://segmentfault.com/a/1190000022545889">https://segmentfault.com/a/1190000022545889</a></p><p>在并发编程中同步原语也就是我们通常说的锁的主要作用是保证多个线程或者 <code>goroutine</code>在访问同一片内存时不会出现混乱的问题。<code>Go</code>语言的<code>sync</code>包提供了常见的并发编程同步原语，上一期转载的文章《<a href="https://link.segmentfault.com/?enc=TitSKVQMWEaJuZcPts3ceg==.DQeNe2dUjbZ5w8XBZWYnqG9IQ9bmqH7xPSzEs29VV09MGt1b7UbWVV9D361cVn6/9EWIIRQjWarFH9kvaUODTMIOJxOr7hvsEHpdOKVGFy6tLC+cONb4Prn1ibnUH5iw0XrF4+OvcHDtu4DBJ3vnG3gBAm7yoezP/nBtoPqkMK5HfdVxdGnSrEuWIHlNgPnU1vKykAzZ4T4SEeggLQ29AxR2OhCY0BXdBD5roFvJtj5lwTPTXCi35C5BM990jIMd+QYouz3ZiekEpGI992udCQLrGKK2K4f3dKrgZe5nozk6I6/W5cxaxjSG51Zq7aqepcgXXhPyafsXj0j69QvYog==">Golang 并发编程之同步原语</a>》中也详述了 <code>Mutex</code>、<code>RWMutex</code>、<code>WaitGroup</code>、<code>Once</code> 和 <code>Cond</code> 这些同步原语的实现原理。今天的文章里让我们回到应用层，聚焦<code>sync</code>包里这些同步原语的应用场景，同时也会介绍<code>sync</code>包中的<code>Pool</code>和<code>Map</code>的应用场景和使用方法。话不多说，让我们开始吧。</p><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p><code>sync.Mutex</code>可能是<code>sync</code>包中使用最广泛的原语。它允许在共享资源上互斥访问（不能同时访问）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">mutex := &amp;sync.Mutex&#123;&#125;<br><br>mutex.Lock()<br><span class="hljs-comment">// Update共享变量 (比如切片，结构体指针等)</span><br>mutex.Unlock()<br></code></pre></td></tr></table></figure><p>必须指出的是，在第一次被使用后，不能再对<code>sync.Mutex</code>进行复制。（<code>sync</code>包的所有原语都一样）。如果结构体具有同步原语字段，则必须通过指针传递它。</p><h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p><code>sync.RWMutex</code>是一个读写互斥锁，它提供了我们上面的刚刚看到的<code>sync.Mutex</code>的<code>Lock</code>和<code>UnLock</code>方法（因为这两个结构都实现了<code>sync.Locker</code>接口）。但是，它还允许使用<code>RLock</code>和<code>RUnlock</code>方法进行并发读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">mutex := &amp;sync.RWMutex&#123;&#125;<br><br>mutex.Lock()<br><span class="hljs-comment">// Update 共享变量</span><br>mutex.Unlock()<br><br>mutex.RLock()<br><span class="hljs-comment">// Read 共享变量</span><br>mutex.RUnlock()<br></code></pre></td></tr></table></figure><p><code>sync.RWMutex</code>允许至少一个读锁或一个写锁存在，而<code>sync.Mutex</code>允许一个读锁或一个写锁存在。</p><p>通过基准测试来比较这几个方法的性能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">BenchmarkMutexLock-4       83497579         17.7 ns/op<br>BenchmarkRWMutexLock-4     35286374         44.3 ns/op<br>BenchmarkRWMutexRLock-4    89403342         15.3 ns/op<br></code></pre></td></tr></table></figure><p>可以看到锁定&#x2F;解锁<code>sync.RWMutex</code>读锁的速度比锁定&#x2F;解锁<code>sync.Mutex</code>更快，另一方面，在<code>sync.RWMutex</code>上调用<code>Lock()</code>&#x2F; <code>Unlock()</code>是最慢的操作。</p><p>因此，只有在频繁读取和不频繁写入的场景里，才应该使用<code>sync.RWMutex</code>。</p><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p><code>sync.WaitGroup</code>也是一个经常会用到的同步原语，它的使用场景是在一个<code>goroutine</code>等待一组<code>goroutine</code>执行完成。</p><p><code>sync.WaitGroup</code>拥有一个内部计数器。当计数器等于<code>0</code>时，则<code>Wait()</code>方法会立即返回。否则它将阻塞执行<code>Wait()</code>方法的<code>goroutine</code>直到计数器等于<code>0</code>时为止。</p><p>要增加计数器，我们必须使用<code>Add(int)</code>方法。要减少它，我们可以使用<code>Done()</code>（将计数器减<code>1</code>），也可以传递负数给<code>Add</code>方法把计数器减少指定大小，<code>Done()</code>方法底层就是通过<code>Add(-1)</code>实现的。</p><p>在以下示例中，我们将启动八个<code>goroutine</code>，并等待他们完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">wg := &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++ &#123;<br>  wg.Add(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Do something</span><br>    wg.Done()<br>  &#125;()<br>&#125;<br><br>wg.Wait()<br><span class="hljs-comment">// 继续往下执行...</span><br></code></pre></td></tr></table></figure><p>每次创建<code>goroutine</code>时，我们都会使用<code>wg.Add(1)</code>来增加<code>wg</code>的内部计数器。我们也可以在<code>for</code>循环之前调用<code>wg.Add(8)</code>。</p><p>与此同时，每个<code>goroutine</code>完成时，都会使用<code>wg.Done()</code>减少<code>wg</code>的内部计数器。</p><p><code>main goroutine</code>会在八个<code>goroutine</code>都执行<code>wg.Done()</code>将计数器变为<code>0</code>后才能继续执行。</p><h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p><code>sync.Map</code>是一个并发版本的<code>Go</code>语言的<code>map</code>，我们可以：</p><ul><li>使用<code>Store(interface &#123;&#125;，interface &#123;&#125;)</code>添加元素。</li><li>使用<code>Load(interface &#123;&#125;) interface &#123;&#125;</code>检索元素。</li><li>使用<code>Delete(interface &#123;&#125;)</code>删除元素。</li><li>使用<code>LoadOrStore(interface &#123;&#125;，interface &#123;&#125;) (interface &#123;&#125;，bool)</code>检索或添加之前不存在的元素。如果键之前在<code>map</code>中存在，则返回的布尔值为<code>true</code>。</li><li>使用<code>Range</code>遍历元素。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">m := &amp;sync.Map&#123;&#125;<br><br><span class="hljs-comment">// 添加元素</span><br>m.Store(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>)<br>m.Store(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>)<br><br><span class="hljs-comment">// 获取元素1</span><br>value, contains := m.Load(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> contains &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, value.(<span class="hljs-type">string</span>))<br>&#125;<br><br><span class="hljs-comment">// 返回已存value，否则把指定的键值存储到map中</span><br>value, loaded := m.LoadOrStore(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-keyword">if</span> !loaded &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, value.(<span class="hljs-type">string</span>))<br>&#125;<br><br>m.Delete(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 迭代所有元素</span><br>m.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%d: %s\n&quot;</span>, key.(<span class="hljs-type">int</span>), value.(<span class="hljs-type">string</span>))<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的程序会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">one<br>three<br>1: one<br>2: two<br></code></pre></td></tr></table></figure><p>如你所见，<code>Range</code>方法接收一个类型为<code>func(key，value interface &#123;&#125;)bool</code>的函数参数。如果函数返回了<code>false</code>，则停止迭代。有趣的事实是，即使我们在恒定时间后返回<code>false</code>，最坏情况下的时间复杂度仍为<code>O(n)</code>。</p><p>我们应该在什么时候使用<code>sync.Map</code>而不是在普通的<code>map</code>上使用<code>sync.Mutex</code>？</p><ul><li>当我们对<code>map</code>有频繁的读取和不频繁的写入时。</li><li>当多个<code>goroutine</code>读取，写入和覆盖不相交的键时。具体是什么意思呢？例如，如果我们有一个分片实现，其中包含一组4个<code>goroutine</code>，每个<code>goroutine</code>负责25％的键（每个负责的键不冲突）。在这种情况下，<code>sync.Map</code>是首选。</li></ul><h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><p><code>sync.Pool</code>是一个并发池，负责安全地保存一组对象。它有两个导出方法：</p><ul><li><code>Get() interface&#123;&#125;</code> 用来从并发池中取出元素。</li><li><code>Put(interface&#123;&#125;)</code> 将一个对象加入并发池。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">pool := &amp;sync.Pool&#123;&#125;<br><br>pool.Put(NewConnection(<span class="hljs-number">1</span>))<br>pool.Put(NewConnection(<span class="hljs-number">2</span>))<br>pool.Put(NewConnection(<span class="hljs-number">3</span>))<br><br>connection := pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>connection = pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>connection = pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1<br>3<br>2<br></code></pre></td></tr></table></figure><p>需要注意的是<code>Get()</code>方法会从并发池中随机取出对象，无法保证以固定的顺序获取并发池中存储的对象。</p><p>还可以为<code>sync.Pool</code>指定一个创建者方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">pool := &amp;sync.Pool&#123;<br>  New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">return</span> NewConnection()<br>  &#125;,<br>&#125;<br><br>connection := pool.Get().(*Connection)<br></code></pre></td></tr></table></figure><p>这样每次调用<code>Get()</code>时，将返回由在<code>pool.New</code>中指定的函数创建的对象（在本例中为指针）。</p><p>那么什么时候使用sync.Pool？有两个用例：</p><p>第一个是当我们必须重用共享的和长期存在的对象（例如，数据库连接）时。第二个是用于优化内存分配。</p><p>让我们考虑一个写入缓冲区并将结果持久保存到文件中的函数示例。使用<code>sync.Pool</code>，我们可以通过在不同的函数调用之间重用同一对象来重用为缓冲区分配的空间。<br>第一步是检索先前分配的缓冲区（如果是第一个调用，则创建一个缓冲区，但这是抽象的）。然后，<code>defer</code>操作是将缓冲区放回<code>sync.Pool</code>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeFile</span><span class="hljs-params">(pool *sync.Pool, filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    buf := pool.Get().(*bytes.Buffer)<br><br>  <span class="hljs-keyword">defer</span> pool.Put(buf)<br><br>    <span class="hljs-comment">// Reset 缓存区，不然会连接上次调用时保存在缓存区里的字符串foo</span><br>    <span class="hljs-comment">// 编程foofoo 以此类推</span><br>    buf.Reset()<br><br>    buf.WriteString(<span class="hljs-string">&quot;foo&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> ioutil.WriteFile(filename, buf.Bytes(), <span class="hljs-number">0644</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p><code>sync.Once</code>是一个简单而强大的原语，可确保一个函数仅执行一次。在下面的示例中，只有一个<code>goroutine</code>会显示输出消息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">once := &amp;sync.Once&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>    i := i<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;first %d\n&quot;</span>, i)<br>        &#125;)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用了<code>Do(func ())</code>方法来指定只能被调用一次的部分。</p><h2 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h2><p><code>sync.Cond</code>可能是<code>sync</code>包提供的同步原语中最不常用的一个，它用于发出信号（一对一）或广播信号（一对多）到<code>goroutine</code>。让我们考虑一个场景，我们必须向一个<code>goroutine</code>指示共享切片的第一个元素已更新。创建<code>sync.Cond</code>需要<code>sync.Locker</code>对象（<code>sync.Mutex</code>或<code>sync.RWMutex</code>）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">cond := sync.<span class="hljs-built_in">NewCond</span>(&amp;sync.Mutex&#123;&#125;)<br></code></pre></td></tr></table></figure><p>然后，让我们编写负责显示切片的第一个元素的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printFirstElement</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, cond *sync.Cond)</span></span> &#123;<br>    cond.L.Lock()<br>    cond.Wait()<br>    fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, s[<span class="hljs-number">0</span>])<br>    cond.L.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>cond.L</code>访问内部的互斥锁。一旦获得了锁，我们将调用<code>cond.Wait()</code>，这会让当前<code>goroutine</code>在收到信号前一直处于阻塞状态。</p><p>让我们回到<code>main goroutine</code>。我们将通过传递共享切片和先前创建的<code>sync.Cond</code>来创建<code>printFirstElement</code>池。然后我们调用<code>get()</code>函数，将结果存储在<code>s[0]</code>中并发出信号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; runtime.NumCPU(); i++ &#123;<br>    <span class="hljs-keyword">go</span> printFirstElement(s, cond)<br>&#125;<br><br>i := get()<br>cond.L.Lock()<br>s[<span class="hljs-number">0</span>] = i<br>cond.Signal()<br>cond.L.Unlock()<br></code></pre></td></tr></table></figure><p>这个信号会解除一个<code>goroutine</code>的阻塞状态，解除阻塞的<code>goroutine</code>将会显示<code>s[0]</code>中存储的值。</p><p>但是，有的人可能会争辩说我们的代码破坏了<code>Go</code>的最基本原则之一：</p><blockquote><p>不要通过共享内存进行通信；而是通过通信共享内存。</p></blockquote><p>确实，在这个示例中，最好使用<code>channel</code>来传递<code>get()</code>返回的值。但是我们也提到了<code>sync.Cond</code>也可以用于广播信号。我们修改一下上面的示例，把<code>Signal()</code>调用改为调用<code>Broadcast()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">i := get()<br>cond.L.Lock()<br>s[<span class="hljs-number">0</span>] = i<br>cond.Broadcast()<br>cond.L.Unlock()<br></code></pre></td></tr></table></figure><p>在这种情况下，所有goroutine都将被触发。<br>众所周知，<code>channel</code>里的元素只会由一个<code>goroutine</code>接收到。通过<code>channel</code>模拟广播的唯一方法是关闭<code>channel</code>。</p><blockquote><p>当一个channel被关闭后，channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。</p></blockquote><p>但是这种方式只能广播一次。因此，尽管存在很大争议，但这无疑是<code>sync.Cond</code>的一个有趣的功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes之client-go之informer工作原理源码解析</title>
    <link href="/2025/04/03/kubernetes%E4%B9%8Bclient-go%E4%B9%8Binformer%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/04/03/kubernetes%E4%B9%8Bclient-go%E4%B9%8Binformer%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.haohtml.com/archives/32179/">https://blog.haohtml.com/archives/32179/</a></p><h1 id="kubernetes-之-client-go-之-informer-工作原理源码解析"><a href="#kubernetes-之-client-go-之-informer-工作原理源码解析" class="headerlink" title="kubernetes 之 client-go 之 informer 工作原理源码解析"></a>kubernetes 之 client-go 之 informer 工作原理源码解析</h1><p>本文主要介绍有关 <code>client go</code> 架构实现原理，在整个client-go架构中有一个很重要的组件就是 <code>informer</code>，本节我们重点对其进行一些介绍。</p><h1 id="Informer-机制"><a href="#Informer-机制" class="headerlink" title="Informer 机制"></a>Informer 机制</h1><p>采用 k8s HTTP API 可以查询集群中所有的资源对象并 Watch 其变化，但大量的 HTTP 调用会对 API Server 造成较大的负荷，而且网络调用可能存在较大的延迟。除此之外，开发者还需要在程序中处理资源的缓存，HTTP 链接出问题后的重连等。为了解决这些问题并简化 Controller 的开发工作，K8s 在 client go 中提供了一个 <code>informer</code> 客户端库，可以视其为一个组件。</p><p>在 Kubernetes 中，<code>Informer</code> 可以用于监视 Kubernetes API 服务器中的资源并将它们的当前状态缓存到本地(<code>index -&gt; store)</code> ，这样就避免了客户端不断地向 API 服务器发送请求，直接从本地即可。</p><p>相比直接采用 HTTP Watch，使用 Kubernetes Informer 有以下优势：</p><ul><li>减少 API 服务器的负载：通过在本地缓存资源信息，Informer 减少了需要向 API 服务器发出的请求数量。这可以防止由于 API 服务器过载而影响整个集群的性能。</li><li>提高应用程序性能：使用缓存的数据，客户端应用程序可以快速访问资源信息，而无需等待 API 服务器响应。这可以提高应用程序性能并减少延迟。</li><li>简化代码：Informer 提供了一种更简单、更流畅的方式来监视 Kubernetes 中的资源更改。客户端应用程序可以使用现有的 Informer 库来处理这些任务，而无需编写复杂的代码来管理与 API 服务器的连接并处理更新。</li><li>更高的可靠性：由于 Informer 在本地缓存数据，因此即使 API 服务器不可用或存在问题，它们也可以继续工作。这可以确保客户端应用程序即使在底层 Kubernetes 基础结构出现问题时也能保持功能。</li></ul><p>下面一起看一下 client-go 库的实现原理</p><h1 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h1><p>我们先看一下来自 <a href="https://github.com/kubernetes/sample-controller/blob/master/docs/images/client-go-controller-interaction.jpeg">官方</a> 的 <code>client-go</code> 架构图</p><p><img src="/2025/04/03/kubernetes%E4%B9%8Bclient-go%E4%B9%8Binformer%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/client-go-controller-interaction.jpeg" alt="client-go-controller-interaction.jpeg"></p><p>整个架构图分上、下两部分，其中上部分为 <code>client-go</code> 的实现，而下部分是我们自己要实现的 <code>Custom Controller</code>，每部分由不同的组件组成，上下两部分通过虚线连接起来。其介绍请参考 <a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></p><blockquote><p>有时候 <code>Controller</code> 也被叫做 <code>Operator</code>，这两个术语的混用有时让人感到迷惑。 <code>Controller</code> 是一个通用的术语，凡是遵循 “Watch K8s 资源并根据资源变化进行调谐” 模式的控制程序都可以叫做 <code>Controller</code>。而 <code>Operator</code> 是一种专用的 <code>Controller</code>，用于在 Kubernetes 中管理一些复杂的 <strong>有状态</strong> 的应用程序。例如在 Kubernetes 中管理 MySQL 数据库的 MySQL Operator。</p></blockquote><p>在实现 <code>controller</code> 时一般在 <code>Informer</code> 配置回调函数 <code>Callbacks（ResourceEventHandlers）</code>来实现 <code>Informer</code> 和 <code>Custom Controller</code> 上下两部分之间的通讯，这个在上面的链接里均有介绍。如果上图不容易理解的话，也可以参考下面两张架构图。<img src="https://blogstatic.haohtml.com/uploads/2023/04/d2b5ca33bd970f64a6301fa75ae2eb22-3.png" alt="img"><img src="https://blogstatic.haohtml.com/uploads/2023/04/d2b5ca33bd970f64a6301fa75ae2eb22-2.png" alt="img"></p><p>注意这里写入 <code>workqueue</code> 队列的是API对象的 <code>key</code>， 即 <code>namespace/name</code>；接着在控制循环 <code>Control Loop</code> 里先从 <code>workqueue</code> 读取这个 <code>key</code>；然后根据 <code>key</code>从 <code>indexer</code> 缓存里读取对象。如果对象不存在则说明前面是通过 <code>DeleteFunc</code> 写入的，则需要删除key， 否则进行其它处理，执行控制器模式里的对比“<code>期望状态</code>” 和 “<code>实际状态</code>”的逻辑了。</p><p>下面根据官网给出的架构图，我们一起看一下它的实现代码。</p><h1 id="架构实现源码分析"><a href="#架构实现源码分析" class="headerlink" title="架构实现源码分析"></a>架构实现源码分析</h1><p>这里以官方提供的 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/examples/workqueue/README.md">workqueue</a> 示例为例，按照上方的架构图对其 <strong>每一个步骤</strong> 进行源码分析</p><p>入口函数为 main函数中的 <code>go controller.Run(1, stop)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>...<br><br><span class="hljs-comment">// create the pod watcher</span><br>podListWatcher := cache.NewListWatchFromClient(clientset.CoreV1().RESTClient(), <span class="hljs-string">&quot;pods&quot;</span>, v1.NamespaceDefault, fields.Everything())<br><br><span class="hljs-comment">// create the workqueue</span><br>queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())<br><br><span class="hljs-comment">// 创建 indexer 和 informer</span><br>indexer, informer := cache.NewIndexerInformer(podListWatcher, &amp;v1.Pod&#123;&#125;, <span class="hljs-number">0</span>, cache.ResourceEventHandlerFuncs&#123;&#125;<br><br>controller := NewController(queue, indexer, informer)<br><br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(stop)<br><span class="hljs-keyword">go</span> controller.Run(<span class="hljs-number">1</span>, stop)<br><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewController</span><span class="hljs-params">(queue workqueue.RateLimitingInterface, indexer cache.Indexer, informer cache.Controller)</span></span> *Controller &#123;<br><span class="hljs-keyword">return</span> &amp;Controller&#123;<br>informer: informer,<br>indexer:  indexer,<br>queue:    queue,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建的是一个 <code>pods</code> 类型的 <code>ListWatch</code>, 接着创建了一个带 <strong>限速率</strong> 功能的 <code>workqueue</code>（底层queue 的实现对应代码为 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/util/workqueue/queue.go#L64-L88%EF%BC%89">https://github.com/kubernetes/client-go/blob/v12.0.0/util/workqueue/queue.go#L64-L88）</a>, 然后调用 <code>cache.NewIndexInformer</code> 来创建 <code>indexer</code> 和 <code>informer</code>。</p><p>这里的 <code>workqueue</code> 主要是在 <code>ResoureEventHandlers</code> 回调时调用，对应的是第 <code>7) Enqueue Object Key</code> 步骤。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> Run(threadiness <span class="hljs-type">int</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">defer</span> runtime.HandleCrash()<br><br><span class="hljs-comment">// Let the workers stop when we are done</span><br><span class="hljs-keyword">defer</span> c.queue.ShutDown()<br>klog.Info(<span class="hljs-string">&quot;Starting Pod controller&quot;</span>)<br><br><span class="hljs-comment">// 启用 informer 服务</span><br><span class="hljs-keyword">go</span> c.informer.Run(stopCh)<br><br><span class="hljs-comment">// Wait for all involved caches to be synced, before processing items from the queue is started</span><br><span class="hljs-keyword">if</span> !cache.WaitForCacheSync(stopCh, c.informer.HasSynced) &#123;<br>runtime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;Timed out waiting for caches to sync&quot;</span>))<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 业务逻辑回调 c.runWorker</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadiness; i++ &#123;<br><span class="hljs-keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)<br>&#125;<br><br>&lt;-stopCh<br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先调用 <code>go c.informer.Run()</code> 来启用 informer 服务，让其在一个单独的 <code>goroutine</code> 运行， 其实现对应架构图中的 1~7 步骤。</p><p>接着再调用 <code>go wait.Until(c.runWorker, time.Second, stopCh)</code> 来实现自定义控制器的逻辑，其对应架构图中的 8~9 步骤。</p><p>下面我们先看一下 <code>informer</code> 服务的实现 （ <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/controller.go#L97-L125%EF%BC%89%E3%80%82">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/controller.go#L97-L125）。</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><br>    <span class="hljs-comment">// 首先创建 Reflector</span><br>    r := NewReflector(<br>        c.config.ListerWatcher,<br>        c.config.ObjectType,<br>        c.config.Queue,<br>        c.config.FullResyncPeriod,<br>    )<br><br><br>    <span class="hljs-comment">// 启用 Reflector 服务</span><br>    wg.StartWithChannel(stopCh, r.Run)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先创建一个 <code>Reflector</code> 对象，并注入 <code>podListWatcher</code> 和 <code>Delta Fifo Queue</code> 队列， 其中 <code>ObjectType</code> 为 <code>&amp;v1.Pod&#123;&#125;</code>，接着启用 <code>Reflector</code> 服务（<a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/reflector.go#L119-L128%EF%BC%89">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/reflector.go#L119-L128）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/reflector.go</span><br><span class="hljs-comment">// Run starts a watch and handles watch events. Will restart the watch if it is closed.</span><br><span class="hljs-comment">// Run will exit when stopCh is closed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    <span class="hljs-comment">// 启用 ListAndWatch</span><br>    wait.Until(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="hljs-literal">nil</span> &#123;<br>            utilruntime.HandleError(err)<br>        &#125;<br>    &#125;, r.period, stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着看一下 <code>r.ListAndWatch()</code> 实现 （<a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/reflector.go#L156-L307%EF%BC%89">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/reflector.go#L156-L307）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// It returns error if ListAndWatch didn&#x27;t even try to initialize watch.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> ListAndWatch(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><br>    <span class="hljs-comment">// 当前为客户端首次请求资源的情况</span><br>    <span class="hljs-keyword">if</span> err := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>                    panicCh &lt;- r<br>                &#125;<br>            &#125;()<br><br>            <span class="hljs-comment">// 1. 向 apiserver 发送请求</span><br>            <span class="hljs-comment">// 如果支持 listerWatcher，则尝试以 chunks 的方式获取资源列表; 否则第一个列表就返回完整的响应</span><br>            pager := pager.New(pager.SimplePageFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opts metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br>                <span class="hljs-keyword">return</span> r.listerWatcher.List(opts)<br>            &#125;))<br>            <span class="hljs-keyword">if</span> r.WatchListPageSize != <span class="hljs-number">0</span> &#123;<br>                pager.PageSize = r.WatchListPageSize<br>            &#125;<br>            <span class="hljs-comment">// Pager falls back to full list if paginated list calls fail due to an &quot;Expired&quot; error.</span><br>            list, err = pager.List(context.Background(), options)<br>            <span class="hljs-built_in">close</span>(listCh)<br>        &#125;()<br><br>        <span class="hljs-comment">// 2. 读取响应 以 channel通道的方式获取上面 goroutine 的响应结果</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-stopCh:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">case</span> r := &lt;-panicCh:<br>            <span class="hljs-built_in">panic</span>(r)<br>        <span class="hljs-keyword">case</span> &lt;-listCh:<br>        &#125;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: Failed to list %v: %v&quot;</span>, r.name, r.expectedType, err)<br>        &#125;<br><br>        <span class="hljs-comment">// 3.1 从响应结果列表里获取版本号信息</span><br>        listMetaInterface, err := meta.ListAccessor(list)<br>        resourceVersion = listMetaInterface.GetResourceVersion()<br><br>        items, err := meta.ExtractList(list)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: Unable to understand list result %#v (%v)&quot;</span>, r.name, list, err)<br>        &#125;<br><br>        <span class="hljs-comment">// 3.2 根据上次获取的版本号同步最新记录, 更新 Store(Delta FIIO queue) 为最新内容</span><br>        <span class="hljs-keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: Unable to sync list result: %v&quot;</span>, r.name, err)<br>        &#125;<br><br>        <span class="hljs-comment">// 3.3 更新最新版本号</span><br>        r.setLastSyncResourceVersion(resourceVersion)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br><br>    <span class="hljs-comment">// 非首次则根据版本号来获取最新变更资源</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-stopCh:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">default</span>:<br>        &#125;<br><br>        timeoutSeconds := <span class="hljs-type">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="hljs-number">1.0</span>))<br>        options = metav1.ListOptions&#123;<br>            ResourceVersion: resourceVersion,<br>            TimeoutSeconds: &amp;timeoutSeconds,<br>            AllowWatchBookmarks: <span class="hljs-literal">false</span>,<br>        &#125;<br><br>        <span class="hljs-comment">// 根据版本号获取最新资源，并将更新信息写入 Delta Fifo Queue</span><br>        w, err := r.listerWatcher.Watch(options)<br>        <span class="hljs-keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> err != errorStopRequested &#123;<br>                klog.Warningf(<span class="hljs-string">&quot;%s: watch of %v ended with: %v&quot;</span>, r.name, r.expectedType, err)<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于首次访问 <code>apiserver</code>，如果支持 <code>listerWatcher</code> 的话，则以 <code>chunk</code> 的方式获取资源 ，否则一次性获取完整的资源信息，然后再从响应结果里读取当前资源信息号。</p><p>当获取资源列表后，对于以后更新的资源，则需要根据 <code>上次的版本号</code> 来监控以后变更的资源，这样就可以只监控后续变更的资源即可，大大减少数据的传输，即这里是以 <code>增量</code> 方式获取资源，后续的操作从这个 <code>增量队列</code> 里获取资源信息即可。</p><p>上面这些对应的正是架构图中的 <code>1) List &amp; Watch</code> 步骤。</p><p>我们再看一下 <code>r.watchHandler</code> 的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// watchHandler watches w and keeps *resourceVersion up to date.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> watchHandler(w watch.Interface, resourceVersion *<span class="hljs-type">string</span>, errc <span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><br>    ...<br><br>loop:<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-stopCh:<br>            <span class="hljs-keyword">return</span> errorStopRequested<br>        <span class="hljs-keyword">case</span> err := &lt;-errc:<br>            <span class="hljs-keyword">return</span> err<br>        <span class="hljs-keyword">case</span> event, ok := &lt;-w.ResultChan():<br>            <span class="hljs-keyword">if</span> !ok &#123;<br>                <span class="hljs-keyword">break</span> loop<br>            &#125;<br>            <span class="hljs-keyword">if</span> event.Type == watch.Error &#123;<br>                <span class="hljs-keyword">return</span> apierrs.FromObject(event.Object)<br>            &#125;<br>            <span class="hljs-keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="hljs-literal">nil</span> &amp;&amp; e != a &#123;<br>                utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: expected type %v, but watch event object had type %v&quot;</span>, r.name, e, a))<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            meta, err := meta.Accessor(event.Object)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, r.name, event))<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            newResourceVersion := meta.GetResourceVersion()<br><br>            <span class="hljs-comment">// 更新 Delta Fifo Queue</span><br>            <span class="hljs-keyword">switch</span> event.Type &#123;<br>            <span class="hljs-keyword">case</span> watch.Added:<br>                <span class="hljs-comment">// 对应 tools/cache/delta_fifo.go#L171-L178</span><br>                err := r.store.Add(event.Object)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                    utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to add watch event object (%#v) to store: %v&quot;</span>, r.name, event.Object, err))<br>                &#125;<br>            <span class="hljs-keyword">case</span> watch.Modified:<br>                err := r.store.Update(event.Object)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                    utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to update watch event object (%#v) to store: %v&quot;</span>, r.name, event.Object, err))<br>                &#125;<br>            <span class="hljs-keyword">case</span> watch.Deleted:<br>                err := r.store.Delete(event.Object)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                    utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to delete watch event object (%#v) from store: %v&quot;</span>, r.name, event.Object, err))<br>                &#125;<br>            <span class="hljs-keyword">case</span> watch.Bookmark:<br>                <span class="hljs-comment">// A `Bookmark` means watch has synced here, just update the resourceVersion</span><br>            <span class="hljs-keyword">default</span>:<br>                utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, r.name, event))<br>            &#125;<br>            *resourceVersion = newResourceVersion<br>            r.setLastSyncResourceVersion(newResourceVersion)<br>            eventCount++<br>        &#125;<br>    &#125;<br><br>    watchDuration := r.clock.Since(start)<br>    <span class="hljs-keyword">if</span> watchDuration &lt; <span class="hljs-number">1</span>*time.Second &amp;&amp; eventCount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received&quot;</span>, r.name)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里只是对增量队列 <code>Delta Fifo queue</code> 里的资源进行了更新操作，其实现代码见 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/delta_fifo.go#L171-L220">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/delta_fifo.go#L171-L220</a> ， 其对应的正是 <code>2）Add Object</code> 这一步。</p><p>对于 <code>3）Pop Object</code> 这个操作入口函数为 <code>processLoop</code> ( <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/controller.go#L139-L161">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/controller.go#L139-L161</a>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> processLoop() &#123;<br><span class="hljs-keyword">for</span> &#123;<br><br><span class="hljs-comment">// 从 Delta Fifo Queue 读取对象</span><br>obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err == FIFOClosedError &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> c.config.RetryOnError &#123;<br><span class="hljs-comment">// This is the safe way to re-enqueue.</span><br>c.config.Queue.AddIfNotPresent(obj)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其增量队列Pop实现见</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/delta_fifo.go</span><br><span class="hljs-comment">// Pop returns a &#x27;Deltas&#x27;, which has a complete list of all the things</span><br><span class="hljs-comment">// that happened to the object (deltas) while it was sitting in the queue.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> Pop(process PopProcessFunc) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    f.lock.Lock()<br>    <span class="hljs-keyword">defer</span> f.lock.Unlock()<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(f.queue) == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 阻塞方式获取一个对象</span><br>            <span class="hljs-comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span><br>            <span class="hljs-comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span><br>            <span class="hljs-comment">// Which causes this loop to continue and return from the Pop().</span><br>            <span class="hljs-keyword">if</span> f.IsClosed() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, FIFOClosedError<br>            &#125;<br><br>            f.cond.Wait()<br>        &#125;<br><br>        <span class="hljs-comment">// f.queue 是一个slice, 这里获取首个元素后并更新这个切片</span><br>        id := f.queue[<span class="hljs-number">0</span>]<br>        f.queue = f.queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> f.initialPopulationCount &gt; <span class="hljs-number">0</span> &#123;<br>            f.initialPopulationCount--<br>        &#125;<br><br>        <span class="hljs-comment">// 将id作为key从items这个 map 中获取 Deltas 信息</span><br>        item, ok := f.items[id]<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            <span class="hljs-comment">// Item may have been deleted subsequently.</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-built_in">delete</span>(f.items, id)<br><br>        <span class="hljs-comment">// 这里 process 是下一步的进入</span><br>        err := process(item)<br>        <span class="hljs-keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;<br>            f.addIfNotPresent(id, item)<br>            err = e.Err<br>        &#125;<br>        <span class="hljs-comment">// Don&#x27;t need to copyDeltas here, because we&#x27;re transferring</span><br>        <span class="hljs-comment">// ownership to the caller.</span><br>        <span class="hljs-keyword">return</span> item, err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>process</code> 函数在这里是作为一个参数传递过来的，其声明位置为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInformer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    lw ListerWatcher,</span></span><br><span class="hljs-params"><span class="hljs-function">    objType runtime.Object,</span></span><br><span class="hljs-params"><span class="hljs-function">    resyncPeriod time.Duration,</span></span><br><span class="hljs-params"><span class="hljs-function">    h ResourceEventHandler,</span></span><br><span class="hljs-params"><span class="hljs-function">    clientState Store,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> Controller &#123;<br>    ...<br><br>    cfg := &amp;Config&#123;<br>        ...<br><br>        Process: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>            <span class="hljs-comment">// from oldest to newest</span><br>            <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> obj.(Deltas) &#123;<br>                <span class="hljs-keyword">switch</span> d.Type &#123;<br>                <span class="hljs-keyword">case</span> Sync, Added, Updated:<br>                    <span class="hljs-keyword">if</span> old, exists, err := clientState.Get(d.Object); err == <span class="hljs-literal">nil</span> &amp;&amp; exists &#123;<br>                        <span class="hljs-comment">// 对应第 4） 和 5) 步骤</span><br>                        <span class="hljs-keyword">if</span> err := clientState.Update(d.Object); err != <span class="hljs-literal">nil</span> &#123;<br>                            <span class="hljs-keyword">return</span> err<br>                        &#125;<br>                        h.OnUpdate(old, d.Object)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> err := clientState.Add(d.Object); err != <span class="hljs-literal">nil</span> &#123;<br>                            <span class="hljs-keyword">return</span> err<br>                        &#125;<br>                        h.OnAdd(d.Object)<br>                    &#125;<br>                <span class="hljs-keyword">case</span> Deleted:<br>                    <span class="hljs-keyword">if</span> err := clientState.Delete(d.Object); err != <span class="hljs-literal">nil</span> &#123;<br>                        <span class="hljs-keyword">return</span> err<br>                    &#125;<br>                    h.OnDelete(d.Object)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;,<br>    &#125;<br>        <span class="hljs-keyword">return</span> New(cfg)<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的是 <code>Config.Process</code> 这个函数。</p><p>对于架构图中的 <code>4)Add Object</code> 和 <code>5）Store Object &amp; Key</code> 对应的则是对 <code>clientState</code> 的调用。</p><p>而 <code>6）Dispatch Event Handler functions</code> 则为对 对象 <code>h</code> 的调用，它是一个实现了 <code>Resource Event Handlers</code> 接口的结构体，它有三个实现方法 <code>h.OnAdd</code> 、<code>h.OnUpdate</code> 和 <code>h.OnDelete</code>，而这三个方法原型已在 main 函数里实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ...<br><br>    <span class="hljs-comment">// Bind the workqueue to a cache with the help of an informer. This way we make sure that</span><br>    <span class="hljs-comment">// whenever the cache is updated, the pod key is added to the workqueue.</span><br>    <span class="hljs-comment">// Note that when we finally process the item from the workqueue, we might see a newer version</span><br>    <span class="hljs-comment">// of the Pod than the version which was responsible for triggering the update.</span><br>    indexer, informer := cache.NewIndexerInformer(podListWatcher, &amp;v1.Pod&#123;&#125;, <span class="hljs-number">0</span>, cache.ResourceEventHandlerFuncs&#123;<br>        AddFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        UpdateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(old <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(<span class="hljs-built_in">new</span>)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        DeleteFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            <span class="hljs-comment">// IndexerInformer uses a delta queue, therefore for deletes we have to use this</span><br>            <span class="hljs-comment">// key function.</span><br>            key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>    &#125;, cache.Indexers&#123;&#125;)<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用的结构体名为 <code>cache.ResourceEventHandlerFuncs</code> ()</p><p>在 main 函数里的 <code>queue.Add(key)</code> 则对应的是步骤 <code>7) Enqueue Object key</code>, 将 <code>key</code> 写入一个 <code>workqueue</code> 队列。</p><p>而对于 <code>8）Get key</code> 则对应的是 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/examples/workqueue/main.go#L51-L67">controller.processNextItem()</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> processNextItem() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// Wait until there is a new item in the working queue</span><br><span class="hljs-comment">// 对应 8 步骤，从wprkqueue 里读取一个 key</span><br>key, quit := c.queue.Get()<br><span class="hljs-keyword">if</span> quit &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// Tell the queue that we are done with processing this key. This unblocks the key for other workers</span><br><span class="hljs-comment">// This allows safe parallel processing because two pods with the same key are never processed in</span><br><span class="hljs-comment">// parallel.</span><br><span class="hljs-keyword">defer</span> c.queue.Done(key)<br><br><span class="hljs-comment">// Invoke the method containing the business logic</span><br>err := c.syncToStdout(key.(<span class="hljs-type">string</span>))<br><br><span class="hljs-comment">// 出错，重试 5 次</span><br><span class="hljs-comment">// Handle the error if something went wrong during the execution of the business logic</span><br>c.handleErr(err, key)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从 <code>workqueue</code> 里获取一个key， 通过 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/examples/workqueue/main.go#L69-L88">controller.syncToStdout()</a> <code>9) Get Object for key</code>处理。最后调用 <code>c.queue.Done()</code> 表示当前 <code>key</code> 处理完毕。</p><p>而 <code>9) Get Object for key</code> 对应 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/examples/workqueue/main.go#L69-L88">controller.syncToStdout()</a> 函数的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> syncToStdout(key <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 对应步骤 9，从 index 里读取对象</span><br>obj, exists, err := c.indexer.GetByKey(key)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Errorf(<span class="hljs-string">&quot;Fetching object with key %s from store failed with %v&quot;</span>, key, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !exists &#123;<br><span class="hljs-comment">// Below we will warm up our cache with a Pod, so that we will see a delete for one pod</span><br>fmt.Printf(<span class="hljs-string">&quot;Pod %s does not exist anymoren&quot;</span>, key)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Note that you also have to check the uid if you have a local controlled resource, which</span><br><span class="hljs-comment">// is dependent on the actual instance, to detect that a Pod was recreated with the same name</span><br>fmt.Printf(<span class="hljs-string">&quot;Sync/Add/Update for Pod %sn&quot;</span>, obj.(*v1.Pod).GetName())<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到对 <code>workqueue</code> 的写入与读取全部在 <code>Custom Controller</code> 部分来实现的，有时候对一个对象处理会出现失败的情况，这种情况下就需要对其 key 进行 <code>RateLimited</code> 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// handleErr checks if an error happened and makes sure we will retry later.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> handleErr(err <span class="hljs-type">error</span>, key <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Forget about the #AddRateLimited history of the key on every successful synchronization.</span><br><span class="hljs-comment">// This ensures that future processing of updates for this key is not delayed because of</span><br><span class="hljs-comment">// an outdated error history.</span><br>c.queue.Forget(key)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// This controller retries 5 times if something goes wrong. After that, it stops trying.</span><br><span class="hljs-keyword">if</span> c.queue.NumRequeues(key) &lt; <span class="hljs-number">5</span> &#123;<br>klog.Infof(<span class="hljs-string">&quot;Error syncing pod %v: %v&quot;</span>, key, err)<br><br><span class="hljs-comment">// Re-enqueue the key rate limited. Based on the rate limiter on the</span><br><span class="hljs-comment">// queue and the re-enqueue history, the key will be processed later again.</span><br>c.queue.AddRateLimited(key)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c.queue.Forget(key)<br><span class="hljs-comment">// Report to an external entity that, even after several retries, we could not successfully process this key</span><br>runtime.HandleError(err)<br>klog.Infof(<span class="hljs-string">&quot;Dropping pod %q out of the queue: %v&quot;</span>, key, err)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>queue.AddRateLimted(key)</code> 表示 <strong>过一段时间</strong> 将当前 key重新写入 <code>workqueue</code> 里，同时累计当前key的重试次数, 如果重试多次（当前示例为5次）仍失败的话，则调用 <code>runtime.HandleError(err)</code> 处理。</p><p><code>c.queue.Forget</code> 表示一旦key完成，则清除其重试记录，避免影响下次重试，可以看出来 <code>Forget</code> 是对重试行为的处理，这个与 <code>c.queue.Done()</code> 的作用是不一样的。</p><p>至此整个架构图中的每个步骤我们基本介绍完了，对于部分细节问题可能还需要花一些时间进行消化。</p><h1 id="SharedInformer"><a href="#SharedInformer" class="headerlink" title="SharedInformer"></a>SharedInformer</h1><p>如果在一个应用中有多处相互独立的业务逻辑都需要监控同一种资源对象，用户会编写多个 <code>Informer</code> 来进行处理。这会导致应用中发起对 K8s <code>API Server</code> 同一资源的多次 <code>ListAndWatch</code> 调用，并且每一个 <code>Informer</code> 中都有一份单独的本地缓存，增加了内存占用。</p><p>K8s 在 <code>client go</code> 中基于 <code>Informer</code> 之上再次做了一层封装，提供了 <code>SharedInformer</code> 机制。采用 <code>SharedInformer</code> 后，客户端对同一种资源对象只会有一个对 <code>API Server</code> 的 <code>ListAndWatch</code> 调用，多个 <code>Informer</code> 也会共用同一份缓存，减少了对 <code>API Server</code> 的请求，提高了性能。</p><p>而对 <code>SharedInformer</code> 对象的获取一般是通过 <em><code>SharedInformerFactory</code></em> 工厂模式来获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SharedInformerFactory provides shared informers for resources in all known</span><br><span class="hljs-comment">// API group versions.</span><br></code></pre></td></tr></table></figure><p>在内部通过调用 <code>InformerFor()</code> 方法从 <code>cache</code> 中获取某一资源对应的 <code>Informer</code>，如果缓存中不存在，则需要通过指定的函数先创建并加入缓存，然后返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client-go/informers/factory.go#L1870-L208</span><br><span class="hljs-comment">// InternalInformerFor returns the SharedIndexInformer for obj using an internal client.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br>informerType := reflect.TypeOf(obj)<br>informer, exists := f.informers[informerType]<br><span class="hljs-keyword">if</span> exists &#123;<br><span class="hljs-keyword">return</span> informer<br>&#125;<br><br>resyncPeriod, exists := f.customResync[informerType]<br><span class="hljs-keyword">if</span> !exists &#123;<br>resyncPeriod = f.defaultResync<br>&#125;<br><br>informer = newFunc(f.client, resyncPeriod)<br>f.informers[informerType] = informer<br><br><span class="hljs-keyword">return</span> informer<br>&#125;<br></code></pre></td></tr></table></figure><p>这里所谓的 <code>cache</code> 其实就是一个 <code>map</code> 对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sharedInformerFactory <span class="hljs-keyword">struct</span> &#123;<br>        informers <span class="hljs-keyword">map</span>[reflect.Type]cache.SharedIndexInformer<br>&#125;<br></code></pre></td></tr></table></figure><p>对于自定义控制器开发，即可以直接选择使用 <a href="https://github.com/kubernetes-sigs/controller-runtime">Controller Runtime</a> (<a href="https://github.com/kubernetes-sigs/controller-runtime/blob/main/examples/README.md">官方Example</a>)库开发，也可以基于 <a href="https://github.com/operator-framework/operator-sdk">Operator SDK</a>. 开发，还可以基于 <a href="https://book.kubebuilder.io/">kubebuilder</a> 开发框架，其中后两者都会使用 Controller Runtime 库，而 kubebuiler 作为一款开发框架，由于其对开发者极其友好，因此是目前最优先的考虑，参考  <a href="https://book.kubebuilder.io/quick-start.html">Kubebuilder’s Quick Start</a> 了解其用法。</p><p><strong><code>CRD</code> 、<code>CR</code> 和 <code>控制器</code> 的区别</strong><img src="https://blogstatic.haohtml.com/uploads/2023/08/d2b5ca33bd970f64a6301fa75ae2eb22-1.png" alt="img"></p><p><code>CRD</code> 用于定义自定义资源类型, 如果程序开发中定义的类对象，脱离了控制器没有任何意义； <code>CR</code> （Custom Resource）是 <code>CRD</code> 定义的资源的实例化对象，是用户自定义的资源类型的具体实例，类似于根据类实例化了一个对象。<img src="https://blogstatic.haohtml.com/uploads/2023/08/d2b5ca33bd970f64a6301fa75ae2eb22-2.png" alt="img"></p><p><code>自定义控制器</code> 用于管理和控制<code>CRD</code>所定义的自定义资源的行为，类似于 <code>针对实例化对象</code> 的一些基本信息做出相应的动作或行为（实现期望状态与实际状态一致）的控制器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在Kubernetes开发中，<code>client-go</code> 和 <code>Informers</code> 是两个密切相关的概念。</p><p><code>client-go</code> 是 Kubernetes 官方提供的Go语言客户端库，用于与 <code>Kubernetes API</code> 进行通信。它封装了对 <code>Kubernetes API</code> 的各种操作，包括创建、获取、更新和删除资源等，提供了一组简单易用的API接口，方便开发人员进行与Kubernetes集群的交互。</p><p>而 <code>Informers</code> 是 <code>client-go</code> 库中的一部分，它是一种实现了缓存和事件通知机制的机制。<code>Informers</code> 通过监听 Kubernetes <code>API Server</code>上的资源变更事件，将这些事件转换为相应的通知，提供给开发人员使用。这样，开发人员就可以在自己的应用程序中使用Informers来获取最新的资源信息，并进行相应的操作。</p><p>使用 <code>Informers</code> 的好处是，避免了频繁地向 Kubernetes <code>API Server</code> 发送请求来获取最新的资源信息，而是通过缓存和事件通知来获取并同步资源的变更。这样可以减轻Kubernetes <code>API Server</code> 的负担，提高应用程序的性能和效率。</p><p>因此，可以说 <code>client-go</code> 是Kubernetes开发中与 <code>API Server</code> 进行交互的核心组件，而<code>Informers</code> 是 <code>client-go</code> 的一部分，提供了缓存和事件通知的机制，方便开发人员使用。在使用 <code>client-go</code> 进行Kubernetes开发时，可以选择是否使用 <code>Informers</code> 来获取最新的资源信息。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h1><ul><li><a href="https://github.com/kubernetes-sigs/controller-runtime/blob/main/examples/README.md">https://github.com/kubernetes-sigs/controller-runtime/blob/main/examples/README.md</a></li><li><a href="https://time.geekbang.org/column/article/42076">深入解析声明式API（二）：编写自定义控制器</a></li><li><a href="https://blog.csdn.net/weixin_37546425/article/details/118758066">kubebuilder之一：kubernetes operator工作原理</a></li><li><a href="https://www.cnblogs.com/charlieroro/p/10330390.html">kubernetes client-go解析</a></li><li><a href="https://hliangzhao.cn/articles/000001640262318a67c149f524b43a6b2796c4ae753cf2b000">自定义资源对象与控制器的实现</a></li><li><a href="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAkubernetes%E4%B9%8Bclient-go&t=blog&u=weixin_42663840">深入浅出kubernetes之client-go</a></li><li><a href="https://mp.weixin.qq.com/s/TyA1bNXLQs1mXzZbw2PHfw?vid=1688850245817352&deviceid=6239469c-f992-42d3-a9b7-4313801e1c91&version=4.1.3.6008&platform=win">Kubernetes Controller 机制详解（一）</a></li><li><a href="https://github.com/kubernetes/kubernetes/blob/master/staging/README.md">官方所有依赖仓库清单</a></li><li><a href="https://github.com/kubernetes-sigs/kubebuilder">https://github.com/kubernetes-sigs/kubebuilder</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Client-go源码分析之ListerWatcher</title>
    <link href="/2025/04/02/Client-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListerWatcher/"/>
    <url>/2025/04/02/Client-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListerWatcher/</url>
    
    <content type="html"><![CDATA[<h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一 背景"></a>一 背景</h2><p>kubernetes所有API对象都存储在etcd中，并只能通过apiserver访问。如果很多客户端频繁的列举全量对象（比如列举所有的Pod），这会造成apiserver不堪重负。</p><p>ListerWatcher是Lister和Watcher的结合体，ListerWatcher负责列举全量对象，Watcher负责监视（本文将watch翻译为监视）对象的增量变化。</p><p>通过客户端缓存，至在没有任何状态变化的情况下只需要读取本地缓存即可，减少对API-server的压力效率提升显而易见。通过列举全量对象完成本地缓存，而监视增量则是为了及时的将apiserver的状态变化更新到本地缓存。所以，在apiserver与客户端之间绝大部分传输的是对象的增量变化，当然在异常的情况下还是要重新列举一次全量对象。</p><p>本文值得客户端本地缓存就是Indexer，client-go不仅实现了缓存，同时还加了索引，进一步提升了检索效率。</p><h2 id="二-ListerWatcher"><a href="#二-ListerWatcher" class="headerlink" title="二 ListerWatcher"></a>二 ListerWatcher</h2><p>Kubernetes 控制面 (control plane) 的核心是 **API 服务器 (API server)**。API 服务器负责提供 HTTP API，以供用户，集群中的不同部分和集群外部组件相互通信。控制器也不例外，所有控制器都通过 API 获取集群的当前状态，也通过 API 对集群状态进行修改。</p><p>list-watch，作为k8s系统中统一的异步消息传递方式，对系统的性能、数据一致性起到关键性的作用。</p><p><img src="/2025/04/02/Client-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListerWatcher/20220120151429.png" alt="img"></p><p>值得一提的是，Kubernetes 提供了 watch 机制方便客户端实时获取集群状态，有了这个接口，控制器才得以无延迟（准确地说是低延迟）地对状态变更作出响应。这里指的 “状态变更”，就是我们常说的**事件 (event)**。</p><h3 id="2-1-EventType"><a href="#2-1-EventType" class="headerlink" title="2.1 EventType"></a>2.1 EventType</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// EventType defines the possible types of events.</span><br><span class="hljs-keyword">type</span> EventType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>Added    EventType = <span class="hljs-string">&quot;ADDED&quot;</span><br>Modified EventType = <span class="hljs-string">&quot;MODIFIED&quot;</span><br>Deleted  EventType = <span class="hljs-string">&quot;DELETED&quot;</span><br>Bookmark EventType = <span class="hljs-string">&quot;BOOKMARK&quot;</span><br>Error    EventType = <span class="hljs-string">&quot;ERROR&quot;</span><br>)<br></code></pre></td></tr></table></figure><h3 id="2-2-ListerWatcher定义"><a href="#2-2-ListerWatcher定义" class="headerlink" title="2.2 ListerWatcher定义"></a>2.2 ListerWatcher定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 复制代码</span><br><span class="hljs-comment">// client-go/tools/cache/listwatch.go</span><br><span class="hljs-comment">// Lister is any object that knows how to perform an initial list.</span><br><span class="hljs-keyword">type</span> Lister <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// List should return a list type object; the Items field will be extracted, and the</span><br><span class="hljs-comment">// ResourceVersion field will be used to start the watch in the right place.</span><br>List(options metav1.ListOptions) (runtime.Object, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// Watcher is any object that knows how to start a watch on a resource.</span><br><span class="hljs-keyword">type</span> Watcher <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Watch should begin a watch at the specified version.</span><br>Watch(options metav1.ListOptions) (watch.Interface, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// ListerWatcher is any object that knows how to perform an initial list and start a watch on a resource.</span><br><span class="hljs-keyword">type</span> ListerWatcher <span class="hljs-keyword">interface</span> &#123;<br>Lister<br>Watcher<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-创建ListWatcher对象"><a href="#2-3-创建ListWatcher对象" class="headerlink" title="2.3 创建ListWatcher对象"></a>2.3 创建ListWatcher对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewListWatchFromClient creates a new ListWatch from the specified client, resource, namespace and field selector.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewListWatchFromClient</span><span class="hljs-params">(c Getter, resource <span class="hljs-type">string</span>, namespace <span class="hljs-type">string</span>, fieldSelector fields.Selector)</span></span> *ListWatch &#123;<br>optionsModifier := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options *metav1.ListOptions)</span></span> &#123;<br>options.FieldSelector = fieldSelector.String()<br>&#125;<br><span class="hljs-keyword">return</span> NewFilteredListWatchFromClient(c, resource, namespace, optionsModifier)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-小试牛刀"><a href="#三-小试牛刀" class="headerlink" title="三 小试牛刀"></a>三 小试牛刀</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl proxy</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进行listwatch default名称空间下的pods</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl <span class="hljs-string">&quot;127.0.0.1:8001/api/v1/namespaces/default/pods?watch=1&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod进行观察</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run nginx --image=nginx</span><br>&#123;&quot;type&quot;:&quot;ADDED&quot;,&quot;object&quot;:&#123;&quot;kind&quot;:&quot;Pod&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;nginx&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;uid&quot;:&quot;8d0548ce-fb67-4b71-93ec-59ad67b429d9&quot;,&quot;resourceVersion&quot;:&quot;2925331&quot;,&quot;creationTimestamp&quot;:&quot;2022-01-20T07:32:22Z&quot;,&quot;labels&quot;:&#123;&quot;run&quot;:&quot;nginx&quot;&#125;,&quot;managedFields&quot;:[&#123;&quot;manager&quot;:&quot;kubectl-run&quot;,&quot;operation&quot;:&quot;Update&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;time&quot;:&quot;2022-01-20T07:32:22Z&quot;,&quot;fieldsType&quot;:&quot;FieldsV1&quot;,&quot;fieldsV1&quot;:&#123;&quot;f:metadata&quot;:&#123;&quot;f:labels&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:run&quot;:&#123;&#125;&#125;&#125;,&quot;f:spec&quot;:&#123;&quot;f:containers&quot;:&#123;&quot;k:&#123;\&quot;name\&quot;:\&quot;nginx\&quot;&#125;&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:image&quot;:&#123;&#125;,&quot;f:imagePullPolicy&quot;:&#123;&#125;,&quot;f:name&quot;:&#123;&#125;,&quot;f:resources&quot;:&#123;&#125;,&quot;f:terminationMessagePath&quot;:&#123;&#125;,&quot;f:terminationMessagePolicy&quot;:&#123;&#125;&#125;&#125;,&quot;f:dnsPolicy&quot;:&#123;&#125;,&quot;f:enableServiceLinks&quot;:&#123;&#125;,&quot;f:restartPolicy&quot;:&#123;&#125;,&quot;f:schedulerName&quot;:&#123;&#125;,&quot;f:securityContext&quot;:&#123;&#125;,&quot;f:terminationGracePeriodSeconds&quot;:&#123;&#125;&#125;&#125;&#125;]&#125;,&quot;spec&quot;:&#123;&quot;volumes&quot;:[&#123;&quot;name&quot;:&quot;kube-api-access-nc5v8&quot;,&quot;projected&quot;:&#123;&quot;sources&quot;:[&#123;&quot;serviceAccountToken&quot;:&#123;&quot;expirationSeconds&quot;:3607,&quot;path&quot;:&quot;token&quot;&#125;&#125;,&#123;&quot;configMap&quot;:&#123;&quot;name&quot;:&quot;kube-root-ca.crt&quot;,&quot;items&quot;:[&#123;&quot;key&quot;:&quot;ca.crt&quot;,&quot;path&quot;:&quot;ca.crt&quot;&#125;]&#125;&#125;,&#123;&quot;downwardAPI&quot;:&#123;&quot;items&quot;:[&#123;&quot;path&quot;:&quot;namespace&quot;,&quot;fieldRef&quot;:&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;fieldPath&quot;:&quot;metadata.namespace&quot;&#125;&#125;]&#125;&#125;],&quot;defaultMode&quot;:420&#125;&#125;],&quot;containers&quot;:[&#123;&quot;name&quot;:&quot;nginx&quot;,&quot;image&quot;:&quot;nginx&quot;,&quot;resources&quot;:&#123;&#125;,&quot;volumeMounts&quot;:[&#123;&quot;name&quot;:&quot;kube-api-access-nc5v8&quot;,&quot;readOnly&quot;:true,&quot;mountPath&quot;:&quot;/var/run/secrets/kubernetes.io/serviceaccount&quot;&#125;],&quot;terminationMessagePath&quot;:&quot;/dev/termination-log&quot;,&quot;terminationMessagePolicy&quot;:&quot;File&quot;,&quot;imagePullPolicy&quot;:&quot;Always&quot;&#125;],&quot;restartPolicy&quot;:&quot;Always&quot;,&quot;terminationGracePeriodSeconds&quot;:30,&quot;dnsPolicy&quot;:&quot;ClusterFirst&quot;,&quot;serviceAccountName&quot;:&quot;default&quot;,&quot;serviceAccount&quot;:&quot;default&quot;,&quot;securityContext&quot;:&#123;&#125;,&quot;schedulerName&quot;:&quot;default-scheduler&quot;,&quot;tolerations&quot;:[&#123;&quot;key&quot;:&quot;node.kubernetes.io/not-ready&quot;,&quot;operator&quot;:&quot;Exists&quot;,&quot;effect&quot;:&quot;NoExecute&quot;,&quot;tolerationSeconds&quot;:300&#125;,&#123;&quot;key&quot;:&quot;node.kubernetes.io/unreachable&quot;,&quot;operator&quot;:&quot;Exists&quot;,&quot;effect&quot;:&quot;NoExecute&quot;,&quot;tolerationSeconds&quot;:300&#125;],&quot;priority&quot;:0,&quot;enableServiceLinks&quot;:true,&quot;preemptionPolicy&quot;:&quot;PreemptLowerPriority&quot;&#125;,&quot;status&quot;:&#123;&quot;phase&quot;:&quot;Pending&quot;,&quot;qosClass&quot;:&quot;BestEffort&quot;&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="四-代码实现"><a href="#四-代码实现" class="headerlink" title="四 代码实现"></a>四 代码实现</h2><p>编写代码对default名称空间下的configmap进行list watch。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br><span class="hljs-string">&quot;k8s.io/apimachinery/pkg/api/meta&quot;</span><br>metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="hljs-string">&quot;k8s.io/apimachinery/pkg/fields&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/tools/cache&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/util/homedir&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Must</span><span class="hljs-params">(e <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(e)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitClientSet</span><span class="hljs-params">()</span></span> (*kubernetes.Clientset, <span class="hljs-type">error</span>) &#123;<br>kubeconfig := filepath.Join(homedir.HomeDir(), <span class="hljs-string">&quot;.kube&quot;</span>, <span class="hljs-string">&quot;config&quot;</span>)<br>restConfig, err := clientcmd.BuildConfigFromFlags(<span class="hljs-string">&quot;&quot;</span>, kubeconfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> kubernetes.NewForConfig(restConfig)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitListerWatcher</span><span class="hljs-params">(clientSet *kubernetes.Clientset, resource, namespace <span class="hljs-type">string</span>, fieldSelector fields.Selector)</span></span> cache.ListerWatcher &#123;<br>restClient := clientSet.CoreV1().RESTClient()<br><span class="hljs-keyword">return</span> cache.NewListWatchFromClient(restClient, resource, namespace, fieldSelector)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>clientSet, err := InitClientSet()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 什么常量</span><br>resource := <span class="hljs-string">&quot;configmaps&quot;</span><br>namespace := <span class="hljs-string">&quot;default&quot;</span><br><br>configMapListerWatcher := InitListerWatcher(clientSet, resource, namespace, fields.Everything())<br><br><span class="hljs-comment">// 1. list操作</span><br>listObj, err := configMapListerWatcher.List(metav1.ListOptions&#123;&#125;)<br><br><span class="hljs-comment">// meta 包封装了一些处理 runtime.Object 对象的方法，屏蔽了反射和类型转换的过程，</span><br><span class="hljs-comment">// 提取出的 items 类型为 []runtime.Object</span><br>items, err := meta.ExtractList(listObj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>Must(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;list result:&quot;</span>)<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br>configmaps, ok := item.(*v1.ConfigMap)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;namespace: %s, resource name:%s\n&quot;</span>, configmaps.Namespace, configmaps.Name)<br>&#125;<br><br><span class="hljs-comment">// 2. watch 操作</span><br>listMetaInterface, err := meta.ListAccessor(listObj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>Must(err)<br>&#125;<br>resourceVersion := listMetaInterface.GetResourceVersion()<br><br>watchObj, err := configMapListerWatcher.Watch(metav1.ListOptions&#123;<br>ResourceVersion: resourceVersion,<br>&#125;)<br><br><span class="hljs-comment">// 接收信号</span><br>stopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>signal.Notify(stopCh, os.Interrupt)<br>fmt.Println(<span class="hljs-string">&quot;Start watching...&quot;</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stopCh:<br>fmt.Println(<span class="hljs-string">&quot;exit&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> event, ok := &lt;-watchObj.ResultChan():<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;Broken channel&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>configmaps, ok := event.Object.(*v1.ConfigMap)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;eventType: %s, watch obj:%s\n&quot;</span>, event.Type, configmaps.Name)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行创建configmap测试</p><p><img src="/2025/04/02/Client-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListerWatcher/20220120153657.png" alt="img"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><ul><li>ListerWatcher就是为SharedIndexInformer列举全量对象、监视对象增量变化设计的接口，实现就是Clientset的List和Watch函数；</li><li>SharedIndexInformer利用ListerWatcher实现了本地缓存与apiserver之间的状态一致性；</li><li>不仅可以提升客户端访问API对象的效率，同时可以将对象的增量变化回调给使用者；</li><li>从原理上讲，可以用etcd的clientv3.Client实现ListerWatcher，SharedIndexInformer同步etcd的对象，这样一些简单的醒目就可以复用SharedIndexInformer了，毕竟不是所有的项目都需要一个apiserver；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中的Defer必掌握的7知识点</title>
    <link href="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang中的Defer必掌握的7知识点"><a href="#Golang中的Defer必掌握的7知识点" class="headerlink" title="Golang中的Defer必掌握的7知识点"></a>Golang中的Defer必掌握的7知识点</h1><p>转自：<a href="https://www.yuque.com/aceld/golang/qnubsg">https://www.yuque.com/aceld/golang/qnubsg</a></p><p>知识点1：defer的执行顺序</p><p>多个defer出现的时候，它是一个“栈”的关系，也就是先进后出。一个函数中，写在前面的defer会比写在后面的defer调用的晚。</p><p>示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> func1()<br>    <span class="hljs-keyword">defer</span> func2()<br>    <span class="hljs-keyword">defer</span> func3()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/1651037338287-fd17c81d-a1ad-4bc7-ae7e-eec8a264af5f.webp" alt="112-defer2.jpeg"></p><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">C<br>B<br>A<br></code></pre></td></tr></table></figure><h3 id="知识点2-defer与return谁先谁后"><a href="#知识点2-defer与return谁先谁后" class="headerlink" title="知识点2: defer与return谁先谁后"></a>知识点2: defer与return谁先谁后</h3><p>示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferFunc</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;defer func called&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnFunc</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;return func called&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnAndDefer</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><br>    <span class="hljs-keyword">defer</span> deferFunc()<br><br>    <span class="hljs-keyword">return</span> returnFunc()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    returnAndDefer()<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">return</span> func called<br>defer func called<br></code></pre></td></tr></table></figure><p>结论为：<strong>return之后的语句先执行，defer后的语句后执行</strong></p><h3 id="知识点3：函数的返回值初始化"><a href="#知识点3：函数的返回值初始化" class="headerlink" title="知识点3：函数的返回值初始化"></a>知识点3：函数的返回值初始化</h3><p>该知识点不属于defer本身，但是调用的场景却与defer有联系，所以也算是defer必备了解的知识点之一。</p><p>如 ： <code>func DeferFunc1(i int) (t int) &#123;&#125;</code><br>其中返回值<code>t int</code>，这个<code>t</code>会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。</p><p><img src="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/1651037374393-f3e9c019-5990-41a0-8774-d73d0a805a25.png" alt="img"></p><p>示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br><br>    fmt.Println(<span class="hljs-string">&quot;t = &quot;</span>, t)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    DeferFunc11(<span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t =  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>证明，<strong>只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见</strong>。</p><h3 id="知识点4-有名函数返回值遇见defer情况"><a href="#知识点4-有名函数返回值遇见defer情况" class="headerlink" title="知识点4: 有名函数返回值遇见defer情况"></a>知识点4: 有名函数返回值遇见defer情况</h3><p>在没有defer的情况下，其实函数的返回就是与return一致的，但是有了defer就不一样了。</p><p>我们通过<strong>知识点2</strong>得知，先return，再defer，所以在执行完return之后，还要再执行defer里的语句，依然可以修改本应该返回的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnButDefer</span><span class="hljs-params">()</span></span> (t <span class="hljs-type">int</span>) &#123;  <span class="hljs-comment">//t初始化0， 并且作用域为该函数全域</span><br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t = t * <span class="hljs-number">10</span><br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(returnButDefer())<br>&#125;<br></code></pre></td></tr></table></figure><p>该<code>returnButDefer()</code>本应的返回值是<code>1</code>，但是在return之后，又被defer的匿名func函数执行，所以<code>t=t*10</code>被执行，最后<code>returnButDefer()</code>返回给上层<code>main()</code>的结果为<code>10</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run test.go<br>10<br></code></pre></td></tr></table></figure><h3 id="知识点5-defer遇见panic"><a href="#知识点5-defer遇见panic" class="headerlink" title="知识点5: defer遇见panic"></a>知识点5: defer遇见panic</h3><p>我们知道，能够触发defer的是遇见return(或函数体到末尾)和遇见panic。</p><p>根据<strong>知识点2</strong>，我们知道，defer遇见return情况如下：</p><p><img src="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/1651037399517-3b0df721-59da-4ce2-8cd2-2c178b7fa355.jpeg" alt="img"></p><p>那么，遇到panic时，遍历本协程的defer链表，并执行defer。在执行defer过程中:遇到recover则停止panic，返回recover处继续往下执行。如果没有遇到recover，遍历完本协程的defer链表后，向stderr抛出panic信息。</p><p><img src="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/1651037430519-67ffce42-f7eb-4698-8190-618c89274e2f.jpeg" alt="img"></p><h4 id="A-defer遇见panic，但是并不捕获异常的情况"><a href="#A-defer遇见panic，但是并不捕获异常的情况" class="headerlink" title="A. defer遇见panic，但是并不捕获异常的情况"></a>A. defer遇见panic，但是并不捕获异常的情况</h4><p>test10.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    defer_call()<br><br>    fmt.Println(<span class="hljs-string">&quot;main 正常结束&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defer_call</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之前1&quot;</span>) &#125;()<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之前2&quot;</span>) &#125;()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;异常内容&quot;</span>)  <span class="hljs-comment">//触发defer出栈</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之后，永远执行不到&quot;</span>) &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">defer: panic 之前2<br>defer: panic 之前1<br>panic: 异常内容<br>//... 异常堆栈信息<br></code></pre></td></tr></table></figure><h4 id="B-defer遇见panic，并捕获异常"><a href="#B-defer遇见panic，并捕获异常" class="headerlink" title="B. defer遇见panic，并捕获异常"></a>B. defer遇见panic，并捕获异常</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    defer_call()<br><br>    fmt.Println(<span class="hljs-string">&quot;main 正常结束&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defer_call</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;defer: panic 之前1, 捕获异常&quot;</span>)<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(err)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之前2, 不捕获&quot;</span>) &#125;()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;异常内容&quot;</span>)  <span class="hljs-comment">//触发defer出栈</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之后, 永远执行不到&quot;</span>) &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span>: <span class="hljs-built_in">panic</span> 之前<span class="hljs-number">2</span>, 不捕获<br><span class="hljs-keyword">defer</span>: <span class="hljs-built_in">panic</span> 之前<span class="hljs-number">1</span>, 捕获异常<br>异常内容<br>main 正常结束<br></code></pre></td></tr></table></figure><p><strong>defer 最大的功能是 panic 后依然有效</strong><br>所以defer可以保证你的一些资源一定会被关闭，从而避免一些异常出现的问题。</p><h3 id="知识点6-defer中包含panic"><a href="#知识点6-defer中包含panic" class="headerlink" title="知识点6: defer中包含panic"></a>知识点6: defer中包含panic</h3><p>编译执行下面代码会出现什么?</p><p>test16.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span>&#123;<br>           fmt.Println(err)<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           fmt.Println(<span class="hljs-string">&quot;fatal&quot;</span>)<br>       &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;defer panic&quot;</span>)<br>    &#125;()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">defer panic<br></code></pre></td></tr></table></figure><p><strong>分析</strong></p><p><strong>panic仅有最后一个可以被revover捕获</strong>。</p><p>触发<code>panic(&quot;panic&quot;)</code>后defer顺序出栈执行，第一个被执行的defer中 会有<code>panic(&quot;defer panic&quot;)</code>异常语句，这个异常将会覆盖掉main中的异常<code>panic(&quot;panic&quot;)</code>，最后这个异常被第二个执行的defer捕获到。</p><h3 id="知识点7-defer下的函数参数包含子函数"><a href="#知识点7-defer下的函数参数包含子函数" class="headerlink" title="知识点7: defer下的函数参数包含子函数"></a>知识点7: defer下的函数参数包含子函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(index <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    fmt.Println(index)<br><br>    <span class="hljs-keyword">return</span> index<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> function(<span class="hljs-number">1</span>, function(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">defer</span> function(<span class="hljs-number">2</span>, function(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，有4个函数，他们的index序号分别为1，2，3，4。</p><p>那么这4个函数的先后执行顺序是什么呢？这里面有两个defer， 所以defer一共会压栈两次，先进栈1，后进栈2。 那么在压栈function1的时候，需要连同函数地址、函数形参一同进栈，那么为了得到function1的第二个参数的结果，所以就需要先执行function3将第二个参数算出，那么function3就被第一个执行。同理压栈function2，就需要执行function4算出function2第二个参数的值。然后函数结束，先出栈fuction2、再出栈function1.</p><p>所以顺序如下：</p><ul><li>defer压栈function1，压栈函数地址、形参1、形参2(调用function3) –&gt; 打印3</li><li>defer压栈function2，压栈函数地址、形参1、形参2(调用function4) –&gt; 打印4</li><li>defer出栈function2, 调用function2 –&gt; 打印2</li><li>defer出栈function1, 调用function1–&gt; 打印1</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">3<br>4<br>2<br>1<br></code></pre></td></tr></table></figure><h3 id="练习：defer面试真题"><a href="#练习：defer面试真题" class="headerlink" title="练习：defer面试真题"></a>练习：defer面试真题</h3><p>了解以上6个defer的知识点，我们来验证一下网上的真题吧。</p><p>下面代码输出什么？</p><p>test11.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    t = i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    t := i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc3</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += i<br>    &#125;()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc4</span><span class="hljs-params">()</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        fmt.Println(i)<br>        fmt.Println(t)<br>    &#125;(t)<br>    t = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(DeferFunc1(<span class="hljs-number">1</span>))<br>    fmt.Println(DeferFunc2(<span class="hljs-number">1</span>))<br>    fmt.Println(DeferFunc3(<span class="hljs-number">1</span>))<br>    DeferFunc4()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习题分析"><a href="#练习题分析" class="headerlink" title="练习题分析"></a>练习题分析</h3><h4 id="DeferFunc1"><a href="#DeferFunc1" class="headerlink" title="DeferFunc1"></a>DeferFunc1</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    t = i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>将返回值t赋值为传入的i，此时t为1</li><li>执行return语句将t赋值给t（等于啥也没做）</li><li>执行defer方法，将t + 3 &#x3D; 4</li><li>函数返回 4<br>因为t的作用域为整个函数所以修改有效。</li></ol><h4 id="DeferFunc2"><a href="#DeferFunc2" class="headerlink" title="DeferFunc2"></a>DeferFunc2</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    t := i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>创建变量t并赋值为1</li><li>执行return语句，注意这里是将t赋值给返回值，此时返回值为1（这个返回值并不是t）</li><li>执行defer方法，将t + 3 &#x3D; 4</li><li>函数返回返回值1</li></ol><p>也可以按照如下代码理解:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (result <span class="hljs-type">int</span>) &#123;<br>    t := i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码return的时候相当于将t赋值给了result，当defer修改了t的值之后，对result是不会造成影响的。</p><h4 id="DeferFunc3"><a href="#DeferFunc3" class="headerlink" title="DeferFunc3"></a>DeferFunc3</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc3</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += i<br>    &#125;()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>首先执行return将返回值t赋值为2</li><li>执行defer方法将t + 1</li><li>最后返回 3</li></ol><h4 id="DeferFunc4"><a href="#DeferFunc4" class="headerlink" title="DeferFunc4"></a>DeferFunc4</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc4</span><span class="hljs-params">()</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        fmt.Println(i)<br>        fmt.Println(t)<br>    &#125;(t)<br>    t = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>初始化返回值t为零值 0</li><li>首先执行defer的第一步，赋值defer中的func入参t为0</li><li>执行defer的第二步，将defer压栈</li><li>将t赋值为1</li><li>执行return语句，将返回值t赋值为2</li><li>执行defer的第三步，出栈并执行<br>因为在入栈时defer执行的func的入参已经赋值了，此时它作为的是一个形式参数，所以打印为0；相对应的因为最后已经将t的值修改为2，所以再打印一个2</li></ol><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a><strong>结果</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>1<br>3<br>0<br>2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解client-go中的indexer</title>
    <link href="/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/"/>
    <url>/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解client-go中的indexer"><a href="#深入理解client-go中的indexer" class="headerlink" title="深入理解client-go中的indexer"></a>深入理解client-go中的indexer</h1><p>转自：<a href="https://cloud.tencent.com/developer/article/1692517?cps_key=1d358d18a7a17b4a6df8d67a62fd3d3d">https://cloud.tencent.com/developer/article/1692517?cps_key=1d358d18a7a17b4a6df8d67a62fd3d3d</a></p><p><img src="/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/640.png" alt="图片"></p><p>前面我们讲到 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzU4MjQ0MTU4Ng==&mid=2247485864&idx=1&sn=2011dfed276fe75a767d1e55f7d979ce&chksm=fdb906b5cace8fa3a01b911ac1004f6d6b57d8e0ae0d9a0e0746cdfa988947cc0e37ad2a980c&scene=21%23wechat_redirect&objectId=1692517&objectType=1&isNewArticle=undefined">DeltaFIFO 中的元素通过 Pop 函数弹出后</a>，在指定的回调函数中将元素添加到了 Indexer 中。Indexer 是什么？字面意思是索引器，它就是 Informer 中的 LocalStore 部分，我们可以和<a href="https://cloud.tencent.com/product/tencentdb-catalog?from_column=20065&from=20065">数据库</a>进行类比，数据库是建立在存储之上的，索引也是构建在存储之上，只是和数据做了一个映射，使得按照某些条件查询速度会非常快，所以说 Indexer 本身也是一个存储，只是它在存储的基础上扩展了索引功能。从 Indexer 接口的定义可以证明这一点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/indexer.go</span><br><br><span class="hljs-comment">// Indexer 使用多个索引扩展了 Store，并限制了每个累加器只能容纳当前对象</span><br><span class="hljs-comment">// 这里有3种字符串需要说明：</span><br><span class="hljs-comment">// 1. 一个存储键，在 Store 接口中定义（其实就是对象键）</span><br><span class="hljs-comment">// 2. 一个索引的名称（相当于索引分类名称）</span><br><span class="hljs-comment">// 3. 索引键，由 IndexFunc 生成，可以是一个字段值或从对象中计算出来的任何字符串</span><br><span class="hljs-keyword">type</span> Indexer <span class="hljs-keyword">interface</span> &#123;<br> Store  <span class="hljs-comment">// 继承了 Store 存储接口，所以说 Indexer 也是存储</span><br> <span class="hljs-comment">// indexName 是索引类名称，obj 是对象，计算 obj 在 indexName 索引类中的索引键，然后通过索引键把所有的对象取出来</span><br>  <span class="hljs-comment">// 获取 obj 对象在索引类中的索引键相匹配的对象</span><br> Index(indexName <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) ([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br> <span class="hljs-comment">// indexKey 是 indexName 索引分类中的一个索引键</span><br>  <span class="hljs-comment">// 函数返回 indexKey 指定的所有对象键 IndexKeys </span><br> IndexKeys(indexName, indexedValue <span class="hljs-type">string</span>) ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br> ListIndexFuncValues(indexName <span class="hljs-type">string</span>) []<span class="hljs-type">string</span><br> ByIndex(indexName, indexedValue <span class="hljs-type">string</span>) ([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br> GetIndexers() Indexers<br> <span class="hljs-comment">// 添加新的索引在存储中</span><br> AddIndexers(newIndexers Indexers) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a><strong>Indexer</strong></h3><p>在去查看 Indexer 的接口具体实现之前，我们需要了解 Indexer 中几个非常重要的概念：<code>Indices</code>、<code>Index</code>、<code>Indexers</code> 及 <code>IndexFunc</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/indexer.go</span><br><br><span class="hljs-comment">// 用于计算一个对象的索引键集合</span><br><span class="hljs-keyword">type</span> IndexFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// 索引键与对象键集合的映射</span><br><span class="hljs-keyword">type</span> Index <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]sets.String<br><br><span class="hljs-comment">// 索引器名称（或者索引分类）与 IndexFunc 的映射，相当于存储索引的各种分类</span><br><span class="hljs-keyword">type</span> Indexers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]IndexFunc<br><br><span class="hljs-comment">// 索引器名称与 Index 索引的映射</span><br><span class="hljs-keyword">type</span> Indices <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Index<br></code></pre></td></tr></table></figure><p>这4个数据结构的命名非常容易让大家混淆，直接查看源码也不是那么容易的。这里我们来仔细解释下。首先什么叫索引，索引就是为了快速查找的，比如我们需要查找某个节点上的所有 Pod，那就让 Pod 按照节点名称排序列举出来，对应的就是 Index 这个类型，具体的就是 <code>map[node]sets.pod</code>，但是如何去查找可以有多种方式，就是上面的 Indexers 这个类型的作用。我们可以用一个比较具体的示例来解释他们的关系和含义，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br> <span class="hljs-string">&quot;fmt&quot;</span><br><br> v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br> <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/api/meta&quot;</span><br> metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br> <span class="hljs-string">&quot;k8s.io/client-go/tools/cache&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br> NamespaceIndexName = <span class="hljs-string">&quot;namespace&quot;</span><br> NodeNameIndexName  = <span class="hljs-string">&quot;nodeName&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NamespaceIndexFunc</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br> m, err := meta.Accessor(obj)<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;&quot;</span>&#125;, fmt.Errorf(<span class="hljs-string">&quot;object has no meta: %v&quot;</span>, err)<br> &#125;<br> <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;m.GetNamespace()&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NodeNameIndexFunc</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br> pod, ok := obj.(*v1.Pod)<br> <span class="hljs-keyword">if</span> !ok &#123;<br>  <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;, <span class="hljs-literal">nil</span><br> &#125;<br> <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;pod.Spec.NodeName&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> index := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers&#123;<br>  NamespaceIndexName: NamespaceIndexFunc,<br>  NodeNameIndexName:  NodeNameIndexFunc,<br> &#125;)<br><br> pod1 := &amp;v1.Pod&#123;<br>  ObjectMeta: metav1.ObjectMeta&#123;<br>   Name:      <span class="hljs-string">&quot;index-pod-1&quot;</span>,<br>   Namespace: <span class="hljs-string">&quot;default&quot;</span>,<br>  &#125;,<br>  Spec: v1.PodSpec&#123;NodeName: <span class="hljs-string">&quot;node1&quot;</span>&#125;,<br> &#125;<br> pod2 := &amp;v1.Pod&#123;<br>  ObjectMeta: metav1.ObjectMeta&#123;<br>   Name:      <span class="hljs-string">&quot;index-pod-2&quot;</span>,<br>   Namespace: <span class="hljs-string">&quot;default&quot;</span>,<br>  &#125;,<br>  Spec: v1.PodSpec&#123;NodeName: <span class="hljs-string">&quot;node2&quot;</span>&#125;,<br> &#125;<br> pod3 := &amp;v1.Pod&#123;<br>  ObjectMeta: metav1.ObjectMeta&#123;<br>   Name:      <span class="hljs-string">&quot;index-pod-3&quot;</span>,<br>   Namespace: <span class="hljs-string">&quot;kube-system&quot;</span>,<br>  &#125;,<br>  Spec: v1.PodSpec&#123;NodeName: <span class="hljs-string">&quot;node2&quot;</span>&#125;,<br> &#125;<br><br> _ = index.Add(pod1)<br> _ = index.Add(pod2)<br> _ = index.Add(pod3)<br><br> <span class="hljs-comment">// ByIndex 两个参数：IndexName（索引器名称）和 indexKey（需要检索的key）</span><br> pods, err := index.ByIndex(NamespaceIndexName, <span class="hljs-string">&quot;default&quot;</span>)<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-built_in">panic</span>(err)<br> &#125;<br> <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>  fmt.Println(pod.(*v1.Pod).Name)<br> &#125;<br><br> fmt.Println(<span class="hljs-string">&quot;==========================&quot;</span>)<br><br> pods, err = index.ByIndex(NodeNameIndexName, <span class="hljs-string">&quot;node2&quot;</span>)<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-built_in">panic</span>(err)<br> &#125;<br> <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>  fmt.Println(pod.(*v1.Pod).Name)<br> &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 输出结果为：</span><br>index-pod<span class="hljs-number">-1</span><br>index-pod<span class="hljs-number">-2</span><br>==========================<br>index-pod<span class="hljs-number">-2</span><br>index-pod<span class="hljs-number">-3</span><br></code></pre></td></tr></table></figure><p>在上面的示例中首先通过 NewIndexer 函数实例化 Indexer 对象，第一个参数就是用于计算资源对象键的函数，这里我们使用的是 <code>MetaNamespaceKeyFunc</code> 这个默认的对象键函数；第二个参数是 Indexers，也就是存储索引器，上面我们知道 <code>Indexers</code> 的定义为 <code>map[string]IndexFunc</code>，为什么要定义成一个 map 呢？我们可以类比数据库中，我们要查询某项数据，索引的方式是不是多种多样啊？为了扩展，Kubernetes 中就使用一个 map 来存储各种各样的存储索引器，至于存储索引器如何生成，就使用一个 <code>IndexFunc</code> 暴露出去，给使用者自己实现即可。</p><p>这里我们定义的了两个索引键生成函数：<code>NamespaceIndexFunc</code> 与 <code>NodeNameIndexFunc</code>，一个根据资源对象的命名空间来进行索引，一个根据资源对象所在的节点进行索引。然后定义了3个 Pod，前两个在 default 命名空间下面，另外一个在 kube-system 命名空间下面，然后通过 <code>index.Add</code> 函数添加这3个 Pod 资源对象。然后通过 <code>index.ByIndex</code> 函数查询在名为 <code>namespace</code> 的索引器下面匹配索引键为 <code>default</code> 的 Pod 列表。也就是查询 default 这个命名空间下面的所有 Pod，这里就是前两个定义的 Pod。</p><p>对上面的示例如果我们理解了，那么就很容易理解上面定义的4个数据结构了：</p><ul><li>IndexFunc：索引器函数，用于计算一个资源对象的索引值列表，上面示例是指定命名空间为索引值结果，当然我们也可以根据需求定义其他的，比如根据 Label 标签、Annotation 等属性来生成索引值列表。</li><li>Index：存储数据，对于上面的示例，我们要查找某个命名空间下面的 Pod，那就要让 Pod 按照其命名空间进行索引，对应的 Index 类型就是 <code>map[namespace]sets.pod</code>。</li><li>Indexers：存储索引器，key 为索引器名称，value 为索引器的实现函数，上面的示例就是 <code>map[&quot;namespace&quot;]MetaNamespaceIndexFunc</code>。</li><li>Indices：存储缓存器，key 为索引器名称，value 为缓存的数据，对于上面的示例就是 <code>map[&quot;namespace&quot;]map[namespace]sets.pod</code>。</li></ul><p>可能最容易混淆的是 Indexers 和 Indices 这两个概念，因为平时很多时候我们没有怎么区分二者的关系，这里我们可以这样理解：Indexers 是存储索引（生成索引键）的，Indices 里面是存储的真正的数据（对象键），这样可能更好理解。</p><p><img src="/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/658k4cmdot.png" alt="img"></p><p><img src="/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/640-1743599934675-3.webp" alt="图片"></p><p>按照上面的理解我们可以得到上面示例的索引数据如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Indexers 就是包含的所有索引器(分类)以及对应实现</span><br>Indexers: &#123;  <br>  <span class="hljs-string">&quot;namespace&quot;</span>: NamespaceIndexFunc,<br>  <span class="hljs-string">&quot;nodeName&quot;</span>: NodeNameIndexFunc,<br>&#125;<br><span class="hljs-comment">// Indices 就是包含的所有索引分类中所有的索引数据</span><br>Indices: &#123;<br> <span class="hljs-string">&quot;namespace&quot;</span>: &#123;  <span class="hljs-comment">//namespace 这个索引分类下的所有索引数据</span><br>  <span class="hljs-string">&quot;default&quot;</span>: [<span class="hljs-string">&quot;pod-1&quot;</span>, <span class="hljs-string">&quot;pod-2&quot;</span>],  <span class="hljs-comment">// Index 就是一个索引键下所有的对象键列表</span><br>  <span class="hljs-string">&quot;kube-system&quot;</span>: [<span class="hljs-string">&quot;pod-3&quot;</span>]   <span class="hljs-comment">// Index</span><br> &#125;,<br> <span class="hljs-string">&quot;nodeName&quot;</span>: &#123;  <span class="hljs-comment">//nodeName 这个索引分类下的所有索引数据(对象键列表)</span><br>  <span class="hljs-string">&quot;node1&quot;</span>: [<span class="hljs-string">&quot;pod-1&quot;</span>],  <span class="hljs-comment">// Index</span><br>  <span class="hljs-string">&quot;node2&quot;</span>: [<span class="hljs-string">&quot;pod-2&quot;</span>, <span class="hljs-string">&quot;pod-3&quot;</span>]  <span class="hljs-comment">// Index</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadSafeMap"><a href="#ThreadSafeMap" class="headerlink" title="ThreadSafeMap"></a><strong>ThreadSafeMap</strong></h3><p>上面我们理解了 Indexer 中的几个重要的数据类型，下面我们来看下 Indexer 接口的具体实现 cache，位于文件 <code>k8s.io/client-go/tools/cache/store.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// [k8s.io/client-go/tools/cache/store.go](http://k8s.io/client-go/tools/cache/store.go)</span><br><br><span class="hljs-comment">// cache 用一个 ThreadSafeStore 和一个关联的 KeyFunc 来实现 Indexer</span><br><span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;<br> <span class="hljs-comment">// cacheStorage 是一个线程安全的存储</span><br> cacheStorage ThreadSafeStore<br>  <span class="hljs-comment">// keyFunc 用于计算对象键</span><br> keyFunc KeyFunc<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到这个 cache 包含一个 <code>ThreadSafeStore</code> 的属性，这是一个并发安全的存储，因为是存储，所以自然就有存储相关的增、删、改、查等操作，Indexer 就是在 ThreadSafeMap 基础上进行封装的，实现了索引相关的功能。接下来我们先来看看 ThreadSafeStore 的定义，位于 <code>k8s.io/client-go/tools/cache/thread_safe_store.go</code> 文件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ThreadSafeStore <span class="hljs-keyword">interface</span> &#123;<br> Add(key <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;)<br> Update(key <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;)<br> Delete(key <span class="hljs-type">string</span>)<br> Get(key <span class="hljs-type">string</span>) (item <span class="hljs-keyword">interface</span>&#123;&#125;, exists <span class="hljs-type">bool</span>)<br> List() []<span class="hljs-keyword">interface</span>&#123;&#125;<br> ListKeys() []<span class="hljs-type">string</span><br> Replace(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">string</span>)<br> Index(indexName <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) ([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br> IndexKeys(indexName, indexKey <span class="hljs-type">string</span>) ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br> ListIndexFuncValues(name <span class="hljs-type">string</span>) []<span class="hljs-type">string</span><br> ByIndex(indexName, indexKey <span class="hljs-type">string</span>) ([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br> GetIndexers() Indexers<br><br> AddIndexers(newIndexers Indexers) <span class="hljs-type">error</span><br> Resync() <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从接口的定义可以看出 ThreadSafeStore 和 Index 基本上差不多，但还是有一些区别的，这个接口是需要通过对象键来进行索引的。接下来我们来看看这个接口的具体实现 threadSafeMap 的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// threadSafeMap 实现了 ThreadSafeStore</span><br><span class="hljs-keyword">type</span> threadSafeMap <span class="hljs-keyword">struct</span> &#123;<br> lock  sync.RWMutex<br>  <span class="hljs-comment">// 存储资源对象数据，key(对象键) 通过 keyFunc 得到</span><br>  <span class="hljs-comment">// 这就是真正存储的数据（对象键 -&gt; 对象）</span><br> items <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br> <span class="hljs-comment">// indexers 索引分类与索引键函数的映射</span><br> indexers Indexers<br> <span class="hljs-comment">// indices 通过索引可以快速找到对象键</span><br> indices Indices<br>&#125;<br></code></pre></td></tr></table></figure><p>不要把索引键和对象键搞混了，索引键是用于对象快速查找的；对象键是对象在存储中的唯一命名，对象是通过名字+对象的方式存储的。接下来我们来仔细看下接口的具体实现，首先还是比较简单的 Add、Delete、Update 几个函数的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// 添加对象</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> Add(key <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br> c.lock.Lock()<br> <span class="hljs-keyword">defer</span> c.lock.Unlock()<br>  <span class="hljs-comment">// 获取老的对象</span><br> oldObject := c.items[key]<br>  <span class="hljs-comment">// 写入新的对象，items 中存的是 objKey -&gt; obj 的映射</span><br> c.items[key] = obj<br>  <span class="hljs-comment">// 添加了新的对象，所以要更新索引</span><br> c.updateIndices(oldObject, obj, key)<br>&#125;<br><br><span class="hljs-comment">// 更新对象，可以看到实现和 Add 是一样的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> Update(key <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br> c.lock.Lock()<br> <span class="hljs-keyword">defer</span> c.lock.Unlock()<br> oldObject := c.items[key]<br> c.items[key] = obj<br> c.updateIndices(oldObject, obj, key)<br>&#125;<br><br><span class="hljs-comment">// 删除对象</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> Delete(key <span class="hljs-type">string</span>) &#123;<br> c.lock.Lock()<br> <span class="hljs-keyword">defer</span> c.lock.Unlock()<br>  <span class="hljs-comment">// 判断对象是否存在，存在才执行删除操作</span><br> <span class="hljs-keyword">if</span> obj, exists := c.items[key]; exists &#123;<br>    <span class="hljs-comment">// 删除对象索引</span><br>  c.deleteFromIndices(obj, key)<br>    <span class="hljs-comment">// 删除对象本身</span><br>  <span class="hljs-built_in">delete</span>(c.items, key)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到基本的实现比较简单，就是添加、更新、删除对象数据后，然后更新或删除对应的索引，所以我们需要查看下更新或删除索引的具体实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// updateIndices 更新索引</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> updateIndices(oldObj <span class="hljs-keyword">interface</span>&#123;&#125;, newObj <span class="hljs-keyword">interface</span>&#123;&#125;, key <span class="hljs-type">string</span>) &#123;<br> <span class="hljs-comment">// 如果有旧的对象，需要先从索引中删除这个对象</span><br> <span class="hljs-keyword">if</span> oldObj != <span class="hljs-literal">nil</span> &#123;<br>  c.deleteFromIndices(oldObj, key)<br> &#125;<br>  <span class="hljs-comment">// 循环所有的索引器</span><br> <span class="hljs-keyword">for</span> name, indexFunc := <span class="hljs-keyword">range</span> c.indexers &#123;<br>    <span class="hljs-comment">// 获取对象的索引键</span><br>  indexValues, err := indexFunc(newObj)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;unable to calculate an index entry for key %q on index %q: %v&quot;</span>, key, name, err))<br>  &#125;<br>    <span class="hljs-comment">// 得到当前索引器的索引</span><br>  index := c.indices[name]<br>  <span class="hljs-keyword">if</span> index == <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-comment">// 没有对应的索引，则初始化一个索引</span><br>   index = Index&#123;&#125;<br>   c.indices[name] = index<br>  &#125;<br>    <span class="hljs-comment">// 循环所有的索引键</span><br>  <span class="hljs-keyword">for</span> _, indexValue := <span class="hljs-keyword">range</span> indexValues &#123;<br>      <span class="hljs-comment">// 得到索引键对应的对象键列表</span><br>   set := index[indexValue]<br>   <span class="hljs-keyword">if</span> set == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 没有对象键列表则初始化一个空列表</span><br>    set = sets.String&#123;&#125;<br>    index[indexValue] = set<br>   &#125;<br>      <span class="hljs-comment">// 将对象键插入到集合中，方便索引</span><br>   set.Insert(key)<br>  &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">// deleteFromIndices 删除对象索引</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> deleteFromIndices(obj <span class="hljs-keyword">interface</span>&#123;&#125;, key <span class="hljs-type">string</span>) &#123;<br> <span class="hljs-comment">// 循环所有的索引器</span><br> <span class="hljs-keyword">for</span> name, indexFunc := <span class="hljs-keyword">range</span> c.indexers &#123;<br>  <span class="hljs-comment">// 获取删除对象的索引键列表</span><br>  indexValues, err := indexFunc(obj)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;unable to calculate an index entry for key %q on index %q: %v&quot;</span>, key, name, err))<br>  &#125;<br>  <span class="hljs-comment">// 获取当前索引器的索引</span><br>  index := c.indices[name]<br>  <span class="hljs-keyword">if</span> index == <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-keyword">continue</span><br>  &#125;<br>  <span class="hljs-comment">// 循环所有索引键</span><br>  <span class="hljs-keyword">for</span> _, indexValue := <span class="hljs-keyword">range</span> indexValues &#123;<br>   <span class="hljs-comment">// 获取索引键对应的对象键列表</span><br>   set := index[indexValue]<br>   <span class="hljs-keyword">if</span> set != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 从对象键列表中删除当前要删除的对象键</span><br>    set.Delete(key)<br><br>    <span class="hljs-comment">// 如果当集合为空的时候不删除set，那么具有高基数的短生命资源的 indices 会导致未使用的空集合随时间增加内存。</span><br>    <span class="hljs-comment">// `kubernetes/kubernetes/issues/84959`.</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(set) == <span class="hljs-number">0</span> &#123;<br>     <span class="hljs-built_in">delete</span>(index, indexValue)<br>    &#125;<br>   &#125;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加索引和删除索引的实现都挺简单的，其实主要还是要对 indices、indexs 这些数据结构非常了解，这样就非常容易了，我们可以将 indexFunc 当成当前对象的命名空间来看待，这样对于上面的索引更新和删除的理解就肯定没问题了。</p><p>然后接下来就是几个查询相关的接口实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// 获取对象</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">Get</span>(key string) (item interface&#123;&#125;, exists bool) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()  <span class="hljs-comment">// 只需要读锁</span><br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <span class="hljs-comment">// 直接从 map 中读取值</span><br> item, exists = c.<span class="hljs-property">items</span>[key]<br> <span class="hljs-keyword">return</span> item, exists<br>&#125;<br><br><span class="hljs-comment">// 对象列举</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">List</span>() []interface&#123;&#125; &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br> list := <span class="hljs-title function_">make</span>([]interface&#123;&#125;, <span class="hljs-number">0</span>, <span class="hljs-title function_">len</span>(c.<span class="hljs-property">items</span>))<br> <span class="hljs-keyword">for</span> _, item := range c.<span class="hljs-property">items</span> &#123;<br>  list = <span class="hljs-title function_">append</span>(list, item)<br> &#125;<br> <span class="hljs-keyword">return</span> list<br>&#125;<br><br><span class="hljs-comment">// 返回 threadSafeMap 中所有的对象键列表</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">ListKeys</span>() []string &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br> list := <span class="hljs-title function_">make</span>([]string, <span class="hljs-number">0</span>, <span class="hljs-title function_">len</span>(c.<span class="hljs-property">items</span>))<br> <span class="hljs-keyword">for</span> key := range c.<span class="hljs-property">items</span> &#123;<br>  list = <span class="hljs-title function_">append</span>(list, key)<br> &#125;<br> <span class="hljs-keyword">return</span> list<br>&#125;<br><br><span class="hljs-comment">// 替换所有对象，相当于重新构建索引</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">Replace</span>(items map[string]interface&#123;&#125;, resourceVersion string) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">Lock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">Unlock</span>()<br>  <span class="hljs-comment">// 直接覆盖之前的对象</span><br> c.<span class="hljs-property">items</span> = items<br><br> <span class="hljs-comment">// 重新构建索引</span><br> c.<span class="hljs-property">indices</span> = <span class="hljs-title class_">Indices</span>&#123;&#125;<br> <span class="hljs-keyword">for</span> key, item := range c.<span class="hljs-property">items</span> &#123;<br>    <span class="hljs-comment">// 更新元素的索引</span><br>  c.<span class="hljs-title function_">updateIndices</span>(nil, item, key)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后接下来就是和索引相关的几个接口实现，第一个就是 Index 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// 通过指定的索引器和对象获取符合这个对象特征的所有对象</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">Index</span>(indexName string, obj interface&#123;&#125;) ([]interface&#123;&#125;, error) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <span class="hljs-comment">// 获得索引器 indexName 的索引键计算函数</span><br> indexFunc := c.<span class="hljs-property">indexers</span>[indexName]<br> <span class="hljs-keyword">if</span> indexFunc == nil &#123;<br>  <span class="hljs-keyword">return</span> nil, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;Index with name %s does not exist&quot;</span>, indexName)<br> &#125;<br>  <span class="hljs-comment">// 获取指定 obj 对象的索引键</span><br> indexedValues, err := <span class="hljs-title function_">indexFunc</span>(obj)<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> nil, err<br> &#125;<br>  <span class="hljs-comment">// 获得索引器 indexName 的所有索引</span><br> index := c.<span class="hljs-property">indices</span>[indexName]<br> <br>  <span class="hljs-comment">// 用来存储对象键的集合</span><br> <span class="hljs-keyword">var</span> storeKeySet sets.<span class="hljs-property">String</span><br> <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(indexedValues) == <span class="hljs-number">1</span> &#123;<br>    <span class="hljs-comment">// 大多数情况下只有一个值匹配（默认获取的索引键就是对象的 namespace）</span><br>    <span class="hljs-comment">// 直接拿到这个索引键的对象键集合</span><br>  storeKeySet = index[indexedValues[<span class="hljs-number">0</span>]]<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 由于有多个索引键，则可能有重复的对象键出现，索引需要去重</span><br>  storeKeySet = sets.<span class="hljs-property">String</span>&#123;&#125;<br>    <span class="hljs-comment">// 循环索引键</span><br>  <span class="hljs-keyword">for</span> _, indexedValue := range indexedValues &#123;<br>      <span class="hljs-comment">// 循环索引键下面的对象键，因为要去重</span><br>   <span class="hljs-keyword">for</span> key := range index[indexedValue] &#123;<br>    storeKeySet.<span class="hljs-title class_">Insert</span>(key)<br>   &#125;<br>  &#125;<br> &#125;<br>  <span class="hljs-comment">// 拿到了所有的对象键集合过后，循环拿到所有的对象集合</span><br> list := <span class="hljs-title function_">make</span>([]interface&#123;&#125;, <span class="hljs-number">0</span>, storeKeySet.<span class="hljs-title class_">Len</span>())<br> <span class="hljs-keyword">for</span> storeKey := range storeKeySet &#123;<br>  list = <span class="hljs-title function_">append</span>(list, c.<span class="hljs-property">items</span>[storeKey])<br> &#125;<br> <span class="hljs-keyword">return</span> list, nil<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 Index 函数就是获取一个指定对象的索引键，然后把这个索引键下面的所有的对象全部获取到，比如我们要获取一个 Pod 所在命名空间下面的所有 Pod，如果更抽象一点，就是符合对象<em>某些特征</em>的所有对象，而这个特征就是我们指定的索引键函数计算出来的。然后接下来就是一个比较重要的 ByIndex 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// 和上面的 Index 函数类似，只是是直接指定的索引键</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">ByIndex</span>(indexName, indexedValue string) ([]interface&#123;&#125;, error) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <br>  <span class="hljs-comment">// 获得索引器 indexName 的索引键计算函数</span><br> indexFunc := c.<span class="hljs-property">indexers</span>[indexName]<br> <span class="hljs-keyword">if</span> indexFunc == nil &#123;<br>  <span class="hljs-keyword">return</span> nil, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;Index with name %s does not exist&quot;</span>, indexName)<br> &#125;<br>  <span class="hljs-comment">// 获得索引器 indexName 的所有索引</span><br> index := c.<span class="hljs-property">indices</span>[indexName]<br>  <span class="hljs-comment">// 获取指定索引键的所有所有对象键</span><br> set := index[indexedValue]<br>  <span class="hljs-comment">// 然后根据对象键遍历获取对象</span><br> list := <span class="hljs-title function_">make</span>([]interface&#123;&#125;, <span class="hljs-number">0</span>, set.<span class="hljs-title class_">Len</span>())<br> <span class="hljs-keyword">for</span> key := range set &#123;<br>  list = <span class="hljs-title function_">append</span>(list, c.<span class="hljs-property">items</span>[key])<br> &#125;<br><br> <span class="hljs-keyword">return</span> list, nil<br>&#125;<br></code></pre></td></tr></table></figure><p>可以很清楚地看到 ByIndex 函数和 Index 函数比较类似，但是更简单了，直接获取一个指定的索引键的全部资源对象。然后是其他几个索引相关的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// IndexKeys 和上面的 ByIndex 几乎是一样的，只是这里是直接返回对象键列表</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">IndexKeys</span>(indexName, indexedValue string) ([]string, error) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <span class="hljs-comment">// 获取索引器 indexName 的索引键计算函数</span><br> indexFunc := c.<span class="hljs-property">indexers</span>[indexName]<br> <span class="hljs-keyword">if</span> indexFunc == nil &#123;<br>  <span class="hljs-keyword">return</span> nil, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;Index with name %s does not exist&quot;</span>, indexName)<br> &#125;<br>  <span class="hljs-comment">// 获取索引器 indexName 的所有索引</span><br> index := c.<span class="hljs-property">indices</span>[indexName]<br> <span class="hljs-comment">// 直接获取指定索引键的对象键集合</span><br> set := index[indexedValue]<br> <span class="hljs-keyword">return</span> set.<span class="hljs-title class_">List</span>(), nil<br>&#125;<br><br><span class="hljs-comment">// 获取索引器下面的所有索引键</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">ListIndexFuncValues</span>(indexName string) []string &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <span class="hljs-comment">// 获取索引器 indexName 的所有索引</span><br> index := c.<span class="hljs-property">indices</span>[indexName]<br> names := <span class="hljs-title function_">make</span>([]string, <span class="hljs-number">0</span>, <span class="hljs-title function_">len</span>(index))<br>  <span class="hljs-comment">// 遍历索引得到索引键</span><br> <span class="hljs-keyword">for</span> key := range index &#123;<br>  names = <span class="hljs-title function_">append</span>(names, key)<br> &#125;<br> <span class="hljs-keyword">return</span> names<br>&#125;<br><br><span class="hljs-comment">// 直接返回 indexers</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">GetIndexers</span>() <span class="hljs-title class_">Indexers</span> &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">indexers</span><br>&#125;<br><br><span class="hljs-comment">// 添加一个新的 Indexers</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">AddIndexers</span>(newIndexers <span class="hljs-title class_">Indexers</span>) error &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">Lock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">Unlock</span>()<br><br> <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(c.<span class="hljs-property">items</span>) &gt; <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-keyword">return</span> fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;cannot add indexers to running index&quot;</span>)<br> &#125;<br>  <span class="hljs-comment">// 获取旧的索引器和新的索引器keys</span><br> oldKeys := sets.<span class="hljs-title class_">StringKeySet</span>(c.<span class="hljs-property">indexers</span>)<br> newKeys := sets.<span class="hljs-title class_">StringKeySet</span>(newIndexers)<br>  <br>  <span class="hljs-comment">// 如果包含新的索引器，则提示冲突</span><br> <span class="hljs-keyword">if</span> oldKeys.<span class="hljs-title class_">HasAny</span>(newKeys.<span class="hljs-title class_">List</span>()...) &#123;<br>  <span class="hljs-keyword">return</span> fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;indexer conflict: %v&quot;</span>, oldKeys.<span class="hljs-title class_">Intersection</span>(newKeys))<br> &#125;<br>  <span class="hljs-comment">// 将新的索引器添加到 Indexers 中</span><br> <span class="hljs-keyword">for</span> k, v := range newIndexers &#123;<br>  c.<span class="hljs-property">indexers</span>[k] = v<br> &#125;<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-comment">// 没有真正实现 Resync 操作 </span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">Resync</span>() error &#123;<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们就将 ThreadSafeMap 的实现进行了分析说明。整体来说比较方便，一个就是将对象数据存入到一个 map 中，然后就是维护索引，方便根据索引来查找到对应的对象。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a><strong>cache</strong></h3><p>接下来再回过头去看 cache 的实现就非常简单了，因为 cache 就是对 ThreadSafeStore 的一个再次封装，很多操作都是直接调用的 <code>ThreadSafeStore</code> 的操作实现的，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/store.go</span><br><br><span class="hljs-comment">// Add 插入一个元素到 cache 中</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Add</span>(obj interface&#123;&#125;) error &#123;<br> key, err := c.<span class="hljs-title function_">keyFunc</span>(obj)  <span class="hljs-comment">// 生成对象键</span><br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">KeyError</span>&#123;obj, err&#125;<br> &#125;<br>  <span class="hljs-comment">// 将对象添加到底层的 ThreadSafeStore 中</span><br> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Add</span>(key, obj)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-comment">// 更新cache中的对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Update</span>(obj interface&#123;&#125;) error &#123;<br> key, err := c.<span class="hljs-title function_">keyFunc</span>(obj)<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">KeyError</span>&#123;obj, err&#125;<br> &#125;<br> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Update</span>(key, obj)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-comment">// 删除cache中的对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Delete</span>(obj interface&#123;&#125;) error &#123;<br> key, err := c.<span class="hljs-title function_">keyFunc</span>(obj)<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">KeyError</span>&#123;obj, err&#125;<br> &#125;<br> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Delete</span>(key)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-comment">// 得到cache中所有的对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">List</span>() []interface&#123;&#125; &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">List</span>()<br>&#125;<br><br><span class="hljs-comment">// 得到cache中所有的对象键</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">ListKeys</span>() []string &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">ListKeys</span>()<br>&#125;<br><br><span class="hljs-comment">// 得到cache中的Indexers</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">GetIndexers</span>() <span class="hljs-title class_">Indexers</span> &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">GetIndexers</span>()<br>&#125;<br><br><span class="hljs-comment">// 得到对象obj与indexName索引器关联的所有对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Index</span>(indexName string, obj interface&#123;&#125;) ([]interface&#123;&#125;, error) &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Index</span>(indexName, obj)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">IndexKeys</span>(indexName, indexKey string) ([]string, error) &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">IndexKeys</span>(indexName, indexKey)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">ListIndexFuncValues</span>(indexName string) []string &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">ListIndexFuncValues</span>(indexName)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">ByIndex</span>(indexName, indexKey string) ([]interface&#123;&#125;, error) &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">ByIndex</span>(indexName, indexKey)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">AddIndexers</span>(newIndexers <span class="hljs-title class_">Indexers</span>) error &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">AddIndexers</span>(newIndexers)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Get</span>(obj interface&#123;&#125;) (item interface&#123;&#125;, exists bool, err error) &#123;<br> key, err := c.<span class="hljs-title function_">keyFunc</span>(obj)<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> nil, <span class="hljs-literal">false</span>, <span class="hljs-title class_">KeyError</span>&#123;obj, err&#125;<br> &#125;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-title class_">GetByKey</span>(key)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">GetByKey</span>(key string) (item interface&#123;&#125;, exists bool, err error) &#123;<br> item, exists = c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Get</span>(key)<br> <span class="hljs-keyword">return</span> item, exists, nil<br>&#125;<br><br><span class="hljs-comment">// 替换cache中所有的对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Replace</span>(list []interface&#123;&#125;, resourceVersion string) error &#123;<br> items := <span class="hljs-title function_">make</span>(map[string]interface&#123;&#125;, <span class="hljs-title function_">len</span>(list))<br> <span class="hljs-keyword">for</span> _, item := range list &#123;<br>  key, err := c.<span class="hljs-title function_">keyFunc</span>(item)<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-title class_">KeyError</span>&#123;item, err&#125;<br>  &#125;<br>  items[key] = item<br> &#125;<br> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Replace</span>(items, resourceVersion)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Resync</span>() error &#123;<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 cache 没有自己独特的实现方式，都是调用的包含的 <code>ThreadSafeStore</code> 操作接口。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>前面我们已经知道了 Reflector 通过 ListAndWatch 把数据传入 DeltaFIFO 后，经过 DeltaFIFO 的 Pop 函数将资源对象存入到了本地的一个存储 Indexer 中，而这个底层真正的存储其实就是上面的 ThreadSafeStore。</p><p>要理解 Indexer 组件，最主要就是要把索引、索引器（索引分类）、索引键、对象键这几个概念弄清楚，有时候确实容易混乱，我们将上面的示例理解了应该就很好理解了，比如我们按照命名空间来进行索引，可以简单的理解为这个 Indexer 就是简单的把相同命名空间的对象放在一个集合中，然后基于命名空间来查找对象。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pod创建过程</title>
    <link href="/2025/03/31/pod%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/03/31/pod%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Pod创建过程"><a href="#Pod创建过程" class="headerlink" title="Pod创建过程"></a><a href="https://www.cnblogs.com/love-DanDan/p/18402153">Pod创建过程</a></h2><p>以下是为Kubernetes初学者设计的《Pod创建全流程详解》教学讲义，结合技术细节与教学逻辑，帮助学生深入理解Kubernetes内部机制：</p><hr><h3 id="Kubernetes-Pod创建全流程教学讲义"><a href="#Kubernetes-Pod创建全流程教学讲义" class="headerlink" title="Kubernetes Pod创建全流程教学讲义"></a><strong>Kubernetes Pod创建全流程教学讲义</strong></h3><p><strong>目标</strong>：理解从<code>kubectl create</code>到Pod运行的完整生命周期<br><strong>难度</strong>：中级<br><strong>预计时长</strong>：45分钟<br><strong>核心概念图</strong>：<br><code>用户请求 → API Server → 持久化 → 控制器 → 调度 → 节点执行</code></p><hr><h4 id="一、前置知识回顾（5分钟）"><a href="#一、前置知识回顾（5分钟）" class="headerlink" title="一、前置知识回顾（5分钟）"></a><strong>一、前置知识回顾（5分钟）</strong></h4><ol><li><strong>Pod是什么</strong>  <ul><li>Kubernetes最小调度单元</li><li>一个或多个容器的逻辑集合（共享网络&#x2F;存储命名空间）</li></ul></li><li><strong>关键组件角色</strong>  <pre><code class=" mermaid">graph LRA[kubectl] --&gt; B[API Server]B --&gt; C[etcd]B --&gt; D[Controller Manager]B --&gt; E[Scheduler]E --&gt; F[Kubelet]F --&gt; G[Container Runtime]</code></pre></li></ol><hr><h4 id="二、Pod创建全流程详解（30分钟）"><a href="#二、Pod创建全流程详解（30分钟）" class="headerlink" title="二、Pod创建全流程详解（30分钟）"></a><strong>二、Pod创建全流程详解（30分钟）</strong></h4><h5 id="阶段1：用户提交请求（Client-Side）"><a href="#阶段1：用户提交请求（Client-Side）" class="headerlink" title="阶段1：用户提交请求（Client Side）"></a><strong>阶段1：用户提交请求（Client Side）</strong></h5><ol><li><strong>命令解析</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f pod.yaml → <br>  kubectl 将YAML转换为JSON → <br>  通过kubeconfig找到APIServer地址<br></code></pre></td></tr></table></figure></li><li><strong>认证与授权</strong>  <ul><li>认证方式：X.509证书&#x2F;Bearer Token&#x2F;ServiceAccount</li><li>授权检查：RBAC验证用户是否有<code>create pod</code>权限</li></ul></li></ol><h5 id="阶段2：API-Server处理"><a href="#阶段2：API-Server处理" class="headerlink" title="阶段2：API Server处理"></a><strong>阶段2：API Server处理</strong></h5><ol><li><strong>请求接收</strong>  <ul><li>监听端口：6443 (HTTPS)</li><li>请求示例：<code>POST /api/v1/namespaces/default/pods</code></li></ul></li><li><strong>准入控制（Admission Control）</strong>  <ul><li>修改&#x2F;验证请求的拦截链  </li><li>关键插件：  <ul><li><code>NamespaceLifecycle</code>：检查命名空间是否存在  </li><li><code>ResourceQuota</code>：是否超过资源配额  </li><li><code>DefaultStorageClass</code>：自动添加存储类  </li><li><strong>示例</strong>：MutatingWebhook自动注入Sidecar容器</li></ul></li></ul></li></ol><h5 id="阶段3：持久化存储（etcd）"><a href="#阶段3：持久化存储（etcd）" class="headerlink" title="阶段3：持久化存储（etcd）"></a><strong>阶段3：持久化存储（etcd）</strong></h5><ol><li><strong>数据写入</strong>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">API Server → 将Pod对象 → 存储为etcd的key-value<br><span class="hljs-comment">// Key路径示例：/registry/pods/default/my-pod</span><br></code></pre></td></tr></table></figure></li><li><strong>返回结果</strong>  <ul><li>返回HTTP 201 Created → <code>kubectl</code>显示”pod&#x2F;my-pod created”</li></ul></li></ol><h5 id="阶段4：控制器响应（Control-Loop）"><a href="#阶段4：控制器响应（Control-Loop）" class="headerlink" title="阶段4：控制器响应（Control Loop）"></a><strong>阶段4：控制器响应（Control Loop）</strong></h5><ol><li><strong>Informer监听机制</strong>  <ul><li>Controller Manager中的<code>ReplicationController</code>持续watch etcd变化</li><li>发现新Pod对象 → 加入工作队列</li></ul></li><li><strong>节点调度决策</strong>  <ul><li><strong>调度器工作流程</strong>：<pre><code class=" mermaid">graph TDA[获取未调度Pod] --&gt; B&#123;预选阶段&#125;B --&gt; C[过滤不满足节点：资源/污点等]C --&gt; D&#123;优选阶段&#125;D --&gt; E[节点打分：资源均衡/亲和性]E --&gt; F[绑定节点：写入Pod.spec.nodeName]</code></pre></li><li><strong>关键算法</strong>：  <ul><li>预选(Predicates)：节点CPU&#x2F;Memory是否充足  </li><li>优选(Priorities)：选择资源利用率最低的节点</li></ul></li></ul></li></ol><h5 id="阶段5：节点执行（Node-Level）"><a href="#阶段5：节点执行（Node-Level）" class="headerlink" title="阶段5：节点执行（Node Level）"></a><strong>阶段5：节点执行（Node Level）</strong></h5><ol><li><p><strong>Kubelet接管</strong>  </p><ul><li>Watch到绑定本节点的Pod → 调用CRI（Container Runtime Interface）</li></ul></li><li><p><strong>容器启动流程</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sequence">Kubelet→CRI: 创建Pod沙盒（pause容器）<br>CRI→Runtime: 创建容器组<br>Runtime→Container: 启动业务容器<br>Container→Kubelet: 状态反馈<br></code></pre></td></tr></table></figure></li><li><p><strong>状态上报</strong>  </p><ul><li>Kubelet持续监控 → 通过API Server更新Pod状态至etcd</li></ul></li></ol><hr><h4 id="三、核心故障点与排错（7分钟）"><a href="#三、核心故障点与排错（7分钟）" class="headerlink" title="三、核心故障点与排错（7分钟）"></a><strong>三、核心故障点与排错（7分钟）</strong></h4><table><thead><tr><th>阶段</th><th>常见错误</th><th>诊断命令</th></tr></thead><tbody><tr><td>调度阶段</td><td>Pending状态</td><td><code>kubectl describe pod</code> 查看Events</td></tr><tr><td>镜像拉取</td><td>ImagePullBackOff</td><td><code>kubectl logs -p</code></td></tr><tr><td>节点资源</td><td>Insufficient cpu&#x2F;memory</td><td><code>kubectl top nodes</code></td></tr><tr><td>网络配置</td><td>CNI插件未就绪</td><td>检查<code>kube-system</code>的DaemonSet</td></tr></tbody></table><hr><h4 id="四、实验与验证（8分钟）"><a href="#四、实验与验证（8分钟）" class="headerlink" title="四、实验与验证（8分钟）"></a><strong>四、实验与验证（8分钟）</strong></h4><ol><li><strong>实时观察创建流程</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 终端1：事件监听</span><br>kubectl get events -w<br><br><span class="hljs-comment"># 终端2：创建Pod</span><br>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml<br></code></pre></td></tr></table></figure></li><li><strong>关键状态检查点</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl get pod -o wide -w  <span class="hljs-comment"># 观察调度节点</span><br>kubectl describe pod nginx  <span class="hljs-comment"># 查看详细生命周期事件</span><br></code></pre></td></tr></table></figure></li></ol><hr><h4 id="五、进阶思考题"><a href="#五、进阶思考题" class="headerlink" title="五、进阶思考题"></a><strong>五、进阶思考题</strong></h4><ol><li>如果API Server重启，已创建但未调度的Pod会丢失吗？<br><strong>答案</strong>：不会，状态已持久化在etcd</li><li>如何实现Pod跨可用区的高可用调度？<br><strong>提示</strong>：利用<code>podAntiAffinity</code> + 多节点组</li></ol><h2 id="Controller-Manager和Scheduler在Pod创建中的作用"><a href="#Controller-Manager和Scheduler在Pod创建中的作用" class="headerlink" title="Controller Manager和Scheduler在Pod创建中的作用"></a>Controller Manager和Scheduler在Pod创建中的作用</h2><hr><h3 id="控制器响应阶段深度解析"><a href="#控制器响应阶段深度解析" class="headerlink" title="控制器响应阶段深度解析"></a><strong>控制器响应阶段深度解析</strong></h3><h4 id="核心组件分工"><a href="#核心组件分工" class="headerlink" title="核心组件分工"></a><strong>核心组件分工</strong></h4><pre><code class=" mermaid">graph LRA[Controller Manager] --&gt;|管理工作负载控制器| B[ReplicaSet/Deployment等]C[Scheduler] --&gt;|专属调度器| D[绑定节点]E[无主Pod] --&gt;|直接进入| CB --&gt;|创建副本Pod| C</code></pre><hr><h3 id="一、Controller-Manager的作用（控制面管家）"><a href="#一、Controller-Manager的作用（控制面管家）" class="headerlink" title="一、Controller Manager的作用（控制面管家）"></a><strong>一、Controller Manager的作用（控制面管家）</strong></h3><p><strong>职责</strong>：管理各类<strong>工作负载控制器</strong>，确保系统状态符合用户声明<br><strong>涉及控制器</strong>：  </p><ol><li><strong>ReplicaSet控制器</strong>（若Pod由Deployment创建）<ul><li>监听到Deployment创建 → 生成ReplicaSet → ReplicaSet创建Pod副本</li><li>持续检查：实际Pod数 vs 期望副本数</li></ul></li><li><strong>DaemonSet控制器</strong>（若为DaemonSet Pod）<ul><li>确保每个匹配节点运行一个Pod副本</li></ul></li><li><strong>Job控制器</strong>（一次性任务）<ul><li>创建Pod直到完成任务计数</li></ul></li></ol><p><strong>关键动作</strong>：  </p><ul><li><strong>创建裸Pod时</strong>：Controller Manager<strong>不会介入</strong>（无关联控制器）</li><li><strong>工作负载Pod创建时</strong>：  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 伪代码流程</span><br><span class="hljs-keyword">if</span> 用户创建Deployment &#123;<br>  ReplicaSet控制器创建Pod对象（未调度状态）<br>  写入etcd → 触发调度器工作<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="二、Scheduler的作用（调度专家）"><a href="#二、Scheduler的作用（调度专家）" class="headerlink" title="二、Scheduler的作用（调度专家）"></a><strong>二、Scheduler的作用（调度专家）</strong></h3><p><strong>专属职责</strong>：为<strong>未分配节点的Pod</strong>选择最佳运行节点<br><strong>触发条件</strong>：Pod满足 <code>spec.nodeName == &quot;&quot;</code><br><strong>工作流程</strong>：  </p><pre><code class=" mermaid">sequenceDiagram    Scheduler-&gt;&gt;API Server: Watch未调度Pod    API Server-&gt;&gt;etcd: 持久化Pod状态    Scheduler-&gt;&gt;Scheduler: 执行调度算法    Scheduler-&gt;&gt;API Server: 发送Binding请求    API Server-&gt;&gt;etcd: 更新Pod.spec.nodeName</code></pre><p><strong>具体决策步骤</strong>：  </p><ol><li><strong>预选（Predicates）</strong>：硬件过滤  <ul><li>检查候选节点：CPU&#x2F;Memory是否充足、端口冲突、节点污点容忍等  </li><li><em>示例</em>：排除只有4GB内存的节点（Pod请求8GB）</li></ul></li><li><strong>优选（Priorities）</strong>：软性评分  <ul><li>计算节点得分：资源平衡（选择空闲CPU最多的）、亲和性策略等  </li><li><em>示例</em>：给同可用区的节点+10分</li></ul></li><li><strong>绑定（Bind）</strong>：  <ul><li>将最优节点名写入Pod的<code>spec.nodeName</code>字段  </li><li><strong>注意</strong>：Scheduler不直接操作kubelet，只更新API对象</li></ul></li></ol><hr><h3 id="三、关键交互案例"><a href="#三、关键交互案例" class="headerlink" title="三、关键交互案例"></a><strong>三、关键交互案例</strong></h3><h4 id="场景1：创建裸Pod（无控制器管理）"><a href="#场景1：创建裸Pod（无控制器管理）" class="headerlink" title="场景1：创建裸Pod（无控制器管理）"></a><strong>场景1：创建裸Pod（无控制器管理）</strong></h4><ol><li><code>kubectl create -f pod.yaml</code> → API Server直写etcd</li><li><strong>Scheduler</strong> 检测到该Pod无节点 → 启动调度流程</li><li>绑定节点后 → 目标节点<strong>kubelet</strong>接管</li></ol><h4 id="场景2：通过Deployment创建Pod"><a href="#场景2：通过Deployment创建Pod" class="headerlink" title="场景2：通过Deployment创建Pod"></a><strong>场景2：通过Deployment创建Pod</strong></h4><ol><li>用户创建Deployment → <strong>Controller Manager</strong>中的Deployment控制器激活</li><li>Deployment创建ReplicaSet → <strong>ReplicaSet控制器</strong>生成Pod模板（未调度）</li><li><strong>Scheduler</strong> 发现未调度Pod → 执行节点绑定</li><li><strong>kubelet</strong> 启动容器 → ReplicaSet控制器持续监控Pod状态</li></ol><hr><h3 id="四、故障排查聚焦点"><a href="#四、故障排查聚焦点" class="headerlink" title="四、故障排查聚焦点"></a><strong>四、故障排查聚焦点</strong></h3><table><thead><tr><th>组件</th><th>故障表现</th><th>排查命令</th><th>日志位置</th></tr></thead><tbody><tr><td>Controller Manager</td><td>Pod未被创建</td><td><code>kubectl get rs -o wide</code></td><td>Master节点<code>/var/log/kube-controller-manager.log</code></td></tr><tr><td>Scheduler</td><td>Pod卡在Pending</td><td><code>kubectl describe pod</code> 看Events</td><td>Master节点<code>/var/log/kube-scheduler.log</code></td></tr><tr><td>kubelet</td><td>Pod启动失败</td><td><code>journalctl -u kubelet</code></td><td>Worker节点<code>/var/log/kubelet.log</code></td></tr></tbody></table><hr><h3 id="五、实验验证（动手理解）"><a href="#五、实验验证（动手理解）" class="headerlink" title="五、实验验证（动手理解）"></a><strong>五、实验验证（动手理解）</strong></h3><ol><li><p><strong>观察调度器决策</strong>：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 跟踪调度日志（需配置日志级别）</span><br>kubectl logs -n kube-system &lt;scheduler-pod&gt; --<span class="hljs-built_in">tail</span>=50 | grep <span class="hljs-string">&quot;Scheduling&quot;</span><br></code></pre></td></tr></table></figure><p><strong>输出示例</strong>：<br><code>&quot;Successfully assigned default/nginx-5ffd6d7cdf-abc12 to worker-02&quot;</code></p></li><li><p><strong>模拟调度失败</strong>：  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 创建必定调度失败的Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">impossible-pod</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">test</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">resources:</span><br>      <span class="hljs-attr">requests:</span><br>        <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;999&quot;</span>  <span class="hljs-comment"># 超过节点总CPU</span><br>  <span class="hljs-attr">nodeSelector:</span><br>    <span class="hljs-attr">disktype:</span> <span class="hljs-string">ssd</span>   <span class="hljs-comment"># 节点无此标签</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl describe pod impossible-pod<br><span class="hljs-comment"># Events显示：</span><br><span class="hljs-comment"># 0/3 nodes available: 1 node(s) didn&#x27;t match Pod&#x27;s node affinity...</span><br></code></pre></td></tr></table></figure></li></ol><hr><h3 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a><strong>关键结论</strong></h3><ol><li><strong>Controller Manager</strong>  <ul><li>管理<strong>工作负载控制器</strong>（ReplicaSet&#x2F;DaemonSet等）  </li><li><strong>不直接处理调度</strong>，只确保Pod副本数符合预期</li></ul></li><li><strong>Scheduler</strong>  <ul><li>专属处理<strong>节点绑定决策</strong>  </li><li>独立于Controller Manager运行  </li><li>只关心 <code>spec.nodeName==&quot;&quot;</code> 的Pod</li></ul></li><li><strong>协作本质</strong>：  <pre><code class=" mermaid">graph LRetcd--&gt;|状态存储| A[Controller Manager]etcd--&gt;|状态存储| B[Scheduler]A--&gt;|创建未调度Pod| etcdB--&gt;|监听未调度Pod| etcd</code></pre></li></ol><blockquote><p>教学建议：用乐高积木比喻——Controller Manager是生产积木的工厂，Scheduler是决定积木放在哪个位置的分配员，kubelet是最终拼装积木的工人。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s平台排错一览图</title>
    <link href="/2025/03/31/k8s%E5%B9%B3%E5%8F%B0%E6%8E%92%E9%94%99%E4%B8%80%E8%A7%88%E5%9B%BE/"/>
    <url>/2025/03/31/k8s%E5%B9%B3%E5%8F%B0%E6%8E%92%E9%94%99%E4%B8%80%E8%A7%88%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s排错一览图"><a href="#k8s排错一览图" class="headerlink" title="k8s排错一览图"></a>k8s排错一览图</h1><p>转自：<a href="https://dbwu.tech/posts/k8s/source_code/pod_create/">https://dbwu.tech/posts/k8s/source_code/pod_create/</a></p><p><img src="/2025/03/31/k8s%E5%B9%B3%E5%8F%B0%E6%8E%92%E9%94%99%E4%B8%80%E8%A7%88%E5%9B%BE/k8s-pod-debug-flow.jpeg" alt="Pod Debug 流程图"></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8szh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang实现M:N生产者消费者模型</title>
    <link href="/2025/03/31/Golang%E5%AE%9E%E7%8E%B0M-N%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/31/Golang%E5%AE%9E%E7%8E%B0M-N%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang实现M-N生产者消费者队列（带5秒超时丢弃机制）"><a href="#Golang实现M-N生产者消费者队列（带5秒超时丢弃机制）" class="headerlink" title="Golang实现M:N生产者消费者队列（带5秒超时丢弃机制）"></a>Golang实现M:N生产者消费者队列（带5秒超时丢弃机制）</h1><p>下面是一个完整的Go实现，包含M个生产者和N个消费者的队列系统，生产者和消费者都有5秒超时丢弃机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>ID       <span class="hljs-type">int</span><br>Data     <span class="hljs-keyword">interface</span>&#123;&#125;<br>produced time.Time<br>&#125;<br><br><span class="hljs-keyword">type</span> Queue <span class="hljs-keyword">struct</span> &#123;<br>tasks      <span class="hljs-keyword">chan</span> Task<br>timeout    time.Duration<br>producerWg sync.WaitGroup<br>consumerWg sync.WaitGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewQueue</span><span class="hljs-params">(bufferSize <span class="hljs-type">int</span>, timeout time.Duration)</span></span> *Queue &#123;<br><span class="hljs-keyword">return</span> &amp;Queue&#123;<br>tasks:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Task, bufferSize),<br>timeout: timeout,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Producer 生产者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Producer(id <span class="hljs-type">int</span>, ctx context.Context) &#123;<br><span class="hljs-keyword">defer</span> q.producerWg.Done()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 模拟生产任务</span><br>task := Task&#123;<br>ID:       rand.Intn(<span class="hljs-number">1000</span>),<br>Data:     fmt.Sprintf(<span class="hljs-string">&quot;Data from producer %d&quot;</span>, id),<br>produced: time.Now(),<br>&#125;<br><br><span class="hljs-comment">// 尝试发送任务，带超时</span><br>ctxSend, cancel := context.WithTimeout(ctx, q.timeout)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> q.tasks &lt;- task:<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d produced task %d\n&quot;</span>, id, task.ID)<br><span class="hljs-keyword">case</span> &lt;-ctxSend.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d timeout, discarding task %d\n&quot;</span>, id, task.ID)<br>&#125;<br>cancel()<br><br><span class="hljs-comment">// 模拟生产间隔</span><br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1500</span>)) * time.Millisecond)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Consumer 消费者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Consumer(id <span class="hljs-type">int</span>, ctx context.Context) &#123;<br><span class="hljs-keyword">defer</span> q.consumerWg.Done()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 尝试接收任务，带超时</span><br>ctxRecv, cancel := context.WithTimeout(ctx, q.timeout)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> task := &lt;-q.tasks:<br><span class="hljs-comment">// 检查任务是否已经超时（从生产到消费）</span><br><span class="hljs-keyword">if</span> time.Since(task.produced) &gt; q.timeout &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d discarded expired task %d (age: %v)\n&quot;</span>, <br>id, task.ID, time.Since(task.produced))<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 处理任务</span><br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d processing task %d: %v\n&quot;</span>, id, task.ID, task.Data)<br><span class="hljs-comment">// 模拟处理时间</span><br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">2000</span>)) * time.Millisecond)<br><span class="hljs-keyword">case</span> &lt;-ctxRecv.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d timeout waiting for task\n&quot;</span>, id)<br>&#125;<br>cancel()<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 配置参数</span><br><span class="hljs-keyword">const</span> (<br>producerCount = <span class="hljs-number">3</span><br>consumerCount = <span class="hljs-number">2</span><br>bufferSize    = <span class="hljs-number">10</span><br>timeout       = <span class="hljs-number">5</span> * time.Second<br>runtime       = <span class="hljs-number">20</span> * time.Second<br>)<br><br><span class="hljs-comment">// 创建队列</span><br>queue := NewQueue(bufferSize, timeout)<br><br><span class="hljs-comment">// 创建上下文，用于控制goroutine退出</span><br>ctx, cancel := context.WithTimeout(context.Background(), runtime)<br><span class="hljs-keyword">defer</span> cancel()<br><br><span class="hljs-comment">// 启动生产者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= producerCount; i++ &#123;<br>queue.producerWg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> queue.Producer(i, ctx)<br>&#125;<br><br><span class="hljs-comment">// 启动消费者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= consumerCount; i++ &#123;<br>queue.consumerWg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> queue.Consumer(i, ctx)<br>&#125;<br><br><span class="hljs-comment">// 等待所有生产者和消费者退出</span><br>queue.producerWg.Wait()<br><span class="hljs-built_in">close</span>(queue.tasks) <span class="hljs-comment">// 关闭通道，消费者可以退出</span><br>queue.consumerWg.Wait()<br><br>fmt.Println(<span class="hljs-string">&quot;All producers and consumers exited&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><ol><li><strong>生产者超时机制</strong>：<ul><li>每个生产者尝试将任务放入队列时，有5秒的超时限制</li><li>如果5秒内无法放入队列（队列满），则丢弃该任务</li></ul></li><li><strong>消费者超时机制</strong>：<ul><li>每个消费者尝试从队列获取任务时，有5秒的超时限制</li><li>如果5秒内没有获取到任务，则继续尝试</li></ul></li><li><strong>任务过期检查</strong>：<ul><li>消费者获取任务后，会检查任务从生产到现在是否已超过5秒</li><li>如果超过，则直接丢弃该任务</li></ul></li><li><strong>优雅退出</strong>：<ul><li>使用context控制所有goroutine的退出</li><li>主程序运行20秒后自动关闭</li></ul></li></ol><h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><p>程序输出示例（部分）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Producer <span class="hljs-number">1</span> produced <span class="hljs-keyword">task</span> <span class="hljs-number">81</span><br>Producer <span class="hljs-number">2</span> produced <span class="hljs-keyword">task</span> <span class="hljs-number">887</span><br>Consumer <span class="hljs-number">1</span> processing <span class="hljs-keyword">task</span> <span class="hljs-number">81</span>: Data <span class="hljs-keyword">from</span> producer <span class="hljs-number">1</span><br>Consumer <span class="hljs-number">2</span> processing <span class="hljs-keyword">task</span> <span class="hljs-number">887</span>: Data <span class="hljs-keyword">from</span> producer <span class="hljs-number">2</span><br>Producer <span class="hljs-number">3</span> produced <span class="hljs-keyword">task</span> <span class="hljs-number">847</span><br>Producer <span class="hljs-number">1</span> timeout, discarding <span class="hljs-keyword">task</span> <span class="hljs-number">318</span><br>Consumer <span class="hljs-number">1</span> timeout waiting <span class="hljs-keyword">for</span> <span class="hljs-keyword">task</span><br>Consumer <span class="hljs-number">2</span> processing <span class="hljs-keyword">task</span> <span class="hljs-number">847</span>: Data <span class="hljs-keyword">from</span> producer <span class="hljs-number">3</span><br>...<br>All producers and consumers exited<br></code></pre></td></tr></table></figure><p>这个实现提供了完整的M:N生产者消费者模型，并确保了生产者和消费者都有5秒的超时丢弃机制。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-channel实现原理</title>
    <link href="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://zhuanlan.zhihu.com/p/597232906">https://zhuanlan.zhihu.com/p/597232906</a></p><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-0f42d64ad820157d0bcf6370ded4abb0_1440w.jpg" alt="img"></p><p>用过 go 的都知道 <a href="https://zhida.zhihu.com/search?content_id=220851325&content_type=Article&match_order=1&q=channel&zhida_source=entity">channel</a>，无需多言，直接开整！</p><h2 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1 核心数据结构"></a>1 核心数据结构</h2><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-33e6558c73c76c439818cb4477bfb14a_1440w.jpg" alt="img"></p><h3 id="1-1-hchan"><a href="#1-1-hchan" class="headerlink" title="1.1 hchan"></a>1.1 hchan</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>    qcount   <span class="hljs-type">uint</span>           <span class="hljs-comment">// total data in the queue</span><br>    dataqsiz <span class="hljs-type">uint</span>           <span class="hljs-comment">// size of the circular queue</span><br>    buf      unsafe.Pointer <span class="hljs-comment">// points to an array of dataqsiz elements</span><br>    elemsize <span class="hljs-type">uint16</span><br>    closed   <span class="hljs-type">uint32</span><br>    elemtype *_type <span class="hljs-comment">// element type</span><br>    sendx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// send index</span><br>    recvx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// receive index</span><br>    recvq    waitq  <span class="hljs-comment">// list of recv waiters</span><br>    sendq    waitq  <span class="hljs-comment">// list of send waiters</span><br><br>    lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><p>hchan： channel 数据结构</p><p>（1）qcount：当前 channel 中存在多少个元素；</p><p>（2）dataqsize: 当前 channel 能存放的元素容量；</p><p>（3）buf：channel 中用于存放元素的环形缓冲区；</p><p>（4）elemsize：channel 元素类型的大小；</p><p>（5）closed：标识 channel 是否关闭；</p><p>（6）elemtype：channel 元素类型；</p><p>（7）sendx：发送元素进入环形缓冲区的 index；</p><p>（8）recvx：接收元素所处的环形缓冲区的 index；</p><p>（9）recvq：因接收而陷入阻塞的协程队列；</p><p>（10）sendq：因发送而陷入阻塞的协程队列；</p><h3 id="1-2-waitq"><a href="#1-2-waitq" class="headerlink" title="1.2 waitq"></a>1.2 waitq</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>    first *sudog<br>    last  *sudog<br>&#125;<br></code></pre></td></tr></table></figure><p>waitq：阻塞的协程队列</p><p>（1）first：队列头部</p><p>（2）last：队列尾部</p><h3 id="1-3-sudog"><a href="#1-3-sudog" class="headerlink" title="1.3 sudog"></a>1.3 sudog</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;<br>    g *g<br><br>    next *sudog<br>    prev *sudog<br>    elem unsafe.Pointer <span class="hljs-comment">// data element (may point to stack)</span><br>    <span class="hljs-comment">// ...</span><br>    c        *hchan <br>&#125;<br></code></pre></td></tr></table></figure><p>sudog：用于包装协程的节点</p><p>（1）g：<a href="https://zhida.zhihu.com/search?content_id=220851325&content_type=Article&match_order=1&q=goroutine&zhida_source=entity">goroutine</a>，协程；</p><p>（2）next：队列中的下一个节点；</p><p>（3）prev：队列中的前一个节点；</p><p>（4）elem: 读取&#x2F;写入 channel 的数据的容器;</p><p>（5）c：标识与当前 sudog 交互的 chan.</p><h2 id="2-构造器函数"><a href="#2-构造器函数" class="headerlink" title="2 构造器函数"></a>2 构造器函数</h2><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-112b94a7ac698ee34d0b4a7c5641f388_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-type">int</span>)</span></span> *hchan &#123;<br>    elem := t.elem<br><br>    <span class="hljs-comment">// ...</span><br>    mem, overflow := math.MulUintptr(elem.size, <span class="hljs-type">uintptr</span>(size))<br>    <span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> c *hchan<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">// Queue or element size is zero.</span><br>        c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>    <span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">// Elements do not contain pointers.</span><br>        <span class="hljs-comment">// Allocate hchan and buf in one call.</span><br>        c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>        c.buf = add(unsafe.Pointer(c), hchanSize)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// Elements contain pointers.</span><br>        c = <span class="hljs-built_in">new</span>(hchan)<br>        c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>    &#125;<br><br>    c.elemsize = <span class="hljs-type">uint16</span>(elem.size)<br>    c.elemtype = elem<br>    c.dataqsiz = <span class="hljs-type">uint</span>(size)<br>    <br>    lockInit(&amp;c.lock, lockRankHchan)<br><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）判断申请内存空间大小是否越界，mem 大小为 element 类型大小与 element 个数相乘后得到，仅当无缓冲型 channel 时，因个数为 0 导致大小为 0；</p><p>（2）根据类型，初始 channel，分为 无缓冲型、有缓冲元素为 struct 型、有缓冲元素为 pointer 型 channel;</p><p>（3）倘若为无缓冲型，则仅申请一个大小为默认值 96 的空间；</p><p>（4）如若有缓冲的 struct 型，则一次性分配好 96 + mem 大小的空间，并且调整 chan 的 buf 指向 mem 的起始位置；</p><p>（5）倘若为有缓冲的 pointer 型，则分别申请 chan 和 buf 的空间，两者无需连续；</p><p>（6）对 channel 的其余字段进行初始化，包括元素类型大小、元素类型、容量以及锁的初始化.</p><h2 id="3-写流程"><a href="#3-写流程" class="headerlink" title="3 写流程"></a>3 写流程</h2><h3 id="3-1-两类异常情况处理"><a href="#3-1-两类异常情况处理" class="headerlink" title="3.1 两类异常情况处理"></a>3.1 两类异常情况处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>    chansend(c, elem, <span class="hljs-literal">true</span>, getcallerpc())<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>        gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>        throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>    &#125;<br><br><br>    lock(&amp;c.lock)<br><br><br>    <span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>        unlock(&amp;c.lock)<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）对于未初始化的 chan，写入操作会引发死锁；</p><p>（2）对于已关闭的 chan，写入操作会引发 panic.</p><h3 id="3-2-case1：写时存在阻塞读协程"><a href="#3-2-case1：写时存在阻塞读协程" class="headerlink" title="3.2 case1：写时存在阻塞读协程"></a>3.2 case1：写时存在阻塞读协程</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-aeebdcfb97a933e7ab5a6629a9ec385c_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    lock(&amp;c.lock)<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// Found a waiting receiver. We pass the value we want to send</span><br>        <span class="hljs-comment">// directly to the receiver, bypassing the channel buffer (if any).</span><br>        send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）从阻塞度协程队列中取出一个 goroutine 的封装对象 sudog；</p><p>（3）在 send 方法中，会基于 memmove 方法，直接将元素拷贝交给 sudog 对应的 goroutine；</p><p>（4）在 send 方法中会完成解锁动作.</p><h3 id="3-3-case2：写时无阻塞读协程但环形缓冲区仍有空间"><a href="#3-3-case2：写时无阻塞读协程但环形缓冲区仍有空间" class="headerlink" title="3.3 case2：写时无阻塞读协程但环形缓冲区仍有空间"></a>3.3 case2：写时无阻塞读协程但环形缓冲区仍有空间</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-bbf306ebfd01a163e961ac366edd7f21_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    lock(&amp;c.lock)<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br>        <span class="hljs-comment">// Space is available in the channel buffer. Enqueue the element to send.</span><br>        qp := chanbuf(c, c.sendx)<br>        typedmemmove(c.elemtype, qp, ep)<br>        c.sendx++<br>        <span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>            c.sendx = <span class="hljs-number">0</span><br>        &#125;<br>        c.qcount++<br>        unlock(&amp;c.lock)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）将当前元素添加到环形缓冲区 sendx 对应的位置；</p><p>（3）sendx++;</p><p>（4）qcount++;</p><p>（4）解锁，返回.</p><h3 id="3-4-case3：写时无阻塞读协程且环形缓冲区无空间"><a href="#3-4-case3：写时无阻塞读协程且环形缓冲区无空间" class="headerlink" title="3.4 case3：写时无阻塞读协程且环形缓冲区无空间"></a>3.4 case3：写时无阻塞读协程且环形缓冲区无空间</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-0add82424b36cbd0a5edf54d115cf4db_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    lock(&amp;c.lock)<br><br>    <span class="hljs-comment">// ...</span><br>    gp := getg()<br>    mysg := acquireSudog()<br>    mysg.elem = ep<br>    mysg.g = gp<br>    mysg.c = c<br>    gp.waiting = mysg<br>    c.sendq.enqueue(mysg)<br>    <br>    atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br>    <br>    gp.waiting = <span class="hljs-literal">nil</span><br>    closed := !mysg.success<br>    gp.param = <span class="hljs-literal">nil</span><br>    mysg.c = <span class="hljs-literal">nil</span><br>    releaseSudog(mysg)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）构造封装当前 goroutine 的 sudog 对象；</p><p>（3）完成指针指向，建立 sudog、goroutine、channel 之间的指向关系；</p><p>（4）把 sudog 添加到当前 channel 的阻塞写协程队列中；</p><p>（5）park 当前协程；</p><p>（6）倘若协程从 park 中被唤醒，则回收 sudog（sudog能被唤醒，其对应的元素必然已经被读协程取走）；</p><p>（7）解锁，返回</p><h3 id="3-5-写流程整体串联"><a href="#3-5-写流程整体串联" class="headerlink" title="3.5 写流程整体串联"></a>3.5 写流程整体串联</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-152528930008eb3508fcb0b5ffe480a3_1440w.jpg" alt="img"></p><h2 id="4-读流程"><a href="#4-读流程" class="headerlink" title="4 读流程"></a>4 读流程</h2><h3 id="4-1-异常-case1：读空-channel"><a href="#4-1-异常-case1：读空-channel" class="headerlink" title="4.1 异常 case1：读空 channel"></a>4.1 异常 case1：读空 channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>        gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>        throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）park 挂起，引起死锁；</p><h3 id="4-2-异常-case2：channel-已关闭且内部无元素"><a href="#4-2-异常-case2：channel-已关闭且内部无元素" class="headerlink" title="4.2 异常 case2：channel 已关闭且内部无元素"></a>4.2 异常 case2：channel 已关闭且内部无元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>  <br>    lock(&amp;c.lock)<br><br><br>    <span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> c.qcount == <span class="hljs-number">0</span> &#123;<br>            unlock(&amp;c.lock)<br>            <span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>                typedmemclr(c.elemtype, ep)<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-comment">// The channel has been closed, but the channel&#x27;s buffer have data.</span><br>    &#125; <br><br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）直接解锁返回即可</p><h3 id="4-3-case3：读时有阻塞的写协程"><a href="#4-3-case3：读时有阻塞的写协程" class="headerlink" title="4.3 case3：读时有阻塞的写协程"></a>4.3 case3：读时有阻塞的写协程</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-867428e66aeded401bb24ef760d99269_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>   <br>    lock(&amp;c.lock)<br><br><br>    <span class="hljs-comment">// Just found waiting sender with not closed.</span><br>    <span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>        recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>     &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span></span>, skip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// copy data from sender</span><br>recvDirect(c.elemtype, sg, ep)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Queue is full. Take the item at the</span><br><span class="hljs-comment">// head of the queue. Make the sender enqueue</span><br><span class="hljs-comment">// its item at the tail of the queue. Since the</span><br><span class="hljs-comment">// queue is full, those are both the same slot.</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><br>typedmemmove(c.elemtype, qp, sg.elem)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">true</span><br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）从阻塞写协程队列中获取到一个写协程；</p><p>（3）倘若 channel 无缓冲区，则直接读取写协程元素，并唤醒写协程；</p><p>（4）倘若 channel 有缓冲区，则读取缓冲区头部元素，并将写协程元素写入缓冲区尾部后唤醒写写成；</p><p>（5）解锁，返回.</p><h3 id="4-4-case4：读时无阻塞写协程且缓冲区有元素"><a href="#4-4-case4：读时无阻塞写协程且缓冲区有元素" class="headerlink" title="4.4 case4：读时无阻塞写协程且缓冲区有元素"></a>4.4 case4：读时无阻塞写协程且缓冲区有元素</h3><p><img src="https://pic1.zhimg.com/v2-354eb67a148726103d12d08b9d5c3b04_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><br><br>    lock(&amp;c.lock)<br><br><br>    <span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// Receive directly from queue</span><br>        qp := chanbuf(c, c.recvx)<br>        <span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>            typedmemmove(c.elemtype, ep, qp)<br>        &#125;<br>        typedmemclr(c.elemtype, qp)<br>        c.recvx++<br>        <span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>            c.recvx = <span class="hljs-number">0</span><br>        &#125;<br>        c.qcount--<br>        unlock(&amp;c.lock)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）获取到 recvx 对应位置的元素；</p><p>（3）recvx++</p><p>（4）qcount–</p><p>（5）解锁，返回</p><h3 id="4-5-case5：读时无阻塞写协程且缓冲区无元素"><a href="#4-5-case5：读时无阻塞写协程且缓冲区无元素" class="headerlink" title="4.5 case5：读时无阻塞写协程且缓冲区无元素"></a>4.5 case5：读时无阻塞写协程且缓冲区无元素</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-b3070eedf5f179b7a7515dc0ec5892d0_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>    lock(&amp;c.lock)<br><br>    gp := getg()<br>    mysg := acquireSudog()<br>    mysg.elem = ep<br>    gp.waiting = mysg<br>    mysg.g = gp<br>    mysg.c = c<br>    gp.param = <span class="hljs-literal">nil</span><br>    c.recvq.enqueue(mysg)<br>    atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br>    gp.waiting = <span class="hljs-literal">nil</span><br>    success := mysg.success<br>    gp.param = <span class="hljs-literal">nil</span><br>    mysg.c = <span class="hljs-literal">nil</span><br>    releaseSudog(mysg)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）构造封装当前 goroutine 的 sudog 对象；</p><p>（3）完成指针指向，建立 sudog、goroutine、channel 之间的指向关系；</p><p>（4）把 sudog 添加到当前 channel 的阻塞读协程队列中；</p><p>（5）park 当前协程；</p><p>（6）倘若协程从 park 中被唤醒，则回收 sudog（sudog能被唤醒，其对应的元素必然已经被写入）；</p><p>（7）解锁，返回</p><h3 id="4-6-读流程整体串联"><a href="#4-6-读流程整体串联" class="headerlink" title="4.6 读流程整体串联"></a>4.6 读流程整体串联</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-26a783d36cc511f5d57706cb2076d526_1440w.jpg" alt="img"></p><h2 id="5-阻塞与非阻塞模式"><a href="#5-阻塞与非阻塞模式" class="headerlink" title="5 阻塞与非阻塞模式"></a>5 阻塞与非阻塞模式</h2><p>在上述源码分析流程中，均是以阻塞模式为主线进行讲述，忽略非阻塞模式的有关处理逻辑.</p><p>此处阐明两个问题：</p><p>（1）非阻塞模式下，流程逻辑有何区别？</p><p>（2）何时会进入非阻塞模式？</p><h3 id="5-1-非阻塞模式逻辑区别"><a href="#5-1-非阻塞模式逻辑区别" class="headerlink" title="5.1 非阻塞模式逻辑区别"></a>5.1 非阻塞模式逻辑区别</h3><p>非阻塞模式下，读&#x2F;写 channel 方法通过一个 bool 型的响应参数，用以标识是否读取&#x2F;写入成功.</p><p>（1）所有需要使得当前 goroutine 被挂起的操作，在非阻塞模式下都会返回 false；</p><p>（2）所有是的当前 goroutine 会进入死锁的操作，在非阻塞模式下都会返回 false；</p><p>（3）所有能立即完成读取&#x2F;写入操作的条件下，非阻塞模式下会返回 true.</p><h3 id="5-2-何时进入非阻塞模式"><a href="#5-2-何时进入非阻塞模式" class="headerlink" title="5.2 何时进入非阻塞模式"></a>5.2 何时进入非阻塞模式</h3><p>默认情况下，读&#x2F;写 channel 都是阻塞模式，只有在 select 语句组成的多路复用分支中，与 channel 的交互会变成非阻塞模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">select</span>&#123;<br>  <span class="hljs-keyword">case</span> &lt;- ch:<br>  <span class="hljs-keyword">default</span>:<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-代码一览"><a href="#5-3-代码一览" class="headerlink" title="5.3 代码一览"></a>5.3 代码一览</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectnbsend</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span> chansend(c, elem, <span class="hljs-literal">false</span>, getcallerpc())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectnbrecv</span><span class="hljs-params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span> chanrecv(c, elem, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 select 语句包裹的多路复用分支中，读和写 channel 操作会被汇编为 selectnbrecv 和 selectnbsend 方法，底层同样复用 chanrecv 和 chansend 方法，但此时由于第三个入参 block 被设置为 false，导致后续会走进非阻塞的处理分支.</p><h2 id="6-两种读-channel-的协议"><a href="#6-两种读-channel-的协议" class="headerlink" title="6 两种读 channel 的协议"></a>6 两种读 channel 的协议</h2><p>读取 channel 时，可以根据第二个 bool 型的返回值用以判断当前 channel 是否已处于关闭状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>got1 := &lt;- ch<br>got2,ok := &lt;- ch<br></code></pre></td></tr></table></figure><p>实现上述功能的原因是，两种格式下，读 channel 操作会被汇编成不同的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>    chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv2</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="hljs-type">bool</span>) &#123;<br>    _, received = chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-关闭"><a href="#7-关闭" class="headerlink" title="7 关闭"></a>7 关闭</h2><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-46c42a11be76b1e553f5ee79acbcacab_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>    &#125;<br><br>    lock(&amp;c.lock)<br>    <span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>        unlock(&amp;c.lock)<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>    &#125;<br><br>    c.closed = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">var</span> glist gList<br>    <span class="hljs-comment">// release all readers</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        sg := c.recvq.dequeue()<br>        <span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>            typedmemclr(c.elemtype, sg.elem)<br>            sg.elem = <span class="hljs-literal">nil</span><br>        &#125;<br>        gp := sg.g<br>        gp.param = unsafe.Pointer(sg)<br>        sg.success = <span class="hljs-literal">false</span><br>        glist.push(gp)<br>    &#125;<br><br>    <span class="hljs-comment">// release all writers (they will panic)</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        sg := c.sendq.dequeue()<br>        <span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        sg.elem = <span class="hljs-literal">nil</span><br>        gp := sg.g<br>        gp.param = unsafe.Pointer(sg)<br>        sg.success = <span class="hljs-literal">false</span><br>        glist.push(gp)<br>    &#125;<br>    unlock(&amp;c.lock)<br><br>    <span class="hljs-comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span><br>    <span class="hljs-keyword">for</span> !glist.empty() &#123;<br>        gp := glist.pop()<br>        gp.schedlink = <span class="hljs-number">0</span><br>        goready(gp, <span class="hljs-number">3</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）关闭未初始化过的 channel 会 panic；</p><p>（2）加锁；</p><p>（3）重复关闭 channel 会 panic；</p><p>（4）将阻塞读协程队列中的协程节点统一添加到 glist；</p><p>（5）将阻塞写协程队列中的协程节点统一添加到 glist；</p><p>（6）唤醒 glist 当中的所有协程.</p><h2 id="8-一道考题"><a href="#8-一道考题" class="headerlink" title="8 一道考题"></a>8 一道考题</h2><p>要求实现一个 map：</p><p>（1）面向高并发；</p><p>（2）只存在插入和查询操作 O(1)；</p><p>（3）查询时，若 key 存在，直接返回 val；若 key 不存在，阻塞直到 key val 对被放入后，获取 val 返回； 等待指定时长仍未放入，返回超时错误；</p><p>（4）写出真实代码，不能有死锁或者 panic 风险.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyConcurrentMap <span class="hljs-keyword">struct</span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span>Put(k,v <span class="hljs-type">int</span>)&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span>Get(k <span class="hljs-type">int</span>, maxWaitingDuration time.Duration)(<span class="hljs-type">int</span>,<span class="hljs-type">error</span>)&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高并发阻塞式-Map-实现"><a href="#高并发阻塞式-Map-实现" class="headerlink" title="高并发阻塞式 Map 实现"></a>高并发阻塞式 Map 实现</h1><p>下面是一个满足所有要求的 <code>MyConcurrentMap</code> 实现，它使用 Go 的 <code>sync.RWMutex</code> 和 <code>sync.Cond</code> 来实现高效的并发控制和阻塞等待功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyConcurrentMap <span class="hljs-keyword">struct</span> &#123;<br>mu    sync.RWMutex<br>data  <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>conds <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*sync.Cond<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMyConcurrentMap</span><span class="hljs-params">()</span></span> *MyConcurrentMap &#123;<br><span class="hljs-keyword">return</span> &amp;MyConcurrentMap&#123;<br>data:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>),<br>conds: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*sync.Cond),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span> Put(k, v <span class="hljs-type">int</span>) &#123;<br>m.mu.Lock()<br><span class="hljs-keyword">defer</span> m.mu.Unlock()<br><br><span class="hljs-comment">// 放入数据</span><br>m.data[k] = v<br><br><span class="hljs-comment">// 如果有等待该key的goroutine，则通知它们</span><br><span class="hljs-keyword">if</span> cond, ok := m.conds[k]; ok &#123;<br>cond.Broadcast()<br><span class="hljs-comment">// 通知后删除cond，避免内存泄漏</span><br><span class="hljs-built_in">delete</span>(m.conds, k)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span> Get(k <span class="hljs-type">int</span>, maxWaitingDuration time.Duration) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>m.mu.RLock()<br><span class="hljs-comment">// 先快速检查一次</span><br><span class="hljs-keyword">if</span> val, ok := m.data[k]; ok &#123;<br>m.mu.RUnlock()<br><span class="hljs-keyword">return</span> val, <span class="hljs-literal">nil</span><br>&#125;<br>m.mu.RUnlock()<br><br>m.mu.Lock()<br><span class="hljs-comment">// 再次检查，防止在解锁和加锁之间有Put操作</span><br><span class="hljs-keyword">if</span> val, ok := m.data[k]; ok &#123;<br>m.mu.Unlock()<br><span class="hljs-keyword">return</span> val, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 为当前key创建cond（如果不存在）</span><br>cond, ok := m.conds[k]<br><span class="hljs-keyword">if</span> !ok &#123;<br>cond = sync.NewCond(&amp;m.mu)<br>m.conds[k] = cond<br>&#125;<br><br><span class="hljs-comment">// 设置超时</span><br>timeout := time.After(maxWaitingDuration)<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-keyword">var</span> val <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br><span class="hljs-comment">// 启动goroutine等待条件</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 再次检查，防止在等待前已经有Put操作</span><br><span class="hljs-keyword">if</span> v, exists := m.data[k]; exists &#123;<br>val = v<br><span class="hljs-keyword">return</span><br>&#125;<br><br>cond.Wait() <span class="hljs-comment">// 等待通知</span><br><br><span class="hljs-comment">// 被唤醒后检查是否有值</span><br><span class="hljs-keyword">if</span> v, exists := m.data[k]; exists &#123;<br>val = v<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br>m.mu.Unlock()<br><span class="hljs-keyword">return</span> val, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> &lt;-timeout:<br><span class="hljs-comment">// 超时，需要取消等待</span><br>cond.Broadcast() <span class="hljs-comment">// 唤醒所有等待此条件的goroutine</span><br>m.mu.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;timeout waiting for key&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ol><li><strong>并发控制</strong>：<ul><li>使用 <code>sync.RWMutex</code> 实现读写锁，允许多个读操作并发执行</li><li>写操作（Put）获取排他锁</li></ul></li><li><strong>阻塞等待</strong>：<ul><li>使用 <code>sync.Cond</code> 实现条件变量，当 key 不存在时让 Get 操作等待</li><li>每个 key 有自己的条件变量，避免不必要的唤醒</li></ul></li><li><strong>超时处理</strong>：<ul><li>使用 <code>select</code> 和 <code>time.After</code> 实现超时控制</li><li>超时后返回错误并取消等待</li></ul></li><li><strong>内存管理</strong>：<ul><li>在 Put 操作后清理条件变量，避免内存泄漏</li><li>使用 defer 确保锁被释放</li></ul></li><li><strong>双重检查</strong>：<ul><li>Get 操作中进行了两次检查，防止在锁转换间隙有 Put 操作</li></ul></li></ol><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">m := NewMyConcurrentMap()<br><br><span class="hljs-comment">// 并发Put</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>    m.Put(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>)<br>&#125;()<br><br><span class="hljs-comment">// 并发Get</span><br>val, err := m.Get(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>*time.Millisecond)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Value:&quot;</span>, val) <span class="hljs-comment">// 输出 Value: 42</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个实现满足所有要求，并且没有死锁或 panic 的风险。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用kubebuilder实现一个operator</title>
    <link href="/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/"/>
    <url>/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://qingwave.github.io/how-to-write-a-k8s-operator/">https://qingwave.github.io/how-to-write-a-k8s-operator/</a></p><p>Kubernetes 提供了众多的扩展功能，比如 CRD、CRI、CSI 等等，强大的扩展功能让 k8s 迅速占领市场。<a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/">Operator</a>模式可以实现 CRD 并管理自定义资源的生命周期，本文基于<a href="https://kubebuilder.io/">kubebuilder</a>快速实现一个 Operator，示例源码见<a href="https://github.com/qingwave/mygame">mygame</a>。</p><h2 id="Kubebuilder"><a href="#Kubebuilder" class="headerlink" title="Kubebuilder"></a>Kubebuilder</h2><p><code>kubebuilder</code>是一个官方提供快速实现 Operator 的工具包，可快速生成 k8s 的 CRD、Controller、Webhook，用户只需要实现业务逻辑。</p><blockquote><p>类似工具还有<a href="https://sdk.operatorframework.io/">operader-sdk</a>，目前正在与<code>Kubebuilder</code>融合</p></blockquote><p>kubebuilder 封装了<code>controller-runtime</code>与<code>controller-tools</code>，通过<code>controller-gen</code>来生产代码，简化了用户创建 Operator 的步骤。</p><p>一般创建 Operator 流程如下：</p><ol><li>创建工作目录，初始化项目</li><li>创建 API，填充字段</li><li>创建 Controller，编写核心协调逻辑(Reconcile)</li><li>创建 Webhook，实现接口，可选</li><li>验证测试</li><li>发布到集群中</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们准备创建一个 2048 的游戏，对外可以提供服务，也能方便地扩缩容。</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>首先你需要有 Kubernetes、Docker、Golang 相关环境。 Linux 下安装 kubebuilder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/$(go <span class="hljs-built_in">env</span> GOOS)/$(go <span class="hljs-built_in">env</span> GOARCH)<br><span class="hljs-built_in">chmod</span> +x kubebuilder &amp;&amp; <span class="hljs-built_in">mv</span> kubebuilder /usr/local/bin/<br></code></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mkdir -<span class="hljs-selector-tag">p</span> ~/work/mygame &amp;&amp; cd $_<br>kubebuilder init <span class="hljs-attr">--domain</span> qingwave<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span> <span class="hljs-attr">--repo</span> qingwave<span class="hljs-selector-class">.github</span>.io/mygame<br></code></pre></td></tr></table></figure><h3 id="创建-API"><a href="#创建-API" class="headerlink" title="创建 API"></a>创建 API</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">kubebuilder create api <span class="hljs-attr">--group</span> myapp <span class="hljs-attr">--version</span> v1 <span class="hljs-attr">--kind</span> Game<br><br>Create Resource <span class="hljs-selector-attr">[y/n]</span><br><span class="hljs-attribute">y</span> #生成CR<br>Create Controller <span class="hljs-selector-attr">[y/n]</span><br><span class="hljs-attribute">y</span> #生成Controller<br></code></pre></td></tr></table></figure><p>目录结构如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">├── api<br>│   └── <span class="hljs-built_in">v1</span> <span class="hljs-comment"># CRD定义</span><br>├── <span class="hljs-keyword">bin</span><br><span class="hljs-keyword"></span>│   └── controller-gen<br>├── <span class="hljs-built_in">config</span><br>│   ├── crd <span class="hljs-comment"># crd配置</span><br>│   ├── default<br>│   ├── manager <span class="hljs-comment"># operator部署文件</span><br>│   ├── prometheus<br>│   ├── rbac<br>│   └── samples <span class="hljs-comment"># cr示例</span><br>├── controllers<br>│   ├── game_controller.go <span class="hljs-comment"># controller逻辑</span><br>│   └── suite_test.go<br>├── Dockerfile<br>├── go.mod<br>├── go.sum<br>├── hack<br>│   └── <span class="hljs-keyword">boilerplate.go.txt </span><span class="hljs-comment"># 头文件模板</span><br>├── main.go <span class="hljs-comment"># 项目主函数</span><br>├── Makefile<br>└── PROJECT <span class="hljs-comment">#项目元数据</span><br></code></pre></td></tr></table></figure><h3 id="编写-API"><a href="#编写-API" class="headerlink" title="编写 API"></a>编写 API</h3><p>在<code>mygame/api/v1/game_types.go</code>定义我们需要的字段</p><p><code>Spec</code>配置如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> <span class="hljs-type">GameSpec</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Number of desired pods. This is a pointer to distinguish between explicit</span><br><span class="hljs-comment">// zero and not specified. Defaults to 1.</span><br><span class="hljs-comment">// +optional</span><br><span class="hljs-comment">//+kubebuilder:default:=1</span><br><span class="hljs-comment">//+kubebuilder:validation:Minimum:=1</span><br><span class="hljs-type">Replicas</span> *<span class="hljs-built_in">int32</span> `json:<span class="hljs-string">&quot;replicas,omitempty&quot;</span> protobuf:<span class="hljs-string">&quot;varint,1,opt,name=replicas&quot;</span>`<br><br><span class="hljs-comment">// Docker image name</span><br><span class="hljs-comment">// +optional</span><br><span class="hljs-type">Image</span> <span class="hljs-built_in">string</span> `json:<span class="hljs-string">&quot;image,omitempty&quot;</span>`<br><br><span class="hljs-comment">// Ingress Host name</span><br><span class="hljs-type">Host</span> <span class="hljs-built_in">string</span> `json:<span class="hljs-string">&quot;host,omitempty&quot;</span>`<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>kubebuilder:default</code>可以设置默认值</p></blockquote><p><code>Status</code>定义如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const (<br>Running  = &quot;Running&quot;<br>Pending  = &quot;Pending&quot;<br>NotReady = &quot;NotReady&quot;<br>Failed   = &quot;Failed&quot;<br>)<br><br><span class="hljs-keyword">type</span> GameStatus struct &#123;<br>// Phase <span class="hljs-keyword">is</span> the phase <span class="hljs-keyword">of</span> guestbook<br>Phase string `<span class="hljs-type">json</span>:&quot;phase,omitempty&quot;`<br><br>// replicas <span class="hljs-keyword">is</span> the number <span class="hljs-keyword">of</span> Pods created <span class="hljs-keyword">by</span> the StatefulSet controller.<br>Replicas int32 `<span class="hljs-type">json</span>:&quot;replicas&quot;`<br><br>// readyReplicas <span class="hljs-keyword">is</span> the number <span class="hljs-keyword">of</span> Pods created <span class="hljs-keyword">by</span> the StatefulSet controller that have a Ready Condition.<br>ReadyReplicas int32 `<span class="hljs-type">json</span>:&quot;readyReplicas&quot;`<br><br>// LabelSelector <span class="hljs-keyword">is</span> label selectors <span class="hljs-keyword">for</span> query <span class="hljs-keyword">over</span> pods that should match the <span class="hljs-keyword">replica</span> count used <span class="hljs-keyword">by</span> HPA.<br>LabelSelector string `<span class="hljs-type">json</span>:&quot;labelSelector,omitempty&quot;`<br>&#125;<br></code></pre></td></tr></table></figure><p>另外需要添加<code>scale</code>接口</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>+kubebuilder<span class="hljs-function">:subresource</span><span class="hljs-function">:scale</span><span class="hljs-function">:specpath</span>=<span class="hljs-string">.spec.replicas</span>,statuspath=<span class="hljs-string">.status.replicas</span>,selectorpath=<span class="hljs-string">.status.labelSelector</span><br></code></pre></td></tr></table></figure><p>添加<code>kubectl</code>展示参数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;Phase&quot;,<span class="hljs-keyword">type</span>=&quot;string&quot;,JSONPath=&quot;.status.phase&quot;,description=&quot;The phase of game.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;Host&quot;,<span class="hljs-keyword">type</span>=&quot;string&quot;,JSONPath=&quot;.spec.host&quot;,description=&quot;The Host Address.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;DESIRED&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.spec.replicas&quot;,description=&quot;The desired number of pods.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;CURRENT&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.status.replicas&quot;,description=&quot;The number of currently all pods.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;READY&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.status.readyReplicas&quot;,description=&quot;The number of pods ready.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;AGE&quot;,<span class="hljs-keyword">type</span>=&quot;date&quot;,JSONPath=&quot;.metadata.creationTimestamp&quot;,description=&quot;CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.&quot;<br></code></pre></td></tr></table></figure><h3 id="编写-Controller-逻辑"><a href="#编写-Controller-逻辑" class="headerlink" title="编写 Controller 逻辑"></a>编写 Controller 逻辑</h3><p>Controller 的核心逻辑在<code>Reconcile</code>中，我们只需要填充自己的业务逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GameReconciler)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="hljs-type">error</span>) &#123;<br>logger := log.FromContext(ctx)<br>logger.Info(<span class="hljs-string">&quot;revice reconcile event&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><br><span class="hljs-comment">// 获取game对象</span><br>game := &amp;myappv1.Game&#123;&#125;<br><span class="hljs-keyword">if</span> err := r.Get(ctx, req.NamespacedName, game); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)<br>&#125;<br><br>  <span class="hljs-comment">// 如果处在删除中直接跳过</span><br><span class="hljs-keyword">if</span> game.DeletionTimestamp != <span class="hljs-literal">nil</span> &#123;<br>logger.Info(<span class="hljs-string">&quot;game in deleting&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br>  <span class="hljs-comment">// 同步资源，如果资源不存在创建deployment、ingress、service，并更新status</span><br><span class="hljs-keyword">if</span> err := r.syncGame(ctx, game); err != <span class="hljs-literal">nil</span> &#123;<br>logger.Error(err, <span class="hljs-string">&quot;failed to sync game&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>添加 rbac 配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>apps,resources<span class="hljs-operator">=</span>deployments,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>apps,resources<span class="hljs-operator">=</span>deployments<span class="hljs-operator">/</span>status,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;<span class="hljs-keyword">update</span>;patch<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>core,resources<span class="hljs-operator">=</span>services,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>networking,resources<span class="hljs-operator">=</span>ingresses,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><p>具体<code>syncGame</code>逻辑如下</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">func (r *GameReconciler) syncGame(ctx context.Context, obj *myappv1.Game) error &#123;<br><span class="hljs-attribute">logger</span> := log<span class="hljs-variable">.FromContext</span>(ctx)<br><br>game := obj<span class="hljs-variable">.DeepCopy</span>()<br>name := types<span class="hljs-variable">.NamespacedName</span>&#123;<br>Namespace: game<span class="hljs-variable">.Namespace</span>,<br>Name:      game<span class="hljs-variable">.Name</span>,<br>&#125;<br><br>  // 构造owner<br>owner := []metav1<span class="hljs-variable">.OwnerReference</span>&#123;<br>&#123;<br>APIVersion:         game<span class="hljs-variable">.APIVersion</span>,<br>Kind:               game<span class="hljs-variable">.Kind</span>,<br>Name:               game<span class="hljs-variable">.Name</span>,<br>Controller:         pointer<span class="hljs-variable">.BoolPtr</span>(true),<br>BlockOwnerDeletion: pointer<span class="hljs-variable">.BoolPtr</span>(true),<br>UID:                game<span class="hljs-variable">.UID</span>,<br>&#125;,<br>&#125;<br><br>labels := game<span class="hljs-variable">.Labels</span><br>labels[gameLabelName] = game<span class="hljs-variable">.Name</span><br>meta := metav1<span class="hljs-variable">.ObjectMeta</span>&#123;<br>Name:            game<span class="hljs-variable">.Name</span>,<br>Namespace:       game<span class="hljs-variable">.Namespace</span>,<br>Labels:          labels,<br>OwnerReferences: owner,<br>&#125;<br><br>  // 获取对应deployment, 如不存在则创建<br>deploy := &amp;appsv1<span class="hljs-variable">.Deployment</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">if !errors.IsNotFound(err) &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">deploy = &amp;appsv1.Deployment&#123;</span><br><span class="hljs-attribute">ObjectMeta</span>: meta,<br>Spec:       getDeploymentSpec(game, labels),<br>&#125;<br>if err := r<span class="hljs-variable">.Create</span>(ctx, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">logger.Info(&quot;create deployment success&quot;, &quot;name&quot;, name.String())</span><br><span class="hljs-attribute">&#125; else &#123;</span><br><span class="hljs-attribute">    // 如果存在对比和game生成的deployment是否一致，不一致则更新</span><br><span class="hljs-attribute">want</span> := getDeploymentSpec(game, labels)<br>get := getSpecFromDeployment(deploy)<br>if !reflect<span class="hljs-variable">.DeepEqual</span>(want, get) &#123;<br>deploy = &amp;appsv1<span class="hljs-variable">.Deployment</span>&#123;<br>ObjectMeta: meta,<br>Spec:       want,<br>&#125;<br>if err := r<span class="hljs-variable">.Update</span>(ctx, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">logger.Info(&quot;update deployment success&quot;, &quot;name&quot;, name.String())</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  //service创建</span><br><span class="hljs-attribute">svc</span> := &amp;corev1<span class="hljs-variable">.Service</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, svc); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">  ...</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  // ingress创建</span><br><span class="hljs-attribute">ing</span> := &amp;networkingv1<span class="hljs-variable">.Ingress</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, ing); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">...</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">newStatus</span> := myappv1<span class="hljs-variable">.GameStatus</span>&#123;<br>Replicas:      *game<span class="hljs-variable">.Spec</span><span class="hljs-variable">.Replicas</span>,<br>ReadyReplicas: deploy<span class="hljs-variable">.Status</span><span class="hljs-variable">.ReadyReplicas</span>,<br>&#125;<br><br>if newStatus<span class="hljs-variable">.Replicas</span> == newStatus<span class="hljs-variable">.ReadyReplicas</span> &#123;<br>newStatus<span class="hljs-variable">.Phase</span> = myappv1<span class="hljs-variable">.Running</span><br>&#125; else &#123;<br>newStatus<span class="hljs-variable">.Phase</span> = myappv1<span class="hljs-variable">.NotReady</span><br>&#125;<br><br>  // 更新状态<br>if !reflect<span class="hljs-variable">.DeepEqual</span>(game<span class="hljs-variable">.Status</span>, newStatus) &#123;<br>game<span class="hljs-variable">.Status</span> = newStatus<br>logger<span class="hljs-variable">.Info</span>(&quot;update game status&quot;, &quot;name&quot;, name<span class="hljs-variable">.String</span>())<br>return r<span class="hljs-variable">.Client</span><span class="hljs-variable">.Status</span>()<span class="hljs-variable">.Update</span>(ctx, game)<br>&#125;<br><br>return nil<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下生成的 controller 只监听自定义资源，在示例中我们也需要监听<code>game</code>的子资源，如监听<code>deployment</code>是否符合预期</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SetupWithManager sets up the controller with the Manager.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GameReconciler)</span></span> SetupWithManager(mgr ctrl.Manager) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 创建controller</span><br>c, err := controller.New(<span class="hljs-string">&quot;game-controller&quot;</span>, mgr, controller.Options&#123;<br>Reconciler:              r,<br>MaxConcurrentReconciles: <span class="hljs-number">3</span>, <span class="hljs-comment">//controller运行的worker数</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">//监听自定义资源</span><br><span class="hljs-keyword">if</span> err := c.Watch(&amp;source.Kind&#123;Type: &amp;myappv1.Game&#123;&#125;&#125;, &amp;handler.EnqueueRequestForObject&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">//监听deployment,将owner信息即game namespace/name添加到队列</span><br><span class="hljs-keyword">if</span> err := c.Watch(&amp;source.Kind&#123;Type: &amp;appsv1.Deployment&#123;&#125;&#125;, &amp;handler.EnqueueRequestForOwner&#123;<br>OwnerType:    &amp;myappv1.Game&#123;&#125;,<br>IsController: <span class="hljs-literal">true</span>,<br>&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h3><p>安装 CRD</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">make <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>本地运行 operator</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> <span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><p>修改 sample 文件<code>config/samples/myapp_v1_game.yaml</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> myapp.qingwave.github.io/v1<br><span class="hljs-symbol">kind:</span> Game<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> game-sample<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  replicas:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">  image:</span> alexwhen/docker<span class="hljs-number">-2048</span><br><span class="hljs-symbol">  host:</span> mygame.io<br></code></pre></td></tr></table></figure><p>部署<code>game-sample</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">kubectl apply -f config/samples/myapp_v1_game.yaml<br></code></pre></td></tr></table></figure><p>查看<code>game</code>自定义资源状态</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 查看game</span><br><span class="hljs-attribute">kubectl</span> get game<br><span class="hljs-attribute">NAME</span>          PHASE     HOST        DESIRED   CURRENT   READY   AGE<br><span class="hljs-attribute">game</span>-sample   Running   mygame.io   <span class="hljs-number">1</span>         <span class="hljs-number">1</span>         <span class="hljs-number">1</span>       <span class="hljs-number">6</span>m<br><br><span class="hljs-comment"># 查看deploy</span><br><span class="hljs-attribute">kubectl</span> get deploy game-sample<br><span class="hljs-attribute">NAME</span>          READY   UP-TO-DATE   AVAILABLE   AGE<br><span class="hljs-attribute">game</span>-sample   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     <span class="hljs-number">1</span>            <span class="hljs-number">1</span>           <span class="hljs-number">6</span>m<br><br><span class="hljs-comment"># 查看ingress</span><br><span class="hljs-attribute">kubectl</span> get ing game-sample<br><span class="hljs-attribute">NAME</span>          CLASS    HOSTS       ADDRESS        PORTS   AGE<br><span class="hljs-attribute">game</span>-sample   &lt;none&gt;   mygame.io   <span class="hljs-number">192.168.49.2</span>   <span class="hljs-number">80</span>      <span class="hljs-number">7</span>m<br></code></pre></td></tr></table></figure><p>验证应用，在<code>/etc/hosts</code>中添加<code>&lt;Ingress ADDRESS Ip&gt; mygame.io</code>，访问浏览器如下图所示<img src="/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/crd_mygame.png" alt="2048"></p><p>验证扩容</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kubectl</span> scale games.myapp.qingwave.github.io game-sample --replicas <span class="hljs-number">2</span><br><span class="hljs-attribute">game</span>.myapp.qingwave.github.io/game-sample scaled<br><br><span class="hljs-comment"># 扩容后</span><br><span class="hljs-attribute">kubectl</span> get games.myapp.qingwave.github.io<br><span class="hljs-attribute">NAME</span>          PHASE     HOST        DESIRED   CURRENT   READY   AGE<br><span class="hljs-attribute">game</span>-sample   Running   mygame.io   <span class="hljs-number">2</span>         <span class="hljs-number">2</span>         <span class="hljs-number">2</span>       <span class="hljs-number">7</span>m<br></code></pre></td></tr></table></figure><p>如需部署<code>Operator</code>到集群中，可参考官方文档，制作镜像并上传，运行<code>make deploy</code></p><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p>通常我们需要与 CR 自定义资源设置部分字段的默认值，或者验证字段是否合法，这就需要自己实现<code>Webhook</code>，<code>Kubebuilder</code>也提供了<code>Webhook</code>的功能。</p><p>通过设置<code>--defaulting</code>可创建<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">mutatingadmissionwebhook</a>类型准入控制器，用来修改传入资源；参数<code>--programmatic-validation</code>可创建<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">validatingadmissionwebhook</a>，用来验证传入资源</p><blockquote><p>在资源创建、修改时<code>apiserver</code>会通过 http 调用<code>webhook</code>提供的接口，所以会带来额外开销，简单的验证工作可通过<code>//+kubebuilder:validation</code>注解，直接通过<code>openapi</code>验证，性能更好</p></blockquote><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">kubebuilder create webhook</span> <span class="hljs-literal">--</span><span class="hljs-comment">group myapp</span> <span class="hljs-literal">--</span><span class="hljs-comment">version v1</span> <span class="hljs-literal">--</span><span class="hljs-comment">kind Game</span> <span class="hljs-literal">--</span><span class="hljs-comment">defaulting</span> <span class="hljs-literal">--</span><span class="hljs-comment">programmatic</span><span class="hljs-literal">-</span><span class="hljs-comment">validation</span><br></code></pre></td></tr></table></figure><p>生成文件在<code>api/v1/game_webhook.go</code></p><p><code>Default</code>接口可实现修改资源，根据 kubebuilder 注释,当<code>game</code>资源<code>create</code>与<code>update</code>时，调用这个接口</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//+kubebuilder:webhook:<span class="hljs-type">path</span>=/mutate-myapp-qingwave-github-io-v1-game,mutating=<span class="hljs-keyword">true</span>,failurePolicy=fail,sideEffects=<span class="hljs-keyword">None</span>,<span class="hljs-keyword">groups</span>=myapp.qingwave.github.io,resources=games,verbs=<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>,versions=v1,<span class="hljs-type">name</span>=mgame.kb.io,admissionReviewVersions=&#123;v1,v1beta1&#125;<br>const (<br>defaultImage = `alexwhen/docker<span class="hljs-number">-2048</span>`<br>)<br><br>// <span class="hljs-keyword">Default</span> implements webhook.Defaulter so a webhook will be registered <span class="hljs-keyword">for</span> the <span class="hljs-keyword">type</span><br>func (r *Game) <span class="hljs-keyword">Default</span>() &#123;<br>gamelog.<span class="hljs-keyword">Info</span>(&quot;default&quot;, &quot;name&quot;, r.Name)<br><br>// 设置默认镜像<br><span class="hljs-keyword">if</span> r.Spec.Image == &quot;&quot; &#123;<br>r.Spec.Image = defaultImage<br>&#125;<br><br>// 设置默认Host<br><span class="hljs-keyword">if</span> r.Spec.Host == &quot;&quot; &#123;<br>r.Spec.Host = fmt.Sprintf(&quot;%s.%s.mygame.io&quot;, r.Name, r.Namespace)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的通过<code>ValidateCreate</code>、<code>ValidateUpdate</code>可实现<code>validating webhook</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Game)</span></span> ValidateCreate() <span class="hljs-type">error</span> &#123;<br>gamelog.Info(<span class="hljs-string">&quot;validate create&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, r.Name)<br><br><span class="hljs-comment">// Host不能包括通配符</span><br><span class="hljs-keyword">if</span> strings.Contains(r.Spec.Host, <span class="hljs-string">&quot;*&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;host should not contain *&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>本地验证 webhook 需要配置证书，在集群中测试更方便点，可参考官方文档。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经实现了一个功能完全的<code>game-operator</code>，可以管理<code>game</code>资源的生命周期，创建&#x2F;更新 game 时会自动创建<code>deployment、service、ingress</code>等资源，当<code>deployment</code>被误删或者误修改时也可以自动回复到期望状态，也实现了<code>scale</code>接口。</p><p>通过<code>kubebuiler</code>大大简化了开发<code>operator</code>的成本，我们只需要关心业务逻辑即可，不需要再手动去创建<code>client/controller</code>等，但同时<code>kubebuilder</code>生成的代码中屏蔽了很多细节，比如<code>controller</code>的最大 worker 数、同步时间、队列类型等参数设置，只有了解<code>operator</code>的原理才更好应用于生产。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://book.kubebuilder.io/">https://book.kubebuilder.io/</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s证书</title>
    <link href="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/"/>
    <url>/2025/03/30/k8s%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.zhaohuabing.com/post/2020-05-19-k8s-certificate/">https://www.zhaohuabing.com/post/2020-05-19-k8s-certificate/</a></p><p>接触 Kubernetes 以来，我经常看到 Kubernetes 在不同的地方使用了证书（Certificate），在 Kubernetes 安装和组件启动参数中也需要配置大量证书相关的参数。但是 Kubernetes 的文档在解释这些证书的工作机制方面做得并不是太好。经过大量的相关阅读和分析工作后，我基本弄清楚了 Kubernetes 中证书的使用方式。在本文中，我将试图以一种比官方文档更容易理解的方式来说明 Kubernetes 中证书相关的工作机制，如果你也存在这方面的疑惑，希望这篇文章对你有所帮助。</p><h1 id="Kubernetes-组件的认证方式"><a href="#Kubernetes-组件的认证方式" class="headerlink" title="Kubernetes 组件的认证方式"></a>Kubernetes 组件的认证方式</h1><p>首先让我们来看一下 Kubernetes 中的组件：在 Kubernetes 中包含多个以独立进程形式运行的组件，这些组件之间通过 HTTP&#x2F;GRPC 相互通信，以协同完成集群中应用的部署和管理工作。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/components-of-kubernetes.png" alt="img">kubernetes 组件，图片来源<a href="https://kubernetes.io/zh/docs/concepts/overview/components/">kubernetes.io</a></p><p>从图中可以看到，Kubernetes 控制平面中包含了 etctd，kube-api-server，kube-scheduler，kube-controller-manager 等组件，这些组件会相互进行远程调用，例如 kube-api-server 会调用 etcd 接口存储数据，kube-controller-manager 会调用 kube-api-server 接口查询集群中的对象状态；同时，kube-api-server 也会和在工作节点上的 kubelet 和 kube-proxy 进行通信，以在工作节点上部署和管理应用。</p><p>以上这些组件之间的相互调用都是通过网络进行的。在进行网络通信时，通信双方需要验证对方的身份，以避免恶意第三方伪造身份窃取信息或者对系统进行攻击。为了相互验证对方的身份，通信双方中的任何一方都需要做下面两件事情：</p><ul><li>向对方提供标明自己身份的一个证书</li><li>验证对方提供的身份证书是否合法，是否伪造的？</li></ul><p>在 Kubernetes 中使用了数字证书来提供身份证明，我们可以把数字证书简单理解为我们在日常生活中使用的“身份证”，上面标注了证书拥有者的身份信息，例如名称，所属组织机构等。为了保证证书的权威性，会采用一个通信双方都信任的 CA（证书机构，Certificate Authority）来颁发证书。这就类似于现实生活中颁发“身份证”的政府机构。数字证书中最重要的内容实际上是证书拥有者的公钥，该公钥代表了用户的身份。本文假设读者已经了解数字证书和 CA 的基本原理，如果你对此不太清楚，或者希望重新温习一下相关知识，可以先阅读一下这篇文章<a href="https://zhaohuabing.com/post/2020-03-19-pki">《数字证书原理》</a>。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/ca.png" alt="img"></p><p>CA （证书机构），图片来源<a href="https://www.trustauth.cn/ca-question/1791.html">www.trustauth.cn</a></p><p>在 Kubernetes 的组件之间进行通信时，数字证书的验证是在协议层面通过 TLS 完成的，除了需要在建立通信时提供相关的证书和密钥外，在应用层面并不需要进行特殊处理。采用 TLS 进行验证有两种方式：</p><ul><li>服务器单向认证：只需要服务器端提供证书，客户端通过服务器端证书验证服务的身份，但服务器并不验证客户端的身份。这种情况一般适用于对 Internet 开放的服务，例如搜索引擎网站，任何客户端都可以连接到服务器上进行访问，但客户端需要验证服务器的身份，以避免连接到伪造的恶意服务器。</li><li>双向 TLS 认证：除了客户端需要验证服务器的证书，服务器也要通过客户端证书验证客户端的身份。这种情况下服务器提供的是敏感信息，只允许特定身份的客户端访问。</li></ul><p>在 Kubernetes 中，各个组件提供的接口中包含了集群的内部信息。如果这些接口被非法访问，将影响集群的安全，因此组件之间的通信需要采用双向 TLS 认证。即客户端和服务器端都需要验证对方的身份信息。在两个组件进行双向认证时，会涉及到下面这些证书相关的文件：</p><ul><li>服务器端证书：服务器用于证明自身身份的数字证书，里面主要包含了服务器端的公钥以及服务器的身份信息。</li><li>服务器端私钥：服务器端证书中包含的公钥所对应的私钥。公钥和私钥是成对使用的，在进行 TLS 验证时，服务器使用该私钥来向客户端证明自己是服务器端证书的拥有者。</li><li>客户端证书：客户端用于证明自身身份的数字证书，里面主要包含了客户端的公钥以及客户端的身份信息。</li><li>客户端私钥：客户端证书中包含的公钥所对应的私钥，同理，客户端使用该私钥来向服务器端证明自己是客户端证书的拥有者。</li><li>服务器端 CA 根证书：签发服务器端证书的 CA 根证书，客户端使用该 CA 根证书来验证服务器端证书的合法性。</li><li>客户端端 CA 根证书：签发客户端证书的 CA 根证书，服务器端使用该 CA 根证书来验证客户端证书的合法性。</li></ul><p>下面这张来自<a href="https://medium.com/sitewards/the-magic-of-tls-x509-and-mutual-authentication-explained-b2162dec4401">The magic of TLS, X509 and mutual authentication explained</a> 文章中的图形象地解释了双向 TLS 认证的原理。如果你需要了解更多关于 TLS 认证的原理，可以阅读一下 medium 上的原文。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/mutual-tls.png" alt="img"></p><p>图片来源<a href="https://medium.com/sitewards/the-magic-of-tls-x509-and-mutual-authentication-explained-b2162dec4401">The magic of TLS, X509 and mutual authentication explained</a></p><h1 id="Kubernetes-中使用到的CA和证书"><a href="#Kubernetes-中使用到的CA和证书" class="headerlink" title="Kubernetes 中使用到的CA和证书"></a>Kubernetes 中使用到的CA和证书</h1><p>Kubernetes 中使用了大量的证书，本文不会试图覆盖到所有可能使用到的证书，但会讨论到主要的证书。理解了这些证书的使用方法和原理后，也能很快理解其他可能遇到的证书文件。下图标识出了在 kubernetes 中主要使用到的证书和其使用的位置：</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/kubernetes-certificate-usage.png" alt="img"></p><p>Kubernetes 中使用到的主要证书</p><p>上图中使用序号对证书进行了标注。图中的箭头表明了组件的调用方向，箭头所指方向为服务提供方，另一头为服务调用方。为了实现 TLS 双向认证，服务提供方需要使用一个服务器证书，服务调用方则需要提供一个客户端证书，并且双方都需要使用一个 CA 证书来验证对方提供的证书。为了简明起见，上图中只标注了证书使用方提供的证书，并没有标注证书的验证方验证使用的 CA 证书。图中标注的这些证书的作用分别如下：</p><ol><li>etcd 集群中各个节点之间相互通信使用的证书。由于一个 etctd 节点既为其他节点提供服务，又需要作为客户端访问其他节点，因此该证书同时用作服务器证书和客户端证书。</li><li>etcd 集群向外提供服务使用的证书。该证书是服务器证书。</li><li>kube-apiserver 作为客户端访问 etcd 使用的证书。该证书是客户端证书。</li><li>kube-apiserver 对外提供服务使用的证书。该证书是服务器证书。</li><li>kube-controller-manager 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kube-scheduler 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kube-proxy 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kubelet 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>管理员用户通过 kubectl 访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kubelet 对外提供服务使用的证书。该证书是服务器证书。</li><li>kube-apiserver 作为客户端访问 kubelet 采用的证书。该证书是客户端证书。</li><li>kube-controller-manager 用于生成和验证 service-account token 的证书。该证书并不会像其他证书一样用于身份认证，而是将证书中的公钥&#x2F;私钥对用于 service account token 的生成和验证。kube-controller-manager 会用该证书的私钥来生成 service account token，然后以 secret 的方式加载到 pod 中。pod 中的应用可以使用该 token 来访问 kube-apiserver， kube-apiserver 会使用该证书中的公钥来验证请求中的 token。我们将在文中稍后部分详细介绍该证书的使用方法。</li></ol><p>通过这张图，对证书机制比较了解的读者可能已经看出，我们其实可以使用多个不同的 CA 来颁发这些证书。只要在通信的组件中正确配置用于验证对方证书的 CA 根证书，就可以使用不同的 CA 来颁发不同用途的证书。但我们一般建议采用统一的 CA 来颁发 kubernetes 集群中的所有证书，这是因为采用一个集群根 CA 的方式比采用多个 CA 的方式更容易管理，可以避免多个CA 导致的复杂的证书配置、更新等问题，减少由于证书配置错误导致的集群故障。</p><h1 id="Kubernetes-中的证书配置"><a href="#Kubernetes-中的证书配置" class="headerlink" title="Kubernetes 中的证书配置"></a>Kubernetes 中的证书配置</h1><p>前面我们介绍了 Kubernetes 集群中主要使用到的证书。下面我们分别看一下如何将这些证书及其对应的私钥和 CA 根证书需要配置到 Kubernetes 中各个组件中，以供各个组件进行使用。这里假设使用一个集群根 CA 来颁发所有相关证书，因此涉及到 CA 的配置对应的证书文件名都是相同的。</p><h2 id="etcd-证书配置"><a href="#etcd-证书配置" class="headerlink" title="etcd 证书配置"></a>etcd 证书配置</h2><p>需要在 etcd 的启动命令行中配置以下证书相关参数：</p><ul><li>etcd 对外提供服务的服务器证书及私钥。</li><li>etcd 节点之间相互进行认证的 peer 证书、私钥以及验证 peer 的 CA。</li><li>etcd 验证访问其服务的客户端的 CA。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/etcd \\<br>  --cert-file=/etc/etcd/kube-etcd.pem \\                   <span class="hljs-comment"># 对外提供服务的服务器证书</span><br>  --key-file=/etc/etcd/kube-etcd-key.pem \\                <span class="hljs-comment"># 服务器证书对应的私钥</span><br>  --peer-cert-file=/etc/etcd/kube-etcd-peer.pem \\         <span class="hljs-comment"># peer 证书，用于 etcd 节点之间的相互访问</span><br>  --peer-key-file=/etc/etcd/kube-etcd-peer-key.pem \\      <span class="hljs-comment"># peer 证书对应的私钥</span><br>  --trusted-ca-file=/etc/etcd/cluster-root-ca.pem \\       <span class="hljs-comment"># 用于验证访问 etcd 服务器的客户端证书的 CA 根证书</span><br>  --peer-trusted-ca-file=/etc/etcd/cluster-root-ca.pem\\   <span class="hljs-comment"># 用于验证 peer 证书的 CA 根证书</span><br>  ...<br></code></pre></td></tr></table></figure><h2 id="kube-apiserver-证书配置"><a href="#kube-apiserver-证书配置" class="headerlink" title="kube-apiserver 证书配置"></a>kube-apiserver 证书配置</h2><p>需要在 kube-apiserver 中配置以下证书相关参数：</p><ul><li>kube-apiserver 对外提供服务的服务器证书及私钥。</li><li>kube-apiserver 访问 etcd 所需的客户端证书及私钥。</li><li>kube-apiserver 访问 kubelet 所需的客户端证书及私钥。</li><li>验证访问其服务的客户端的 CA。</li><li>验证 etcd 服务器证书的 CA 根证书。</li><li>验证 service account token 的公钥。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-apiserver \\ <br>  --tls-cert-file=/var/lib/kubernetes/kube-apiserver.pem \\                             <span class="hljs-comment"># 用于对外提供服务的服务器证书</span><br>  --tls-private-key-file=/var/lib/kubernetes/kube-apiserver-key.pem \\                  <span class="hljs-comment"># 服务器证书对应的私钥</span><br>  --etcd-certfile=/var/lib/kubernetes/kube-apiserver-etcd-client.pem \\                 <span class="hljs-comment"># 用于访问 etcd 的客户端证书</span><br>  --etcd-keyfile=/var/lib/kubernetes/kube-apiserver-etcd-client-key.pem \\              <span class="hljs-comment"># 用于访问 etcd 的客户端证书的私钥</span><br>  --kubelet-client-certificate=/var/lib/kubernetes/kube-apiserver-kubelet-client.pem \\ <span class="hljs-comment"># 用于访问 kubelet 的客户端证书</span><br>  --kubelet-client-key=/var/lib/kubernetes/kube-apiserver-kubelet-client-key.pem \\     <span class="hljs-comment"># 用于访问 kubelet 的客户端证书的私钥</span><br>  --client-ca-file=/var/lib/kubernetes/cluster-root-ca.pem \\                           <span class="hljs-comment"># 用于验证访问 kube-apiserver 的客户端的证书的 CA 根证书</span><br>  --etcd-cafile=/var/lib/kubernetes/cluster-root-ca.pem \\                              <span class="hljs-comment"># 用于验证 etcd 服务器证书的 CA 根证书  </span><br>  --kubelet-certificate-authority=/var/lib/kubernetes/cluster-root-ca.pem \\            <span class="hljs-comment"># 用于验证 kubelet 服务器证书的 CA 根证书</span><br>  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\                 <span class="hljs-comment"># 用于验证 service account token 的公钥</span><br>  ...<br></code></pre></td></tr></table></figure><h2 id="采用-kubeconfig-访问-kube-apiserver"><a href="#采用-kubeconfig-访问-kube-apiserver" class="headerlink" title="采用 kubeconfig 访问 kube-apiserver"></a>采用 kubeconfig 访问 kube-apiserver</h2><p>Kubernetes 中的各个组件，包括kube-controller-mananger、kube-scheduler、kube-proxy、kubelet等，采用一个kubeconfig 文件中配置的信息来访问 kube-apiserver。该文件中包含了 kube-apiserver 的地址，验证 kube-apiserver 服务器证书的 CA 证书，自己的客户端证书和私钥等访问信息。</p><p>在一个使用 minikube 安装的集群中，生成的 kubeconfig 配置文件如下所示，这四个文件分别为 admin 用户， kube-controller-mananger、kubelet 和 kube-scheduler 的kubeconfig配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /etc/kubernetes/<br>admin.conf  controller-manager.conf  kubelet.conf  scheduler.conf<br></code></pre></td></tr></table></figure><p>我们打开 controller-manager.conf 来看一下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">cluster:</span> <br>    <span class="hljs-comment"># 用于验证 kube-apiserver 服务器证书的 CA 根证书 </span><br>    <span class="hljs-attr">certificate-authority-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQVRBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwdGFXNXAKYTNWaVpVTkJNQjRYRFRJd01ETXdOekF3TXpjeE1Wb1hEVE13TURNd05qQXdNemN4TVZvd0ZURVRNQkVHQTFVRQpBeE1LYldsdWFXdDFZbVZEUVRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTTczCkdIMWxqNkxEUm1FLy9hQ2cvNUlmampKYy8zOGcyMVpITXJDMkx5RGVqZWhrdWUwZFB1WTJ0L2JjTjJYM1dGNEsKaWNzNmhhWnBDbFVxL3pteVRITWhhZnlmVVF5MDFJZmhDV2I5NXI4akpHZ2NyU3U3UUtXM3ZOd1Z1TmhJNmd6SApSWW45Ry82VHJKTjdOMWRjejNmMlU1OFRjUHVCQzZOUzVTc1JmemFSczVDZnd0UTNaa2czQUFVYTlQSDZFVmtDCkIvRGR1bXBialZGakMwSllOWlFVNTlGNUxDeHJ0bEYvOUJsSVhnZGw0ZlNCNzQ0ZW1UelcySEZQek9lTklYYnUKYTJPa0FFTDdJc3hSRTFBaEFKZ1h6cFNmdi9paDBuMEJpQ1VaV1hLZjg2UjZJL2xlK2docG51c21kTXUwbkNEUApHMm9laXhRTit5NzFQU2tGcGdzQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUIwR0ExVWRKUVFXCk1CUUdDQ3NHQVFVRkJ3TUNCZ2dyQmdFRkJRY0RBVEFQQmdOVkhSTUJBZjhFQlRBREFRSC9NQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFCaWpXYlpPNU9uaU9lNHRHUlQvRGFXaFBkY2ZwbE8vcVQ5WkFqU1hXZU41TStubExQZQpGV1NLRGRWU1NzajJ6UVdMU3A1Vjc3MkFoa2NYQlM0a2ZiY2ZCTUl2ejVsYXJZeHgxcnduTzZLbVZSTHdkNUNkCnRER2RjUjF0UzdqeTRSV05ISlAyNWZhZHB5TE9KVzJlZkdLRmRiSnZyRjljekV1ODR5a1drdThtVnNNa0RzTXkKbnVFNGtXblNvODgweFpxVG9QN01qM3hkRlNYYWdoNytwK3FMazk1VjhBNTRUNmRKa2VjSGg4SzdNYVRxdWVOVgpzOVhuZDA2WEJGQWFCVXRsSGZybmRXUzhmaTQ5dTY0NEFWOWJHclNYRnR1Q0lydnIxVkY2d0R3dEJYZi9UUStrCkx3Zk1oNVZDVWt1bEJqWEpqK1ZvRnBLZm5Qck9nbEExZzRtUgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://localhost:8443</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes</span><br><span class="hljs-attr">contexts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">kubernetes</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">system:kube-controller-manager</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-controller-manager@kubernetes</span><br><span class="hljs-attr">current-context:</span> <span class="hljs-string">system:kube-controller-manager@kubernetes</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Config</span><br><span class="hljs-attr">preferences:</span> &#123;&#125;<br><span class="hljs-attr">users:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-controller-manager</span><br>  <span class="hljs-attr">user:</span><br>    <span class="hljs-comment"># 用于访问 kube-apiserver 的客户端证书</span><br>    <span class="hljs-attr">client-certificate-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lJZVE4aDNXSlNmZEF3RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2JXbHVhV3QxWW1WRFFUQWVGdzB5TURBek1EY3dNRE0zTVRGYUZ3MHlNVEExTVRrd05qVTNNemxhTUNreApKekFsQmdOVkJBTVRIbk41YzNSbGJUcHJkV0psTFdOdmJuUnliMnhzWlhJdGJXRnVZV2RsY2pDQ0FTSXdEUVlKCktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU5DTzJpTEZzNGRTTW9sR2plN2tjY1VFbURDVjEvbWQKV1p1cS9DT0RvV1p2Uy80clNrOXNsaFQvektIVTVkVmg3SFV4TGNWU1RkQXZScGEwN3dXK3h2eWlDR3Y5UmMyVAp0bkFnUFFhQ2VkOC8zZlFpMzI1QmZCZVl4UjRTTm8raEM1b0ZYYkhpdC9OWWlQTVMvM1hFOGVCc0dEZCtjd1pzCnhNTDZzc0pJNzVOSmNXckV3eXlMbzIrb1JSRmJ2TlpJWFRZekJpRGd3QkZxNUkzZVA5QTl2d29rUG5STFBSdlYKQU9SV3hUZDMyblJLOTY1SU9uV25mNzY0bHhSeEV6bHIyS09rSzc5NlVJWTlyL0lYOWdGQjNqbGZFK1lBOE5VLwpuV2x3cElNL0ZpMk9hL1hjNnQzNUJHSnNXcTR4bHQ5RDdqS3V2bTNONmJlanJPOFZNODU5QU44Q0F3RUFBYU1uCk1DVXdEZ1lEVlIwUEFRSC9CQVFEQWdXZ01CTUdBMVVkSlFRTU1Bb0dDQ3NHQVFVRkJ3TUNNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFCZVg4QmVuTlJoUTVWaVpMMjRxcWxIMjRlMDVyYWVVTFZJQlQzWE90cmdQcXF1WXRGWgptRG9naEpuSW05aVVMcHFTTUxHMlJrQ0RBMEk2Rit0SGVFVHRMRDlNdjA2N1huQ2VCclhkTFVTYzkwaHNZWm1KClNsVG11c21TZGUxUXJsRnFxQVRZY2VCVWgwM0lSbXZIL1BtS21va1FUZDZER0paVVVhM3ducEN6Nko4aGcySGwKWlZFaURKcHNoeXNBaVdCUWZBN01TRlFlb0poSjhUdHgzdEhNZDlaaHlmcVVHOVByUGJkMUlBQTIrRlVudXRsNwpoRmdZdTBxbG5aZFZCWE9JM1dvZndWZ2dDTEQrbFVCeGgzNVhLNStxYXhWNVlDTit0ZTNFeDJERHVmRW1UV0FoCkwwUVNTc0RTZGd0Vi9TNFhvV2xQcXU0Q2lRVnZydUg3WHkxMwotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br>    <span class="hljs-comment"># 客户端证书对应的私钥</span><br>    <span class="hljs-attr">client-key-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBMEk3YUlzV3poMUl5aVVhTjd1Unh4UVNZTUpYWCtaMVptNnI4STRPaFptOUwvaXRLClQyeVdGUC9Nb2RUbDFXSHNkVEV0eFZKTjBDOUdsclR2QmI3Ry9LSUlhLzFGelpPMmNDQTlCb0o1M3ovZDlDTGYKYmtGOEY1akZIaEkyajZFTG1nVmRzZUszODFpSTh4TC9kY1R4NEd3WU4zNXpCbXpFd3ZxeXdranZrMGx4YXNURApMSXVqYjZoRkVWdTgxa2hkTmpNR0lPREFFV3JramQ0LzBEMi9DaVErZEVzOUc5VUE1RmJGTjNmYWRFcjNya2c2CmRhZC92cmlYRkhFVE9XdllvNlFydjNwUWhqMnY4aGYyQVVIZU9WOFQ1Z0R3MVQrZGFYQ2tnejhXTFk1cjlkenEKM2ZrRVlteGFyakdXMzBQdU1xNitiYzNwdDZPczd4VXp6bjBBM3dJREFRQUJBb0lCQVFDRDVMT2pKZkJoZGVRcgoySWpPT1g2Um9GUTI5YXgrV2JwZnJnU0MyUzNyUUJ1SkJBdWNxd2xIQW5hQktjaW41NlBJZ1c5MnlKUVpRcXliCmhwVmF4c25FM3h3QVgwNFRzb1MvNkVOdnFIZzJiWWVLYTd0dFdOQ0hnNysxUXNOcWxlaG1ZVnBkc3dtdVJhRm0KUis5eXBUaHFPeklkZGtSOEhiRlp0WDN6VEhqbVpYaUhGdlIvMFhYK1BVbDR6SllSWjlCbVBnY2Ric2tSTldScgo0Qk8wUmlQQWRKVEo2VHZLMGhxT1g1UHo4ekl3S1ZzYjdyYndUdXArTGs4eWNCVUd3Q1N3RzEyanVNQW1kYkJJClZmdmlFK1VYRHRIQXdLWXlnMEhCVitJVlEvcVNwSVJ1WXQ4SmY1MWVKN1VEbHhiN3ZRTStEYVNsNjVaMVNyWUcKQU9UTGpPVkJBb0dCQU5PYzB0OG5ybmhUR3V0MGhMdVp6SWs4ekFranhYYWtiSURlZi9XeXlQdW94Z3J2ZGMzcwpsbHV0U3hSOFV4WGVuQjBLZFpnYnNoc1ozeW9GbEI0YThTMzI1UFRsYm9xOVB0TDRaOFBzczQ3L0l1bHYxTk10CnZzZjdKZ1FuaFRCVndkdjN6OXFpdml6bjB4Mk9CdURxdzNSYXcvWEhwRy9RczJ5WmF4S29GNW9SQW9HQkFQeE8KQVBDUXQ2Q2swOFF2WTE4VjFLQXA0d2h1YWEyMS9MeC9rZUZJSURRd0tZZnFHRGdBWUYvQzJUbC9xc29TMXAvTwpFcFVkVkRBNHVpblFVbnFhNGg0a0JOYjRXTFhrSXhRdXdjWHdJNjRMNWR3ZWJHalhxUWUwbnkxQkhkTmU2Z0dqClorbit4OUJLWnJmcEliYkQ2blpYUUREbS9jZWYyWU5NVWRqVWpudnZBb0dBQnlIMUZhSi94ZngvSHNxWm9yMG4KWU1UVTE4WUY1TjdiN1dnU2hoU1ZvNjNucHZ5MVN0Q2JyTkZsZzNaQlVxNWpNck5ralZENXF1SXZYSG85cU5vZApvUC8rYmFiQ0dCa1M0Z2VQYjlJdHB6ZEFWUC80KzNsQ1FmbGNLYTJ2VnBhOVp3MnVTdDlMYTdZUXJxRlg2QUxoCnZhMUZoNlpJQzZETU8yL2NaUStYWkJFQ2dZQnNGMHNGeFNvMlU0YzZISWM1SEZRc2plVnJIa3ArRm1LQnF6R24KVDB3a3I2R0xUZm8wTzgwT0daOFFxQ1pXVGozTzF1MVZIdXlMZ0RJWmFkdDhGVkRjVXRnVDlPK2tkV21sNHVZMwpVOHNsYklsOGhUZ3lybm9IQ0JYTndJRHpwazBnaUk0alRIajBQbnZGUE1hcDAwTm1rYmk1ZXF5czBrblFtMmpSCk9UY1Yxd0tCZ0RNUWZSVlNNNXlGcjVIalJ4UXcwRDdrUWhONDlLbngrMWs2bWRORWJ6VG9rQ1RRcWlSeUJQdGgKcjlqZk0rRXFZcnZ1elRmRVpiS1VBMEZac09yeStxMHpXb29mTURLajFGV3BaTXJBSmdxdDFlcWtFbVFrVi8vSApQMzF3ejZDa1RneDdJby9iZ09PbmhsbUplU3NHaXpqenV2TjFEcWtjNVR3M3oxUSs1dmxmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==</span><br></code></pre></td></tr></table></figure><p>可以看到，访问 kube-apiserver 所需要的相关证书内容已经被采用 base64 编码写入了文件中。其他几个文件中的内容也是类似的，只是配置的用户名和客户端证书有所不同。</p><p>在启动这些组件时，需要在参数中指出 kubeconfig 文件的路径，例如 kube-controller-manager 的启动命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-controller-manager \\<br>--kubeconfig=/etc/kubernetes/controller-manager.conf <br><span class="hljs-comment"># 下面几个证书和访问 kube-apiserver 无关，我们会在后面介绍到</span><br>--cluster-signing-cert-file=/var/lib/kubernetes/cluster-root-ca.pem             <span class="hljs-comment"># 用于签发证书的 CA 根证书</span><br>--cluster-signing-key-file=/var/lib/kubernetes/cluster-root-ca-key.pem          <span class="hljs-comment"># 用于签发证书的 CA 根证书的私钥  </span><br>--service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem  <span class="hljs-comment"># 用于对 service account token 进行签名的私钥</span><br>... <br></code></pre></td></tr></table></figure><h2 id="Service-Account-证书"><a href="#Service-Account-证书" class="headerlink" title="Service Account 证书"></a>Service Account 证书</h2><p>Kubernetes 中有两类用户，一类为 user account，一类为 service account。 service account 主要被 pod 用于访问 kube-apiserver。 在为一个 pod 指定了 service account 后，kubernetes 会为该 service account 生成一个 JWT token，并使用 secret 将该 service account token 加载到 pod 上。pod 中的应用可以使用 service account token 来访问 api server。service account 证书被用于生成和验证 service account token。该证书的用法和前面介绍的其他证书不同，因为实际上使用的是其公钥和私钥，而并不需要对证书进行验证。</p><p>我们可以看到 service account 证书的公钥和私钥分别被配置到了 kube-apiserver 和 kube-controller-manager 的命令行参数中，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-apiserver \\ <br>  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\          <span class="hljs-comment"># 用于验证 service account token 的公钥</span><br>  ...<br>  <br> /usr/local/bin/kube-controller-manager \\<br> --service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem  <span class="hljs-comment"># 用于对 service account token 进行签名的私钥</span><br> ... <br></code></pre></td></tr></table></figure><p>下图展示了 kubernetes 中生成、使用和验证 service account token 的过程。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/service-account-token.png" alt="img"></p><h3 id="认证方法：客户端证书还是-token-？"><a href="#认证方法：客户端证书还是-token-？" class="headerlink" title="认证方法：客户端证书还是 token ？"></a>认证方法：客户端证书还是 token ？</h3><p>我们可以看到，Kubernetes 提供了两种客户端认证的方法，控制面组件采用的是客户端数字证书;而在集群中部署的应用则采用了 service account token 的方式。为什么 Kubernetes 不为 service account 也生成一个证书，并采用该证书进行身份认证呢？ 实际上 Istio 就是这样做的，Istio 会自动为每个 service account 生成一个证书，并使用该证书来在 pod 中的应用之间建立双向 tls 认证。我没有找到 Kubernetes 这个设计决策的相关说明，如果你知道原因或对此有自己的见解，欢迎联系我进行探讨。</p><h2 id="Kubernetes-证书签发"><a href="#Kubernetes-证书签发" class="headerlink" title="Kubernetes 证书签发"></a>Kubernetes 证书签发</h2><p>Kubernetes 提供了一个 <code>certificates.k8s.io</code> API，可以使用配置的 CA 根证书来签发用户证书。该 API 由 kube-controller-manager 实现，其签发证书使用的根证书在下面的命令行中进行配置。我们希望 Kubernetes 采用集群根 CA 来签发用户证书，因此在 kube-controller-manager 的命令行参数中将相关参数配置为了集群根 CA。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-controller-manager \\<br>--cluster-signing-cert-file=/var/lib/kubernetes/cluster-root-ca.pem             <span class="hljs-comment"># 用于签发证书的 CA 根证书</span><br>--cluster-signing-key-file=/var/lib/kubernetes/cluster-root-ca-key.pem          <span class="hljs-comment"># 用于签发证书的 CA 根证书的私钥  </span><br>... <br></code></pre></td></tr></table></figure><p>关于更多 Kubernetes 证书签发 API 的内容，可以参见 <a href="https://kubernetes.io/zh/docs/tasks/tls/managing-tls-in-a-cluster/">管理集群中的 TLS 认证</a>。</p><h2 id="使用-TLS-bootstrapping-简化-Kubelet-证书制作"><a href="#使用-TLS-bootstrapping-简化-Kubelet-证书制作" class="headerlink" title="使用 TLS bootstrapping 简化 Kubelet 证书制作"></a>使用 TLS bootstrapping 简化 Kubelet 证书制作</h2><p>在安装 Kubernetes 时，我们需要为每一个工作节点上的 Kubelet 分别生成一个证书。由于工作节点可能很多，手动生成 Kubelet 证书的过程会比较繁琐。为了解决这个问题，Kubernetes 提供了 <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS bootstrapping </a>的方式来简化 Kubelet 证书的生成过程。其原理是预先提供一个 bootstrapping token，kubelet 采用该 bootstrapping token 进行客户端验证，调用 kube-apiserver 的证书签发 API 来生成 自己需要的证书。要启用该功能，需要在 kube-apiserver 中启用 <code>--enable-bootstrap-token-auth</code> ，并创建一个 kubelet 访问 kube-apiserver 使用的 bootstrap token secret。如果使用 kubeadmin 安装，可以使用 <code>kubeadm token create</code>命令来创建 token。</p><p>采用TLS bootstrapping 生成证书的流程如下：</p><ol><li>调用 kube-apiserver 生成一个 bootstrap token。</li><li>将该 bootstrap token 写入到一个 kubeconfig 文件中，作为 kubelet 调用 kube-apiserver 的客户端验证方式。</li><li>通过 <code>--bootstrap-kubeconfig</code> 启动参数将 bootstrap token 传递给 kubelet 进程。</li><li>Kubelet 采用bootstrap token 调用 kube-apiserver API，生成自己所需的服务器和客户端证书。</li><li>证书生成后，Kubelet 采用生成的证书和 kube-apiserver 进行通信，并删除本地的 kubeconfig 文件，以避免 bootstrap token 泄漏风险。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Kubernetes 中使用了大量的证书来确保集群的安全，弄清楚这些证书的用途和配置方法将有助于我们深入理解 kubernetes 的安装过程和组件的配置。本文是笔者在学习 过程中整理的 Kubernetes 集群中主要使用到的证书，由于笔者对 Kubernetes 的理解有限，文章中难免存在部分错误，欢迎指正。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://kubernetes.io/zh/docs/setup/best-practices/certificates/">Kubernetes PKI 证书和要求</a></li><li><a href="https://github.com/kelseyhightower/kubernetes-the-hard-wa">kubernetes the hard way</a></li><li><a href="https://blog.51cto.com/13210651/2361208">Kubernetes 之 二进制安装(二) 证书详解</a></li><li><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS bootstrapping</a></li><li><a href="https://zhaohuabing.com/post/2020-03-19-pki/">数字证书原理</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s-选主-实战验证</title>
    <link href="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/"/>
    <url>/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s-选主-实战验证"><a href="#k8s-选主-实战验证" class="headerlink" title="k8s-选主-实战验证"></a>k8s-选主-实战验证</h1><p>转自：<a href="https://blog.csdn.net/boling_cavalry/article/details/132129123">https://blog.csdn.net/boling_cavalry/article/details/132129123</a></p><h4 id="本篇概览"><a href="#本篇概览" class="headerlink" title="本篇概览"></a>本篇概览</h4><p>•本文是《client-go实战》系列的第十二篇，又有一个精彩的知识点在本章呈现：选主(leader-election)•在解释什么是选主之前，咱们先来看一个场景（有真实适用场景的技术，学起来才有动力），如下图所示（稍后有详细说明）</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/230a3f9ae9a956d7d112c28c02a38ff4.png" alt="Image 32: 在这里插入图片描述"></p><p>上图所描述的业务场景是个普通的controller应用：</p><p>1.右侧是人工操作，通过kubectl命令修改了service资源2.左侧的业务应用订阅了service的变化，在收到service变更的事件后，对pod进行写操作（例如将收到事件的时间写入pod的label）</p><p>•以上的业务应用就是个很普通的controller，很简单，运行起来也没啥问题，但是，如果这个业务应用有多个实例呢？</p><h4 id="多实例的问题"><a href="#多实例的问题" class="headerlink" title="多实例的问题"></a>多实例的问题</h4><p>•所谓多个实例，就是同样的业务应用我们运行了多个进程（例如三个），为什么多个进程？同一个应用运行多个进程不是很正常么？横向扩容不就是多进程嘛•多个进程运行的时候，如果service发生变化，那么每个进程都会去修改pod的label，这不是我们想要的（只要修改一次就行了）•所以，如何解决这个问题呢？三个进程都是同一套代码，都会订阅service的变化，但是最终只修改一次pod•经验丰富的您应该会想到分布式锁，三个进程去抢分布式锁，抢到的负责更新，没错，这是一个正确的解法•但是，分布式锁需要引入相关组件吧，redis的setnx，或者mysql的乐观锁，这样就需要维护新的组件了•其实这在kubernetes是个很典型的问题，毕竟pod多实例在kubernetes是常态了，所以当然也有官方的解法，页就是本文的主题：选主(leader-election)</p><h4 id="选主-leader-election"><a href="#选主-leader-election" class="headerlink" title="选主(leader-election)"></a>选主(leader-election)</h4><p>•说到这里您应该能理解选主的含义了：多个进程竞争某个key的leader，咱们可以把特定的代码放在竞争成功后再执行，由于同一时刻只有一个进程可以竞争成功，这就相当于在不引入额外组件的情况下，只用client-go就实现了分布式锁•由于选主只是个特定的小知识点，本篇就没什么多余的理论要研究了，接下来直接开始实战，编码实现一个功能来说明选主的用法•实战的业务需求如下</p><p>1.开发一个应用，该应用同时运行多个进程2.当kubernetes的指定namespace下的service发生变化时，在pod的label中记录这个service的变化时间3.每次serivce变化，pod的label只能修改一次（尽管此时有多个进程）</p><p>•让我们少些套路，多一点真诚，不说废话，直接开始动手实战吧</p><h4 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h4><p>•如果您不想编写代码，也可以从GitHub上直接下载，地址和链接信息如下表所示(<a href="https://github.com/zq2599/blog/_demos)%EF%BC%9A">https://github.com/zq2599/blog\_demos)：</a></p><table><thead><tr><th>名称</th><th>链接</th><th>备注</th></tr></thead><tbody><tr><td>项目主页</td><td><a href="https://github.com/zq2599/blog/_demos">https://github.com/zq2599/blog\_demos</a></td><td>该项目在GitHub上的主页</td></tr><tr><td>git仓库地址(https)</td><td><a href="https://github.com/zq2599/blog/_demos.git">https://github.com/zq2599/blog\_demos.git</a></td><td>该项目源码的仓库地址，https协议</td></tr><tr><td>git仓库地址(ssh)</td><td><a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#104;&#117;&#98;&#46;&#99;&#x6f;&#x6d;</a>:zq2599&#x2F;blog_demos.git</td><td>该项目源码的仓库地址，ssh协议</td></tr></tbody></table><p>•这个git项目中有多个文件夹，本篇的源码在leader-tutorials文件夹下，如下图黄框所示：</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/fc33e0f2da6fec4b7043fc97415dd155.png" alt="Image 33: 在这里插入图片描述"></p><h4 id="提前了解选主的代码"><a href="#提前了解选主的代码" class="headerlink" title="提前了解选主的代码"></a>提前了解选主的代码</h4><p>•接下来会开发一个完整的controller应用，以此来说明选主功能•如果您觉得完整应用的代码太多，懒得看，只想了解选主部分，那就在此提前将整个工程中选主相关的代码贴出来•核心代码如下所示，先创建锁对象，就像分布式锁一样，总要有个key，然后执行leaderelection.RunOrDie方法参与选主，一旦有了结果，OnNewLeader方法会被回调，这时候通过自身id和leader的id比较就知道是不是自己了，另外，当OnStartedLeading被执行的时候，就意味着当前进程就是leader，并且可以立即开始执行只有leader才能做的事情了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// startLeaderElection 选主的核心逻辑代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startLeaderElection</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, stop <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]创建选主所需的锁对象&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 创建锁对象</span><br>    lock := &amp;resourcelock.LeaseLock&#123;<br>        LeaseMeta: metav1.ObjectMeta&#123;<br>            Name:      <span class="hljs-string">&quot;leader-tutorials&quot;</span>,<br>            Namespace: NAMESPACE,<br>        &#125;,<br>        Client: clientset.CoordinationV1(),<br>        LockConfig: resourcelock.ResourceLockConfig&#123;<br>            Identity: processIndentify,<br>        &#125;,<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始选主&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 启动选主操作</span><br>    leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;<br>        Lock:            lock,<br>        ReleaseOnCancel: <span class="hljs-literal">true</span>,<br>        LeaseDuration:   <span class="hljs-number">10</span> * time.Second,<br>        RenewDeadline:   <span class="hljs-number">5</span> * time.Second,<br>        RetryPeriod:     <span class="hljs-number">2</span> * time.Second,<br>        Callbacks: leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]当前进程是leader，只有leader才能执行的业务逻辑立即开始&quot;</span>, processIndentify)<br>                <span class="hljs-comment">// 在这里写入选主成功的代码，</span><br>                <span class="hljs-comment">// 就像抢分布式锁一样，当前进程选举成功的时候，这的代码就会被执行，</span><br>                <span class="hljs-comment">// 所以，在这里填写抢锁成功的业务逻辑吧，本例中就是监听service变化，然后修改pod的label</span><br>                CreateAndStartController(ctx, clientset, &amp;v1.Service&#123;&#125;, <span class="hljs-string">&quot;services&quot;</span>, NAMESPACE, stop)<br>            &#125;,<br>            OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-comment">// 失去了leader时的逻辑</span><br>                klog.Infof(<span class="hljs-string">&quot;[%s]失去leader身份，不再是leader了&quot;</span>, processIndentify)<br>                os.Exit(<span class="hljs-number">0</span>)<br>            &#125;,<br>            OnNewLeader: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span> &#123;<br>                <span class="hljs-comment">// 收到通知，知道最终的选举结果</span><br>                <span class="hljs-keyword">if</span> identity == processIndentify &#123;<br>                    klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，当前进程就是leader&quot;</span>, processIndentify)<br>                    <span class="hljs-comment">// I just got the lock</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，leader是 : [%s]&quot;</span>, processIndentify, identity)<br>            &#125;,<br>        &#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实战：部署service和deployment"><a href="#实战：部署service和deployment" class="headerlink" title="实战：部署service和deployment"></a>实战：部署service和deployment</h4><p>•首先请准备好k8s环境，这在《client-go实战之六:时隔两年，刷新版本继续实战》里面已有详细说明•然后把本次实战所需的service和deployment部署好，- 所有要部署的内容我都集中在这个名为nginx-deployment-service.yaml脚本中了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">client-go-tutorials</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>        <span class="hljs-comment"># 这是第一个业务自定义label，指定了mysql的语言类型是c语言</span><br>        <span class="hljs-attr">language:</span> <span class="hljs-string">c</span><br>        <span class="hljs-comment"># 这是第二个业务自定义label，指定了这个pod属于哪一类服务，nginx属于web类</span><br>        <span class="hljs-attr">business-service-type:</span> <span class="hljs-string">web</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>          <span class="hljs-attr">resources:</span><br>            <span class="hljs-attr">limits:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span><br>            <span class="hljs-attr">requests:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.1&quot;</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">64Mi</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">client-go-tutorials</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30011</span><br></code></pre></td></tr></table></figure><p>•先执行以下命令创建namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create namespace client-go-tutorials<br></code></pre></td></tr></table></figure><p>•再执行以下命令即可完成资源的创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f nginx-deployment-service.yaml<br></code></pre></td></tr></table></figure><p>•来查看一下资源情况，如下图，service和pod都创建好了，准备工作完成，可以开始编码了</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/73fa79a5cf8315f15417361895009780.png" alt="Image 36: 在这里插入图片描述"></p><h4 id="编码：准备工程"><a href="#编码：准备工程" class="headerlink" title="编码：准备工程"></a>编码：准备工程</h4><p>•执行命令名为go mod init leader-tutorials，新建module•确保您的goproxy是正常的•执行命令go get k8s.io&#x2F;<a href="mailto:&#x63;&#x6c;&#105;&#101;&#x6e;&#116;&#45;&#103;&#111;&#64;&#118;&#x30;&#46;&#x32;&#50;&#46;&#x38;">&#x63;&#x6c;&#105;&#101;&#x6e;&#116;&#45;&#103;&#111;&#64;&#118;&#x30;&#46;&#x32;&#50;&#46;&#x38;</a>，下载client-go的指定版本•现在工程已经准备好了，接着就是具体的编码</p><h4 id="编码：梳理"><a href="#编码：梳理" class="headerlink" title="编码：梳理"></a>编码：梳理</h4><p>•咱们按照开发顺序开始写代码，如果您看过欣宸的《client-go实战》系列，此刻对使用client-go开发简易版controller应该很熟悉了，这里再简单提一下开发的流程</p><p>1.将controller完整的写出来，功能是监听service，一旦有变化就更新pod的label2.在主控逻辑中，根据选主结果决定是否启动步骤1中的controller</p><p>•下面开始写代码</p><h4 id="编码：controller"><a href="#编码：controller" class="headerlink" title="编码：controller"></a>编码：controller</h4><p>•新建controller.go文件•在controller.go中增加常量和数据结构的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br><br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/fields&quot;</span><br>    objectruntime <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/types&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/util/runtime&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/util/wait&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/cache&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/util/workqueue&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    LABLE_SERVICE_UPDATE_TIME = <span class="hljs-string">&quot;service-update-time&quot;</span> <span class="hljs-comment">// 这个label用来记录service的更新时间</span><br>)<br><br><span class="hljs-comment">// 自定义controller数据结构，嵌入了真实的控制器</span><br><span class="hljs-keyword">type</span> Controller <span class="hljs-keyword">struct</span> &#123;<br>    ctx       context.Context<br>    clientset *kubernetes.Clientset<br>    <span class="hljs-comment">// 本地缓存，关注的对象都会同步到这里</span><br>    indexer cache.Indexer<br>    <span class="hljs-comment">// 消息队列，用来触发对真实对象的处理事件</span><br>    queue workqueue.RateLimitingInterface<br>    <span class="hljs-comment">// 实际运行运行的控制器</span><br>    informer cache.Controller<br>&#125;<br></code></pre></td></tr></table></figure><p>•然后是controller的套路代码，主要是从队列中不断获取数据并处理的逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// processNextItem 不间断从队列中取得数据并处理</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> processNextItem() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 注意，队列里面不是对象，而是key，这是个阻塞队列，会一直等待</span><br>    key, quit := c.queue.Get()<br>    <span class="hljs-keyword">if</span> quit &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// Tell the queue that we are done with processing this key. This unblocks the key for other workers</span><br>    <span class="hljs-comment">// This allows safe parallel processing because two pods with the same key are never processed in</span><br>    <span class="hljs-comment">// parallel.</span><br>    <span class="hljs-keyword">defer</span> c.queue.Done(key)<br><br>    <span class="hljs-comment">// 注意，这里的syncToStdout应该是业务代码，处理对象变化的事件</span><br>    err := c.updatePodsLabel(key.(<span class="hljs-type">string</span>))<br><br>    <span class="hljs-comment">// 如果前面的业务逻辑遇到了错误，就在此处理</span><br>    c.handleErr(err, key)<br><br>    <span class="hljs-comment">// 外面的调用逻辑是：返回true就继续调用processNextItem方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// runWorker 这是个无限循环，不断地从队列取出数据处理</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> runWorker() &#123;<br>    <span class="hljs-keyword">for</span> c.processNextItem() &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// handleErr 如果前面的业务逻辑执行出现错误，就在此集中处理错误，本例中主要是重试次数的控制</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> handleErr(err <span class="hljs-type">error</span>, key <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// Forget about the #AddRateLimited history of the key on every successful synchronization.</span><br>        <span class="hljs-comment">// This ensures that future processing of updates for this key is not delayed because of</span><br>        <span class="hljs-comment">// an outdated error history.</span><br>        c.queue.Forget(key)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果重试次数未超过5次，就继续重试</span><br>    <span class="hljs-keyword">if</span> c.queue.NumRequeues(key) &lt; <span class="hljs-number">5</span> &#123;<br>        klog.Infof(<span class="hljs-string">&quot;Error syncing pod %v: %v&quot;</span>, key, err)<br><br>        <span class="hljs-comment">// Re-enqueue the key rate limited. Based on the rate limiter on the</span><br>        <span class="hljs-comment">// queue and the re-enqueue history, the key will be processed later again.</span><br>        c.queue.AddRateLimited(key)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 代码走到这里，意味着有错误并且重试超过了5次，应该立即丢弃</span><br>    c.queue.Forget(key)<br>    <span class="hljs-comment">// 这种连续五次重试还未成功的错误，交给全局处理逻辑</span><br>    runtime.HandleError(err)<br>    klog.Infof(<span class="hljs-string">&quot;Dropping pod %q out of the queue: %v&quot;</span>, key, err)<br>&#125;<br><br><span class="hljs-comment">// Run 开始常规的控制器模式（持续响应资源变化事件）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> Run(threadiness <span class="hljs-type">int</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    <span class="hljs-keyword">defer</span> runtime.HandleCrash()<br><br>    <span class="hljs-comment">// Let the workers stop when we are done</span><br>    <span class="hljs-keyword">defer</span> c.queue.ShutDown()<br>    klog.Info(<span class="hljs-string">&quot;Starting Pod controller&quot;</span>)<br><br>    <span class="hljs-keyword">go</span> c.informer.Run(stopCh)<br><br>    <span class="hljs-comment">// Wait for all involved caches to be synced, before processing items from the queue is started</span><br>    <span class="hljs-comment">// 刚开始启动，从api-server一次性全量同步所有数据</span><br>    <span class="hljs-keyword">if</span> !cache.WaitForCacheSync(stopCh, c.informer.HasSynced) &#123;<br>        runtime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;timed out waiting for caches to sync&quot;</span>))<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 支持多个线程并行从队列中取得数据进行处理</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadiness; i++ &#123;<br>        <span class="hljs-keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)<br>    &#125;<br><br>    &lt;-stopCh<br>    klog.Info(<span class="hljs-string">&quot;Stopping Pod controller&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>•从上述代码可见，监听的资源发生变化时，调用的是updatePodsLabel方法，此方法的作用就是查找该namespace下的所有pod，依次用patch的方式更新pod的label</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// updatePodsLabel 这是业务逻辑代码，一旦service发生变化，就修改pod的label，将service的变化事件记录进去</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> updatePodsLabel(key <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 开始进入controller的业务逻辑</span><br>    klog.Infof(<span class="hljs-string">&quot;[%s]这里是controller的业务逻辑，key [%s]&quot;</span>, processIndentify, key)<br>    <span class="hljs-comment">// 从本地缓存中取出完整的对象</span><br>    _, exists, err := c.indexer.GetByKey(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Errorf(<span class="hljs-string">&quot;[%s]根据key[%s]从本地缓存获取对象失败 : %v&quot;</span>, processIndentify, key, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> !exists &#123;<br>        klog.Infof(<span class="hljs-string">&quot;[%s]对象不存在，key [%s]，这是个删除事件&quot;</span>, processIndentify, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        klog.Infof(<span class="hljs-string">&quot;[%s]对象存在，key [%s]，这是个新增或修改事件&quot;</span>, processIndentify, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 代码走到这里，表示监听的对象发生了变化，</span><br>    <span class="hljs-comment">// 按照业务设定，需要修改pod的指定label,</span><br>    <span class="hljs-comment">// 准备好操作pod的接口</span><br>    podInterface := c.clientset.CoreV1().Pods(NAMESPACE)<br><br>    <span class="hljs-comment">// 远程取得最新的pod列表</span><br>    pods, err := podInterface.List(c.ctx, metav1.ListOptions&#123;&#125;)<br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Errorf(<span class="hljs-string">&quot;[%s]远程获取pod列表失败 : %v&quot;</span>, processIndentify, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 将service的变化时间写入pod的指定label，这里先获取当前时间</span><br>    updateTime := time.Now().Format(<span class="hljs-string">&quot;20060102150405&quot;</span>)<br>    <span class="hljs-comment">// 准备patch对象</span><br>    patchData := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>        <span class="hljs-string">&quot;metadata&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>            <span class="hljs-string">&quot;labels&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>                LABLE_SERVICE_UPDATE_TIME: updateTime,<br>            &#125;,<br>        &#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 转为byte数组，稍后更新pod的时候，就用这个数组进行patch更新</span><br>    patchByte, _ := json.Marshal(patchData)<br><br>    <span class="hljs-comment">// 遍历所有pod，逐个更新label</span><br>    <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods.Items &#123;<br>        podName := pod.Name<br>        klog.Infof(<span class="hljs-string">&quot;[%s]正在更新pod [%s]&quot;</span>, processIndentify, podName)<br><br>        _, err := podInterface.Patch(c.ctx, podName, types.MergePatchType, patchByte, metav1.PatchOptions&#123;&#125;)<br><br>        <span class="hljs-comment">// 失败就返回，会导致整体重试</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            klog.Infof(<span class="hljs-string">&quot;[%s]更新pod [%s]失败, %v&quot;</span>, processIndentify, podName, err)<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br><br>        klog.Infof(<span class="hljs-string">&quot;[%s]更新pod [%s]成功&quot;</span>, processIndentify, podName)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>•到这里，controller的代码已经写得七七八八了，还剩创建controller对象以及运行informer的代码，这里将它们集中封装在一个方法中，一旦这个方法被调用，就意味着controller会被创建，然后监听service变化再更新pod的label的逻辑就会被执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateAndStartController 为了便于外部使用，这里将controller的创建和启动封装在一起</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateAndStartController</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, objType objectruntime.Object, resource <span class="hljs-type">string</span>, namespace <span class="hljs-type">string</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-comment">// ListWatcher用于获取数据并监听资源的事件</span><br>    podListWatcher := cache.NewListWatchFromClient(clientset.CoreV1().RESTClient(), resource, NAMESPACE, fields.Everything())<br><br>    <span class="hljs-comment">// 限速队列，里面存的是有事件发生的对象的身份信息，而非对象本身</span><br>    queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())<br><br>    <span class="hljs-comment">// 创建本地缓存并对指定类型的资源开始监听</span><br>    <span class="hljs-comment">// 注意，如果业务上有必要，其实可以将新增、修改、删除等事件放入不同队列，然后分别做针对性处理，</span><br>    <span class="hljs-comment">// 但是，controller对应的模式，主要是让status与spec达成一致，也就是说增删改等事件，对应的都是查到实际情况，令其与期望情况保持一致，</span><br>    <span class="hljs-comment">// 因此，多数情况下增删改用一个队列即可，里面放入变化的对象的身份，至于处理方式只有一种：查到实际情况，令其与期望情况保持一致</span><br>    indexer, informer := cache.NewIndexerInformer(podListWatcher, objType, <span class="hljs-number">0</span>, cache.ResourceEventHandlerFuncs&#123;<br>        AddFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 再次注意：这里放入队列的并非对象，而是对象的身份，作用是仅仅告知消费方，该对象有变化，</span><br>                <span class="hljs-comment">// 至于有什么变化，需要消费方自行判断，然后再做针对性处理</span><br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        UpdateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(old <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(<span class="hljs-built_in">new</span>)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        DeleteFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>    &#125;, cache.Indexers&#123;&#125;)<br><br>    controller := &amp;Controller&#123;<br>        ctx:       ctx,<br>        clientset: clientset,<br>        informer:  informer,<br>        indexer:   indexer,<br>        queue:     queue,<br>    &#125;<br><br>    <span class="hljs-keyword">go</span> controller.Run(<span class="hljs-number">1</span>, stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编码：主控程序（选主逻辑也在里面）"><a href="#编码：主控程序（选主逻辑也在里面）" class="headerlink" title="编码：主控程序（选主逻辑也在里面）"></a>编码：主控程序（选主逻辑也在里面）</h4><p>•本文是讲选主(leader-election)的，前面做了这么多铺垫，主角该上场了，新建main.go文件•定义常量，以及全局变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;flag&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;path/filepath&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/google/uuid&quot;</span><br>    v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/leaderelection&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/leaderelection/resourcelock&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/util/homedir&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    NAMESPACE = <span class="hljs-string">&quot;client-go-tutorials&quot;</span><br>)<br><br><span class="hljs-comment">// 用于表明当前进程身份的全局变量，目前用的是uuid</span><br><span class="hljs-keyword">var</span> processIndentify <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>•先把套路的代码写了，就是client-go初始化的那部分，以及main方法，里面是整个程序的启动和业务调用流程，可见选主有关的代码都放在名为startLeaderElection的方法中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// initOrDie client有关的初始化操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initOrDie</span><span class="hljs-params">()</span></span> *kubernetes.Clientset &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始初始化kubernetes客户端相关对象&quot;</span>, processIndentify)<br>    <span class="hljs-keyword">var</span> kubeconfig *<span class="hljs-type">string</span><br>    <span class="hljs-keyword">var</span> master <span class="hljs-type">string</span><br><br>    <span class="hljs-comment">// 试图取到当前账号的家目录</span><br>    <span class="hljs-keyword">if</span> home := homedir.HomeDir(); home != <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-comment">// 如果能取到，就把家目录下的.kube/config作为默认配置文件</span><br>        kubeconfig = flag.String(<span class="hljs-string">&quot;kubeconfig&quot;</span>, filepath.Join(home, <span class="hljs-string">&quot;.kube&quot;</span>, <span class="hljs-string">&quot;config&quot;</span>), <span class="hljs-string">&quot;(optional) absolute path to the kubeconfig file&quot;</span>)<br>        master = <span class="hljs-string">&quot;&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果取不到，就没有默认配置文件，必须通过kubeconfig参数来指定</span><br>        flag.StringVar(kubeconfig, <span class="hljs-string">&quot;kubeconfig&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;absolute path to the kubeconfig file&quot;</span>)<br>        flag.StringVar(&amp;master, <span class="hljs-string">&quot;master&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;master url&quot;</span>)<br>        flag.Parse()<br>    &#125;<br><br>    config, err := clientcmd.BuildConfigFromFlags(master, *kubeconfig)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Fatal(err)<br>    &#125;<br><br>    clientset, err := kubernetes.NewForConfig(config)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Fatal(err)<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]kubernetes客户端相关对象创建成功&quot;</span>, processIndentify)<br>    <span class="hljs-keyword">return</span> clientset<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 一次性确定当前进程身份</span><br>    processIndentify = uuid.New().String()<br><br>    <span class="hljs-comment">// 准备一个带cancel的context，这样在主程序退出的时候，可以将停止的信号传递给业务</span><br>    ctx, cancel := context.WithCancel(context.Background())<br>    <span class="hljs-comment">// 这个是用来停止controller的</span><br>    stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br>    <span class="hljs-comment">// 主程序结束的时候，下面的操作可以将业务逻辑都停掉</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">close</span>(stop)<br>        cancel()<br>    &#125;()<br><br>    <span class="hljs-comment">// 初始化clientSet配置，因为是启动阶段，所以必须初始化成功，否则进程退出</span><br>    clientset := initOrDie()<br><br>    <span class="hljs-comment">// 在一个新的协程中执行选主逻辑，以及选主成功的后的逻辑</span><br>    <span class="hljs-keyword">go</span> startLeaderElection(ctx, clientset, stop)<br><br>    <span class="hljs-comment">// 这里可以继续做其他事情</span><br>    klog.Infof(<span class="hljs-string">&quot;选主的协程已经在运行，接下来可以执行其他业务 [%s]&quot;</span>, processIndentify)<br><br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>•最后是选主的代码，如下所示，先创建锁对象，就像分布式锁一样，总要有个key，然后执行leaderelection.RunOrDie方法参与选主，一旦有了结果，OnNewLeader方法会被回调，这时候通过自身id和leader的id比较就知道是不是自己了，另外，当OnStartedLeading被执行的时候，就意味着当前进程就是leader，并且可以立即开始执行只有leader才能做的事情了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// startLeaderElection 选主的核心逻辑代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startLeaderElection</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, stop <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]创建选主所需的锁对象&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 创建锁对象</span><br>    lock := &amp;resourcelock.LeaseLock&#123;<br>        LeaseMeta: metav1.ObjectMeta&#123;<br>            Name:      <span class="hljs-string">&quot;leader-tutorials&quot;</span>,<br>            Namespace: NAMESPACE,<br>        &#125;,<br>        Client: clientset.CoordinationV1(),<br>        LockConfig: resourcelock.ResourceLockConfig&#123;<br>            Identity: processIndentify,<br>        &#125;,<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始选主&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 启动选主操作</span><br>    leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;<br>        Lock:            lock,<br>        ReleaseOnCancel: <span class="hljs-literal">true</span>,<br>        LeaseDuration:   <span class="hljs-number">10</span> * time.Second,<br>        RenewDeadline:   <span class="hljs-number">5</span> * time.Second,<br>        RetryPeriod:     <span class="hljs-number">2</span> * time.Second,<br>        Callbacks: leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]当前进程是leader，只有leader才能执行的业务逻辑立即开始&quot;</span>, processIndentify)<br>                <span class="hljs-comment">// 在这里写入选主成功的代码，</span><br>                <span class="hljs-comment">// 就像抢分布式锁一样，当前进程选举成功的时候，这的代码就会被执行，</span><br>                <span class="hljs-comment">// 所以，在这里填写抢锁成功的业务逻辑吧，本例中就是监听service变化，然后修改pod的label</span><br>                CreateAndStartController(ctx, clientset, &amp;v1.Service&#123;&#125;, <span class="hljs-string">&quot;services&quot;</span>, NAMESPACE, stop)<br>            &#125;,<br>            OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-comment">// 失去了leader时的逻辑</span><br>                klog.Infof(<span class="hljs-string">&quot;[%s]失去leader身份，不再是leader了&quot;</span>, processIndentify)<br>                os.Exit(<span class="hljs-number">0</span>)<br>            &#125;,<br>            OnNewLeader: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span> &#123;<br>                <span class="hljs-comment">// 收到通知，知道最终的选举结果</span><br>                <span class="hljs-keyword">if</span> identity == processIndentify &#123;<br>                    klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，当前进程就是leader&quot;</span>, processIndentify)<br>                    <span class="hljs-comment">// I just got the lock</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，leader是 : [%s]&quot;</span>, processIndentify, identity)<br>            &#125;,<br>        &#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>•上述代码中，请注意LeaderElectionConfig对象的几个重要字段，例如LeaseDuration、RenewDeadline、RetryPeriod这些，是和选主时候的续租、超时、重试相关，需要按照您的实际网络情况进行调整•现在代码写完了，可以开始验证了</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>•这里捋一下验证的步骤</p><p>1.构建项目，生产二进制文件2.执行此二进制文件，启动三个进程3.观察日志，应该有一个进程选举成功，另外两个只会在日志输出选主结果4.修改service资源，再去观察日志，发现leader进程会输出日志，再检查pod的label，发现已经修改5.用ctrl+C命令将leader进程退出，可见另外两个进程会有一个成为新的leader6.再次修改service资源，新的leader会负责更新pod的label</p><p>•接下来开始操作</p><p>1.执行命令go build，对当前工程进行编译构建，得到二进制文件leader-tutorials2.打开三个终端窗口，输入同样的命令.&#x2F;leader-tutorials，选主成功的进程日志如下，之前操作过的残留，所以没有一开始就选主成功，而是等了几秒后才成为leader，一旦成为leader，全量同步service会触发一次pod的更新操作</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/cf656b2b31af8deecf6f3006945138e9.png" alt="Image 44: 在这里插入图片描述"></p><p>•再去看另外两个进程的日志，可见已经识别到leader的身份，于是就没有执行controller的逻辑</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/aca4a7a4b411ea9367898a8bf8243fe0.png" alt="Image 45: 在这里插入图片描述"></p><p>•现在去修改service，用命令kubectl edit service nginx-service -n client-go-tutorials编辑，我这里是给service增加了一个label，如下图所示<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/baf02a2ee6822724c9eef9c0afad8fc9.png" alt="Image 46: 在这里插入图片描述"></p><p>•此刻，leader进程会监听到service变化，下图黄色箭头以下的内容就是处理pod的日志<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/c9616846888ce5759fb84403e098f77f.png" alt="Image 47: 在这里插入图片描述"></p><p>•去看另外两个进程的日志，不会有任何变化，因为controller都没有•执行以下命令查看pod的修改情况(注意pod的名字要从您自己的环境复制)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl describe pod nginx-deployment-78f6b696d9-cr47w -n client-go-tutorials<br></code></pre></td></tr></table></figure><p>•可以看到pod的label有变化，如下图黄色箭头所示，这和上面的leader日志的时间是一致的</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/818ef75c8437ca25ac96894630b5b080.png" alt="Image 48: 在这里插入图片描述"></p><p>•目前leader进程工作正常，再来试试leader进程退出后的情况，用ctrl+C终止leader进程•再去看另外两个进程的日志，发现其中一个成功成为新的leader<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/56e49cc164c374ce25a764dc04a04f50.png" alt="Image 49: 在这里插入图片描述"></p><p>•验证完成，都符合预期•至此，client-go的选主功能实战就完成了，如果您在寻找kubernetes原生的分布式锁方案，希望本篇能给您一些参考</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s-选主</title>
    <link href="/2025/03/27/k8s-%E9%80%89%E4%B8%BB/"/>
    <url>/2025/03/27/k8s-%E9%80%89%E4%B8%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s-选主"><a href="#k8s-选主" class="headerlink" title="k8s-选主"></a>k8s-选主</h1><p>选主是为了在多副本的情况下，避免同一个操作被所有副本分别执行一次（实际只需要执行一次）。</p><p>所以将只需要执行一次的逻辑封装进一个函数，在执行这个函数之前，先进行选主，只有成为leader的副本才会执行该函数。</p><p>实际应用中，可以将自定义的controller逻辑封装起来，只在选主成功的副本里运行controller。其余的副本什么也不做，只是待命而已。这样在leader挂了之后，能快速的切换leader，保证业务逻辑快速恢复。</p><p>转自：<a href="https://qiankunli.github.io/2021/01/13/kubernetes_leader_election.html">https://qiankunli.github.io/2021/01/13/kubernetes_leader_election.html</a></p><p>假设run 是真正的业务逻辑，加入选主逻辑之后，将run挂在 <code>election.RunOrDie</code> 的 OnStartedLeading 回调上。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts">election.RunOrDie(election.LeaderElectionConfig<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">Lock:</span>          rl,<br><span class="hljs-symbol">LeaseDuration:</span> leaseDuration,<br><span class="hljs-symbol">RenewDeadline:</span> renewDuration,<br><span class="hljs-symbol">RetryPeriod:</span>   retryPeriod,<br><span class="hljs-symbol">Callbacks:</span> election.LeaderCallbacks<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">OnStartedLeading:</span> run,<span class="hljs-comment">// 业务逻辑</span><br><span class="hljs-symbol">OnStoppedLeading:</span> func() <span class="hljs-punctuation">&#123;</span><br>log.Fatalf(<span class="hljs-string">&quot;leader election lost&quot;</span>)<br><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;</span>)<br><span class="hljs-comment">// 笔者觉得应该函数封装下，直接 election.RunOrDie(rl,leaseDuration,renewDuration,retryPeriod,run)</span><br></code></pre></td></tr></table></figure><h2 id="选主原理"><a href="#选主原理" class="headerlink" title="选主原理"></a>选主原理</h2><p><strong>leaderelection 主要是利用了k8s API操作的原子性实现了一个分布式锁</strong>，在不断的竞争中进行选举。选中为leader的实体才会执行具体的业务代码。</p><p>代码结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">k8s.io/client-<span class="hljs-keyword">go</span>/tools/leaderelection<br>    /resourcelock<br>        /configmaplock.<span class="hljs-keyword">go</span><br>        /endpointslock.<span class="hljs-keyword">go</span><br>        /<span class="hljs-keyword">interface</span>.<span class="hljs-keyword">go</span>  <span class="hljs-comment">// 定义了锁的操作接口</span><br>        /leaselock.<span class="hljs-keyword">go</span><br>    /leaderelection.<span class="hljs-keyword">go</span><br>    /metrics.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB/leader_election.png" alt="img"></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><a href="http://www.xuyasong.com/?p=2037">K8S 中 scheduler 组件的选主逻辑</a>锁的存在形式：configmap&#x2F;endpoint 的annotation 上，key &#x3D; <code>control-plane.alpha.kubernetes.io/leader</code>， 值对应了 LeaderElectionRecord struct，记录了当前leader 的Identity 以及renewTime</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Endpoints<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">annotations</span>:<br>    <span class="hljs-attribute">control</span>-plane.alpha.kubernetes.io/leader: &#x27;&#123;<span class="hljs-string">&quot;holderIdentity&quot;</span>:<span class="hljs-string">&quot;instance-o24xykos-3_1ad55d32-2abe-49f7-9d68-33ec5eadb906&quot;</span>,<span class="hljs-string">&quot;leaseDurationSeconds&quot;</span>:<span class="hljs-number">15</span>,<span class="hljs-string">&quot;acquireTime&quot;</span>:<span class="hljs-string">&quot;2020-04-23T06:45:07Z&quot;</span>,<span class="hljs-string">&quot;renewTime&quot;</span>:<span class="hljs-string">&quot;2020-04-25T07:55:58Z&quot;</span>,<span class="hljs-string">&quot;leaderTransitions&quot;</span>:<span class="hljs-number">1</span>&#125;&#x27;<br>  <span class="hljs-attribute">creationTimestamp</span>: <span class="hljs-string">&quot;2020-04-22T12:05:29Z&quot;</span><br>  <span class="hljs-attribute">name</span>: kube-scheduler<br>  <span class="hljs-attribute">namespace</span>: kube-system<br>  <span class="hljs-attribute">resourceVersion</span>: <span class="hljs-string">&quot;467853&quot;</span><br>  <span class="hljs-attribute">selfLink</span>: /api/v1/namespaces/kube-system/endpoints/kube-scheduler<br>  <span class="hljs-attribute">uid</span>: f3535807-<span class="hljs-number">0575</span>-<span class="hljs-number">483</span>f-<span class="hljs-number">8471</span>-f8d4fd9eeac6<br></code></pre></td></tr></table></figure><p>“锁”即annotation value 记录了 leader 的一些信息</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&#123;<br>    &quot;holderIdentity&quot;: &quot;instance-o24xykos<span class="hljs-string">-3</span>_1ad55d32<span class="hljs-string">-2</span>abe<span class="hljs-string">-49</span>f7<span class="hljs-string">-9</span>d68<span class="hljs-string">-33</span>ec5eadb906&quot;, <br>    &quot;leaseDurationSeconds&quot;: 15, <br>    &quot;acquireTime&quot;: &quot;2020<span class="hljs-string">-04</span><span class="hljs-string">-23</span>T06:45:07Z&quot;, <br>    &quot;renewTime&quot;: &quot;2020<span class="hljs-string">-04</span><span class="hljs-string">-25</span>T07:55:58Z&quot;, <br>    &quot;leaderTransitions&quot;: 1<br>&#125;<br></code></pre></td></tr></table></figure><p>代码体现</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elm">// k8s.io/client-go/tools/leaderelection/resourcelock/interface.go<br><span class="hljs-keyword">type</span> <span class="hljs-type">Interface</span> interface &#123;<br>// <span class="hljs-type">Get</span> returns the <span class="hljs-type">LeaderElectionRecord</span><br><span class="hljs-type">Get</span>() (*<span class="hljs-type">LeaderElectionRecord</span>, error)<br>// <span class="hljs-type">Create</span> attempts to create a <span class="hljs-type">LeaderElectionRecord</span><br><span class="hljs-type">Create</span>(ler <span class="hljs-type">LeaderElectionRecord</span>) error<br>// <span class="hljs-type">Update</span> will update and existing <span class="hljs-type">LeaderElectionRecord</span><br>    <span class="hljs-type">Update</span>(ler <span class="hljs-type">LeaderElectionRecord</span>) error<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>kubernetes 的 update 是原子的、安全的</strong>：Kubernetes 通过定义资源版本字段实现了乐观并发控制，资源版本 (ResourceVersion)字段包含在 Kubernetes 对象的元数据 (Metadata)中。这个字符串格式的字段标识了对象的内部版本号，其取值来自 etcd 的 modifiedindex，且当对象被修改时，该字段将随之被修改。值得注意的是该字段由服务端维护</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> ObjectMeta <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a   resource or set of resources.Clients must treat these values as opaque and passed unmodified   back to the server.They may only be valid for a particular resource or set of resources.</span><br>    <span class="hljs-comment">// Populated by the system.Read-only.</span><br>    ResourceVersion <span class="hljs-keyword">string</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>所谓的选主，就是看哪个follower能将自己的信息更新到 object 的annotation 上</strong>。</p><h3 id="选主逻辑"><a href="#选主逻辑" class="headerlink" title="选主逻辑"></a>选主逻辑</h3><ol><li>leader 每隔RetryPeriod时间会通过tryAcquireOrRenew续约, 如果续约失败, 还会进行再次尝试. 一直到尝试的总时间超过RenewDeadline后该client就会失去leadership.</li><li>follower 获得leadership需要的等待LeaseDuration 时间.</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// client-go/tools/leaderelection/leaderelection.go</span><br>func <span class="hljs-built_in">RunOrDie</span>(ctx context<span class="hljs-selector-class">.Context</span>, lec LeaderElectionConfig) &#123;<br>le, err := <span class="hljs-built_in">NewLeaderElector</span>(lec)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">if</span> lec<span class="hljs-selector-class">.WatchDog</span> != nil &#123;<br>lec<span class="hljs-selector-class">.WatchDog</span><span class="hljs-selector-class">.SetLeaderElection</span>(le)<br>&#125;<br>le<span class="hljs-selector-class">.Run</span>(ctx)<br>&#125;<br><span class="hljs-comment">// 等待，直到ctx 取消/成为leader再失去leader 后返回</span><br>func (le *LeaderElector) <span class="hljs-built_in">Run</span>(ctx context.Context) &#123;<br>defer <span class="hljs-built_in">func</span>() &#123;<br>runtime<span class="hljs-selector-class">.HandleCrash</span>()<br>le<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.Callbacks</span><span class="hljs-selector-class">.OnStoppedLeading</span>()<br>    &#125;()<br>    <span class="hljs-comment">// 等待，除非成为leader（返回true） 或者ctx 取消（返回false）</span><br><span class="hljs-keyword">if</span> !le<span class="hljs-selector-class">.acquire</span>(ctx) &#123;<br>return <br>&#125;<br>ctx, cancel := context<span class="hljs-selector-class">.WithCancel</span>(ctx)<br>defer <span class="hljs-built_in">cancel</span>()<br>    go le<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.Callbacks</span><span class="hljs-selector-class">.OnStartedLeading</span>(ctx)<span class="hljs-comment">// 执行业务方法</span><br>    <span class="hljs-comment">// 成为leader后周期性续期，如果ctx 取消或失去leader 则立即返回</span><br>le<span class="hljs-selector-class">.renew</span>(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>选主核心逻辑</p><ol><li>没有lock，抢占&#x2F;Create</li><li>已有lock，但是别人的，租约没过期则退出 再试，过期则抢占&#x2F;Update</li><li>已有lock，自己的，续期&#x2F;Update</li></ol><p>函数返回 True 说明本 goroutine 已成功抢占到锁，获得租约合同，成为 leader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> tryAcquireOrRenew() <span class="hljs-type">bool</span> &#123;<br>now := metav1.Now()<br>leaderElectionRecord := rl.LeaderElectionRecord&#123;...&#125;<br><span class="hljs-comment">// 1. obtain or create the ElectionRecord</span><br>oldLeaderElectionRecord, err := le.config.Lock.Get()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 获取锁信息失败则直接返回</span><br><span class="hljs-keyword">if</span> !errors.IsNotFound(err) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        <span class="hljs-comment">// 锁不存在则创建，创建失败则返回</span><br><span class="hljs-keyword">if</span> err = le.config.Lock.Create(leaderElectionRecord); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        <span class="hljs-comment">// 创建lock成功 即第一次选主抢占leader 成功，则返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">// 2. Record obtained, check the Identity &amp; Time</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(oldLeaderElectionRecord.HolderIdentity) &gt; <span class="hljs-number">0</span> &amp;&amp; le.observedTime.Add(le.config.LeaseDuration).After(now.Time) &amp;&amp;!le.IsLeader() &#123; <span class="hljs-comment">// 其他leader 未过期</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 3. We&#x27;re going to try to update. The leaderElectionRecord is set to it&#x27;s default</span><br><span class="hljs-comment">// here. Let&#x27;s correct it before updating.</span><br><span class="hljs-keyword">if</span> le.IsLeader() &#123;<br>leaderElectionRecord.AcquireTime = oldLeaderElectionRecord.AcquireTime<br>leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-comment">// update the lock itself</span><br><span class="hljs-keyword">if</span> err = le.config.Lock.Update(leaderElectionRecord); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过LeaderCallbacks 感知leader 状态变化。回调OnStartedLeading 和 OnNewLeader 都会另起协程执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LeaderCallbacks <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// OnStartedLeading is called when a LeaderElector client starts leading</span><br>    <span class="hljs-comment">// 当选主逻辑退出时，会通过 context 传给OnStartedLeading</span><br>OnStartedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context.Context)</span></span><br><span class="hljs-comment">// OnStoppedLeading is called when a LeaderElector client stops leading</span><br>OnStoppedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// OnNewLeader is called when the client observes a leader that is not the previously observed leader. This includes the first observed leader when the client starts.</span><br>OnNewLeader <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>k8s scheduler 调度器的执行入口是 <code>sched.Run</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// k8s.io/kubernetes/cmd/kube-scheduler/app/server.go</span><br>func <span class="hljs-keyword">Run</span>(ctx context.Context, <span class="hljs-keyword">cc</span> schedulerserverconfig.CompletedConfig, outOfTreeRegistryOptions ...Option) <span class="hljs-keyword">error</span> &#123;<br>    ...<br>    <span class="hljs-comment">// If leader election is enabled, runCommand via LeaderElector until done and exit.</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">cc</span>.LeaderElection != nil &#123;<br>        <span class="hljs-keyword">cc</span>.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: sched.<span class="hljs-keyword">Run</span>,    <span class="hljs-comment">// 本节点成为leader时运行</span><br>            OnStoppedLeading: func() &#123;<br>                klog.Fatalf(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>            &#125;,<br>        &#125;<br>        leaderElector, <span class="hljs-keyword">err</span> := leaderelection.NewLeaderElector(*<span class="hljs-keyword">cc</span>.LeaderElection)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;couldn&#x27;t create leader elector: %v&quot;</span>, <span class="hljs-keyword">err</span>)<br>        &#125;<br>        leaderElector.<span class="hljs-keyword">Run</span>(ctx)<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;lost lease&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 如果未开启选主</span><br>    sched.<span class="hljs-keyword">Run</span>(ctx)<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;finished without leader elect&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>k8s controller-manager 的选主逻辑</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span><br>func <span class="hljs-built_in">Run</span>(c *config<span class="hljs-selector-class">.CompletedConfig</span>, stopCh &lt;-chan struct&#123;&#125;) error &#123;<br>    ...<br>    run := <span class="hljs-built_in">func</span>(ctx context.Context) &#123;<br>        ...<br>    &#125;<br>    ...<br>    rl, err := resourcelock<span class="hljs-selector-class">.New</span>(c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.ResourceLock</span>,...)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>klog<span class="hljs-selector-class">.Fatalf</span>(<span class="hljs-string">&quot;error creating lock: %v&quot;</span>, err)<br>    &#125;<br>    leaderelection<span class="hljs-selector-class">.RunOrDie</span>(context<span class="hljs-selector-class">.TODO</span>(), leaderelection.LeaderElectionConfig&#123;<br>Lock:          rl,<br>LeaseDuration: c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.LeaseDuration</span><span class="hljs-selector-class">.Duration</span>,<br>RenewDeadline: c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.RenewDeadline</span><span class="hljs-selector-class">.Duration</span>,<br>RetryPeriod:   c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.RetryPeriod</span><span class="hljs-selector-class">.Duration</span>,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: run,<br>OnStoppedLeading: <span class="hljs-built_in">func</span>() &#123;<br>klog<span class="hljs-selector-class">.Fatalf</span>(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>&#125;,<br>&#125;,<br>WatchDog: electionChecker,<br>Name:     <span class="hljs-string">&quot;kube-controller-manager&quot;</span>,<br>    &#125;)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>controller-runtime 是k8s 为支持自定义Controller 写的公共库，入口代码即为<code>Controller.Start</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cm *controllerManager)</span></span> Start(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 启动不用选主的任务</span><br>    <span class="hljs-keyword">go</span> cm.startNonLeaderElectionRunnables()<br><span class="hljs-keyword">if</span> cm.resourceLock != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果resourceLock 不为空， 表示需要选主，启动选主逻辑</span><br>err := cm.startLeaderElection()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<br>&#125; <br>    ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cm *controllerManager)</span></span> startLeaderElection() (err <span class="hljs-type">error</span>) &#123;<br>l, err := leaderelection.NewLeaderElector(leaderelection.LeaderElectionConfig&#123;<br>Lock:          cm.resourceLock,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ context.Context)</span></span> &#123;<br>cm.startLeaderElectionRunnables()   <span class="hljs-comment">// 启动需要选主的任务</span><br>&#125;,<br>OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>cm.errSignal.SignalError(fmt.Errorf(<span class="hljs-string">&quot;leader election lost&quot;</span>))<br>&#125;,<br>&#125;,<br>&#125;)<br>ctx, cancel := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-cm.internalStop:<br>cancel()<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>&#125;<br>&#125;()<br><span class="hljs-comment">// Start the leader elector process</span><br><span class="hljs-keyword">go</span> l.Run(ctx)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从示例中可以看到</p><ol><li>选主一般是一次性的，成为leader 后即执行核心业务逻辑，或者说业务逻辑由OnStartedLeading 触发。</li><li>如果成为leader 后失去leader，则主协程执行结束。</li></ol><p>scheduler 和 controller-manager 部署在容器中，所以主协程执行结束后，一般会自动重启。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang实现生产者消费者模型</title>
    <link href="/2025/03/25/golang%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/25/golang%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="golang实现生产者消费者模型"><a href="#golang实现生产者消费者模型" class="headerlink" title="golang实现生产者消费者模型"></a>golang实现生产者消费者模型</h1><p>使用context实现优雅退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">int</span>, jobs <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">500</span>)) * time.Millisecond)<br>job := id*<span class="hljs-number">100</span> + i<br>jobs &lt;- job<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d produced job %d\n&quot;</span>, id, job)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> job, ok := &lt;-jobs:<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d: channel closed\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br>&#125;<br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1000</span>)) * time.Millisecond)<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d processed job %d\n&quot;</span>, id, job)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rand.Seed(time.Now().UnixNano())<br><br><span class="hljs-keyword">const</span> numProducers = <span class="hljs-number">3</span><br><span class="hljs-keyword">const</span> numConsumers = <span class="hljs-number">2</span><br><br>jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>ctx, cancel := context.WithCancel(context.Background())<br><br><span class="hljs-comment">// 启动生产者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= numProducers; i++ &#123;<br><span class="hljs-keyword">go</span> producer(ctx, i, jobs)<br>&#125;<br><br><span class="hljs-comment">// 启动消费者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= numConsumers; i++ &#123;<br><span class="hljs-keyword">go</span> consumer(ctx, i, jobs)<br>&#125;<br><br><span class="hljs-comment">// 运行一段时间后停止</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;Stopping producers and consumers...&quot;</span>)<br>cancel() <span class="hljs-comment">// 发送停止信号</span><br><span class="hljs-built_in">close</span>(jobs) <span class="hljs-comment">// 关闭channel</span><br><br><span class="hljs-comment">// 等待一段时间让goroutine退出</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;All done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang GC</title>
    <link href="/2025/03/25/Golang-GC/"/>
    <url>/2025/03/25/Golang-GC/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GC"><a href="#Golang-GC" class="headerlink" title="Golang GC"></a>Golang GC</h1><p>转自: <a href="https://www.yuque.com/aceld/golang/zhzanb">https://www.yuque.com/aceld/golang/zhzanb</a></p><p>本节为重点章节</p><p><img src="/2025/03/25/Golang-GC/1650786480776-52768cf0-0457-4875-a390-543ed516861f.webp" alt="Image 1: 标题.jpeg"></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV1wz4y1y7Kd">https://www.bilibili.com/video/BV1wz4y1y7Kd</a></p><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><p>Golang在GC的演进过程中也经历了很多次变革，本文将按照一下顺序介绍：</p><ul><li>Go V1.3之前的标记-清除(mark and sweep)算法，缺点</li><li>Go V1.5的三色并发标记法</li><li>Go V1.5的三色标记为什么需要STW</li></ul><p>●Go V1.5的三色并发标记法<br>●Go V1.5的三色标记为什么需要STW<br>●Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )<br>●Go V1.8混合写屏障机制<br>●Go V1.8混合写屏障机制的全场景分析</p><h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>接下来我们来看一下在Golang1.3之前的时候主要用的普通的标记-清除算法，此算法主要有两个主要的步骤：</p><p>●标记(Mark phase)<br>●清除(Sweep phase)</p><p>1 标记清除算法的具体步骤</p><p>第一步，暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。</p><p><img src="/2025/03/25/Golang-GC/1650787873045-d038fe47-4898-4b07-9e16-007bebb6fb9c.webp" alt="Image 2: 44-GC1.png"></p><p>图中表示是程序与对象的可达关系，目前程序的可达对象有对象1-2-3，对象4-7等五个对象。</p><p>第二步, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p><p><img src="/2025/03/25/Golang-GC/1650787891194-883ec541-5f13-4934-9274-080e5f44cf5e.webp" alt="Image 3: 42-GC2.png"></p><p>所以对象1-2-3、对象4-7等五个对象被做上标记。</p><p>第三步,  标记完了之后，然后开始清除未标记的对象. 结果如下。</p><p><img src="/2025/03/25/Golang-GC/1650787913616-ecf21ee2-c247-4401-9d3e-5e2fa278726f.webp" alt="Image 4: 45-GC3.png"></p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。</p><p>第四步, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p><p>以上便是标记-清除（mark and sweep）回收的算法。</p><h2 id="二、-标记-清除-mark-and-sweep-的缺点"><a href="#二、-标记-清除-mark-and-sweep-的缺点" class="headerlink" title="二、 标记-清除(mark and sweep)的缺点"></a>二、 标记-清除(mark and sweep)的缺点</h2><p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。</p><p>●STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)；<br>●标记需要扫描整个heap；<br>●清除数据会产生heap碎片。</p><p>Go V1.3版本之前就是以上来实施的,  在执行GC的基本流程就是首先启动STW暂停，然后执行标记，再执行数据回收，最后停止STW，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1650787936233-9002040d-220b-4af6-8e51-75d7887569b4.webp" alt="Image 5: 53-STW1.png"></p><p>从上图来看，全部的GC时间都是包裹在STW范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围.如下所示</p><p><img src="/2025/03/25/Golang-GC/1650788071197-26a29703-0fb5-43f4-afc5-87a35fc78a4b.webp" alt="Image 6: 54-STW2.png"></p><p>上图主要是将STW的步骤提前了一步，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。</p><p>但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。</p><p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用三色并发标记法来优化这个问题.</p><h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，所谓三色标记法实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？我们来看一下具体的过程。</p><p>第一步 , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035738281-051f7a89-e07f-418c-ad0e-7cb94ef1a3b8.webp" alt="Image 7: 46-GC4.png"></p><p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表，是用来记录目前每个对象的标记颜色分类。这里面需要注意的是，所谓“程序”，则是一些对象的根节点集合。所以我们如果将“程序”展开，会得到类似如下的表现形式，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035821416-b0ad644e-ef8e-440a-bbf4-b9e24a7e0257.webp" alt="Image 8: 47-GC5.jpeg"></p><p>第二步, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035842467-7341846f-6dee-4f8b-ad37-dc9723aa6407.webp" alt="Image 9: 48-GC6.jpeg"></p><p>这里 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p><p>第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035859950-96053775-24f7-4bdc-a1fb-295747055b3e.webp" alt="Image 10: 49-GC7.jpeg"></p><p>这一次遍历是只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7. 而之前的灰色对象1和对象4则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p><p>第四步, 重复第三步, 直到灰色中无任何对象，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035907012-927d6cbc-686b-4f81-a1de-097ac7598a8e.webp" alt="Image 11: 50-GC8.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651035916208-9c293dc0-8988-4180-a9b7-412e2599af0e.webp" alt="Image 12: 51-GC9.jpeg"></p><p>当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p><p>第五步: 回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。 以上我们将全部的白色对象进行删除回收，</p><p><img src="/2025/03/25/Golang-GC/1651035960263-e50436a6-4a3c-48f9-82cb-bb5729d71116.webp" alt="Image 13: 52-GC10.jpeg"></p><p>剩下的就是全部依赖的黑色对象。</p><p>以上便是三色并发标记法，不难看出，我们上面已经清楚的体现三色的特性。但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。</p><p>那么Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p><h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？ 我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?</p><p>我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035994109-83972e84-be65-4950-b9bf-a48b676856a5.webp" alt="Image 14: 55-三色标记问题1.jpeg"></p><p>现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。</p><p><img src="/2025/03/25/Golang-GC/1651036029588-29e317e6-8f92-41ca-a28e-65153913d227.webp" alt="Image 15: 56-三色标记问题2.jpeg"></p><p>与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036292354-f70d8185-66a2-4478-9036-b4de940285c5.webp" alt="Image 16: 57-三色标记问题3.jpeg"></p><p>然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036347628-d63c17c4-7cee-4149-8ce9-13cc11bbd343.webp" alt="Image 17: 58-三色标记问题4.jpeg"></p><p>那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036362636-5a98e196-e1cd-49fc-9542-1cb0772a41c4.webp" alt="Image 18: 59-三色标记问题5.jpeg"></p><p>但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。</p><p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p><p>●条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)<br>●条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色) 如果当以上两个条件同时满足时，就会出现对象丢失现象!</p><p>并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。</p><p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p><h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。  这两种方式就是“强三色不变式”和“弱三色不变式”。</p><p>(1) “强-弱” 三色不变式</p><p>●强三色不变式</p><p>不存在黑色对象引用到白色对象的指针。</p><p><img src="/2025/03/25/Golang-GC/1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654.webp" alt="Image 19: 60-三色标记问题6.jpeg"></p><p>强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><p>●弱三色不变式</p><p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p><p><img src="/2025/03/25/Golang-GC/1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed.webp" alt="Image 20: 61-三色标记问题7.jpeg"></p><p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</p><p>(2)  插入屏障</p><p>具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p><p>满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p>伪码如下:</p><p>场景：</p><p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, 栈和堆. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中.</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="/2025/03/25/Golang-GC/1651036442131-91f36e55-5c94-4931-a140-58ff5627c681.webp" alt="Image 21: 62-三色标记插入写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4.webp" alt="Image 22: 63-三色标记插入写屏障2.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d.webp" alt="Image 23: 64-三色标记插入写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036465710-e260440e-b53d-4f76-a826-842e28666efe.webp" alt="Image 24: 65-三色标记插入写屏障4.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036474130-755abe1f-d070-47e6-93cf-7aa129489206.webp" alt="Image 25: 66-三色标记插入写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982.webp" alt="Image 26: 67-三色标记插入写屏障6.jpeg"></p><p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9).  所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p><p><img src="/2025/03/25/Golang-GC/1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431.webp" alt="Image 27: 68-三色标记插入写屏障7.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8.webp" alt="Image 28: 69-三色标记插入写屏障9.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9.webp" alt="Image 29: 70-三色标记插入写屏障10.jpeg"></p><p>最后将栈和堆空间 扫描剩余的全部 白色节点清除.  这次STW大约的时间在10~100ms间.</p><p><img src="/2025/03/25/Golang-GC/1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b.webp" alt="Image 30: 71-三色标记插入写屏障11.jpeg"></p><p>(3)  删除屏障</p><p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p><p>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p><p>伪代码：</p><p>场景：</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="/2025/03/25/Golang-GC/1651036621717-80ea507c-99a9-4e61-9bde-b4cd33f478f4.webp" alt="Image 31: 72-三色标记删除写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036629775-bc69d08e-c270-46ad-b82b-5ad0d0bdcb64.webp" alt="Image 32: 73-三色标记删除写屏障2.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036637089-52a0fc99-7805-40d0-aee7-4124017e90c8.webp" alt="Image 33: 74-三色标记删除写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036644794-05a69ec6-70c9-44c7-9493-44028ba4df7f.webp" alt="Image 34: 75-三色标记删除写屏障4.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036653171-57e34942-2091-4d76-83f3-0b084ebd577d.webp" alt="Image 35: 76-三色标记删除写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036660503-4f49f494-8ede-45dd-8a4c-bfa5499b307a.webp" alt="Image 36: 77-三色标记删除写屏障6.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036668136-8592bd0f-2210-48d9-b43d-7c4a2e16a287.webp" alt="Image 37: 78-三色标记删除写屏障7.jpeg"></p><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p><p>● 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；● 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。<br>(1) 混合写屏障规则</p><p>具体操作:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p>满足: 变形的弱三色不变式.</p><p>伪代码：</p><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p><p>(2) 混合写屏障的具体场景分析</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p><p>GC开始：扫描栈区，将可达对象全部标记为黑</p><p><img src="/2025/03/25/Golang-GC/1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62.webp" alt="Image 38: 79-三色标记混合写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791.webp" alt="Image 39: 80-三色标记混合写屏障2.jpeg"></p><p>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c.webp" alt="Image 40: 81-三色标记混合写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac.webp" alt="Image 41: 82-三色标记混合写屏障4.jpeg"></p><p>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6.webp" alt="Image 42: 83-三色标记混合写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036785024-0edb665e-7b4b-46e3-b8cf-1d4ff02e73cd.webp" alt="Image 43: 84-三色标记混合写屏障6.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c.webp" alt="Image 44: 85-三色标记混合写屏障7.jpeg"></p><p>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a.webp" alt="Image 45: 86-三色标记混合写屏障8.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036833484-a18064d9-1329-42d7-8687-8a029542e85e.webp" alt="Image 46: 87-三色标记混合写屏障9.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4.webp" alt="Image 47: 88-三色标记混合写屏障10.jpeg"></p><p>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814.webp" alt="Image 48: 89-三色标记混合写屏障11.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62.webp" alt="Image 49: 90-三色标记混合写屏障12.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c.webp" alt="Image 50: 91-三色标记混合写屏障13.jpeg"></p><p>Golang中的混合写屏障满足弱三色不变式，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>你觉得怎么样才是好产品</title>
    <link href="/2025/03/25/%E4%BD%A0%E8%A7%89%E5%BE%97%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E6%98%AF%E5%A5%BD%E4%BA%A7%E5%93%81/"/>
    <url>/2025/03/25/%E4%BD%A0%E8%A7%89%E5%BE%97%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E6%98%AF%E5%A5%BD%E4%BA%A7%E5%93%81/</url>
    
    <content type="html"><![CDATA[<h1 id="如何回答”你觉得怎么样才是好产品”的面试问题"><a href="#如何回答”你觉得怎么样才是好产品”的面试问题" class="headerlink" title="如何回答”你觉得怎么样才是好产品”的面试问题"></a>如何回答”你觉得怎么样才是好产品”的面试问题</h1><p>在程序员面试中被问到”你觉得怎么样才是好产品”时，这是一个展示你技术思维与产品思维结合能力的好机会。以下是一个结构化的回答框架：</p><h2 id="1-从用户角度出发"><a href="#1-从用户角度出发" class="headerlink" title="1. 从用户角度出发"></a>1. 从用户角度出发</h2><p>“我认为一个好产品首先要解决真实用户的痛点。它应该：</p><ul><li>满足目标用户的核心需求（刚需）</li><li>提供简单直观的用户体验</li><li>在使用过程中让用户感到愉悦而不是挫败</li></ul><p>比如Slack之所以成功，就是因为它解决了团队沟通中的信息碎片化问题，而且使用起来非常直观。”</p><h2 id="2-加入技术视角"><a href="#2-加入技术视角" class="headerlink" title="2. 加入技术视角"></a>2. 加入技术视角</h2><p>“从技术实现角度看，好产品还应该具备：</p><ul><li><strong>稳定性</strong>：少崩溃、少bug</li><li><strong>性能</strong>：响应快速，不卡顿</li><li><strong>可扩展性</strong>：能随着用户增长而扩展</li><li><strong>安全性</strong>：保护用户数据和隐私</li></ul><p>例如微信在保证海量用户同时在线时的稳定性表现就非常出色。”</p><h2 id="3-商业可持续性"><a href="#3-商业可持续性" class="headerlink" title="3. 商业可持续性"></a>3. 商业可持续性</h2><p>“好产品还需要具备商业可持续性：</p><ul><li>有清晰的盈利模式</li><li>用户获取成本(CA)低于用户生命周期价值(LTV)</li><li>能形成竞争壁垒</li></ul><p>像Notion通过免费增值模式(Freemium)既获得了大量用户，又实现了盈利。”</p><h2 id="4-数据驱动迭代"><a href="#4-数据驱动迭代" class="headerlink" title="4. 数据驱动迭代"></a>4. 数据驱动迭代</h2><p>“真正的好产品会：</p><ul><li>建立完善的数据指标体系</li><li>通过A&#x2F;B测试持续优化</li><li>根据用户反馈快速迭代</li></ul><p>比如抖音的推荐算法就是通过持续的数据分析和优化，才达到如此精准的个性化推荐。”</p><h2 id="5-结合应聘公司产品"><a href="#5-结合应聘公司产品" class="headerlink" title="5. 结合应聘公司产品"></a>5. 结合应聘公司产品</h2><p>“特别是对于贵公司的产品[XXX]，我认为它很好地体现了这些特质，比如…[具体举例]。如果我有机会加入，我希望能在[某个技术方面]做出贡献，帮助产品变得更好。”</p><h2 id="回答技巧"><a href="#回答技巧" class="headerlink" title="回答技巧"></a>回答技巧</h2><ol><li><strong>结构化表达</strong>：使用清晰的逻辑框架(如上述几点)</li><li><strong>举例说明</strong>：引用知名产品或该公司产品为例</li><li><strong>展现技术深度</strong>：作为程序员，要展示你从技术角度对产品的理解</li><li><strong>适度谦虚</strong>：”这是我目前的理解，当然好产品的标准可能还有很多…”</li><li><strong>关联岗位</strong>：最后可以关联到你应聘的岗位如何帮助打造好产品</li></ol><p>记住，面试官问这个问题不仅是考察你的产品思维，也在观察你的沟通表达能力和逻辑思维能力。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang GMP模型</title>
    <link href="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GMP模型"><a href="#Golang-GMP模型" class="headerlink" title="Golang GMP模型"></a>Golang GMP模型</h1><p>转自：<a href="https://www.yuque.com/aceld/golang/srxd6d">https://www.yuque.com/aceld/golang/srxd6d</a></p><p>本节为重点章节 本章节含视频版:</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650775952013-f19f9c96-b995-42d6-bc9c-8b1e73b602d8.webp" alt="Image 1: GPM封面.png"></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV19r4y1w7Nx">https://www.bilibili.com/video/BV19r4y1w7Nx</a></p><h2 id="一、Golang“调度器”的由来？"><a href="#一、Golang“调度器”的由来？" class="headerlink" title="一、Golang“调度器”的由来？"></a>一、Golang“调度器”的由来？</h2><h3 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代”</p><p>一切的程序只能串行发生。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776039816-a8a5efb6-06be-4984-bfb0-7565c14b0a61.webp" alt="Image 2: 5-单进程操作系统.png"></p><p>早期的单进程操作系统，面临2个问题：</p><p>1.单一的执行流程，计算机只能一个任务一个任务处理。</p><p>2.进程阻塞所带来的CPU时间浪费。</p><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p><h3 id="2-多进程-线程时代有了调度器需求"><a href="#2-多进程-线程时代有了调度器需求" class="headerlink" title="(2)多进程&#x2F;线程时代有了调度器需求"></a>(2)多进程&#x2F;线程时代有了调度器需求</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776059361-384f6fb5-e2b1-4f99-8701-f57694aa8ecb.webp" alt="Image 3: 6-多进程操作系统.png"></p><p>在多进程&#x2F;多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p><p>怎么才能提高CPU的利用率呢？</p><p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776077730-2a6860a3-0466-4df9-925d-9ecd5cb9ad7d.webp" alt="Image 4: 7-cpu切换浪费成本.png"></p><p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p><h3 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3) 协程来提高CPU利用率"></a>(3) 协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。</p><p>大量的进程&#x2F;线程出现了新的问题</p><p>●高内存占用<br>●调度的高消耗CPU</p><p>好了，然后工程师们就发现，其实一个线程分为<strong>“内核态“线程和”用户态“线程</strong>。</p><p><strong>一个“用户态线程”必须要绑定一个“内核态线程”</strong>，但是**CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)**。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776112186-eff4e8b8-8742-44cd-a828-db1653649ee7.webp" alt="Image 5: 8-线程的内核和用户态.png"></p><p>这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”.</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776128796-5b795bfb-3289-4f6b-85a0-f24399dfc79c.webp" alt="Image 6: 9-协程和线程.png"></p><p>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p><p>之后，我们就看到了有3中协程和线程的映射关系：</p><p>N:1关系</p><p>N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上</p><p>缺点：</p><p>●某个程序用不了硬件的多核加速能力<br>●一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776145617-04763b3d-1b15-42c7-9653-cde21bcc98bc.webp" alt="Image 7: 10-N-1关系.png"></p><p>1:1 关系</p><p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，</p><p>缺点：</p><p>●协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776180139-043037ed-cb5b-4c24-9fcf-691a05db17f9.webp" alt="Image 8: 11-1-1.png"></p><p>M:N关系</p><p>M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776193242-4fecd540-5cbb-4f2d-8121-5312dbc6958a.webp" alt="Image 9: 12-m-n.png"></p><p>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p><h3 id="4-Go语言的协程goroutine"><a href="#4-Go语言的协程goroutine" class="headerlink" title="(4) Go语言的协程goroutine"></a>(4) Go语言的协程goroutine</h3><p>Go为了提供更容易使用的并发方法，使用了goroutine和channel。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被runtime调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。</p><p>Goroutine特点：</p><p>●占用内存更小（几kb）<br>●调度更灵活(runtime调度)</p><h3 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5) 被废弃的goroutine调度器"></a>(5) 被废弃的goroutine调度器</h3><p>好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p><p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p><p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776259684-6015cb7b-b33e-47f9-b241-185c57dc2745.webp" alt="Image 10: 13-gm.png"></p><p>下面我们来看看被废弃的golang调度器是如何实现的？</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776272668-ac680807-d927-4c10-9e1d-3960bdabd0e3.webp" alt="Image 11: 14-old调度器.png"></p><p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局G队列是有互斥锁进行保护的。</p><p>老调度器有几个缺点：</p><ol><li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。</li><li>M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol><h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。</p><p>在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776288599-36c23cc6-3d25-4f6f-8f80-83bd43aa6dec.webp" alt="Image 12: 15-gmp.png"></p><p>Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p><h3 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1) GMP模型"></a>(1) GMP模型</h3><p>在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776301442-fb76123c-8d0e-4375-af35-b5728a5b1bc7.webp" alt="Image 13: 16-GMP-调度.png"></p><ol><li>全局队列（Global Queue）：存放等待运行的G。</li><li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li><li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol><p>Goroutine调度器和OS调度器是通过M结合起来的，<strong>每个M都代表了1个内核线程</strong>，OS调度器负责把内核线程分配到CPU的核上执行。</p><p>有关P和M的个数问题</p><p>1、P的数量：</p><p>●由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。</p><p>2、M的数量:</p><p>●go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。<br>●runtime&#x2F;debug中的SetMaxThreads函数，设置M的最大数量<br>●一个M阻塞了，会创建新的M。</p><p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p><p>P和M何时会被创建</p><p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p><p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p><h3 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2) 调度器的设计策略"></a>(2) 调度器的设计策略</h3><p>复用线程：避免频繁的创建、销毁线程，而是对线程的复用。</p><p>1）work stealing机制</p><p>当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p><p>2）hand off机制</p><p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p><p>利用并行：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS &#x3D; 核数&#x2F;2，则最多利用了一半的CPU核进行并行。</p><p>抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p><p>全局G队列：在新的调度器中依然有全局G队列，当P的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过work stealing机制从其他P的本地队列偷取G。</p><h3 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func()  调度流程"></a>(3) go func()  调度流程</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776333419-50d3a922-bd53-4bff-b0b6-280e6abc5d74.webp" alt="Image 14: 18-go-func调度周期.jpeg"></p><p>从上图我们可以分析出几个结论：</p><p>1、我们通过 go func()来创建一个goroutine；</p><p>2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p><p>3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p><p>4、一个M调度G执行的过程是一个循环机制；</p><p>5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在等待执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p><p>6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p><h3 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4) 调度器的生命周期"></a>(4) 调度器的生命周期</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776346389-ab0ffa04-c707-4ec8-a810-0929533fd00c.webp" alt="Image 15: 17-pic-go调度器生命周期.png"></p><p>特殊的M0和G0</p><p>M0</p><p>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p><p>G0</p><p>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p><p>我们来跟踪一段代码</p><p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p><p>也会经历如上图所示的过程：</p><ol><li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li><li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li><li>示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li><li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li><li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li><li>M运行G</li><li>G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</li></ol><p>调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。</p><h3 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5) 可视化GMP编程"></a>(5) 可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据。</p><p>方式1：go tool trace</p><p>trace记录了运行时的信息，能提供可视化的Web页面。</p><p>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p><p>trace.go</p><p>运行程序</p><p>会得到一个trace.out文件，然后我们可以用一个工具打开，来分析这个文件。</p><p>我们可以通过浏览器打开<a href="http://127.0.0.1:33479网址，点击view">http://127.0.0.1:33479网址，点击view</a> trace 能够看见可视化的调度流程。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776395564-f4f1ba06-1af0-4842-a241-8ea7e56b0612.webp" alt="Image 16: 19-go-trace1.png"></p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776402701-9db41a28-ffc9-4702-8cd1-6670f8cd0d28.webp" alt="Image 17: 20-go-trace2.png"></p><p>G信息</p><p>点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776424129-7608477e-4b67-40f3-8782-a0eb346ef8eb.webp" alt="Image 18: 20-go-trace3.png"></p><p>一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p><p>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p><p>M信息</p><p>点击Threads那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776444325-d259c370-0aa5-4650-a5fd-2449190c97a1.webp" alt="Image 19: 22-go-trace4.png"></p><p>一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。</p><p>P信息</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776459340-7053a162-0e39-4955-b0e6-d4714171be3a.webp" alt="Image 20: 23-go-trace5.png"></p><p>G1中调用了main.main，创建了trace goroutine g18。G1运行在P1上，G18运行在P0上。</p><p>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。</p><p>我们在来看看上面的M信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776484643-1c8841a4-01a1-4948-a8a7-616678fb5317.webp" alt="Image 21: 24-go-trace6.png"></p><p>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776494915-1d38f0bf-cbd8-4958-ae55-1144a86e50a2.webp" alt="Image 22: 25-go-trace7.png"></p><p>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p><p>方式2：Debug trace</p><p>编译</p><p>通过Debug方式运行</p><p>●SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；<br>●0ms：即从程序启动到输出这行日志的时间；<br>●gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；<br>●idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；<br>●threads: os threads&#x2F;M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；<br>●spinningthreads: 处于自旋状态的os thread数量；<br>●idlethread: 处于idle状态的os thread的数量；<br>●runqueue&#x3D;0： Scheduler全局队列中G的数量；<br>●[0 0]: 分别为2个P的local queue中的G的数量。</p><p>下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。</p><h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><p>(1)场景1</p><p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P的本地队列。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776522560-a33b69e2-2842-4132-8cbe-f2bad017bc7e.webp" alt="Image 23: 26-gmp场景1.png"></p><p>(2)场景2</p><p>G1运行完成后(函数：goexit)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：schedule）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了线程M1的复用。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776536644-c6fba007-d952-4a22-8939-ca1a898a5c3c.webp" alt="Image 24: 27-gmp场景2.png"></p><p>(3)场景3</p><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776549767-57ceac17-5504-46ac-af56-0dba59359e8b.webp" alt="Image 25: 28-gmp场景3.png"></p><p>(4)场景4</p><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列)</p><p>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776570176-d9d5abd4-3a48-461c-a43c-6ef504c4038f.webp" alt="Image 26: 29-gmp场景4.png"></p><p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。<br>(5)场景5</p><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776584395-dfb9c26b-b0a8-4c17-b46e-649302df87d5.webp" alt="Image 27: 30-gmp场景5.png"></p><p>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。<br>(6)场景6</p><p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776600276-58bdcec4-00e6-4f24-89c8-e4f01fd1d9fb.webp" alt="Image 28: 31-gmp场景6.png"></p><p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程（没有G但为运行状态的线程，不断寻找G）。<br>(7)场景7</p><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。M2从全局队列取的G数量符合下面的公式：</p><p>相关源码参考:</p><p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是从全局队列到P本地队列的负载均衡。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776688586-9207de08-5203-403f-8857-42942e84dcb1.webp" alt="Image 29: 32-gmp场景7.001.jpeg"></p><p>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。<br>(8)场景8</p><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777780659-cef000df-3d46-4fd5-b0ed-3dc466bf1cd2.webp" alt="Image 30: 33-gmp场景8.png"></p><p>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。<br>(9)场景9</p><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777794441-a7ed7fc2-e495-4022-a3b6-581930e5acd0.webp" alt="Image 31: 34-gmp场景9.png"></p><p>为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们希望当有新goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程(当前例子中的GOMAXPROCS&#x3D;4，所以一共4个P)，多余的没事做线程会让他们休眠。<br>(10)场景10</p><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;&#x3D;P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777810926-ca4030f3-f29a-4211-8722-677b229be440.webp" alt="Image 32: 35-gmp场景10.png"></p><p>(11)场景11</p><p>G8创建了G9，假如G8进行了非阻塞系统调用。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777823944-25f0ea1a-3431-457e-b4cf-342654a953b6.webp" alt="Image 33: 36-gmp场景11.png"></p><p>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go Map</title>
    <link href="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Map"><a href="#Go-Map" class="headerlink" title="Go Map"></a>Go Map</h1><p>map 是一种key-value的键值对存储结构，其中key不能重复，底层用<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=hash%E8%A1%A8&zhida_source=entity">hash表</a>存储。</p><p>平日里我们一般是这样使用map的：</p><blockquote><p>&#x2F;&#x2F; 创建<br>&#x2F;&#x2F; map[KeyType]ValueType<br>var m map[int]int<br>m :&#x3D; make(map[int]int)<br>m :&#x3D; map[int]int{<br>1: 1,<br>2: 2,<br>}<br>&#x2F;&#x2F; 读取<br>i :&#x3D; m[1]<br>v, ok :&#x3D; m[1]<br>​<br>&#x2F;&#x2F; 遍历<br>for key, value :&#x3D; range m {<br>println(“Key: “, key, “Value: “, value)<br>}<br>​<br>&#x2F;&#x2F; 删除<br>delete(m, 1)</p></blockquote><p>map的数据结构在源码结构中的关键字段如下，在<code>src/runtime/map.go</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    count     <span class="hljs-type">int</span>    <span class="hljs-comment">// 元素的个数</span><br>    B         <span class="hljs-type">uint8</span>  <span class="hljs-comment">// buckets 数组的长度就是 2^B 个</span><br>    overflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// 溢出桶的数量</span><br><br>    buckets    unsafe.Pointer <span class="hljs-comment">// 2^B个桶对应的数组指针</span><br>    oldbuckets unsafe.Pointer  <span class="hljs-comment">// 发生扩容时，记录扩容前的buckets数组指针</span><br><br>    extra *mapextra <span class="hljs-comment">//用于保存溢出桶的地址</span><br>&#125;<br><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>    overflow    *[]*bmap<br>    oldoverflow *[]*bmap<br><br>    nextOverflow *bmap<br>&#125;<br><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br><br><span class="hljs-comment">//在编译期间会产生新的结构体</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存储哈希值的高8位</span><br>    data    <span class="hljs-type">byte</span>[<span class="hljs-number">1</span>]  <span class="hljs-comment">//key value数据:key/key/key/.../value/value/value...</span><br>    overflow *bmap   <span class="hljs-comment">//溢出bucket的地址</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了便于理解源码的结构，我们提炼关键字段并转换为图形模式：</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-a8fbef952441e788d882d0656c2cf091_1440w.jpg" alt="img"></p><p>在go的map实现中，它的底层结构体是hmap，hmap里维护着若干个bucket数组 (即桶数组)。</p><p>Bucket数组中每个元素都是bmap结构，也即每个bucket（桶）都是bmap结构，【ps：后文为了语义一致，和方便理解，就不再提bmap了，统一叫作桶】 每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶(溢出桶)。</p><h2 id="map中数据操作"><a href="#map中数据操作" class="headerlink" title="map中数据操作"></a><strong>map中数据操作</strong></h2><p>了解了map的数据结构后，下面让我们学习一下在map中存取数据的过程：</p><h3 id="GET获取数据"><a href="#GET获取数据" class="headerlink" title="GET获取数据"></a><strong>GET获取数据</strong></h3><p><strong>假设当前 B&#x3D;4 即桶数量为2^B&#x3D;16个</strong>，要从map中获取k4对应的value</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>参考上图，k4的get流程可以归纳为如下几步：</strong></p><p>①<strong>计算k4的hash值</strong>。[由于当前主流机都是64位操作系统，所以计算结果有64个比特位]</p><p>②<strong>通过最后的“B”位来确定在哪号桶</strong>，此时B为4，所以取k4对应哈希值的后4位，也就是0101，0101用十进制表示为5，所以在5号桶）</p><p>③<strong>根据k4对应的hash值前8位快速确定是在这个桶的哪个位置</strong>（额外说明一下，在bmap中存放了每个key对应的tophash，是key的哈希值前8位),一旦发现前8位一致，则会执行下一步</p><p>④<strong>对比key完整的hash是否匹配</strong>，如果匹配则获取对应value</p><p>⑤<strong>如果都没有找到，就去连接的下一个溢出桶中找</strong></p><p>有很多同学会问这里为什么要多维护一个tophash，即hash前8位？</p><p>这是因为tophash可以快速确定key是否正确，也可以把它理解成一种缓存措施，如果前8位都不对了，后面就没有必要比较了。</p><h3 id="PUT存放数据"><a href="#PUT存放数据" class="headerlink" title="PUT存放数据"></a><strong>PUT存放数据</strong></h3><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>map的赋值流程可总结位如下几步：</strong></p><p>①<strong>通过key的hash值后“B”位确定是哪一个桶</strong>，图中示例为4号桶。</p><p>② 遍历当前桶，通过key的tophash和hash值，防止key重复，然后<strong>找到第一个可以插入的位置</strong>，即空位置处存储数据。</p><p>③如果<strong>当前桶元素已满，会通过overflow链接创建一个新的桶</strong>，来存储数据。</p><p><strong>关于hash冲突</strong>：当两个不同的 key 落在同一个桶中，就是发生了哈希冲突。冲突的解决手段是采用链表法：在 桶 中，从前往后找到第一个空位进行插入。如果8个kv满了，那么当前桶就会连接到下一个溢出桶（bmap）。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a><strong>扩容</strong></h3><h3 id="扩容的方式"><a href="#扩容的方式" class="headerlink" title="扩容的方式"></a><strong>扩容的方式</strong></h3><p>扩容有两种，一种是等量扩容，另一种是2倍扩容</p><ul><li><strong>相同容量扩容</strong></li></ul><p>由于map中不断的put和delete key，桶中可能会出现很多断断续续的空位，这些空位会导致连接的bmap溢出桶很长，导致扫描时间边长。这种扩容实际上是一种整理，把后置位的数据整理到前面。<strong>这种情况下，元素会发生重排，但不会换桶。</strong></p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-2ecbb8a8c52d395061f67e41620b1504_1440w.jpg" alt="img"></p><p>img</p><ul><li><strong>2倍容量扩容</strong></li></ul><p>这种2倍扩容是由于当前桶数组确实不够用了，<strong>发生这种扩容时，元素会重排，可能会发生桶迁移</strong>。</p><p>如图中所示，扩容前B&#x3D;2,扩容后B&#x3D;3，假设一元素key的hash值后三位为101，那么由上文的介绍可知，在扩容前，由hash值的后两位来决定几号桶，即 01 所以元素在1号桶。 在扩容发生后，由hash值得后三位来决定几号桶，即101所以元素会迁移到5号桶。</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-d38e6d960012d58d4192f904985a4ca1_1440w.jpg" alt="img"></p><p>img</p><h2 id="发生扩容的条件"><a href="#发生扩容的条件" class="headerlink" title="发生扩容的条件"></a><strong>发生扩容的条件</strong></h2><p>首先我们了解下**<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90&zhida_source=entity">装载因子</a>(loadFactor)**的概念</p><p>loadFactor:&#x3D;count &#x2F; (2^B) 即 装载因子 &#x3D; map中元素的个数 &#x2F; map中当前桶的个数</p><p>通过计算公式我们可以得知，<strong>装载因子是指当前map中，每个桶中的平均元素个数。</strong></p><p><strong>扩容条件1</strong>：<strong>装载因子 &gt; 6.5</strong> (源码中定义的)</p><p>这个也非常容易理解，正常情况下，如果没有溢出桶，那么一个桶中最多有8个元素，当平均每个桶中的数据超过了6.5个，那就意味着当前容量要不足了，发生扩容。</p><p><strong>扩容条件2</strong>: <strong>溢出桶的数量过多</strong></p><p>当 B &lt; 15 时，如果overflow的bucket数量超过 2^B。</p><p>当 B &gt;&#x3D; 15 时，overflow的bucket数量超过 2^15。</p><p>简单来讲，新加入key的hash值后B位都一样，使得个别桶一直在插入新数据，进而导致它的溢出桶链条越来越长。如此一来，当map在操作数据时，扫描速度就会变得很慢。及时的扩容，可以对这些元素进行重排，使元素在桶的位置更平均一些。</p><p><strong>扩容时的细节</strong></p><ol><li>在我们的hmap结构中有一个oldbuckets吗，扩容刚发生时，会先将老数据存到这个里面。</li><li>每次对map进行删改操作时，会触发从oldbucket中迁移到bucket的操作【非一次性，分多次】</li><li>在扩容没有完全迁移完成之前，每次get或者put遍历数据时，都会先遍历oldbuckets，然后再遍历buckets。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><p><strong>map是线程不安全的</strong></p><p>在同一时间点，两个 <a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=goroutine&zhida_source=entity">goroutine</a> 对同一个map进行读写操作是不安全的。举个栗子：</p><p>某map桶数量为4，即B&#x3D;2。此时 goroutine1来插入key1， goroutine2来读取 key2. 可能会发生如下过程：</p><p>① goroutine2 计算key2的hash值,B&#x3D;2，并确定桶号为1。</p><p>② goroutine1添加key1，触发扩容条件。</p><p>③ B&#x3D;B+1&#x3D;3, buckets数据迁移到oldbuckets。</p><p>④ goroutine2从桶1中遍历，获取数据失败。</p><p>在工作中，当我们涉及到对一个map进行并发读写时，一般采用的做法是采用golang中自带的<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=mutex%E9%94%81&zhida_source=entity">mutex锁</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">struct</span> &#123;<br>    sync.RWMutex<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := Resource&#123;m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine写map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.Lock()<br>            r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)] = j<br>            r.Unlock()<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine读map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.RLock()<br>            fmt.Println(r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)])<br>            r.RUnlock()<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对map数据进行操作时不可取地址</li></ul><p>因为随着map元素的增长，map底层重新分配空间会导致之前的地址无效。</p><p>[<a href="https://zhuanlan.zhihu.com/p/495998623#ref_1">1]</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/495998623#ref_1_0">^</a>Map <a href="https://juejin.cn/post/7029679896183963678#heading-1">https://juejin.cn/post/7029679896183963678#heading-1</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.jpg" alt="排序算法"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums<br>    &#125;<br>    <span class="hljs-comment">// 冒泡排序核心实现代码</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        flag := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(nums) - i - <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>] &#123;<br>                nums[j], nums[j+<span class="hljs-number">1</span>] = nums[j+<span class="hljs-number">1</span>], nums[j]<br>                flag = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !flag &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br>    nums = bubbleSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.webp" alt="冒泡排序"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(list []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pivot := list[low] <span class="hljs-comment">//导致 low 位置值为空</span><br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        <span class="hljs-comment">//high指针值 &gt;= pivot high指针👈移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &lt;= list[high] &#123;<br>            high--<br>        &#125;<br>        <span class="hljs-comment">//填补low位置空值</span><br>        <span class="hljs-comment">//high指针值 &lt; pivot high值 移到low位置</span><br>        <span class="hljs-comment">//high 位置值空</span><br>        list[low] = list[high]<br>        <span class="hljs-comment">//low指针值 &lt;= pivot low指针👉移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &gt;= list[low] &#123;<br>            low++<br>        &#125;<br>        <span class="hljs-comment">//填补high位置空值</span><br>        <span class="hljs-comment">//low指针值 &gt; pivot low值 移到high位置</span><br>        <span class="hljs-comment">//low位置值空</span><br>        list[high] = list[low]<br>    &#125;<br>    <span class="hljs-comment">//pivot 填补 low位置的空值</span><br>    list[low] = pivot<br>    <span class="hljs-keyword">return</span> low<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(list []<span class="hljs-type">int</span>,low,high <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> high &gt; low&#123;<br>        <span class="hljs-comment">//位置划分</span><br>        pivot := partition(list,low,high)<br>        <span class="hljs-comment">//左边部分排序</span><br>        QuickSort(list,low,pivot<span class="hljs-number">-1</span>)<br>        <span class="hljs-comment">//右边排序</span><br>        QuickSort(list,pivot+<span class="hljs-number">1</span>,high)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestQuickSort</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    list := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">44</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">33</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>,<span class="hljs-number">54</span>,<span class="hljs-number">9</span>&#125;<br>    QuickSort(list,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(list)<span class="hljs-number">-1</span>)<br>    t.Log(list)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quick_sort_partition_animation.gif" alt="快速排序"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入url后发生了什么</title>
    <link href="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器输入url后发生了什么"><a href="#浏览器输入url后发生了什么" class="headerlink" title="浏览器输入url后发生了什么"></a>浏览器输入url后发生了什么</h2><h3 id="1-输入地址"><a href="#1-输入地址" class="headerlink" title="1. 输入地址"></a>1. 输入地址</h3><p>浏览器从历史记录，书签中智能匹配url，甚至从缓存中直接把网页展示出来。</p><h3 id="2-浏览器查找域名对应的IP地址"><a href="#2-浏览器查找域名对应的IP地址" class="headerlink" title="2. 浏览器查找域名对应的IP地址"></a>2. 浏览器查找域名对应的IP地址</h3><ol><li><p>查找本地硬盘的hosts文件，如果有的话直接使用hosts文件中的ip地址。</p></li><li><p>如果hosts文件中没有，则向本地DNS服务器发送请求。本地DNS服务器一般是网络接入供应商提供，比如中国电信，中国移动。</p></li><li><p>本地DNS服务器查缓存，有的话就直接返回。</p></li><li><p>本地DNS服务器缓存没有命中的话，向根服务器查询。</p></li><li><p>根服务器提供下一层级服务器地址。</p></li><li><p>迭代查询直到查询到IP地址。</p></li><li><p>本地DNS服务器向浏览器返回IP地址，并将IP地址记录在自己的缓存中，已备下次使用。</p></li></ol><h3 id="3-浏览器跟web服务器建立TCP连接"><a href="#3-浏览器跟web服务器建立TCP连接" class="headerlink" title="3. 浏览器跟web服务器建立TCP连接"></a>3. 浏览器跟web服务器建立TCP连接</h3><p>通过TCP三次握手，建立连接。</p><h3 id="4-浏览器发送HTTP请求"><a href="#4-浏览器发送HTTP请求" class="headerlink" title="4. 浏览器发送HTTP请求"></a>4. 浏览器发送HTTP请求</h3><p>请求信息包含三个部分：</p><ul><li>请求方法URI协议&#x2F;版本</li><li>请求头(Request Header)</li><li>请求正文</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span>/sample.jspHTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Accept</span>:image/gif.image/jpeg,*/*<br><span class="hljs-attribute">Accept</span>-Language:zh-cn<br><span class="hljs-attribute">Connection</span>:Keep-Alive<br><span class="hljs-attribute">Host</span>:localhost<br><span class="hljs-attribute">User</span>-Agent:Mozila/<span class="hljs-number">4</span>.<span class="hljs-number">0</span>(compatible;MSIE5.<span class="hljs-number">01</span>;Window NT5.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">Accept</span>-Encoding:gzip,deflate<br><br><span class="hljs-attribute">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>TCP三次握手</p><ol><li><p>第一次握手：</p><p>客户端生成数据包：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">SYN</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">seq</span> <span class="hljs-operator">=</span> J (随机生成一个数J)<br></code></pre></td></tr></table></figure><p>发送出数据包后，客户端进入SYN_SENT状态，等待服务端确认。</p></li><li><p>第二次握手：</p><p>服务端收到数据包，生成返回数据包：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">SYN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = K (随机生成一个数K)<br><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = J + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>发送出数据包后，服务端进入SYN_RCVD状态。</p></li><li><p>第三次握手：</p><p>客户端收到数据包，检查ack是否为J+1，ACK是否为1。若正确，则生成数据包：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = K + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>将数据包发出，客户端进入ESTABLISHED状态。</p><p>服务端收到数据包后，检查ack是否为K+1，ACK是否为1。若正确，服务端进入ESTABLISHED状态。</p></li><li><p>完成三次握手，开始传输数据。</p></li></ol><p><img src="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p>为什么需要三次握手</p><p>主要是为了防止服务端一直等待，浪费资源。</p><p>假设没有三次握手，客户端发出的连接请求在网络中滞留了，客户端超时已经释放了连接。服务端接收到请求后，发出确认。确认发出后连接就建立了，服务端就会一直等待客户端发来数据，而客户端实际已经释放了连接，收到确认后不会理睬，这将导致服务端浪费资源。</p><p>TCP四次挥手</p><ol><li><p>第一次挥手：</p><p>客户端发送FIN，用来关闭客户端到服务端的数据传输，客户端进入FIN_WAIT_1状态</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">FIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">seq</span> <span class="hljs-operator">=</span> x<br><span class="hljs-attribute">ack</span> <span class="hljs-operator">=</span> y<br></code></pre></td></tr></table></figure></li><li><p>第二次挥手：</p><p>服务端收到FIN，发送一个ACK给客户端，服务端进入CLOSE_WAIT状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = y<br><span class="hljs-attr">ack</span> = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>客户端收到ACK，进入FIN_WAIT_2状态。</p></li><li><p>第三次挥手：</p><p>服务端处理完剩余数据后，也向客户端发送FIN，服务端进入LAST_ACK状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">FIN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = y<br><span class="hljs-attr">ack</span> = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>第四次挥手：</p><p>客户端收到FIN，发送一个ACK给服务端，客户端进入TIME_WAIT状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = x + <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = y + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>服务端收到ACK，进入CLOSE状态。</p><p><img src="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中的byte类型和rune类型</title>
    <link href="/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.cnblogs.com/wjaaron/p/14822799.html">https://www.cnblogs.com/wjaaron/p/14822799.html</a></p><p>Go 语言中定义字符串要用双引号，而不是单引号，单引号中只能包含一个元素，表示一个字符。</p><p>Go语言中字符有两种类型，分别是：</p><p>uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符<br>rune 类型，代表一个 UTF-8 字符<br>了解编码知识的应该知道，ASCII 编码字符是1个字节的，而 UTF-8 是可变长的编码，当要表示中文等非 ASCll 编码的字符时，需要使用 UTF-8 编码来保证不会乱码。关于字符编码相关知识，推荐看这篇廖雪峰的介绍 字符编码</p><p>假如我们要遍历输出一个包含中文的字符串时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Println(str[i])<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的打印结果是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">104<br>101<br>108<br>108<br>111<br>32<br>228<br>184<br>150<br>231<br>149<br>140<br></code></pre></td></tr></table></figure><p>Go 语言字符串存储的其实是类型为 byte 的只读切片，或者说一个字符串就是一堆字节。在 UTF-8 编码中一个英文字符可以用一个字节存储，一个中文字符需要三个或四个字节存储，而 ASCII 码符号只有 128 个，大于 128 的都不在范围内。上述代码的遍历方式就是以 ASCII 类型来读字符的。</p><p>可以看到输出结果中的前 6 个都是在 ASCII 表中的，但是后 6 个就不在表中了，后面 6 个的每一个字节都不能单独表示一个字符，而是用 3 个在一起才能表示一个字符，明显超出了 ASCII 表的范围，所以当打印具体字符时就会乱码，比如我们现在来打印每一个真实字符，需要使用到占位符 %c：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, str[i]) <span class="hljs-comment">// hello ä¸ç</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello ä¸ç<br></code></pre></td></tr></table></figure><p>明显乱码了。解释这么多就是为了说明如果字符串中有非 ASCII 码的字符时，就不能使用 byte 来表示字符，需要使用 rune 类型来表示。</p><p>使用 rune 类型来遍历字符串<br>在 Go 中，有一个遍历方式是 range，它默认就是以 UTF-8 编码形式去读每一个字符。当涉及到的字符串中含有非英文字符时，可以使用 range 来遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> str &#123;<br>  fmt.Println(r)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">104<br>101<br>108<br>108<br>111<br>32<br>19990<br>30028<br></code></pre></td></tr></table></figure><p>此时输出的字节编码就是 UTF-8 编码号，UTF-8 编码是包含 ASCII 编码的，所以前 6 个编号还是一样的，后面两个编号分别代表世，界。</p><p>修改字符串<br>Go 语言中对字符串的修改其实不是对字符串本身的修改，而是复制字符串，同时修改值，即重新分配来内存，需要先将字符串转化成数组，[]byte 或 []rune，然后再转换成 string 型。</p><p>那么我要说的也很明显了，就是要区别使用 []byte 或 []rune。</p><p>对于全是ASCII编码的字符串，使用 []byte 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;abc&quot;</span><br> s2 := []<span class="hljs-type">byte</span>(str)<br> s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span><br> fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//bbc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; string()表示强制类型转换，转换为字符串<br>对于包含中文等字符的字符串时，那就要用 []rune 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    str:=<span class="hljs-string">&quot;白猫&quot;</span><br>    s2:=[]<span class="hljs-type">rune</span>(str)<br>    s2[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;黑&#x27;</span><br>    fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//黑猫</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结<br>在处理字符时，要考虑字符的编码范围，然后根据需要使用 byte 类型或 rune类型。</p><p>byte 类型只能正常输出 ASCII 编码范围的字符；rune 类型可以输出 UTF-8 编码范围的字符。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang并发编程</title>
    <link href="/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="goroutine的使用"><a href="#goroutine的使用" class="headerlink" title="goroutine的使用"></a>goroutine的使用</h2><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。<br>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。<br>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> hello() <span class="hljs-comment">// 启动另外一个goroutine去执行hello函数</span><br>    fmt.Println(<span class="hljs-string">&quot;main goroutine done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h2><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// goroutine结束就登记-1</span><br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 启动一个goroutine就登记+1</span><br>        <span class="hljs-keyword">go</span> hello(i)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 等待所有登记的goroutine都结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p><h2 id="注意退出"><a href="#注意退出" class="headerlink" title="注意退出"></a>注意退出</h2><p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大纲</title>
    <link href="/2024/12/05/%E5%A4%A7%E7%BA%B2/"/>
    <url>/2024/12/05/%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol><li>为什么对slice append时，要用原来的变量来接收<br>s &#x3D; append(s, 1)</li></ol><p>因为append是一个函数，函数的传参是值拷贝，传进去的s在函数内部已经是另一个s了，而函数外部原来的s.len并不会被改变，所以要用函数返回的新s来覆盖原来的s</p><p>go内存管理<br>go协程原理<br>go并发编程<br>go网络编程</p><p>gin框架</p><p>context包</p><p>channel底层原理</p><p>实现M:N生产者消费者模型，双方均设置超时5s丢弃机制</p><p>实现高并发阻塞式Map</p><p>sync.Cond</p><p>sync.Once<br>sync.Map原理</p><p>go协程如何退出的</p><p>make和new的区别</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>namespace</p><p>cgroups</p><p>常见命令</p><p>查看日志的相关命令</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p>list-watch 底层原理</p><p>helm chart</p><p>pod创建全链路分析</p><p>k8s集群部署实战</p><p>drain</p><p>kube-apiserver 缓存机制</p><p>etcd</p><p>pod都有哪些状态</p><p>分布式训练</p><p>tensorflow如何支持分布式训练</p><p>如何使用docker进行机器学习训练</p><p>如何使用k8s进行机器学习训练</p><p>kubelet是如何把pod拉起来的</p><p>Dockerfile</p><p>scheduler是如何调度pod的</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>socket编程</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>测试文章图片：<br><img src="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.jpg" alt="测试"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/20/hello-world/"/>
    <url>/2024/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
