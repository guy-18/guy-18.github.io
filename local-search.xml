<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Golang GC</title>
    <link href="/2025/03/25/Golang-GC/"/>
    <url>/2025/03/25/Golang-GC/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GC"><a href="#Golang-GC" class="headerlink" title="Golang GC"></a>Golang GC</h1><p>转自: <a href="https://www.yuque.com/aceld/golang/zhzanb">https://www.yuque.com/aceld/golang/zhzanb</a></p><p>本节为重点章节</p><p><img src="/2025/03/25/Golang-GC/1650786480776-52768cf0-0457-4875-a390-543ed516861f.webp" alt="Image 1: 标题.jpeg"></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV1wz4y1y7Kd">https://www.bilibili.com/video/BV1wz4y1y7Kd</a></p><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><p>Golang在GC的演进过程中也经历了很多次变革，本文将按照一下顺序介绍：</p><ul><li>Go V1.3之前的标记-清除(mark and sweep)算法，缺点</li><li>Go V1.5的三色并发标记法</li><li>Go V1.5的三色标记为什么需要STW</li></ul><p>●Go V1.5的三色并发标记法<br>●Go V1.5的三色标记为什么需要STW<br>●Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )<br>●Go V1.8混合写屏障机制<br>●Go V1.8混合写屏障机制的全场景分析</p><h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>接下来我们来看一下在Golang1.3之前的时候主要用的普通的标记-清除算法，此算法主要有两个主要的步骤：</p><p>●标记(Mark phase)<br>●清除(Sweep phase)</p><p>1 标记清除算法的具体步骤</p><p>第一步，暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。</p><p><img src="/2025/03/25/Golang-GC/1650787873045-d038fe47-4898-4b07-9e16-007bebb6fb9c.webp" alt="Image 2: 44-GC1.png"></p><p>图中表示是程序与对象的可达关系，目前程序的可达对象有对象1-2-3，对象4-7等五个对象。</p><p>第二步, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p><p><img src="/2025/03/25/Golang-GC/1650787891194-883ec541-5f13-4934-9274-080e5f44cf5e.webp" alt="Image 3: 42-GC2.png"></p><p>所以对象1-2-3、对象4-7等五个对象被做上标记。</p><p>第三步,  标记完了之后，然后开始清除未标记的对象. 结果如下。</p><p><img src="/2025/03/25/Golang-GC/1650787913616-ecf21ee2-c247-4401-9d3e-5e2fa278726f.webp" alt="Image 4: 45-GC3.png"></p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。</p><p>第四步, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p><p>以上便是标记-清除（mark and sweep）回收的算法。</p><h2 id="二、-标记-清除-mark-and-sweep-的缺点"><a href="#二、-标记-清除-mark-and-sweep-的缺点" class="headerlink" title="二、 标记-清除(mark and sweep)的缺点"></a>二、 标记-清除(mark and sweep)的缺点</h2><p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。</p><p>●STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)；<br>●标记需要扫描整个heap；<br>●清除数据会产生heap碎片。</p><p>Go V1.3版本之前就是以上来实施的,  在执行GC的基本流程就是首先启动STW暂停，然后执行标记，再执行数据回收，最后停止STW，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1650787936233-9002040d-220b-4af6-8e51-75d7887569b4.webp" alt="Image 5: 53-STW1.png"></p><p>从上图来看，全部的GC时间都是包裹在STW范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围.如下所示</p><p><img src="/2025/03/25/Golang-GC/1650788071197-26a29703-0fb5-43f4-afc5-87a35fc78a4b.webp" alt="Image 6: 54-STW2.png"></p><p>上图主要是将STW的步骤提前了一步，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。</p><p>但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。</p><p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用三色并发标记法来优化这个问题.</p><h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，所谓三色标记法实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？我们来看一下具体的过程。</p><p>第一步 , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035738281-051f7a89-e07f-418c-ad0e-7cb94ef1a3b8.webp" alt="Image 7: 46-GC4.png"></p><p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表，是用来记录目前每个对象的标记颜色分类。这里面需要注意的是，所谓“程序”，则是一些对象的根节点集合。所以我们如果将“程序”展开，会得到类似如下的表现形式，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035821416-b0ad644e-ef8e-440a-bbf4-b9e24a7e0257.webp" alt="Image 8: 47-GC5.jpeg"></p><p>第二步, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035842467-7341846f-6dee-4f8b-ad37-dc9723aa6407.webp" alt="Image 9: 48-GC6.jpeg"></p><p>这里 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p><p>第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035859950-96053775-24f7-4bdc-a1fb-295747055b3e.webp" alt="Image 10: 49-GC7.jpeg"></p><p>这一次遍历是只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7. 而之前的灰色对象1和对象4则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p><p>第四步, 重复第三步, 直到灰色中无任何对象，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035907012-927d6cbc-686b-4f81-a1de-097ac7598a8e.webp" alt="Image 11: 50-GC8.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651035916208-9c293dc0-8988-4180-a9b7-412e2599af0e.webp" alt="Image 12: 51-GC9.jpeg"></p><p>当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p><p>第五步: 回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。 以上我们将全部的白色对象进行删除回收，</p><p><img src="/2025/03/25/Golang-GC/1651035960263-e50436a6-4a3c-48f9-82cb-bb5729d71116.webp" alt="Image 13: 52-GC10.jpeg"></p><p>剩下的就是全部依赖的黑色对象。</p><p>以上便是三色并发标记法，不难看出，我们上面已经清楚的体现三色的特性。但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。</p><p>那么Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p><h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？ 我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?</p><p>我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035994109-83972e84-be65-4950-b9bf-a48b676856a5.webp" alt="Image 14: 55-三色标记问题1.jpeg"></p><p>现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。</p><p><img src="/2025/03/25/Golang-GC/1651036029588-29e317e6-8f92-41ca-a28e-65153913d227.webp" alt="Image 15: 56-三色标记问题2.jpeg"></p><p>与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036292354-f70d8185-66a2-4478-9036-b4de940285c5.webp" alt="Image 16: 57-三色标记问题3.jpeg"></p><p>然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036347628-d63c17c4-7cee-4149-8ce9-13cc11bbd343.webp" alt="Image 17: 58-三色标记问题4.jpeg"></p><p>那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036362636-5a98e196-e1cd-49fc-9542-1cb0772a41c4.webp" alt="Image 18: 59-三色标记问题5.jpeg"></p><p>但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。</p><p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p><p>●条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)<br>●条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色) 如果当以上两个条件同时满足时，就会出现对象丢失现象!</p><p>并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。</p><p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p><h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。  这两种方式就是“强三色不变式”和“弱三色不变式”。</p><p>(1) “强-弱” 三色不变式</p><p>●强三色不变式</p><p>不存在黑色对象引用到白色对象的指针。</p><p><img src="/2025/03/25/Golang-GC/1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654.webp" alt="Image 19: 60-三色标记问题6.jpeg"></p><p>强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><p>●弱三色不变式</p><p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p><p><img src="/2025/03/25/Golang-GC/1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed.webp" alt="Image 20: 61-三色标记问题7.jpeg"></p><p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</p><p>(2)  插入屏障</p><p>具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p><p>满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p>伪码如下:</p><p>场景：</p><p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, 栈和堆. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中.</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="/2025/03/25/Golang-GC/1651036442131-91f36e55-5c94-4931-a140-58ff5627c681.webp" alt="Image 21: 62-三色标记插入写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4.webp" alt="Image 22: 63-三色标记插入写屏障2.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d.webp" alt="Image 23: 64-三色标记插入写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036465710-e260440e-b53d-4f76-a826-842e28666efe.webp" alt="Image 24: 65-三色标记插入写屏障4.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036474130-755abe1f-d070-47e6-93cf-7aa129489206.webp" alt="Image 25: 66-三色标记插入写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982.webp" alt="Image 26: 67-三色标记插入写屏障6.jpeg"></p><p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9).  所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p><p><img src="/2025/03/25/Golang-GC/1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431.webp" alt="Image 27: 68-三色标记插入写屏障7.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8.webp" alt="Image 28: 69-三色标记插入写屏障9.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9.webp" alt="Image 29: 70-三色标记插入写屏障10.jpeg"></p><p>最后将栈和堆空间 扫描剩余的全部 白色节点清除.  这次STW大约的时间在10~100ms间.</p><p><img src="/2025/03/25/Golang-GC/1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b.webp" alt="Image 30: 71-三色标记插入写屏障11.jpeg"></p><p>(3)  删除屏障</p><p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p><p>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p><p>伪代码：</p><p>场景：</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="/2025/03/25/Golang-GC/1651036621717-80ea507c-99a9-4e61-9bde-b4cd33f478f4.webp" alt="Image 31: 72-三色标记删除写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036629775-bc69d08e-c270-46ad-b82b-5ad0d0bdcb64.webp" alt="Image 32: 73-三色标记删除写屏障2.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036637089-52a0fc99-7805-40d0-aee7-4124017e90c8.webp" alt="Image 33: 74-三色标记删除写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036644794-05a69ec6-70c9-44c7-9493-44028ba4df7f.webp" alt="Image 34: 75-三色标记删除写屏障4.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036653171-57e34942-2091-4d76-83f3-0b084ebd577d.webp" alt="Image 35: 76-三色标记删除写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036660503-4f49f494-8ede-45dd-8a4c-bfa5499b307a.webp" alt="Image 36: 77-三色标记删除写屏障6.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036668136-8592bd0f-2210-48d9-b43d-7c4a2e16a287.webp" alt="Image 37: 78-三色标记删除写屏障7.jpeg"></p><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p><p>● 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；● 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。<br>(1) 混合写屏障规则</p><p>具体操作:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p>满足: 变形的弱三色不变式.</p><p>伪代码：</p><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p><p>(2) 混合写屏障的具体场景分析</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p><p>GC开始：扫描栈区，将可达对象全部标记为黑</p><p><img src="/2025/03/25/Golang-GC/1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62.webp" alt="Image 38: 79-三色标记混合写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791.webp" alt="Image 39: 80-三色标记混合写屏障2.jpeg"></p><p>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c.webp" alt="Image 40: 81-三色标记混合写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac.webp" alt="Image 41: 82-三色标记混合写屏障4.jpeg"></p><p>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6.webp" alt="Image 42: 83-三色标记混合写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036785024-0edb665e-7b4b-46e3-b8cf-1d4ff02e73cd.webp" alt="Image 43: 84-三色标记混合写屏障6.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c.webp" alt="Image 44: 85-三色标记混合写屏障7.jpeg"></p><p>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a.webp" alt="Image 45: 86-三色标记混合写屏障8.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036833484-a18064d9-1329-42d7-8687-8a029542e85e.webp" alt="Image 46: 87-三色标记混合写屏障9.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4.webp" alt="Image 47: 88-三色标记混合写屏障10.jpeg"></p><p>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814.webp" alt="Image 48: 89-三色标记混合写屏障11.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62.webp" alt="Image 49: 90-三色标记混合写屏障12.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c.webp" alt="Image 50: 91-三色标记混合写屏障13.jpeg"></p><p>Golang中的混合写屏障满足弱三色不变式，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang GMP模型</title>
    <link href="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GMP模型"><a href="#Golang-GMP模型" class="headerlink" title="Golang GMP模型"></a>Golang GMP模型</h1><p>转自：<a href="https://www.yuque.com/aceld/golang/srxd6d">https://www.yuque.com/aceld/golang/srxd6d</a></p><p>本节为重点章节 本章节含视频版:</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650775952013-f19f9c96-b995-42d6-bc9c-8b1e73b602d8.webp" alt="Image 1: GPM封面.png"></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV19r4y1w7Nx">https://www.bilibili.com/video/BV19r4y1w7Nx</a></p><h2 id="一、Golang“调度器”的由来？"><a href="#一、Golang“调度器”的由来？" class="headerlink" title="一、Golang“调度器”的由来？"></a>一、Golang“调度器”的由来？</h2><h3 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代”</p><p>一切的程序只能串行发生。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776039816-a8a5efb6-06be-4984-bfb0-7565c14b0a61.webp" alt="Image 2: 5-单进程操作系统.png"></p><p>早期的单进程操作系统，面临2个问题：</p><p>1.单一的执行流程，计算机只能一个任务一个任务处理。</p><p>2.进程阻塞所带来的CPU时间浪费。</p><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p><h3 id="2-多进程-线程时代有了调度器需求"><a href="#2-多进程-线程时代有了调度器需求" class="headerlink" title="(2)多进程&#x2F;线程时代有了调度器需求"></a>(2)多进程&#x2F;线程时代有了调度器需求</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776059361-384f6fb5-e2b1-4f99-8701-f57694aa8ecb.webp" alt="Image 3: 6-多进程操作系统.png"></p><p>在多进程&#x2F;多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p><p>怎么才能提高CPU的利用率呢？</p><p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776077730-2a6860a3-0466-4df9-925d-9ecd5cb9ad7d.webp" alt="Image 4: 7-cpu切换浪费成本.png"></p><p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p><h3 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3) 协程来提高CPU利用率"></a>(3) 协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。</p><p>大量的进程&#x2F;线程出现了新的问题</p><p>●高内存占用<br>●调度的高消耗CPU</p><p>好了，然后工程师们就发现，其实一个线程分为<strong>“内核态“线程和”用户态“线程</strong>。</p><p><strong>一个“用户态线程”必须要绑定一个“内核态线程”</strong>，但是**CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)**。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776112186-eff4e8b8-8742-44cd-a828-db1653649ee7.webp" alt="Image 5: 8-线程的内核和用户态.png"></p><p>这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”.</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776128796-5b795bfb-3289-4f6b-85a0-f24399dfc79c.webp" alt="Image 6: 9-协程和线程.png"></p><p>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p><p>之后，我们就看到了有3中协程和线程的映射关系：</p><p>N:1关系</p><p>N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上</p><p>缺点：</p><p>●某个程序用不了硬件的多核加速能力<br>●一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776145617-04763b3d-1b15-42c7-9653-cde21bcc98bc.webp" alt="Image 7: 10-N-1关系.png"></p><p>1:1 关系</p><p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，</p><p>缺点：</p><p>●协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776180139-043037ed-cb5b-4c24-9fcf-691a05db17f9.webp" alt="Image 8: 11-1-1.png"></p><p>M:N关系</p><p>M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776193242-4fecd540-5cbb-4f2d-8121-5312dbc6958a.webp" alt="Image 9: 12-m-n.png"></p><p>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p><h3 id="4-Go语言的协程goroutine"><a href="#4-Go语言的协程goroutine" class="headerlink" title="(4) Go语言的协程goroutine"></a>(4) Go语言的协程goroutine</h3><p>Go为了提供更容易使用的并发方法，使用了goroutine和channel。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被runtime调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。</p><p>Goroutine特点：</p><p>●占用内存更小（几kb）<br>●调度更灵活(runtime调度)</p><h3 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5) 被废弃的goroutine调度器"></a>(5) 被废弃的goroutine调度器</h3><p>好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p><p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p><p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776259684-6015cb7b-b33e-47f9-b241-185c57dc2745.webp" alt="Image 10: 13-gm.png"></p><p>下面我们来看看被废弃的golang调度器是如何实现的？</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776272668-ac680807-d927-4c10-9e1d-3960bdabd0e3.webp" alt="Image 11: 14-old调度器.png"></p><p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局G队列是有互斥锁进行保护的。</p><p>老调度器有几个缺点：</p><ol><li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。</li><li>M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol><h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。</p><p>在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776288599-36c23cc6-3d25-4f6f-8f80-83bd43aa6dec.webp" alt="Image 12: 15-gmp.png"></p><p>Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p><h3 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1) GMP模型"></a>(1) GMP模型</h3><p>在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776301442-fb76123c-8d0e-4375-af35-b5728a5b1bc7.webp" alt="Image 13: 16-GMP-调度.png"></p><ol><li>全局队列（Global Queue）：存放等待运行的G。</li><li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li><li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol><p>Goroutine调度器和OS调度器是通过M结合起来的，<strong>每个M都代表了1个内核线程</strong>，OS调度器负责把内核线程分配到CPU的核上执行。</p><p>有关P和M的个数问题</p><p>1、P的数量：</p><p>●由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。</p><p>2、M的数量:</p><p>●go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。<br>●runtime&#x2F;debug中的SetMaxThreads函数，设置M的最大数量<br>●一个M阻塞了，会创建新的M。</p><p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p><p>P和M何时会被创建</p><p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p><p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p><h3 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2) 调度器的设计策略"></a>(2) 调度器的设计策略</h3><p>复用线程：避免频繁的创建、销毁线程，而是对线程的复用。</p><p>1）work stealing机制</p><p>当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p><p>2）hand off机制</p><p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p><p>利用并行：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS &#x3D; 核数&#x2F;2，则最多利用了一半的CPU核进行并行。</p><p>抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p><p>全局G队列：在新的调度器中依然有全局G队列，当P的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过work stealing机制从其他P的本地队列偷取G。</p><h3 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func()  调度流程"></a>(3) go func()  调度流程</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776333419-50d3a922-bd53-4bff-b0b6-280e6abc5d74.webp" alt="Image 14: 18-go-func调度周期.jpeg"></p><p>从上图我们可以分析出几个结论：</p><p>1、我们通过 go func()来创建一个goroutine；</p><p>2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p><p>3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p><p>4、一个M调度G执行的过程是一个循环机制；</p><p>5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在等待执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p><p>6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p><h3 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4) 调度器的生命周期"></a>(4) 调度器的生命周期</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776346389-ab0ffa04-c707-4ec8-a810-0929533fd00c.webp" alt="Image 15: 17-pic-go调度器生命周期.png"></p><p>特殊的M0和G0</p><p>M0</p><p>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p><p>G0</p><p>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p><p>我们来跟踪一段代码</p><p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p><p>也会经历如上图所示的过程：</p><ol><li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li><li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li><li>示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li><li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li><li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li><li>M运行G</li><li>G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</li></ol><p>调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。</p><h3 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5) 可视化GMP编程"></a>(5) 可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据。</p><p>方式1：go tool trace</p><p>trace记录了运行时的信息，能提供可视化的Web页面。</p><p>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p><p>trace.go</p><p>运行程序</p><p>会得到一个trace.out文件，然后我们可以用一个工具打开，来分析这个文件。</p><p>我们可以通过浏览器打开<a href="http://127.0.0.1:33479网址，点击view">http://127.0.0.1:33479网址，点击view</a> trace 能够看见可视化的调度流程。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776395564-f4f1ba06-1af0-4842-a241-8ea7e56b0612.webp" alt="Image 16: 19-go-trace1.png"></p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776402701-9db41a28-ffc9-4702-8cd1-6670f8cd0d28.webp" alt="Image 17: 20-go-trace2.png"></p><p>G信息</p><p>点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776424129-7608477e-4b67-40f3-8782-a0eb346ef8eb.webp" alt="Image 18: 20-go-trace3.png"></p><p>一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p><p>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p><p>M信息</p><p>点击Threads那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776444325-d259c370-0aa5-4650-a5fd-2449190c97a1.webp" alt="Image 19: 22-go-trace4.png"></p><p>一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。</p><p>P信息</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776459340-7053a162-0e39-4955-b0e6-d4714171be3a.webp" alt="Image 20: 23-go-trace5.png"></p><p>G1中调用了main.main，创建了trace goroutine g18。G1运行在P1上，G18运行在P0上。</p><p>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。</p><p>我们在来看看上面的M信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776484643-1c8841a4-01a1-4948-a8a7-616678fb5317.webp" alt="Image 21: 24-go-trace6.png"></p><p>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776494915-1d38f0bf-cbd8-4958-ae55-1144a86e50a2.webp" alt="Image 22: 25-go-trace7.png"></p><p>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p><p>方式2：Debug trace</p><p>编译</p><p>通过Debug方式运行</p><p>●SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；<br>●0ms：即从程序启动到输出这行日志的时间；<br>●gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；<br>●idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；<br>●threads: os threads&#x2F;M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；<br>●spinningthreads: 处于自旋状态的os thread数量；<br>●idlethread: 处于idle状态的os thread的数量；<br>●runqueue&#x3D;0： Scheduler全局队列中G的数量；<br>●[0 0]: 分别为2个P的local queue中的G的数量。</p><p>下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。</p><h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><p>(1)场景1</p><p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P的本地队列。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776522560-a33b69e2-2842-4132-8cbe-f2bad017bc7e.webp" alt="Image 23: 26-gmp场景1.png"></p><p>(2)场景2</p><p>G1运行完成后(函数：goexit)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：schedule）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了线程M1的复用。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776536644-c6fba007-d952-4a22-8939-ca1a898a5c3c.webp" alt="Image 24: 27-gmp场景2.png"></p><p>(3)场景3</p><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776549767-57ceac17-5504-46ac-af56-0dba59359e8b.webp" alt="Image 25: 28-gmp场景3.png"></p><p>(4)场景4</p><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列)</p><p>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776570176-d9d5abd4-3a48-461c-a43c-6ef504c4038f.webp" alt="Image 26: 29-gmp场景4.png"></p><p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。<br>(5)场景5</p><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776584395-dfb9c26b-b0a8-4c17-b46e-649302df87d5.webp" alt="Image 27: 30-gmp场景5.png"></p><p>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。<br>(6)场景6</p><p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776600276-58bdcec4-00e6-4f24-89c8-e4f01fd1d9fb.webp" alt="Image 28: 31-gmp场景6.png"></p><p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程（没有G但为运行状态的线程，不断寻找G）。<br>(7)场景7</p><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。M2从全局队列取的G数量符合下面的公式：</p><p>相关源码参考:</p><p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是从全局队列到P本地队列的负载均衡。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776688586-9207de08-5203-403f-8857-42942e84dcb1.webp" alt="Image 29: 32-gmp场景7.001.jpeg"></p><p>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。<br>(8)场景8</p><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777780659-cef000df-3d46-4fd5-b0ed-3dc466bf1cd2.webp" alt="Image 30: 33-gmp场景8.png"></p><p>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。<br>(9)场景9</p><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777794441-a7ed7fc2-e495-4022-a3b6-581930e5acd0.webp" alt="Image 31: 34-gmp场景9.png"></p><p>为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们希望当有新goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程(当前例子中的GOMAXPROCS&#x3D;4，所以一共4个P)，多余的没事做线程会让他们休眠。<br>(10)场景10</p><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;&#x3D;P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777810926-ca4030f3-f29a-4211-8722-677b229be440.webp" alt="Image 32: 35-gmp场景10.png"></p><p>(11)场景11</p><p>G8创建了G9，假如G8进行了非阻塞系统调用。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777823944-25f0ea1a-3431-457e-b4cf-342654a953b6.webp" alt="Image 33: 36-gmp场景11.png"></p><p>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go Map</title>
    <link href="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Map"><a href="#Go-Map" class="headerlink" title="Go Map"></a>Go Map</h1><p>map 是一种key-value的键值对存储结构，其中key不能重复，底层用<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=hash%E8%A1%A8&zhida_source=entity">hash表</a>存储。</p><p>平日里我们一般是这样使用map的：</p><blockquote><p>&#x2F;&#x2F; 创建<br>&#x2F;&#x2F; map[KeyType]ValueType<br>var m map[int]int<br>m :&#x3D; make(map[int]int)<br>m :&#x3D; map[int]int{<br>1: 1,<br>2: 2,<br>}<br>&#x2F;&#x2F; 读取<br>i :&#x3D; m[1]<br>v, ok :&#x3D; m[1]<br>​<br>&#x2F;&#x2F; 遍历<br>for key, value :&#x3D; range m {<br>println(“Key: “, key, “Value: “, value)<br>}<br>​<br>&#x2F;&#x2F; 删除<br>delete(m, 1)</p></blockquote><p>map的数据结构在源码结构中的关键字段如下，在<code>src/runtime/map.go</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    count     <span class="hljs-type">int</span>    <span class="hljs-comment">// 元素的个数</span><br>    B         <span class="hljs-type">uint8</span>  <span class="hljs-comment">// buckets 数组的长度就是 2^B 个</span><br>    overflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// 溢出桶的数量</span><br><br>    buckets    unsafe.Pointer <span class="hljs-comment">// 2^B个桶对应的数组指针</span><br>    oldbuckets unsafe.Pointer  <span class="hljs-comment">// 发生扩容时，记录扩容前的buckets数组指针</span><br><br>    extra *mapextra <span class="hljs-comment">//用于保存溢出桶的地址</span><br>&#125;<br><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>    overflow    *[]*bmap<br>    oldoverflow *[]*bmap<br><br>    nextOverflow *bmap<br>&#125;<br><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br><br><span class="hljs-comment">//在编译期间会产生新的结构体</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存储哈希值的高8位</span><br>    data    <span class="hljs-type">byte</span>[<span class="hljs-number">1</span>]  <span class="hljs-comment">//key value数据:key/key/key/.../value/value/value...</span><br>    overflow *bmap   <span class="hljs-comment">//溢出bucket的地址</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了便于理解源码的结构，我们提炼关键字段并转换为图形模式：</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-a8fbef952441e788d882d0656c2cf091_1440w.jpg" alt="img"></p><p>在go的map实现中，它的底层结构体是hmap，hmap里维护着若干个bucket数组 (即桶数组)。</p><p>Bucket数组中每个元素都是bmap结构，也即每个bucket（桶）都是bmap结构，【ps：后文为了语义一致，和方便理解，就不再提bmap了，统一叫作桶】 每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶(溢出桶)。</p><h2 id="map中数据操作"><a href="#map中数据操作" class="headerlink" title="map中数据操作"></a><strong>map中数据操作</strong></h2><p>了解了map的数据结构后，下面让我们学习一下在map中存取数据的过程：</p><h3 id="GET获取数据"><a href="#GET获取数据" class="headerlink" title="GET获取数据"></a><strong>GET获取数据</strong></h3><p><strong>假设当前 B&#x3D;4 即桶数量为2^B&#x3D;16个</strong>，要从map中获取k4对应的value</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>参考上图，k4的get流程可以归纳为如下几步：</strong></p><p>①<strong>计算k4的hash值</strong>。[由于当前主流机都是64位操作系统，所以计算结果有64个比特位]</p><p>②<strong>通过最后的“B”位来确定在哪号桶</strong>，此时B为4，所以取k4对应哈希值的后4位，也就是0101，0101用十进制表示为5，所以在5号桶）</p><p>③<strong>根据k4对应的hash值前8位快速确定是在这个桶的哪个位置</strong>（额外说明一下，在bmap中存放了每个key对应的tophash，是key的哈希值前8位),一旦发现前8位一致，则会执行下一步</p><p>④<strong>对比key完整的hash是否匹配</strong>，如果匹配则获取对应value</p><p>⑤<strong>如果都没有找到，就去连接的下一个溢出桶中找</strong></p><p>有很多同学会问这里为什么要多维护一个tophash，即hash前8位？</p><p>这是因为tophash可以快速确定key是否正确，也可以把它理解成一种缓存措施，如果前8位都不对了，后面就没有必要比较了。</p><h3 id="PUT存放数据"><a href="#PUT存放数据" class="headerlink" title="PUT存放数据"></a><strong>PUT存放数据</strong></h3><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>map的赋值流程可总结位如下几步：</strong></p><p>①<strong>通过key的hash值后“B”位确定是哪一个桶</strong>，图中示例为4号桶。</p><p>② 遍历当前桶，通过key的tophash和hash值，防止key重复，然后<strong>找到第一个可以插入的位置</strong>，即空位置处存储数据。</p><p>③如果<strong>当前桶元素已满，会通过overflow链接创建一个新的桶</strong>，来存储数据。</p><p><strong>关于hash冲突</strong>：当两个不同的 key 落在同一个桶中，就是发生了哈希冲突。冲突的解决手段是采用链表法：在 桶 中，从前往后找到第一个空位进行插入。如果8个kv满了，那么当前桶就会连接到下一个溢出桶（bmap）。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a><strong>扩容</strong></h3><h3 id="扩容的方式"><a href="#扩容的方式" class="headerlink" title="扩容的方式"></a><strong>扩容的方式</strong></h3><p>扩容有两种，一种是等量扩容，另一种是2倍扩容</p><ul><li><strong>相同容量扩容</strong></li></ul><p>由于map中不断的put和delete key，桶中可能会出现很多断断续续的空位，这些空位会导致连接的bmap溢出桶很长，导致扫描时间边长。这种扩容实际上是一种整理，把后置位的数据整理到前面。<strong>这种情况下，元素会发生重排，但不会换桶。</strong></p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-2ecbb8a8c52d395061f67e41620b1504_1440w.jpg" alt="img"></p><p>img</p><ul><li><strong>2倍容量扩容</strong></li></ul><p>这种2倍扩容是由于当前桶数组确实不够用了，<strong>发生这种扩容时，元素会重排，可能会发生桶迁移</strong>。</p><p>如图中所示，扩容前B&#x3D;2,扩容后B&#x3D;3，假设一元素key的hash值后三位为101，那么由上文的介绍可知，在扩容前，由hash值的后两位来决定几号桶，即 01 所以元素在1号桶。 在扩容发生后，由hash值得后三位来决定几号桶，即101所以元素会迁移到5号桶。</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-d38e6d960012d58d4192f904985a4ca1_1440w.jpg" alt="img"></p><p>img</p><h2 id="发生扩容的条件"><a href="#发生扩容的条件" class="headerlink" title="发生扩容的条件"></a><strong>发生扩容的条件</strong></h2><p>首先我们了解下**<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90&zhida_source=entity">装载因子</a>(loadFactor)**的概念</p><p>loadFactor:&#x3D;count &#x2F; (2^B) 即 装载因子 &#x3D; map中元素的个数 &#x2F; map中当前桶的个数</p><p>通过计算公式我们可以得知，<strong>装载因子是指当前map中，每个桶中的平均元素个数。</strong></p><p><strong>扩容条件1</strong>：<strong>装载因子 &gt; 6.5</strong> (源码中定义的)</p><p>这个也非常容易理解，正常情况下，如果没有溢出桶，那么一个桶中最多有8个元素，当平均每个桶中的数据超过了6.5个，那就意味着当前容量要不足了，发生扩容。</p><p><strong>扩容条件2</strong>: <strong>溢出桶的数量过多</strong></p><p>当 B &lt; 15 时，如果overflow的bucket数量超过 2^B。</p><p>当 B &gt;&#x3D; 15 时，overflow的bucket数量超过 2^15。</p><p>简单来讲，新加入key的hash值后B位都一样，使得个别桶一直在插入新数据，进而导致它的溢出桶链条越来越长。如此一来，当map在操作数据时，扫描速度就会变得很慢。及时的扩容，可以对这些元素进行重排，使元素在桶的位置更平均一些。</p><p><strong>扩容时的细节</strong></p><ol><li>在我们的hmap结构中有一个oldbuckets吗，扩容刚发生时，会先将老数据存到这个里面。</li><li>每次对map进行删改操作时，会触发从oldbucket中迁移到bucket的操作【非一次性，分多次】</li><li>在扩容没有完全迁移完成之前，每次get或者put遍历数据时，都会先遍历oldbuckets，然后再遍历buckets。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><p><strong>map是线程不安全的</strong></p><p>在同一时间点，两个 <a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=goroutine&zhida_source=entity">goroutine</a> 对同一个map进行读写操作是不安全的。举个栗子：</p><p>某map桶数量为4，即B&#x3D;2。此时 goroutine1来插入key1， goroutine2来读取 key2. 可能会发生如下过程：</p><p>① goroutine2 计算key2的hash值,B&#x3D;2，并确定桶号为1。</p><p>② goroutine1添加key1，触发扩容条件。</p><p>③ B&#x3D;B+1&#x3D;3, buckets数据迁移到oldbuckets。</p><p>④ goroutine2从桶1中遍历，获取数据失败。</p><p>在工作中，当我们涉及到对一个map进行并发读写时，一般采用的做法是采用golang中自带的<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=mutex%E9%94%81&zhida_source=entity">mutex锁</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">struct</span> &#123;<br>    sync.RWMutex<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := Resource&#123;m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine写map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.Lock()<br>            r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)] = j<br>            r.Unlock()<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine读map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.RLock()<br>            fmt.Println(r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)])<br>            r.RUnlock()<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对map数据进行操作时不可取地址</li></ul><p>因为随着map元素的增长，map底层重新分配空间会导致之前的地址无效。</p><p>[<a href="https://zhuanlan.zhihu.com/p/495998623#ref_1">1]</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/495998623#ref_1_0">^</a>Map <a href="https://juejin.cn/post/7029679896183963678#heading-1">https://juejin.cn/post/7029679896183963678#heading-1</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.jpg" alt="排序算法"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums<br>    &#125;<br>    <span class="hljs-comment">// 冒泡排序核心实现代码</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        flag := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(nums) - i - <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>] &#123;<br>                nums[j], nums[j+<span class="hljs-number">1</span>] = nums[j+<span class="hljs-number">1</span>], nums[j]<br>                flag = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !flag &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br>    nums = bubbleSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.webp" alt="冒泡排序"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(list []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pivot := list[low] <span class="hljs-comment">//导致 low 位置值为空</span><br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        <span class="hljs-comment">//high指针值 &gt;= pivot high指针👈移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &lt;= list[high] &#123;<br>            high--<br>        &#125;<br>        <span class="hljs-comment">//填补low位置空值</span><br>        <span class="hljs-comment">//high指针值 &lt; pivot high值 移到low位置</span><br>        <span class="hljs-comment">//high 位置值空</span><br>        list[low] = list[high]<br>        <span class="hljs-comment">//low指针值 &lt;= pivot low指针👉移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &gt;= list[low] &#123;<br>            low++<br>        &#125;<br>        <span class="hljs-comment">//填补high位置空值</span><br>        <span class="hljs-comment">//low指针值 &gt; pivot low值 移到high位置</span><br>        <span class="hljs-comment">//low位置值空</span><br>        list[high] = list[low]<br>    &#125;<br>    <span class="hljs-comment">//pivot 填补 low位置的空值</span><br>    list[low] = pivot<br>    <span class="hljs-keyword">return</span> low<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(list []<span class="hljs-type">int</span>,low,high <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> high &gt; low&#123;<br>        <span class="hljs-comment">//位置划分</span><br>        pivot := partition(list,low,high)<br>        <span class="hljs-comment">//左边部分排序</span><br>        QuickSort(list,low,pivot<span class="hljs-number">-1</span>)<br>        <span class="hljs-comment">//右边排序</span><br>        QuickSort(list,pivot+<span class="hljs-number">1</span>,high)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestQuickSort</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    list := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">44</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">33</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>,<span class="hljs-number">54</span>,<span class="hljs-number">9</span>&#125;<br>    QuickSort(list,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(list)<span class="hljs-number">-1</span>)<br>    t.Log(list)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quick_sort_partition_animation.gif" alt="快速排序"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入url后发生了什么</title>
    <link href="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器输入url后发生了什么"><a href="#浏览器输入url后发生了什么" class="headerlink" title="浏览器输入url后发生了什么"></a>浏览器输入url后发生了什么</h2><h3 id="1-输入地址"><a href="#1-输入地址" class="headerlink" title="1. 输入地址"></a>1. 输入地址</h3><p>浏览器从历史记录，书签中智能匹配url，甚至从缓存中直接把网页展示出来。</p><h3 id="2-浏览器查找域名对应的IP地址"><a href="#2-浏览器查找域名对应的IP地址" class="headerlink" title="2. 浏览器查找域名对应的IP地址"></a>2. 浏览器查找域名对应的IP地址</h3><ol><li><p>查找本地硬盘的hosts文件，如果有的话直接使用hosts文件中的ip地址。</p></li><li><p>如果hosts文件中没有，则向本地DNS服务器发送请求。本地DNS服务器一般是网络接入供应商提供，比如中国电信，中国移动。</p></li><li><p>本地DNS服务器查缓存，有的话就直接返回。</p></li><li><p>本地DNS服务器缓存没有命中的话，向根服务器查询。</p></li><li><p>根服务器提供下一层级服务器地址。</p></li><li><p>迭代查询直到查询到IP地址。</p></li><li><p>本地DNS服务器向浏览器返回IP地址，并将IP地址记录在自己的缓存中，已备下次使用。</p></li></ol><h3 id="3-浏览器跟web服务器建立TCP连接"><a href="#3-浏览器跟web服务器建立TCP连接" class="headerlink" title="3. 浏览器跟web服务器建立TCP连接"></a>3. 浏览器跟web服务器建立TCP连接</h3><p>通过TCP三次握手，建立连接。</p><h3 id="4-浏览器发送HTTP请求"><a href="#4-浏览器发送HTTP请求" class="headerlink" title="4. 浏览器发送HTTP请求"></a>4. 浏览器发送HTTP请求</h3><p>请求信息包含三个部分：</p><ul><li>请求方法URI协议&#x2F;版本</li><li>请求头(Request Header)</li><li>请求正文</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span>/sample.jspHTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Accept</span>:image/gif.image/jpeg,*/*<br><span class="hljs-attribute">Accept</span>-Language:zh-cn<br><span class="hljs-attribute">Connection</span>:Keep-Alive<br><span class="hljs-attribute">Host</span>:localhost<br><span class="hljs-attribute">User</span>-Agent:Mozila/<span class="hljs-number">4</span>.<span class="hljs-number">0</span>(compatible;MSIE5.<span class="hljs-number">01</span>;Window NT5.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">Accept</span>-Encoding:gzip,deflate<br><br><span class="hljs-attribute">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>TCP三次握手</p><ol><li><p>第一次握手：</p><p>客户端生成数据包：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">SYN</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">seq</span> <span class="hljs-operator">=</span> J (随机生成一个数J)<br></code></pre></td></tr></table></figure><p>发送出数据包后，客户端进入SYN_SENT状态，等待服务端确认。</p></li><li><p>第二次握手：</p><p>服务端收到数据包，生成返回数据包：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">SYN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = K (随机生成一个数K)<br><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = J + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>发送出数据包后，服务端进入SYN_RCVD状态。</p></li><li><p>第三次握手：</p><p>客户端收到数据包，检查ack是否为J+1，ACK是否为1。若正确，则生成数据包：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = K + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>将数据包发出，客户端进入ESTABLISHED状态。</p><p>服务端收到数据包后，检查ack是否为K+1，ACK是否为1。若正确，服务端进入ESTABLISHED状态。</p></li><li><p>完成三次握手，开始传输数据。</p></li></ol><p><img src="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p>为什么需要三次握手</p><p>主要是为了防止服务端一直等待，浪费资源。</p><p>假设没有三次握手，客户端发出的连接请求在网络中滞留了，客户端超时已经释放了连接。服务端接收到请求后，发出确认。确认发出后连接就建立了，服务端就会一直等待客户端发来数据，而客户端实际已经释放了连接，收到确认后不会理睬，这将导致服务端浪费资源。</p><p>TCP四次挥手</p><ol><li><p>第一次挥手：</p><p>客户端发送FIN，用来关闭客户端到服务端的数据传输，客户端进入FIN_WAIT_1状态</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">FIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">seq</span> <span class="hljs-operator">=</span> x<br><span class="hljs-attribute">ack</span> <span class="hljs-operator">=</span> y<br></code></pre></td></tr></table></figure></li><li><p>第二次挥手：</p><p>服务端收到FIN，发送一个ACK给客户端，服务端进入CLOSE_WAIT状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = y<br><span class="hljs-attr">ack</span> = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>客户端收到ACK，进入FIN_WAIT_2状态。</p></li><li><p>第三次挥手：</p><p>服务端处理完剩余数据后，也向客户端发送FIN，服务端进入LAST_ACK状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">FIN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = y<br><span class="hljs-attr">ack</span> = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>第四次挥手：</p><p>客户端收到FIN，发送一个ACK给服务端，客户端进入TIME_WAIT状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = x + <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = y + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>服务端收到ACK，进入CLOSE状态。</p><p><img src="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中的byte类型和rune类型</title>
    <link href="/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.cnblogs.com/wjaaron/p/14822799.html">https://www.cnblogs.com/wjaaron/p/14822799.html</a></p><p>Go 语言中定义字符串要用双引号，而不是单引号，单引号中只能包含一个元素，表示一个字符。</p><p>Go语言中字符有两种类型，分别是：</p><p>uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符<br>rune 类型，代表一个 UTF-8 字符<br>了解编码知识的应该知道，ASCII 编码字符是1个字节的，而 UTF-8 是可变长的编码，当要表示中文等非 ASCll 编码的字符时，需要使用 UTF-8 编码来保证不会乱码。关于字符编码相关知识，推荐看这篇廖雪峰的介绍 字符编码</p><p>假如我们要遍历输出一个包含中文的字符串时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Println(str[i])<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的打印结果是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">104<br>101<br>108<br>108<br>111<br>32<br>228<br>184<br>150<br>231<br>149<br>140<br></code></pre></td></tr></table></figure><p>Go 语言字符串存储的其实是类型为 byte 的只读切片，或者说一个字符串就是一堆字节。在 UTF-8 编码中一个英文字符可以用一个字节存储，一个中文字符需要三个或四个字节存储，而 ASCII 码符号只有 128 个，大于 128 的都不在范围内。上述代码的遍历方式就是以 ASCII 类型来读字符的。</p><p>可以看到输出结果中的前 6 个都是在 ASCII 表中的，但是后 6 个就不在表中了，后面 6 个的每一个字节都不能单独表示一个字符，而是用 3 个在一起才能表示一个字符，明显超出了 ASCII 表的范围，所以当打印具体字符时就会乱码，比如我们现在来打印每一个真实字符，需要使用到占位符 %c：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, str[i]) <span class="hljs-comment">// hello ä¸ç</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello ä¸ç<br></code></pre></td></tr></table></figure><p>明显乱码了。解释这么多就是为了说明如果字符串中有非 ASCII 码的字符时，就不能使用 byte 来表示字符，需要使用 rune 类型来表示。</p><p>使用 rune 类型来遍历字符串<br>在 Go 中，有一个遍历方式是 range，它默认就是以 UTF-8 编码形式去读每一个字符。当涉及到的字符串中含有非英文字符时，可以使用 range 来遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> str &#123;<br>  fmt.Println(r)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">104<br>101<br>108<br>108<br>111<br>32<br>19990<br>30028<br></code></pre></td></tr></table></figure><p>此时输出的字节编码就是 UTF-8 编码号，UTF-8 编码是包含 ASCII 编码的，所以前 6 个编号还是一样的，后面两个编号分别代表世，界。</p><p>修改字符串<br>Go 语言中对字符串的修改其实不是对字符串本身的修改，而是复制字符串，同时修改值，即重新分配来内存，需要先将字符串转化成数组，[]byte 或 []rune，然后再转换成 string 型。</p><p>那么我要说的也很明显了，就是要区别使用 []byte 或 []rune。</p><p>对于全是ASCII编码的字符串，使用 []byte 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;abc&quot;</span><br> s2 := []<span class="hljs-type">byte</span>(str)<br> s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span><br> fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//bbc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; string()表示强制类型转换，转换为字符串<br>对于包含中文等字符的字符串时，那就要用 []rune 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    str:=<span class="hljs-string">&quot;白猫&quot;</span><br>    s2:=[]<span class="hljs-type">rune</span>(str)<br>    s2[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;黑&#x27;</span><br>    fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//黑猫</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结<br>在处理字符时，要考虑字符的编码范围，然后根据需要使用 byte 类型或 rune类型。</p><p>byte 类型只能正常输出 ASCII 编码范围的字符；rune 类型可以输出 UTF-8 编码范围的字符。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang并发编程</title>
    <link href="/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="goroutine的使用"><a href="#goroutine的使用" class="headerlink" title="goroutine的使用"></a>goroutine的使用</h2><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。<br>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。<br>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> hello() <span class="hljs-comment">// 启动另外一个goroutine去执行hello函数</span><br>    fmt.Println(<span class="hljs-string">&quot;main goroutine done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h2><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// goroutine结束就登记-1</span><br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 启动一个goroutine就登记+1</span><br>        <span class="hljs-keyword">go</span> hello(i)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 等待所有登记的goroutine都结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p><h2 id="注意退出"><a href="#注意退出" class="headerlink" title="注意退出"></a>注意退出</h2><p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大纲</title>
    <link href="/2024/12/05/%E5%A4%A7%E7%BA%B2/"/>
    <url>/2024/12/05/%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol><li>为什么对slice append时，要用原来的变量来接收<br>s &#x3D; append(s, 1)</li></ol><p>因为append是一个函数，函数的传参是值拷贝，传进去的s在函数内部已经是另一个s了，而函数外部原来的s.len并不会被改变，所以要用函数返回的新s来覆盖原来的s</p><p>go内存管理<br>go协程原理<br>go并发编程<br>go网络编程</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>测试文章图片：<br><img src="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.jpg" alt="测试"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/10/21/test/"/>
    <url>/2024/10/21/test/</url>
    
    <content type="html"><![CDATA[<p>this is a test.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/20/hello-world/"/>
    <url>/2024/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
