<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go Map</title>
    <link href="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Map"><a href="#Go-Map" class="headerlink" title="Go Map"></a>Go Map</h1><p>map 是一种key-value的键值对存储结构，其中key不能重复，底层用<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=hash%E8%A1%A8&zhida_source=entity">hash表</a>存储。</p><p>平日里我们一般是这样使用map的：</p><blockquote><p>&#x2F;&#x2F; 创建<br>&#x2F;&#x2F; map[KeyType]ValueType<br>var m map[int]int<br>m :&#x3D; make(map[int]int)<br>m :&#x3D; map[int]int{<br>1: 1,<br>2: 2,<br>}<br>&#x2F;&#x2F; 读取<br>i :&#x3D; m[1]<br>v, ok :&#x3D; m[1]<br>​<br>&#x2F;&#x2F; 遍历<br>for key, value :&#x3D; range m {<br>println(“Key: “, key, “Value: “, value)<br>}<br>​<br>&#x2F;&#x2F; 删除<br>delete(m, 1)</p></blockquote><p>map的数据结构在源码结构中的关键字段如下，在<code>src/runtime/map.go</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    count     <span class="hljs-type">int</span>    <span class="hljs-comment">// 元素的个数</span><br>    B         <span class="hljs-type">uint8</span>  <span class="hljs-comment">// buckets 数组的长度就是 2^B 个</span><br>    overflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// 溢出桶的数量</span><br><br>    buckets    unsafe.Pointer <span class="hljs-comment">// 2^B个桶对应的数组指针</span><br>    oldbuckets unsafe.Pointer  <span class="hljs-comment">// 发生扩容时，记录扩容前的buckets数组指针</span><br><br>    extra *mapextra <span class="hljs-comment">//用于保存溢出桶的地址</span><br>&#125;<br><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>    overflow    *[]*bmap<br>    oldoverflow *[]*bmap<br><br>    nextOverflow *bmap<br>&#125;<br><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br><br><span class="hljs-comment">//在编译期间会产生新的结构体</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存储哈希值的高8位</span><br>    data    <span class="hljs-type">byte</span>[<span class="hljs-number">1</span>]  <span class="hljs-comment">//key value数据:key/key/key/.../value/value/value...</span><br>    overflow *bmap   <span class="hljs-comment">//溢出bucket的地址</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了便于理解源码的结构，我们提炼关键字段并转换为图形模式：</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-a8fbef952441e788d882d0656c2cf091_1440w.jpg" alt="img"></p><p>在go的map实现中，它的底层结构体是hmap，hmap里维护着若干个bucket数组 (即桶数组)。</p><p>Bucket数组中每个元素都是bmap结构，也即每个bucket（桶）都是bmap结构，【ps：后文为了语义一致，和方便理解，就不再提bmap了，统一叫作桶】 每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶(溢出桶)。</p><h2 id="map中数据操作"><a href="#map中数据操作" class="headerlink" title="map中数据操作"></a><strong>map中数据操作</strong></h2><p>了解了map的数据结构后，下面让我们学习一下在map中存取数据的过程：</p><h3 id="GET获取数据"><a href="#GET获取数据" class="headerlink" title="GET获取数据"></a><strong>GET获取数据</strong></h3><p><strong>假设当前 B&#x3D;4 即桶数量为2^B&#x3D;16个</strong>，要从map中获取k4对应的value</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>参考上图，k4的get流程可以归纳为如下几步：</strong></p><p>①<strong>计算k4的hash值</strong>。[由于当前主流机都是64位操作系统，所以计算结果有64个比特位]</p><p>②<strong>通过最后的“B”位来确定在哪号桶</strong>，此时B为4，所以取k4对应哈希值的后4位，也就是0101，0101用十进制表示为5，所以在5号桶）</p><p>③<strong>根据k4对应的hash值前8位快速确定是在这个桶的哪个位置</strong>（额外说明一下，在bmap中存放了每个key对应的tophash，是key的哈希值前8位),一旦发现前8位一致，则会执行下一步</p><p>④<strong>对比key完整的hash是否匹配</strong>，如果匹配则获取对应value</p><p>⑤<strong>如果都没有找到，就去连接的下一个溢出桶中找</strong></p><p>有很多同学会问这里为什么要多维护一个tophash，即hash前8位？</p><p>这是因为tophash可以快速确定key是否正确，也可以把它理解成一种缓存措施，如果前8位都不对了，后面就没有必要比较了。</p><h3 id="PUT存放数据"><a href="#PUT存放数据" class="headerlink" title="PUT存放数据"></a><strong>PUT存放数据</strong></h3><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>map的赋值流程可总结位如下几步：</strong></p><p>①<strong>通过key的hash值后“B”位确定是哪一个桶</strong>，图中示例为4号桶。</p><p>② 遍历当前桶，通过key的tophash和hash值，防止key重复，然后<strong>找到第一个可以插入的位置</strong>，即空位置处存储数据。</p><p>③如果<strong>当前桶元素已满，会通过overflow链接创建一个新的桶</strong>，来存储数据。</p><p><strong>关于hash冲突</strong>：当两个不同的 key 落在同一个桶中，就是发生了哈希冲突。冲突的解决手段是采用链表法：在 桶 中，从前往后找到第一个空位进行插入。如果8个kv满了，那么当前桶就会连接到下一个溢出桶（bmap）。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a><strong>扩容</strong></h3><h3 id="扩容的方式"><a href="#扩容的方式" class="headerlink" title="扩容的方式"></a><strong>扩容的方式</strong></h3><p>扩容有两种，一种是等量扩容，另一种是2倍扩容</p><ul><li><strong>相同容量扩容</strong></li></ul><p>由于map中不断的put和delete key，桶中可能会出现很多断断续续的空位，这些空位会导致连接的bmap溢出桶很长，导致扫描时间边长。这种扩容实际上是一种整理，把后置位的数据整理到前面。<strong>这种情况下，元素会发生重排，但不会换桶。</strong></p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-2ecbb8a8c52d395061f67e41620b1504_1440w.jpg" alt="img"></p><p>img</p><ul><li><strong>2倍容量扩容</strong></li></ul><p>这种2倍扩容是由于当前桶数组确实不够用了，<strong>发生这种扩容时，元素会重排，可能会发生桶迁移</strong>。</p><p>如图中所示，扩容前B&#x3D;2,扩容后B&#x3D;3，假设一元素key的hash值后三位为101，那么由上文的介绍可知，在扩容前，由hash值的后两位来决定几号桶，即 01 所以元素在1号桶。 在扩容发生后，由hash值得后三位来决定几号桶，即101所以元素会迁移到5号桶。</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-d38e6d960012d58d4192f904985a4ca1_1440w.jpg" alt="img"></p><p>img</p><h2 id="发生扩容的条件"><a href="#发生扩容的条件" class="headerlink" title="发生扩容的条件"></a><strong>发生扩容的条件</strong></h2><p>首先我们了解下**<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90&zhida_source=entity">装载因子</a>(loadFactor)**的概念</p><p>loadFactor:&#x3D;count &#x2F; (2^B) 即 装载因子 &#x3D; map中元素的个数 &#x2F; map中当前桶的个数</p><p>通过计算公式我们可以得知，<strong>装载因子是指当前map中，每个桶中的平均元素个数。</strong></p><p><strong>扩容条件1</strong>：<strong>装载因子 &gt; 6.5</strong> (源码中定义的)</p><p>这个也非常容易理解，正常情况下，如果没有溢出桶，那么一个桶中最多有8个元素，当平均每个桶中的数据超过了6.5个，那就意味着当前容量要不足了，发生扩容。</p><p><strong>扩容条件2</strong>: <strong>溢出桶的数量过多</strong></p><p>当 B &lt; 15 时，如果overflow的bucket数量超过 2^B。</p><p>当 B &gt;&#x3D; 15 时，overflow的bucket数量超过 2^15。</p><p>简单来讲，新加入key的hash值后B位都一样，使得个别桶一直在插入新数据，进而导致它的溢出桶链条越来越长。如此一来，当map在操作数据时，扫描速度就会变得很慢。及时的扩容，可以对这些元素进行重排，使元素在桶的位置更平均一些。</p><p><strong>扩容时的细节</strong></p><ol><li>在我们的hmap结构中有一个oldbuckets吗，扩容刚发生时，会先将老数据存到这个里面。</li><li>每次对map进行删改操作时，会触发从oldbucket中迁移到bucket的操作【非一次性，分多次】</li><li>在扩容没有完全迁移完成之前，每次get或者put遍历数据时，都会先遍历oldbuckets，然后再遍历buckets。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><p><strong>map是线程不安全的</strong></p><p>在同一时间点，两个 <a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=goroutine&zhida_source=entity">goroutine</a> 对同一个map进行读写操作是不安全的。举个栗子：</p><p>某map桶数量为4，即B&#x3D;2。此时 goroutine1来插入key1， goroutine2来读取 key2. 可能会发生如下过程：</p><p>① goroutine2 计算key2的hash值,B&#x3D;2，并确定桶号为1。</p><p>② goroutine1添加key1，触发扩容条件。</p><p>③ B&#x3D;B+1&#x3D;3, buckets数据迁移到oldbuckets。</p><p>④ goroutine2从桶1中遍历，获取数据失败。</p><p>在工作中，当我们涉及到对一个map进行并发读写时，一般采用的做法是采用golang中自带的<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=mutex%E9%94%81&zhida_source=entity">mutex锁</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">struct</span> &#123;<br>    sync.RWMutex<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := Resource&#123;m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine写map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.Lock()<br>            r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)] = j<br>            r.Unlock()<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine读map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.RLock()<br>            fmt.Println(r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)])<br>            r.RUnlock()<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对map数据进行操作时不可取地址</li></ul><p>因为随着map元素的增长，map底层重新分配空间会导致之前的地址无效。</p><p>[<a href="https://zhuanlan.zhihu.com/p/495998623#ref_1">1]</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/495998623#ref_1_0">^</a>Map <a href="https://juejin.cn/post/7029679896183963678#heading-1">https://juejin.cn/post/7029679896183963678#heading-1</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.jpg" alt="排序算法"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums<br>    &#125;<br>    <span class="hljs-comment">// 冒泡排序核心实现代码</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        flag := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(nums) - i - <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>] &#123;<br>                nums[j], nums[j+<span class="hljs-number">1</span>] = nums[j+<span class="hljs-number">1</span>], nums[j]<br>                flag = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !flag &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br>    nums = bubbleSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.webp" alt="冒泡排序"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(list []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pivot := list[low] <span class="hljs-comment">//导致 low 位置值为空</span><br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        <span class="hljs-comment">//high指针值 &gt;= pivot high指针👈移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &lt;= list[high] &#123;<br>            high--<br>        &#125;<br>        <span class="hljs-comment">//填补low位置空值</span><br>        <span class="hljs-comment">//high指针值 &lt; pivot high值 移到low位置</span><br>        <span class="hljs-comment">//high 位置值空</span><br>        list[low] = list[high]<br>        <span class="hljs-comment">//low指针值 &lt;= pivot low指针👉移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &gt;= list[low] &#123;<br>            low++<br>        &#125;<br>        <span class="hljs-comment">//填补high位置空值</span><br>        <span class="hljs-comment">//low指针值 &gt; pivot low值 移到high位置</span><br>        <span class="hljs-comment">//low位置值空</span><br>        list[high] = list[low]<br>    &#125;<br>    <span class="hljs-comment">//pivot 填补 low位置的空值</span><br>    list[low] = pivot<br>    <span class="hljs-keyword">return</span> low<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(list []<span class="hljs-type">int</span>,low,high <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> high &gt; low&#123;<br>        <span class="hljs-comment">//位置划分</span><br>        pivot := partition(list,low,high)<br>        <span class="hljs-comment">//左边部分排序</span><br>        QuickSort(list,low,pivot<span class="hljs-number">-1</span>)<br>        <span class="hljs-comment">//右边排序</span><br>        QuickSort(list,pivot+<span class="hljs-number">1</span>,high)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestQuickSort</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    list := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">44</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">33</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>,<span class="hljs-number">54</span>,<span class="hljs-number">9</span>&#125;<br>    QuickSort(list,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(list)<span class="hljs-number">-1</span>)<br>    t.Log(list)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quick_sort_partition_animation.gif" alt="快速排序"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中的byte类型和rune类型</title>
    <link href="/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.cnblogs.com/wjaaron/p/14822799.html">https://www.cnblogs.com/wjaaron/p/14822799.html</a></p><p>Go 语言中定义字符串要用双引号，而不是单引号，单引号中只能包含一个元素，表示一个字符。</p><p>Go语言中字符有两种类型，分别是：</p><p>uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符<br>rune 类型，代表一个 UTF-8 字符<br>了解编码知识的应该知道，ASCII 编码字符是1个字节的，而 UTF-8 是可变长的编码，当要表示中文等非 ASCll 编码的字符时，需要使用 UTF-8 编码来保证不会乱码。关于字符编码相关知识，推荐看这篇廖雪峰的介绍 字符编码</p><p>假如我们要遍历输出一个包含中文的字符串时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Println(str[i])<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的打印结果是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">104<br>101<br>108<br>108<br>111<br>32<br>228<br>184<br>150<br>231<br>149<br>140<br></code></pre></td></tr></table></figure><p>Go 语言字符串存储的其实是类型为 byte 的只读切片，或者说一个字符串就是一堆字节。在 UTF-8 编码中一个英文字符可以用一个字节存储，一个中文字符需要三个或四个字节存储，而 ASCII 码符号只有 128 个，大于 128 的都不在范围内。上述代码的遍历方式就是以 ASCII 类型来读字符的。</p><p>可以看到输出结果中的前 6 个都是在 ASCII 表中的，但是后 6 个就不在表中了，后面 6 个的每一个字节都不能单独表示一个字符，而是用 3 个在一起才能表示一个字符，明显超出了 ASCII 表的范围，所以当打印具体字符时就会乱码，比如我们现在来打印每一个真实字符，需要使用到占位符 %c：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, str[i]) <span class="hljs-comment">// hello ä¸ç</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello ä¸ç<br></code></pre></td></tr></table></figure><p>明显乱码了。解释这么多就是为了说明如果字符串中有非 ASCII 码的字符时，就不能使用 byte 来表示字符，需要使用 rune 类型来表示。</p><p>使用 rune 类型来遍历字符串<br>在 Go 中，有一个遍历方式是 range，它默认就是以 UTF-8 编码形式去读每一个字符。当涉及到的字符串中含有非英文字符时，可以使用 range 来遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> str &#123;<br>  fmt.Println(r)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">104<br>101<br>108<br>108<br>111<br>32<br>19990<br>30028<br></code></pre></td></tr></table></figure><p>此时输出的字节编码就是 UTF-8 编码号，UTF-8 编码是包含 ASCII 编码的，所以前 6 个编号还是一样的，后面两个编号分别代表世，界。</p><p>修改字符串<br>Go 语言中对字符串的修改其实不是对字符串本身的修改，而是复制字符串，同时修改值，即重新分配来内存，需要先将字符串转化成数组，[]byte 或 []rune，然后再转换成 string 型。</p><p>那么我要说的也很明显了，就是要区别使用 []byte 或 []rune。</p><p>对于全是ASCII编码的字符串，使用 []byte 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;abc&quot;</span><br> s2 := []<span class="hljs-type">byte</span>(str)<br> s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span><br> fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//bbc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; string()表示强制类型转换，转换为字符串<br>对于包含中文等字符的字符串时，那就要用 []rune 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    str:=<span class="hljs-string">&quot;白猫&quot;</span><br>    s2:=[]<span class="hljs-type">rune</span>(str)<br>    s2[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;黑&#x27;</span><br>    fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//黑猫</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结<br>在处理字符时，要考虑字符的编码范围，然后根据需要使用 byte 类型或 rune类型。</p><p>byte 类型只能正常输出 ASCII 编码范围的字符；rune 类型可以输出 UTF-8 编码范围的字符。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang并发编程</title>
    <link href="/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="goroutine的使用"><a href="#goroutine的使用" class="headerlink" title="goroutine的使用"></a>goroutine的使用</h2><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。<br>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。<br>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> hello() <span class="hljs-comment">// 启动另外一个goroutine去执行hello函数</span><br>    fmt.Println(<span class="hljs-string">&quot;main goroutine done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h2><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// goroutine结束就登记-1</span><br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 启动一个goroutine就登记+1</span><br>        <span class="hljs-keyword">go</span> hello(i)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 等待所有登记的goroutine都结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p><h2 id="注意退出"><a href="#注意退出" class="headerlink" title="注意退出"></a>注意退出</h2><p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大纲</title>
    <link href="/2024/12/05/%E5%A4%A7%E7%BA%B2/"/>
    <url>/2024/12/05/%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol><li>为什么对slice append时，要用原来的变量来接收<br>s &#x3D; append(s, 1)</li></ol><p>因为append是一个函数，函数的传参是值拷贝，传进去的s在函数内部已经是另一个s了，而函数外部原来的s.len并不会被改变，所以要用函数返回的新s来覆盖原来的s</p><p>go内存管理<br>go协程原理<br>go并发编程<br>go网络编程</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>测试文章图片：<br><img src="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.jpg" alt="测试"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/10/21/test/"/>
    <url>/2024/10/21/test/</url>
    
    <content type="html"><![CDATA[<p>this is a test.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/20/hello-world/"/>
    <url>/2024/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
