<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go算法题-六</title>
    <link href="/2025/06/12/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%85%AD/"/>
    <url>/2025/06/12/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="Go算法题-六"><a href="#Go算法题-六" class="headerlink" title="Go算法题-六"></a>Go算法题-六</h1><h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span>  &#123;<br>    k = k % <span class="hljs-built_in">len</span>(nums)<br>    reverse(nums)<br>    reverse(nums[:k])<br>    reverse(nums[k:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a); i &lt; n / <span class="hljs-number">2</span>; i ++ &#123;<br>        a[i], a[n<span class="hljs-number">-1</span>-i] = a[n<span class="hljs-number">-1</span>-i], a[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;<br>    row := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(matrix))<br>    col := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> matrix &#123;<br>        <span class="hljs-keyword">for</span> j, v := <span class="hljs-keyword">range</span> r &#123;<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>                row[i] = <span class="hljs-literal">true</span><br>                col[j] = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> matrix &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> r &#123;<br>            <span class="hljs-keyword">if</span> row[i] || col[j] &#123;<br>                r[j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *Node</span><br><span class="hljs-comment"> *     Random *Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> cachedNode <span class="hljs-keyword">map</span>[*Node]*Node<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deepCopy</span><span class="hljs-params">(node *Node)</span></span> *Node &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n, has := cachedNode[node]; has &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    newNode := &amp;Node&#123;Val: node.Val&#125;<br>    cachedNode[node] = newNode<br>    newNode.Next = deepCopy(node.Next)<br>    newNode.Random = deepCopy(node.Random)<br>    <span class="hljs-keyword">return</span> newNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span></span> *Node &#123;<br>    cachedNode = <span class="hljs-keyword">map</span>[*Node]*Node&#123;&#125;<br>    <span class="hljs-keyword">return</span> deepCopy(head)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, left, right <span class="hljs-type">int</span>)</span></span> * TreeNode &#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right) / <span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>    root.Left = helper(nums, left, mid<span class="hljs-number">-1</span>)<br>    root.Right = helper(nums, mid+<span class="hljs-number">1</span>, right)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    list := preorderTraversal(root)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>        prev, curr := list[i<span class="hljs-number">-1</span>], list[i]<br>        prev.Left, prev.Right = <span class="hljs-literal">nil</span>, curr<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []*TreeNode &#123;<br>    list := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        list = <span class="hljs-built_in">append</span>(list, root)<br>        list = <span class="hljs-built_in">append</span>(list, preorderTraversal(root.Left)...)<br>        list = <span class="hljs-built_in">append</span>(list, preorderTraversal(root.Right)...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    ans := <span class="hljs-number">0</span><br>    preSum := <span class="hljs-keyword">map</span>[<span class="hljs-type">int64</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>&#125;<br>    <br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode, <span class="hljs-type">int64</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, curr <span class="hljs-type">int64</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        curr += <span class="hljs-type">int64</span>(node.Val)<br>        ans += preSum[curr-<span class="hljs-type">int64</span>(targetSum)]<br>        preSum[curr]++<br>        dfs(node.Left, curr)<br>        dfs(node.Right, curr)<br>        preSum[curr]--<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    dfs(root, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 总行数</span><br>    R := <span class="hljs-built_in">len</span>(grid)<br>    <span class="hljs-comment">// 总列数</span><br>    C := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 上下左右四个方向</span><br>    dr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>    dc := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br><br>    <span class="hljs-comment">// 用于辅助层次遍历</span><br>    queue := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 用于记录到达每个点位对应的深度</span><br>    depth := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 记录首层点位，深度均为0</span><br>    <span class="hljs-keyword">for</span> r := <span class="hljs-number">0</span>; r &lt; R; r++ &#123;<br>        <span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; C; c++ &#123;<br>            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-number">2</span> &#123;<br>                code := r * C + c<br>                queue = <span class="hljs-built_in">append</span>(queue, code)<br>                depth[code] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 进行层序遍历</span><br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        code := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        r := code / C<br>        c := code % C<br>        <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++ &#123;<br>            nr := r + dr[k]<br>            nc := c + dc[k]<br>            <span class="hljs-keyword">if</span> nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="hljs-number">1</span> &#123;<br>                grid[nr][nc] = <span class="hljs-number">2</span><br>                ncode := nr * C + nc<br>                queue = <span class="hljs-built_in">append</span>(queue, ncode)<br>                depth[ncode] = depth[code] + <span class="hljs-number">1</span><br>                <span class="hljs-comment">// 每次进入该if条件，则意味着到达了一个新鲜橘子，深度加1</span><br>                ans = depth[ncode]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否还有新鲜橘子</span><br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 记录所有节点的边，edges[i]含义为第i个节点所指向的所有节点</span><br>    edges := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-comment">// 记录每个节点的入度，即有多少个节点指向它</span><br>    indeg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-comment">// 记录拓扑排序，如果所有节点存在拓扑排序，则课程能正常修完</span><br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 保存所有节点的边和入度</span><br>    <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        edges[info[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(edges[info[<span class="hljs-number">1</span>]], info[<span class="hljs-number">0</span>])<br>        indeg[info[<span class="hljs-number">0</span>]]++<br>    &#125;<br><br>    <span class="hljs-comment">// 先将入度为0的节点入队</span><br>    q := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>        <span class="hljs-keyword">if</span> indeg[i] == <span class="hljs-number">0</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, i)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 广度优先搜索</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        u := q[<span class="hljs-number">0</span>]<br>        q = q[<span class="hljs-number">1</span>:]<br>        result = <span class="hljs-built_in">append</span>(result, u)<br>        <span class="hljs-comment">// 将u入队后，检查u指向的所有节点，将其入度减1</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> edges[u] &#123;<br>            indeg[v]--<br>            <span class="hljs-keyword">if</span> indeg[v] == <span class="hljs-number">0</span> &#123;<br>                q = <span class="hljs-built_in">append</span>(q, v)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(result) == numCourses<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>    children [<span class="hljs-number">26</span>]*Trie<br>    isEnd <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;<br>    <span class="hljs-keyword">return</span> Trie&#123;&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  &#123;<br>    node := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>        ch -= <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[ch] == <span class="hljs-literal">nil</span> &#123;<br>            node.children[ch] = &amp;Trie&#123;&#125;<br>        &#125;<br>        node = node.children[ch]<br>    &#125;<br>    node.isEnd = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> SearchPrefix(prefix <span class="hljs-type">string</span>) *Trie &#123;<br>    node := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> prefix &#123;<br>        ch -= <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[ch] == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        node = node.children[ch]<br>    &#125;<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    node := this.SearchPrefix(word)<br>    <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nil</span> &amp;&amp; node.isEnd<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> this.SearchPrefix(prefix) != <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Insert(word);</span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123;<br>    x <span class="hljs-type">int</span><br>    y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> directions = []pair&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    R := <span class="hljs-built_in">len</span>(board)<br>    C := <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, R)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> visit &#123;<br>        visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, C)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> check <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br>    check = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">if</span> board[i][j] != word[k] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        visit[i][j] = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            visit[i][j] = <span class="hljs-literal">false</span><br>        &#125;()<br><br>        <span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> directions &#123;<br>            newI := i + dir.x<br>            newJ := j + dir.y<br>            <span class="hljs-keyword">if</span> newI &gt;= <span class="hljs-number">0</span> &amp;&amp; newI &lt; R &amp;&amp; newJ &gt;= <span class="hljs-number">0</span> &amp;&amp; newJ &lt; C &amp;&amp; !visit[newI][newJ] &#123;<br>                <span class="hljs-keyword">if</span> check(newI, newJ, k+<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> board &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> check(i, j, <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    f := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f &#123;<br>        f[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> f[i] &#123;<br>            f[i][j] = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            f[i][j] = s[i] == s[j] &amp;&amp; f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    ans := [][]<span class="hljs-type">string</span>&#123;&#125;<br><br>    splits := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> i == n &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, <span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>), splits...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> f[i][j] &#123;<br>                splits = <span class="hljs-built_in">append</span>(splits, s[i:j+<span class="hljs-number">1</span>])<br>                dfs(j+<span class="hljs-number">1</span>)<br>                <span class="hljs-comment">// 放弃当前拆分方案，回退到原状</span><br>                splits = splits[:<span class="hljs-built_in">len</span>(splits)<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> solutions [][]<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 保存最终结果</span><br>    solutions = [][]<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录每一行的皇后放置在哪一列</span><br>    queens := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        queens[i] = <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-comment">// 记录哪些列已经放置了皇后</span><br>    columns := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录哪些对角已经放置了皇后</span><br>    diagonals1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    diagonals2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br><br>    backtrack(queens, n, <span class="hljs-number">0</span>, columns, diagonals1, diagonals2)<br><br>    <span class="hljs-keyword">return</span> solutions<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, n, row <span class="hljs-type">int</span>, columns, diagonals1, diagonals2 <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 如果row == n 说明已经产生了一个正确答案</span><br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        board := generateBoard(queens, n)<br>        solutions = <span class="hljs-built_in">append</span>(solutions, board)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 针对当前第row行，枚举每个列的位置，判断时候能放置皇后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果该列已经放置了皇后，继续下一列</span><br>        <span class="hljs-keyword">if</span> columns[i] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 如果对角已经放置了皇后，继续下一列</span><br>        diag1 := row - i<br>        <span class="hljs-keyword">if</span> diagonals1[diag1] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        diag2 := row + i<br>        <span class="hljs-keyword">if</span> diagonals2[diag2] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 记录第row行的皇后放置位置</span><br>        queens[row] = i<br>        <span class="hljs-comment">// 标记第i列已经放置皇后</span><br>        columns[i] = <span class="hljs-literal">true</span><br>        <span class="hljs-comment">// 标记对应的对角已经放置了皇后</span><br>        diagonals1[diag1] = <span class="hljs-literal">true</span><br>        diagonals2[diag2] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 在第row行放置了一个位置之后，继续进行下一行判断</span><br>        backtrack(queens, n, row+<span class="hljs-number">1</span>, columns, diagonals1, diagonals2)<br><br>        <span class="hljs-comment">// 恢复原本状态，继续寻找第row行的下一个解</span><br>        queens[row] = <span class="hljs-number">-1</span><br>        <span class="hljs-built_in">delete</span>(columns, i)<br>        <span class="hljs-built_in">delete</span>(diagonals1, diag1)<br>        <span class="hljs-built_in">delete</span>(diagonals2, diag2)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateBoard</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    board := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        row := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            row[j] = <span class="hljs-string">&#x27;.&#x27;</span><br>        &#125;<br>        row[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>        board = <span class="hljs-built_in">append</span>(board, <span class="hljs-type">string</span>(row))<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> board<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 核心思想：如果右半边升序，则最小值一定在左半边</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    low := <span class="hljs-number">0</span><br>    high := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        mid := (low + high) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[high] &#123;<br>            high = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[low]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(temperatures)<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        t := temperatures[i]<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; t &gt; temperatures[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &#123;<br>            idx := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            ans[idx] = i - idx<br>        &#125;<br>        stack = <span class="hljs-built_in">append</span>(stack, i)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    occur := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        occur[num]++<br>    &#125;<br><br>    h := &amp;IHeap&#123;&#125;<br>    heap.Init(h)<br><br>    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> occur &#123;<br>        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key, value&#125;)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123;<br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br>    ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        ret[k-i<span class="hljs-number">-1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-keyword">type</span> IHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>] &lt; h[j][<span class="hljs-number">1</span>]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;h[i], h[j] = h[j], h[i]&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>: n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MedianFinder <span class="hljs-keyword">struct</span> &#123;<br>    maxHeap *MaxHeap <span class="hljs-comment">// 存储较小的一半数字</span><br>    minHeap *MinHeap <span class="hljs-comment">// 存储较大的一半数字</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MedianFinder &#123;<br>    mf := MedianFinder&#123;<br>        maxHeap: &amp;MaxHeap&#123;&#125;,<br>        minHeap: &amp;MinHeap&#123;&#125;,<br>    &#125;<br>    heap.Init(mf.maxHeap)<br>    heap.Init(mf.minHeap)<br>    <span class="hljs-keyword">return</span> mf<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> AddNum(num <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-comment">// 总是先加入最大堆</span><br>    heap.Push(this.maxHeap, num)<br><br>    <span class="hljs-comment">// 将最大堆的最大值移到最小堆</span><br>    heap.Push(this.minHeap, heap.Pop(this.maxHeap))<br><br>    <span class="hljs-comment">// 如果最大堆的大小小于最小堆，平衡两个堆</span><br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() &lt; this.minHeap.Len() &#123;<br>        heap.Push(this.maxHeap, heap.Pop(this.minHeap))<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> FindMedian() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 或者根据需求返回其他默认值</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() &gt; this.minHeap.Len() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>((*this.maxHeap)[<span class="hljs-number">0</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">float64</span>((*this.maxHeap)[<span class="hljs-number">0</span>]) + <span class="hljs-type">float64</span>((*this.minHeap)[<span class="hljs-number">0</span>])) / <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-comment">// 最大堆（存储较小的一半数字）</span><br><span class="hljs-keyword">type</span> MaxHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &gt; h[j]&#125; <span class="hljs-comment">// 注意这里是 &gt;，实现最大堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Push(x any) &#123;*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Pop() any &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// 最小堆（存储较大的一半数字）</span><br><span class="hljs-keyword">type</span> MinHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &lt; h[j]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MinHeap)</span></span> Push(x any) &#123;*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MinHeap)</span></span> Pop() any &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.AddNum(num);</span><br><span class="hljs-comment"> * param_2 := obj.FindMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux下查看日志常用命令</title>
    <link href="/2025/05/25/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2025/05/25/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux查看日志常用命令"><a href="#Linux查看日志常用命令" class="headerlink" title="Linux查看日志常用命令"></a>Linux查看日志常用命令</h2><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>-f 实时监控</p><p>-n 指定行数</p><p>-c 指定字符数</p><p><code>tail test.log</code> 默认显示最后10行</p><p><code>tail -n +20 test.log</code> 显示从第20行至末尾。</p><p><code>tail -f test.log</code> 默认显示最后10行，并实时监控，若有新增加的行则继续显示，直到退出程序。</p><p><code>tail -c 10 notes.log</code> 显示最后10个字符</p><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>与tail相反</p><p><code>head test.log</code> 默认显示开头10行</p><p><code>head -n 20 test.log</code> 显示开头20行</p><p><code>head -c 20 test.log</code> 显示开头20个字符</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-5</title>
    <link href="/2025/05/21/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%94/"/>
    <url>/2025/05/21/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 利用性质 + 每次二分丢弃一半选项</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-comment">// 辅助函数，输入下标 i，返回 nums[i] 的值</span><br>    <span class="hljs-comment">// 方便处理 nums[-1] 以及 nums[n] 的边界情况</span><br>    get := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> || i == n &#123;<br>            <span class="hljs-keyword">return</span> math.MinInt64<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[i]<br>    &#125;<br><br>    left := <span class="hljs-number">0</span><br>    right := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> get(mid<span class="hljs-number">-1</span>) &lt; get(mid) &amp;&amp; get(mid) &gt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-keyword">if</span> get(mid) &lt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<br>            res = max(dfs(grid, i, j), res)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == <span class="hljs-built_in">len</span>(grid) || j == <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) || grid[i][j] != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    grid[i][j] = <span class="hljs-number">0</span><br>    area := <span class="hljs-number">1</span><br>    di := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;<br>    dj := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(di); k++ &#123;<br>        area += dfs(grid, i+di[k], j+dj[k])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> area<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    nodes := []<span class="hljs-type">int</span>&#123;&#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        nodes = <span class="hljs-built_in">append</span>(nodes, node.Val)<br>        sum += node.Val<br>        <span class="hljs-keyword">if</span> sum == targetSum &#123;<br>            <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>                res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, nodes...))<br>            &#125;<br>        &#125;<br>        dfs(node.Left)<br>        dfs(node.Right)<br>        sum -= node.Val<br>        nodes = nodes[:<span class="hljs-built_in">len</span>(nodes)<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    dfs(root)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 广度优先搜索 + 二叉树节点编号性质</span><br><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span> &#123;<br>    node *TreeNode<br>    index <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    q := []pair&#123;&#123;root, <span class="hljs-number">1</span>&#125;&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        res = max(res, q[<span class="hljs-built_in">len</span>(q)<span class="hljs-number">-1</span>].index - q[<span class="hljs-number">0</span>].index + <span class="hljs-number">1</span>)<br>        tmp := []pair&#123;&#125;<br>        <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> q &#123;<br>            <span class="hljs-keyword">if</span> p.node.Left != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, pair&#123;p.node.Left, p.index * <span class="hljs-number">2</span>&#125;)<br>            &#125;<br>            <span class="hljs-keyword">if</span> p.node.Right != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, pair&#123;p.node.Right, p.index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125;)<br>            &#125;<br>        &#125;<br>        q = tmp<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := nums[<span class="hljs-number">0</span>]<br>    mx := nums[<span class="hljs-number">0</span>]<br>    mn := nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// 这里mx，mn的计算互不干扰，均使用上一次的结果计算</span><br>        mx, mn = max(nums[i], max(mx * nums[i], mn * nums[i])), min(nums[i], min(mx * nums[i], mn * nums[i]))<br>        res = max(res, mx)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> targetSum == root.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 如果只有一间房，则偷取该间房</span><br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 如果有两间房，则偷取金额大的那一间</span><br>    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果偷取第i间房，则到达i位置时的总金额为，前i-2间房偷到的数额加上第i间房</span><br>        <span class="hljs-comment">// 如果不偷第i间房，则到达i位置时的总金额为，前i-1间房偷到的总数额</span><br>        dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 记录最终结果</span><br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 记录从开头到当前位置的和</span><br>    pre := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// key：前缀和，value：个数</span><br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        pre += nums[i]<br>        <span class="hljs-keyword">if</span> _, ok := m[pre-k]; ok &#123;<br>            count += m[pre-k]<br>        &#125;<br>        m[pre] += <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 摩尔投票法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-number">0</span><br>    candidate := nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> &#123;<br>            candidate = num<br>        &#125;<br>        <span class="hljs-keyword">if</span> num == candidate &#123;<br>            count += <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count -= <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> candidate<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    preSign := <span class="hljs-string">&#x27;+&#x27;</span><br>    num := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s &#123;<br>        isDigit := <span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span><br>        <span class="hljs-keyword">if</span> isDigit &#123;<br>            num = num*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(ch-<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> !isDigit &amp;&amp; ch != <span class="hljs-string">&#x27; &#x27;</span> || i == <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">switch</span> preSign &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    stack = <span class="hljs-built_in">append</span>(stack, num)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    stack = <span class="hljs-built_in">append</span>(stack, -num)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] *= num<br>                <span class="hljs-keyword">default</span>:<br>                    stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] /= num<br>            &#125;<br>            preSign = ch<br>            num = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> stack &#123;<br>        res += v<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    cur := head<br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> cur.Val == cur.Next.Val &#123;<br>            cur.Next = cur.Next.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums1)<br>    m := <span class="hljs-built_in">len</span>(nums2)<br><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// dp[i][j]含义：nums1[:i+1]和nums2[:j+1]的最长公共后缀</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>        <span class="hljs-keyword">if</span> nums1[i] == nums2[<span class="hljs-number">0</span>] &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>        <span class="hljs-keyword">if</span> nums1[<span class="hljs-number">0</span>] == nums2[j] &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; m; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i] == nums2[j] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>                res = max(res, dp[i][j])<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-四</title>
    <link href="/2025/05/19/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%9B%9B/"/>
    <url>/2025/05/19/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    comb := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 当前索引超过了数组总长度</span><br>        <span class="hljs-keyword">if</span> idx == <span class="hljs-built_in">len</span>(candidates) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// target减到了0，说明找到了一个答案</span><br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, comb...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 考虑选择当前元素</span><br>        <span class="hljs-keyword">if</span> target - candidates[idx] &gt;= <span class="hljs-number">0</span> &#123;<br>            comb = <span class="hljs-built_in">append</span>(comb, candidates[idx])<br>            dfs(target-candidates[idx], idx)<br>            comb = comb[:<span class="hljs-built_in">len</span>(comb)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// 不考虑当前元素</span><br>        dfs(target, idx+<span class="hljs-number">1</span>)<br>    &#125;<br>    dfs(target, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    stack := []<span class="hljs-type">string</span>&#123;&#125;<br>    p := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> p &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        cur := s[p]<br>        <span class="hljs-comment">// 如果遍历到数字，就取出所有的后续数字，得到整数字符串后，将其压入栈中</span><br>        <span class="hljs-keyword">if</span> cur &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>            digits := getDigits(s, &amp;p)<br>            stack = <span class="hljs-built_in">append</span>(stack, digits)<br>        <span class="hljs-comment">// 如果遇到字符或左括号，直接压栈</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || cur &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || cur == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-type">string</span>(cur))<br>            p++<br>        <span class="hljs-comment">// 如果遇到右括号</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 持续出栈字符，直到遇到左括号，此时sub中保存了所有的出栈字符</span><br>            sub := []<span class="hljs-type">string</span>&#123;&#125;<br>            <span class="hljs-keyword">for</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != <span class="hljs-string">&quot;[&quot;</span> &#123;<br>                sub = <span class="hljs-built_in">append</span>(sub, stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            &#125;<br>            <span class="hljs-comment">// 将sub中的字符反转，得到正常的字符顺序</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sub)/<span class="hljs-number">2</span>; i++ &#123;<br>                sub[i], sub[<span class="hljs-built_in">len</span>(sub)<span class="hljs-number">-1</span>-i] = sub[<span class="hljs-built_in">len</span>(sub)<span class="hljs-number">-1</span>-i], sub[i]<br>            &#125;<br><br>            <span class="hljs-comment">// 将左括号出栈</span><br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br><br>            <span class="hljs-comment">// 此时栈顶保存的是整数，将此整数出栈，并进行重复处理</span><br>            repTime, _ := strconv.Atoi(stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            t := strings.Repeat(getString(sub), repTime)<br>            <span class="hljs-comment">// 重点，将重复后的字符串重新压入栈中</span><br>            stack = <span class="hljs-built_in">append</span>(stack, t)<br><br>            <span class="hljs-comment">// 继续判断下一个字符</span><br>            p++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> getString(stack)<br>&#125;<br><br><span class="hljs-comment">// 取出所有的后续数字，组成一个整数字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getDigits</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> ; s[*p] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[*p] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; *p++ &#123;<br>        res += <span class="hljs-type">string</span>(s[*p])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getString</span><span class="hljs-params">(v []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> v &#123;<br>        res += s<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> abs(height(root.Left) - height(root.Right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">height</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(height(root.Left), height(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> * x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    rows := <span class="hljs-built_in">len</span>(grid)<br>    cols := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, rows)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dp); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, cols)<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; rows; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; cols; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][j]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; rows; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; cols; j++ &#123;<br>            dp[i][j] = min(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]) + grid[i][j]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[rows<span class="hljs-number">-1</span>][cols<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">``</span><span class="hljs-string">`</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">## [470. 用 Rand7() 实现 Rand10()](https://leetcode.cn/problems/implement-rand10-using-rand7/)</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><span class="hljs-keyword">go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        row := rand7()<br>        col := rand7()<br>        idx := (row<span class="hljs-number">-1</span>)*<span class="hljs-number">7</span> + col<br>        <span class="hljs-keyword">if</span> idx &lt;= <span class="hljs-number">40</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + (idx<span class="hljs-number">-1</span>)%<span class="hljs-number">10</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(matrix)<br>    n := <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    x := <span class="hljs-number">0</span><br>    y := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> matrix[x][y] == target &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">// 如果当前元素大，就往小了走，往小了走就是往左移动</span><br>        <span class="hljs-keyword">if</span> matrix[x][y] &gt; target &#123;<br>            y--<br>        <span class="hljs-comment">// 如果当前元素小，就往大了走，往大了走就是往下走</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(root *TreeNode, lower, upper <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> depth <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span><br>    depth = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        l := depth(root.Left)<br>        r := depth(root.Right)<br><br>        res = max(res, l + r + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">return</span> max(l, r) + <span class="hljs-number">1</span><br>    &#125;<br><br>    depth(root)<br><br>    <span class="hljs-keyword">return</span> res - <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSide := <span class="hljs-number">0</span><br><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix[i]))<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            dp[i][j] = <span class="hljs-type">int</span>(matrix[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                maxSide = <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                dp[i][j] = min(min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> dp[i][j] &gt; maxSide &#123;<br>                    maxSide = dp[i][j]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSide * maxSide<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    numSet := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        numSet[num] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    maxLength := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> numSet &#123;<br>        <span class="hljs-keyword">if</span> !numSet[num<span class="hljs-number">-1</span>] &#123;<br>            curNum := num<br>            curLength := <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> numSet[curNum+<span class="hljs-number">1</span>] &#123;<br>                curNum++<br>                curLength++<br>            &#125;<br>            <span class="hljs-keyword">if</span> curLength &gt; maxLength &#123;<br>                maxLength = curLength<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLength<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 贪心法，只能用于计算最大利润</span><br><span class="hljs-comment">// 思想：所有的利润都要有，所有的亏损都不要。即：只要后一天比前一天价格高，这部分差价就是利润</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        res += max(<span class="hljs-number">0</span>, prices[i]-prices[i<span class="hljs-number">-1</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// // 递归，本质是利用栈</span><br><span class="hljs-comment">// func isPalindrome(head *ListNode) bool &#123;</span><br><span class="hljs-comment">//     // 递归函数外指针，指向链表头部</span><br><span class="hljs-comment">//     p := head</span><br><br><span class="hljs-comment">//     var check func(*ListNode) bool</span><br><span class="hljs-comment">//     check = func(node *ListNode) bool &#123;</span><br><span class="hljs-comment">//         if node != nil &#123;</span><br><span class="hljs-comment">//             // 一开始就进入递归，实际效果上会把当前节点压入函数栈中，并且会一直压到最后一个节点</span><br><span class="hljs-comment">//             // 当开始出栈时，实际就是从最后一个节点往前遍历了</span><br><span class="hljs-comment">//             if !check(node.Next) &#123;</span><br><span class="hljs-comment">//                 return false</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//             // 判断递归外指针与当前节点的值</span><br><span class="hljs-comment">//             if node.Val != p.Val &#123;</span><br><span class="hljs-comment">//                 return false</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//             // 外指针向后移动一位</span><br><span class="hljs-comment">//             p = p.Next</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//         return true</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-comment">//     return check(head)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 快慢指针找中点 + 反转链表 + 遍历对比</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> prev, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        nextTmp := cur.Next<br>        cur.Next = prev<br>        prev = cur<br>        cur = nextTmp<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">endOfFirstHalf</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    fast := head<br>    slow := head<br>    <span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 找到前半部分链表的尾节点并反转后半部分链表</span><br>    firstHalfEnd := endOfFirstHalf(head)<br>    secondHalfStart := reverseList(firstHalfEnd.Next)<br><br>    <span class="hljs-comment">// 判断是否回文</span><br>    p1 := head<br>    p2 := secondHalfStart<br>    result := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> result &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1.Val != p2.Val &#123;<br>            result = <span class="hljs-literal">false</span><br>        &#125;<br>        p1 = p1.Next<br>        p2 = p2.Next<br>    &#125;<br><br>    <span class="hljs-comment">// 还原链表并返回结果</span><br>    firstHalfEnd.Next = reverseList(secondHalfStart)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-三</title>
    <link href="/2025/05/13/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%89/"/>
    <url>/2025/05/13/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    l := <span class="hljs-number">0</span><br>    r := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>            l = mid + <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            r = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>    inStack, outStack []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br>    <span class="hljs-keyword">return</span> MyQueue&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>    q.inStack = <span class="hljs-built_in">append</span>(q.inStack, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> in2out() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.inStack) &gt; <span class="hljs-number">0</span> &#123;<br>        q.outStack = <span class="hljs-built_in">append</span>(q.outStack, q.inStack[<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>])<br>        q.inStack = q.inStack[:<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;<br>        q.in2out()<br>    &#125;<br>    x := q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>    q.outStack = q.outStack[:<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;<br>        q.in2out()<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.inStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 归并排序两个有序链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(head1, head2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p, p1, p2 := dummy, head1, head2<br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1.Val &lt; p2.Val &#123;<br>            p.Next = p1<br>            p1 = p1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = p2<br>            p2 = p2.Next<br>        &#125;<br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> p1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p1<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p2 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p2<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-comment">// 拆分一个链表，分别递归排序，将排好序的两个链表合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(head, tail *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    <br>    <span class="hljs-comment">// 丢弃尾部节点，避免重复</span><br>    <span class="hljs-keyword">if</span> head.Next == tail &#123;<br>        head.Next = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != tail &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>        <span class="hljs-keyword">if</span> fast != tail &#123;<br>            fast = fast.Next<br>        &#125;<br>    &#125;<br><br>    mid := slow<br>    <span class="hljs-comment">// 这里将mid分别作为头和尾递归传递，但作为尾部的mid最终会被丢弃，不会出现mid节点重复的问题</span><br>    <span class="hljs-keyword">return</span> merge(sort(head, mid), sort(mid, tail))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> sort(head, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 用于保存结果集</span><br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 用于保存每一步的结果</span><br>    tmp := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 回溯法，每个位置上要么放左括号，要么放右括号</span><br>    <span class="hljs-comment">// 放的时候校验下合不合法</span><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leftCount, rightCount <span class="hljs-type">int</span>)</span></span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leftCount, rightCount <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 长度达到2n，找到一个答案，加入结果集</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp) == <span class="hljs-number">2</span>*n &#123;<br>            res = <span class="hljs-built_in">append</span>(res, strings.Join(tmp, <span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 只要左括号数量小于n，当前位置放左括号就是合法的</span><br>        <span class="hljs-keyword">if</span> leftCount &lt; n &#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-string">&quot;(&quot;</span>)<br>            backtrack(leftCount+<span class="hljs-number">1</span>, rightCount)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// 只要右括号数量小于左括号，当前位置放右括号就是合法的</span><br>        <span class="hljs-keyword">if</span> rightCount &lt; leftCount &#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-string">&quot;)&quot;</span>)<br>            backtrack(leftCount, rightCount+<span class="hljs-number">1</span>)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 唉，背诵题，原理看题解吧</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    i := n - <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>] &#123;<br>        i--<br>    &#125;<br>    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        j := n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j] &#123;<br>            j--<br>        &#125;<br>        nums[i], nums[j] = nums[j], nums[i]<br>    &#125;<br>    reverse(nums[i+<span class="hljs-number">1</span>:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a); i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br>        a[i], a[n<span class="hljs-number">-1</span>-i] = a[n<span class="hljs-number">-1</span>-i], a[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    v1 := strings.Split(version1, <span class="hljs-string">&quot;.&quot;</span>)<br>    v2 := strings.Split(version2, <span class="hljs-string">&quot;.&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(v1) || i &lt; <span class="hljs-built_in">len</span>(v2); i++ &#123;<br>        x, y := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(v1) &#123;<br>            x, _ = strconv.Atoi(v1[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(v2) &#123;<br>            y, _ = strconv.Atoi(v2[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> x &gt; y &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> x &lt; y &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, x<br>    ans := <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> mid * mid &lt;= x &#123;<br>            ans = mid<br>            l = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 去除前导空格</span><br>s = strings.TrimLeft(s, <span class="hljs-string">&quot; &quot;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 处理符号</span><br>sign := <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>sign = <span class="hljs-number">-1</span><br>s = s[<span class="hljs-number">1</span>:]<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> &#123;<br>s = s[<span class="hljs-number">1</span>:]<br>&#125;<br><br><span class="hljs-keyword">var</span> result <span class="hljs-type">int64</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-comment">// 遇到非数字字符则停止</span><br><span class="hljs-keyword">if</span> ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br>digit := <span class="hljs-type">int64</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>)<br>result = result*<span class="hljs-number">10</span> + digit<br><br><span class="hljs-comment">// 检查溢出</span><br><span class="hljs-keyword">if</span> sign == <span class="hljs-number">1</span> &amp;&amp; result &gt; math.MaxInt32 &#123;<br><span class="hljs-keyword">return</span> math.MaxInt32<br>&#125;<br><span class="hljs-keyword">if</span> sign == <span class="hljs-number">-1</span> &amp;&amp; -result &lt; math.MinInt32 &#123;<br><span class="hljs-keyword">return</span> math.MinInt32<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 应用符号</span><br>final := <span class="hljs-type">int64</span>(sign) * result<br><br><span class="hljs-comment">// 确保结果在32位整数范围内</span><br><span class="hljs-keyword">if</span> final &gt; math.MaxInt32 &#123;<br><span class="hljs-keyword">return</span> math.MaxInt32<br>&#125;<br><span class="hljs-keyword">if</span> final &lt; math.MinInt32 &#123;<br><span class="hljs-keyword">return</span> math.MinInt32<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(final)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p := dummy<br>    digit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> || l2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">var</span> v1, v2 <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> l1 != <span class="hljs-literal">nil</span> &#123;<br>            v1 = l1.Val<br>            l1 = l1.Next<br>        &#125;<br>        <span class="hljs-keyword">if</span> l2 != <span class="hljs-literal">nil</span> &#123;<br>            v2 = l2.Val<br>            l2 = l2.Next<br>        &#125;<br><br>        sum := v1 + v2 + digit<br>        <br>        val := sum % <span class="hljs-number">10</span><br><br>        node := &amp;ListNode&#123;Val: val&#125;<br>        p.Next = node<br>        p = p.Next<br><br>        digit = sum / <span class="hljs-number">10</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> digit != <span class="hljs-number">0</span> &#123;<br>        p.Next = &amp;ListNode&#123;Val: digit&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 用于保存最终结果</span><br>    res := <span class="hljs-number">0</span><br>    <br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-comment">// 为了初始时方便，提前压入-1</span><br>    stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-comment">// 如果是左括号，就压入栈中</span><br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, i)<br>        <span class="hljs-comment">// 如果是右括号，就将栈顶元素出栈（除了栈底元素，栈中肯定全部都是左括号。栈底元素是遍历过的最后的没有被匹配的右括号）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            <span class="hljs-comment">// 如果出栈后栈空了，就说明栈底的右括号被出栈了，那么当前的右括号就成了新的不能被匹配的右括号，压入栈中成为新的栈底</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, i)<br>            <span class="hljs-comment">// 实时更新最长的匹配长度</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res = max(res, i - stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt; n + <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    root := &amp;TreeNode&#123;preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br><br>    <span class="hljs-comment">// 找到中序遍历中的根节点</span><br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 中序遍历根节点左边的节点为左子树，右边的节点为右子树</span><br>    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>], inorder[:i])<br>    root.Right = buildTree(preorder[<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>:], inorder[i+<span class="hljs-number">1</span>:])<br><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    set := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cur <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 如果长度已经超过了nums长度，说明已经得到了一个结果</span><br>        <span class="hljs-keyword">if</span> cur == <span class="hljs-built_in">len</span>(nums) &#123;<br>            <span class="hljs-comment">// 这里要注意，不要把set直接append到结果集中，因为后面还要对set进行修改，引用传递，会受影响</span><br>            <span class="hljs-comment">// 创建一个新的数组，加入结果集中</span><br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, set...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 选择当前元素</span><br>        set = <span class="hljs-built_in">append</span>(set, nums[cur])<br>        dfs(cur+<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment">// 不选择当前元素</span><br>        set = set[:<span class="hljs-built_in">len</span>(set)<span class="hljs-number">-1</span>]<br>        dfs(cur+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 去除两端空格</span><br>    s = strings.Trim(s, <span class="hljs-string">&quot; &quot;</span>)<br><br>    <span class="hljs-comment">// 双指针</span><br>    i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    j := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 从后向前遍历</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 搜索首个空格</span><br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            i -= <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-comment">// 记录单词</span><br>        res = <span class="hljs-built_in">append</span>(res, s[i+<span class="hljs-number">1</span>:j+<span class="hljs-number">1</span>])<br>        <span class="hljs-comment">// 跳过单词间空格</span><br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            i -= <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-comment">// j指向下个单词的尾字符</span><br>        j = i<br>    &#125;<br><br>    <span class="hljs-comment">// 拼接返回</span><br>    <span class="hljs-keyword">return</span> strings.Join(res, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 思路：使用一个辅助栈，每次压栈时同步往辅助栈中压入当前最小值，出栈时也是同步出栈。</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-type">int</span><br>    minStack []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        stack: []<span class="hljs-type">int</span>&#123;&#125;,<br>        minStack: []<span class="hljs-type">int</span>&#123;math.MaxInt64&#125;,<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    this.stack = <span class="hljs-built_in">append</span>(this.stack, val)<br>    top := this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>    this.minStack = <span class="hljs-built_in">append</span>(this.minStack, min(val, top))<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop()  &#123;<br>    this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>    this.minStack = this.minStack[:<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用单个栈的解法，通过向栈中压入差值实现</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-type">int</span><br>    minValue <span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        stack: []<span class="hljs-type">int</span>&#123;&#125;,<br>        minValue: <span class="hljs-number">-1</span>,<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        this.stack = <span class="hljs-built_in">append</span>(this.stack, <span class="hljs-number">0</span>)<br>        this.minValue = val<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        diff := val - this.minValue<br>        this.stack = <span class="hljs-built_in">append</span>(this.stack, diff)<br>        <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> &#123;<br>            this.minValue = val<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop()  &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    diff := this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>    this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br><br>    <span class="hljs-comment">// 如果diff小于0，则当前最小值就是栈顶的原始元素</span><br>    <span class="hljs-comment">// 并且，当前最小值 - diff就是上一次的最小值（参考push中的逻辑）</span><br>    <span class="hljs-comment">// 这里相当于在出栈时恢复上一次的最小值，是关键的一步</span><br>    <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> &#123;<br>        this.minValue = this.minValue - diff<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> this.minValue<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>] + this.minValue<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> this.minValue<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, prevSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum := prevSum * <span class="hljs-number">10</span> + root.Val<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(root.Left, sum) + dfs(root.Right, sum)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> check(root.Left, root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(p, q *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> || q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// lowerBound 返回最小的满足 nums[i] &gt;= target 的下标 i</span><br><span class="hljs-comment">// 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)</span><br><span class="hljs-comment">// 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> <span class="hljs-comment">// 闭区间 [left, right]</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left-1] &lt; target</span><br>        <span class="hljs-comment">// nums[right+1] &gt;= target</span><br>        mid := left + (right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;<br>            right = mid - <span class="hljs-number">1</span> <span class="hljs-comment">// 范围缩小到 [left, mid-1]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span> <span class="hljs-comment">// 范围缩小到 [mid+1, right]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束后 left = right+1</span><br>    <span class="hljs-comment">// 此时 nums[left-1] &lt; target 而 nums[left] = nums[right+1] &gt;= target</span><br>    <span class="hljs-comment">// 所以 left 就是第一个 &gt;= target 的元素下标</span><br>    <span class="hljs-keyword">return</span> left<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    start := lowerBound(nums, target)<br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) || nums[start] != target &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125; <span class="hljs-comment">// nums 中没有 target</span><br>    &#125;<br>    <span class="hljs-comment">// 如果 start 存在，那么 end 必定存在</span><br>    end := lowerBound(nums, target+<span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;start, end&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> preorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><br>    preorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, root.Val)<br>        preorder(root.Left)<br>        preorder(root.Right)<br>    &#125;<br>    preorder(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>apply之后的流程</title>
    <link href="/2025/04/28/apply%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <url>/2025/04/28/apply%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="kubectl-apply-f-xxxx-yaml之后的过程"><a href="#kubectl-apply-f-xxxx-yaml之后的过程" class="headerlink" title="kubectl apply -f xxxx.yaml之后的过程"></a>kubectl apply -f xxxx.yaml之后的过程</h1><p>整个过程首先从kubectl发起，以kubelet生成相应的pod为结束。</p><ul><li>kubectl<ol><li>验证和生成器</li><li>API 版本协商与 API 组</li><li>发送http请求到apiserver</li></ol></li><li>apiserver<ol><li>客户端身份认证</li><li>授权</li><li>准入控制</li><li>数据反序列化，存入etcd</li></ol></li><li>etcd<ol><li>获得数据</li><li>同步数据</li><li>保存数据</li></ol></li><li>controller-manager<ol><li>deploy-controller</li><li>ReplicaSet-controller</li><li>pod-controller</li></ol></li><li>scheduler<ol><li>预选策略</li><li>优选策略</li><li>绑定节点</li></ol></li><li>kubelet<ol><li>pod数据同步</li><li>初始化，资源，卷</li><li>CRI和pause容器</li><li>CNI和pod网络</li><li>容器启动过程</li></ol></li></ul><p><img src="/2025/04/28/apply%E4%B9%8B%E5%90%8E%E7%9A%84%E6%B5%81%E7%A8%8B/what-happens-when-k8s-c0b581cfa122439e84f0e697060fde49.svg" alt="whathappenswhenk8s.svg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go排序包sort</title>
    <link href="/2025/04/23/Go%E6%8E%92%E5%BA%8F%E5%8C%85sort/"/>
    <url>/2025/04/23/Go%E6%8E%92%E5%BA%8F%E5%8C%85sort/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-sort包"><a href="#Go-sort包" class="headerlink" title="Go sort包"></a>Go sort包</h1><p>参考：<a href="https://juejin.cn/post/7140873783362977828">https://juejin.cn/post/7140873783362977828</a></p><h2 id="三种基本类型升序排序"><a href="#三种基本类型升序排序" class="headerlink" title="三种基本类型升序排序"></a>三种基本类型升序排序</h2><p>如果要排序的切片是<code>int64, float64, string</code>类型，且是升序排序，可以使用下面三个函数进行排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Ints(x []<span class="hljs-type">int</span>)<br>sort.Float64s(x []<span class="hljs-type">float64</span>)<br>sort.Strings(x []<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><h2 id="sort-Sort-data-Interface"><a href="#sort-Sort-data-Interface" class="headerlink" title="sort.Sort(data Interface)"></a>sort.Sort(data Interface)</h2><p>这个函数可以对自定义类型的切片进行排序，前提是这种自定义类型得实现<code>Interface</code>接口.</p><p>任何实现了以下接口的类型，都可以调用<code>sort.Sort()</code>进行排序</p><p><strong>Interface</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>Len() <span class="hljs-type">int</span><br>Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br>Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>int类型举例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sortInt []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr sortInt)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(arr)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr sortInt)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> arr[i] &lt; arr[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arr sortInt)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>arr[i], arr[j] = arr[j], arr[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>&#125;<br><span class="hljs-keyword">var</span> _arr sortInt = arr<br>sort.Sort(_arr)<br>sort.Sort(sort.Reverse(_arr))  <span class="hljs-comment">// 逆序排序</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>struct类型举例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> 代码解读复制代码<span class="hljs-keyword">type</span> Students []Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Students)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Students)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i].score &lt; s[j].score<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Students)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>s[i], s[j] = s[j], s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> students Students<br>students = []Student&#123;<br>Student&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">89</span>&#125;,<br>Student&#123;<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">98</span>&#125;,<br>Student&#123;<span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-number">78</span>&#125;,<br>&#125;<br>sort.Sort(students)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sort-Slice-x-interface-less-func-i-j-int-bool"><a href="#sort-Slice-x-interface-less-func-i-j-int-bool" class="headerlink" title="sort.Slice(x interface{}, less func(i, j int) bool)"></a>sort.Slice(x interface{}, less func(i, j int) bool)</h2><p>只需要传入一个自定义的比较函数就可以对切片进行排序，方便快捷。</p><p><strong>int类型举例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>&#125;<br>sort.Slice(arr, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> arr[i] &gt; arr[j]<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>struct类型举例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">students := []Student&#123;<br>Student&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">89</span>&#125;,<br>Student&#123;<span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">98</span>&#125;,<br>Student&#123;<span class="hljs-string">&quot;wangwu&quot;</span>, <span class="hljs-number">78</span>&#125;,<br>&#125;<br>sort.Slice(students, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> students[i].score &gt; students[j].score<br>&#125;)<br>fmt.Println(students)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题-二</title>
    <link href="/2025/04/21/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C/"/>
    <url>/2025/04/21/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 找到最近公共祖先 or 找到p/q本身</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// 如果已经到达底部，直接返回</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前节点是p或者q，返回该节点</span><br>    <span class="hljs-keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    <span class="hljs-comment">// 在左子树中找到最近公共祖先 或 在左子树中找到p/q</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br><br>    <span class="hljs-comment">// 在右子树中找到最近公共祖先 或 在右子树中找到p/q</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <br>    <span class="hljs-comment">// 左子树中找到了p/q，右子树中也找到了p/q</span><br>    <span class="hljs-comment">// 则当前节点为最近公共祖先（只有最近公共祖先满足该条件）</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    <span class="hljs-comment">// 如果只是找到了一个，则返回找到的那个，表示从该节点往下有一个p/q</span><br>    <span class="hljs-comment">// 如果都没找到，返回nil</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 头插法一次遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 设置dummy节点是此类问题的一般做法</span><br>    dummy := &amp;ListNode&#123;Next: head&#125;<br>    pre := dummy<br><br>    <span class="hljs-comment">// 找到left的前一个节点，作为pre</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++ &#123;<br>        pre = pre.Next<br>    &#125;<br><br>    <span class="hljs-comment">// left节点作为cur</span><br>    cur := pre.Next<br><br>    <span class="hljs-comment">// 从left开始遍历，每次循环把当前节点的后一个节点插入到pre后面（该段链表的头部）</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; right-left; i++ &#123;<br>        next := cur.Next<br>        cur.Next = next.Next<br>        next.Next = pre.Next<br>        pre.Next = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// dp[i]为组成数量为i的金额所需的最小硬币数</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 为dp[i]赋初始值</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++ &#123;<br>        <span class="hljs-comment">// 这里的amount+1并没有实际意义，仅仅是为了方便判断是否有解，任何一个大于amount的数均可</span><br>        <span class="hljs-comment">// 因为组成amount所需的硬币数量在任何情况下都不会大于amount</span><br>        dp[i] = amount + <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(coins); j++ &#123;<br>            <span class="hljs-keyword">if</span> coins[j] &lt;= i &#123;<br>                <span class="hljs-comment">// 组成i-coins[j]的最小硬币数，加上本次的一个硬币</span><br>                dp[i] = min(dp[i], dp[i-coins[j]] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> dp[amount] &gt; amount &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br><br>    rows, cols := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    order := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, rows * cols)<br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 记录边界</span><br>    left, right, top, bottom := <span class="hljs-number">0</span>, cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">// 在边界范围内移动</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &amp;&amp; top &lt;= bottom &#123;<br>        <span class="hljs-comment">// 从左往右移动，从最左端left开始，一直到最右端right</span><br>        <span class="hljs-keyword">for</span> col := left; col &lt;= right; col++ &#123;<br>            order[index] = matrix[top][col]<br>            index++<br>        &#125;<br>        <span class="hljs-comment">// 从上往下移动，从最上面的下一个元素开始，到最下端</span><br>        <span class="hljs-keyword">for</span> row := top + <span class="hljs-number">1</span>; row &lt;= bottom; row++ &#123;<br>            order[index] = matrix[row][right]<br>            index++<br>        &#125;<br>        <span class="hljs-comment">// 因为需要始终满足col &gt; left和row &gt; top，这里要保证数组访问不越界</span><br>        <span class="hljs-keyword">if</span> left &lt; right &amp;&amp; top &lt; bottom &#123;<br>            <span class="hljs-comment">// 从右往左移动</span><br>            <span class="hljs-keyword">for</span> col := right - <span class="hljs-number">1</span>; col &gt; left; col-- &#123;<br>                order[index] = matrix[bottom][col]<br>                index++<br>            &#125;<br>            <span class="hljs-comment">// 从下往上移动</span><br>            <span class="hljs-keyword">for</span> row := bottom; row &gt; top; row-- &#123;<br>                order[index] = matrix[row][left]<br>                index++<br>            &#125;<br>        &#125;<br>        left++<br>        right--<br>        top++<br>        bottom--<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> order<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    d := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">len</span> := <span class="hljs-number">1</span><br>    d[<span class="hljs-built_in">len</span>] = nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num &gt; d[<span class="hljs-built_in">len</span>] &#123;<br>            <span class="hljs-built_in">len</span>++<br>            d[<span class="hljs-built_in">len</span>] = num<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l := <span class="hljs-number">1</span><br>            r := <span class="hljs-built_in">len</span><br>            pos := <span class="hljs-number">0</span><br>            <span class="hljs-comment">// 找到比num小的最大的数</span><br>            <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>                mid := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> d[mid] &lt; num &#123;<br>                    pos = mid<br>                    l = mid + <span class="hljs-number">1</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>            d[pos+<span class="hljs-number">1</span>] = num<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lists)<span class="hljs-number">-1</span>)<br>&#125;<br><span class="hljs-comment">// 递归执行，将数组拆成左右两部分，分别合并为一个链表，最终再将两个链表合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(lists []*ListNode, l, r <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> l == r &#123;<br>        <span class="hljs-keyword">return</span> lists[l]<br>    &#125;<br>    <span class="hljs-keyword">if</span> l &gt; r &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (l + r) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid+<span class="hljs-number">1</span>, r))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(a, b *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    dummy := &amp;ListNode&#123;&#125;<br>    tail := dummy<br>    pa := a<br>    pb := b<br>    <span class="hljs-keyword">for</span> pa != <span class="hljs-literal">nil</span> &amp;&amp; pb != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> pa.Val &lt; pb.Val &#123;<br>            tail.Next = pa<br>            pa = pa.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.Next = pb<br>            pb = pb.Next<br>        &#125;<br>        tail = tail.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> pa != <span class="hljs-literal">nil</span> &#123;<br>        tail.Next = pa<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tail.Next = pb<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(head *ListNode)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    mid := middleNode(head)<br>    l1 := head<br>    l2 := mid.Next<br>    mid.Next = <span class="hljs-literal">nil</span><br><br>    l2 = reverseList(l2)<br><br>    mergeList(l1, l2)<br>&#125;<br><br><span class="hljs-comment">// 快慢指针找中点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleNode</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> pre, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br><span class="hljs-comment">// 交替合并链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(l1, l2 *ListNode)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> &amp;&amp; l2 != <span class="hljs-literal">nil</span> &#123;<br>        l1Next := l1.Next<br>        l2Next := l2.Next<br><br>        l1.Next = l2<br>        l1 = l1Next<br><br>        l2.Next = l1<br>        l2 = l2Next<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addStrings</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    add := <span class="hljs-number">0</span><br>    ans := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-built_in">len</span>(num1) - <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(num2) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add != <span class="hljs-number">0</span>; i, j = i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>            x = <span class="hljs-type">int</span>(num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> &#123;<br>            y = <span class="hljs-type">int</span>(num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        result := x + y + add<br>        <span class="hljs-comment">// result % 10 为当前位</span><br>        ans = strconv.Itoa(result % <span class="hljs-number">10</span>) + ans<br>        <span class="hljs-comment">// 向下一位的进位</span><br>        add = result / <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 哈希表存储</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    vis := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> p := headA; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>        vis[p] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> p := headB; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>        <span class="hljs-keyword">if</span> vis[p] &#123;<br>            <span class="hljs-keyword">return</span> p<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 双指针分别从两个链表头部开始遍历，遍历完后转到另一条链表头部遍历</span><br><span class="hljs-comment">// 若存在相交节点，则必定相遇（因为会走过相同距离x1+y+x2）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    pa, pb := headA, headB<br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = headB<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pa = pa.Next<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = headA<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pb = pb.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 先按照左端点进行排序</span><br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br><br>    <span class="hljs-comment">// 用于保存结果</span><br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 遍历排序后的区间</span><br>    <span class="hljs-keyword">for</span> _, interval := <span class="hljs-keyword">range</span> intervals &#123;<br>        n := <span class="hljs-built_in">len</span>(res)<br>        <span class="hljs-comment">// 没有重合：res中最后一个区间的右端点小于当前区间左端点</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>] &#123;<br>            res = <span class="hljs-built_in">append</span>(res, interval)<br>        <span class="hljs-comment">// 有重合，就拓展res中最后一个区间的右边界</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// leftMax[i]的含义是，从i这个位置往左看，最高的高度</span><br>    leftMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        leftMax[i] = max(leftMax[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br><br>    <span class="hljs-comment">// rightMax[i]的含义是，从i这个位置往右看，最高的高度</span><br>    rightMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    rightMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        rightMax[i] = max(rightMax[i+<span class="hljs-number">1</span>], height[i])<br>    &#125;<br><br>    res := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i, h := <span class="hljs-keyword">range</span> height &#123;<br>        res += min(leftMax[i], rightMax[i]) - h<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSum := math.MinInt32<br>    <span class="hljs-keyword">var</span> maxGain <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span> <span class="hljs-type">int</span><br>    maxGain = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br><br>        leftGain := max(maxGain(node.Left), <span class="hljs-number">0</span>)<br>        rightGain := max(maxGain(node.Right), <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment">// 将左子树路径-当前节点-右子树路径 连接起来组成新的一条路径</span><br>        <span class="hljs-comment">// 计算这条路径的和</span><br>        newPathPrice := node.Val + leftGain + rightGain<br><br>        <span class="hljs-comment">// 更新答案</span><br>        maxSum = max(maxSum, newPathPrice)<br><br>        <span class="hljs-comment">// 返回节点的最大贡献值。路径只向一个子树上延申</span><br>        <span class="hljs-keyword">return</span> node.Val + max(leftGain, rightGain)<br>    &#125;<br><br>    maxGain(root)<br><br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>)<br><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _, ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> head<br>        &#125;<br>        seen[head] = <span class="hljs-literal">true</span><br>        head = head.Next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>    <span class="hljs-comment">// dp[i][j]含义：以text1[i-1]结尾的字符串，和以text2[j-1]结尾的字符串之间的最长公共子序列长度</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, c1 := <span class="hljs-keyword">range</span> text1 &#123;<br>        <span class="hljs-keyword">for</span> j, c2 := <span class="hljs-keyword">range</span> text2 &#123;<br>            <span class="hljs-keyword">if</span> c1 == c2 &#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = max(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> SEG_COUNT = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">var</span> (<br>    ans []<span class="hljs-type">string</span><br>    segments []<span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    segments = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, SEG_COUNT)<br>    ans = []<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, segId, segStart <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// segId从0开始的，等于SEG_COUNT说明已经找到了4段</span><br>    <span class="hljs-comment">// segStart从0开始的，等于len(s)说明字符串已经遍历完了</span><br>    <span class="hljs-keyword">if</span> segId == SEG_COUNT &#123;<br>        <span class="hljs-keyword">if</span> segStart == <span class="hljs-built_in">len</span>(s) &#123;<br>            <span class="hljs-comment">// 将dfs过程中保存的segments数组转化成真正的ip字符串</span><br>            ipAddr := <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; SEG_COUNT; i++ &#123;<br>                ipAddr += strconv.Itoa(segments[i])<br>                <span class="hljs-keyword">if</span> i != SEG_COUNT - <span class="hljs-number">1</span> &#123;<br>                    ipAddr += <span class="hljs-string">&quot;.&quot;</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将ip字符串加入到结果集中</span><br>            ans = <span class="hljs-built_in">append</span>(ans, ipAddr)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果还没有找到4段，但字符串已经遍历完了，说明本次尝试无功而返，什么也不做，直接返回</span><br>    <span class="hljs-keyword">if</span> segStart == <span class="hljs-built_in">len</span>(s) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前段，遇到的第一个数字就是0，那么本段也只能为0。保存本段的0，然后开启向下的搜索</span><br>    <span class="hljs-keyword">if</span> s[segStart] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>        segments[segId] = <span class="hljs-number">0</span><br>        dfs(s, segId + <span class="hljs-number">1</span>, segStart + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 一般情况，枚举每一种可能性，并向下递归</span><br>    addr := <span class="hljs-number">0</span> <span class="hljs-comment">// 用来保存本段ip地址数值</span><br>    <span class="hljs-comment">// 从segStart开始尝试，i的总体限制是小于len(s)，但在前期遍历过程中达不到len(s) addr就超过255了</span><br>    <span class="hljs-comment">// 所以这里的for循环并不一定会遍历到len(s)，超过255退出即可，所有可能的结果都会在dfs过程中遍历到</span><br>    <span class="hljs-keyword">for</span> i := segStart; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        addr = addr * <span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-comment">// 如果本轮循环得到的addr数值符合要求，那么就找到了本段的一个解，记录之后向下递归寻找之后几段的解</span><br>        <span class="hljs-keyword">if</span> addr &gt; <span class="hljs-number">0</span> &amp;&amp; addr &lt;= <span class="hljs-number">0xFF</span> &#123;<br>            segments[segId] = addr<br>            dfs(s, segId + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 双指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br>    first, second := head, dummy<br>    <span class="hljs-comment">// first先往前走n步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br>    <span class="hljs-comment">// first和second同时往前走</span><br>    <span class="hljs-keyword">for</span> ; first != <span class="hljs-literal">nil</span>; first = first.Next &#123;<br>        second = second.Next<br>    &#125;<br>    second.Next = second.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br><br>    cur := dummy<br>    <span class="hljs-comment">// 每次都是对比当前节点的后两个节点</span><br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果后两个节点相等</span><br>        <span class="hljs-keyword">if</span> cur.Next.Val == cur.Next.Next.Val &#123;<br>            <span class="hljs-comment">// 记录相等节点的值</span><br>            x := cur.Next.Val<br>            <span class="hljs-comment">// 不停的跳过值为x的节点，注意这里cur是一直没变的，变化的是cur的下一个节点，</span><br>            <span class="hljs-comment">// 也就是说如果cur的下一个节点值为x，那么它就会被跳过</span><br>            <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Val == x &#123;<br>                cur.Next = cur.Next.Next<br>            &#125;<br>        <span class="hljs-comment">// 后两个节点不相等的情况下，cur才往后移动一位</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 层序遍历，右子树先入队，每层保留最右侧节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    q := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        p := []*TreeNode&#123;&#125;<br>        res = <span class="hljs-built_in">append</span>(res, q[<span class="hljs-number">0</span>].Val)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(q); j++ &#123;<br>            node := q[j]<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Left)<br>            &#125;<br>        &#125;<br>        q = p<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> inorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    inorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node * TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        inorder(node.Left)<br>        res = <span class="hljs-built_in">append</span>(res, node.Val)<br>        inorder(node.Right)<br>    &#125;<br><br>    inorder(root)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法题理论</title>
    <link href="/2025/04/20/%E7%AE%97%E6%B3%95%E9%A2%98%E7%90%86%E8%AE%BA/"/>
    <url>/2025/04/20/%E7%AE%97%E6%B3%95%E9%A2%98%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="算法题理论"><a href="#算法题理论" class="headerlink" title="算法题理论"></a>算法题理论</h1><h2 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a>满二叉树：</h2><p>定义：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。</p><p>性质：（根节点为第1层，高度为k, 从1开始编号）</p><ol><li>总节点数：2^(k+1) -1, k&gt;&#x3D;0</li><li>编号为i的节点，i&gt;&#x3D;0，左子节点编号为：2i+1，右子节点编号为：2i+2，父节点：(i-1) &#x2F; 2</li></ol><h2 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a>完全二叉树：</h2><p>定义：以满二叉树为基础，最后一层右侧缺失部分节点的二叉树。</p><p>若一个数组代表完全二叉树层序遍历后的结果，则第一个非叶子节点的编号为：arr.length&#x2F;2-1</p><p><img src="/2025/04/20/%E7%AE%97%E6%B3%95%E9%A2%98%E7%90%86%E8%AE%BA/image-20250419181304984.png" alt="image-20250419181304984"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>b站视频：<a href="https://www.bilibili.com/video/BV1Eb41147dK?spm_id_from=333.788.recommend_more_video.1&vd_source=387dd3d1bd16faa43e7a57664d7939b8">https://www.bilibili.com/video/BV1Eb41147dK?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=387dd3d1bd16faa43e7a57664d7939b8</a></p><p>从最后一个非叶子节点开始建堆，一直进行到根节点，最后根节点的数值为整体最大值</p><p>交换最大值与末尾节点值，去除最后一个节点，重新调整堆</p><p>循环上一步，直到堆只剩一个元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span>(<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> &#123;<br>    tmp := arr[i]<br>    arr[i] = arr[j]<br>    arr[j] = tmp<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapify</span><span class="hljs-params">(tree []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> i &gt;= n &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    c1 := <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span><br>    c2 := <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span><br>    max := i<br>    <span class="hljs-keyword">if</span> c1 &lt; n &amp;&amp; tree[c1] &gt; tree[max] &#123;<br>        max = c1<br>    &#125;<br>    <span class="hljs-keyword">if</span> c2 &lt; n &amp;&amp; tree[c2] &gt; tree[max] &#123;<br>        max = c2<br>    &#125;<br>    <span class="hljs-keyword">if</span> max != i &#123;<br>        swap(tree, max, i)<br>        heapify(tree, n, max)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(tree []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> &#123;<br>    lastNode := n <span class="hljs-number">-1</span><br>    parent := (lastNode - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i := parent; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        heapify(tree, n, i)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(tree []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> &#123;<br>    buildHeap(tree, n)<br>    <span class="hljs-keyword">for</span> i := n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        swap(tree, i, <span class="hljs-number">0</span>)<br>        heapify(tree, i, <span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    tree := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>&#125;<br>    n := <span class="hljs-number">6</span><br>    heapSort(tree, n)<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> tree &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, v)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>假设所有元素均为正数，若有负数，则通过每个元素都加上一个固定值，把所有元素都变成正数</p><ol><li>先遍历一遍数组，找出数组中最大值m</li><li>设置m个桶</li><li>遍历数组，将元素放到对应的桶上，桶的下标即为元素值本身</li><li>遍历桶，取出桶中元素并按次序排列好</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countingSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 找到最大值</span><br>    max := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num &gt; max &#123;<br>            max = num<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置计数桶</span><br>    buckets := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, max+<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment">// 将元素放入桶中</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        buckets[num] += <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历计数桶，取出元素排序</span><br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> elem, elemCount := <span class="hljs-keyword">range</span> buckets &#123;<br>        <span class="hljs-keyword">for</span> elemCount &gt; <span class="hljs-number">0</span> &#123;<br>            nums[index] = elem<br>            elemCount--<br>            index++<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;<br>    countingSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的变种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bucketSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 找到最大值和最小值</span><br>    max := nums[<span class="hljs-number">0</span>]<br>    min := nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num &gt; max &#123;<br>            max = num<br>        &#125;<br>        <span class="hljs-keyword">if</span> num &lt; min &#123;<br>            min = num<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 设置桶</span><br>    defaultBucketSize := <span class="hljs-number">2</span><br>    bucketCount := (max - min) / defaultBucketSize + <span class="hljs-number">1</span><br>    buckets := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, bucketCount)<br>    <br>    <span class="hljs-comment">// 遍历数组，将元素放入桶中</span><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        i := (num - min) / defaultBucketSize<br>        buckets[i] = <span class="hljs-built_in">append</span>(buckets[i], num)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历桶，取出元素排序</span><br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, bucket := <span class="hljs-keyword">range</span> buckets &#123;<br>        <span class="hljs-comment">// 桶内部排序</span><br>        sort.Slice(bucket, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>            <span class="hljs-keyword">return</span> bucket[i] &lt; bucket[j]<br>        &#125;)<br>        <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> bucket &#123;<br>            nums[index] = num<br>            index++<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">100</span>, <span class="hljs-number">49</span>, <span class="hljs-number">50</span>, <span class="hljs-number">98</span>, <span class="hljs-number">34</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>&#125;<br>    bucketSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, l, r <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> l &lt; r &#123;<br>    index := partition(nums, l, r)<br>    fmt.Println(index)<br>    quickSort(nums, l, index<span class="hljs-number">-1</span>)<br>    quickSort(nums, index+<span class="hljs-number">1</span>, r)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, l, r <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>pivot := nums[l]<br><span class="hljs-keyword">for</span> l &lt; r &#123;<br><span class="hljs-keyword">for</span> l &lt; r &amp;&amp; nums[r] &gt; pivot &#123;<br>r--<br>&#125;<br>nums[l] = nums[r]<br><span class="hljs-keyword">for</span> l &lt; r &amp;&amp; nums[l] &lt;= pivot &#123;<br>l++<br>&#125;<br>nums[r] = nums[l]<br>&#125;<br>nums[l] = pivot<br><span class="hljs-keyword">return</span> l<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>&#125;<br>quickSort(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链表实现队列"><a href="#链表实现队列" class="headerlink" title="链表实现队列"></a>链表实现队列</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    value <span class="hljs-type">int</span><br>    next  *Node<br>&#125;<br><br><span class="hljs-keyword">type</span> Queue <span class="hljs-keyword">struct</span> &#123;<br>    head *Node<br>    tail *Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewQueue</span><span class="hljs-params">()</span></span> *Queue &#123;<br>    <span class="hljs-keyword">return</span> &amp;Queue&#123;<br>        head: <span class="hljs-literal">nil</span>,<br>        tail: <span class="hljs-literal">nil</span>,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Enqueue(val <span class="hljs-type">int</span>) &#123;<br>    newNode := &amp;Node&#123;value: val&#125;<br>    <span class="hljs-keyword">if</span> q.tail == <span class="hljs-literal">nil</span> &#123;<br>        q.head = newNode<br>        q.tail = newNode<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        q.tail.next = newNode<br>        q.tail = newNode<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Dequeue() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> q.head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;queue is empty&quot;</span>)<br>    &#125;<br>    val := q.head.value<br>    q.head = q.head.next<br>    <span class="hljs-keyword">if</span> q.head == <span class="hljs-literal">nil</span> &#123;<br>        q.tail = <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> val<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> IsEmpty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> q.head == <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DFS</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(root.Val)<br>    <br>    DFS(root.Left)<br>    DFS(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BFS</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    q := []*TreeNode<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        node := q[<span class="hljs-number">0</span>]<br>        q = q[<span class="hljs-number">1</span>:]<br>        <br>        fmt.Println(node.Val)<br>        <br>        <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, node.Left)<br>        &#125;<br>        <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, node.Right)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go算法题</title>
    <link href="/2025/04/20/Go%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <url>/2025/04/20/Go%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Go算法题"><a href="#Go算法题" class="headerlink" title="Go算法题"></a>Go算法题</h1><p>按出现频率大小递减排序（参考<a href="https://codetop.cc/home%EF%BC%89%EF%BC%9A">https://codetop.cc/home）：</a></p><p>(1) leetcode 3. 给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><p><strong>解答：</strong></p><p> 方法点：</p><ol><li>使用map记录字符，用来判断是否重复</li><li>如果当前字符与前面某字符重复，可以直接跳到重复字符后面，继续比较</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// //外层循环扩展右边界，内层循环扩展左边界</span><br><span class="hljs-comment">// for (int l = 0, r = 0 ; r &lt; n ; r++) &#123;</span><br><span class="hljs-comment">// //当前考虑的元素</span><br><span class="hljs-comment">// while (l &lt;= r &amp;&amp; check()) &#123;//区间[left,right]不符合题意</span><br><span class="hljs-comment">//         //扩展左边界</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//     //区间[left,right]符合题意，统计相关信息</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    l := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> r:=<span class="hljs-number">0</span>, r&lt;n; r++ &#123;<br>        <span class="hljs-comment">// 如果重复，一直跳到重复元素的下一位</span><br>        <span class="hljs-keyword">for</span> m[s[r]] != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">delete</span>(m, s[l])<br>            l++<br>        &#125;<br>        m[s[r]] = <span class="hljs-number">1</span><br>        res = max(res, r-l+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）</p><p><a href="https://leetcode.cn/problems/lru-cache/description/">https://leetcode.cn/problems/lru-cache/description/</a></p><p>leetcode 146. 请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><p><strong>解答：</strong></p><ol><li>使用map来保存cache数据</li><li>使用双向链表来保存访问频率，最近访问的放在链表头部。（双向链表方便尾部删除节点）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    size <span class="hljs-type">int</span><br>    capacity <span class="hljs-type">int</span><br>    cache <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkedNode<br>    head *DLinkedNode<br>    tail *DLinkedNode<br>&#125;<br><br><span class="hljs-keyword">type</span> DLinkedNode <span class="hljs-keyword">struct</span> &#123;<br>    key <span class="hljs-type">int</span><br>    value <span class="hljs-type">int</span><br>    prev *DLinkedNode<br>    next *DLinkedNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initDLinkedNode</span><span class="hljs-params">(key, value <span class="hljs-type">int</span>)</span></span> *DLinkedNode &#123;<br>    <span class="hljs-keyword">return</span> &amp;DLinkedNode&#123;<br>        key: key,<br>        value: value,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    l := LRUCache&#123;<br>        cache: <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkedNode&#123;&#125;,<br>        head: initDLinkedNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        tail: initDLinkedNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        capacity: capacity,<br>    &#125;<br>    l.head.next = l.tail<br>    l.tail.prev = l.head<br>    <span class="hljs-keyword">return</span> l<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    node, ok := this.cache[key]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    this.moveToHead(node)<br>    <span class="hljs-keyword">return</span> node.value<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>    node, ok := this.cache[key]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        node := initDLinkedNode(key, value)<br>        this.cache[key] = node<br>        this.addToHead(node)<br>        this.size++<br>        <span class="hljs-keyword">if</span> this.size &gt; this.capacity &#123;<br>            removed := this.removeTail()<br>            <span class="hljs-built_in">delete</span>(this.cache, removed.key)<br>            this.size--<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node.value = value<br>        this.moveToHead(node)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode) &#123;<br>    node.prev = this.head<br>    node.next = this.head.next<br>    <span class="hljs-comment">// 以下两行顺序不能反</span><br>    this.head.next.prev = node<br>    this.head.next = node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;<br>    node.prev.next = node.next<br>    node.next.prev = node.prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode) &#123;<br>    this.removeNode(node)<br>    this.addToHead(node)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeTail() *DLinkedNode &#123;<br>    node := this.tail.prev<br>    this.removeNode(node)<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(capacity);</span><br><span class="hljs-comment"> * param_1 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>(3) <a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p>解答：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 迭代解法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br><br><span class="hljs-comment">// 递归解法，不好理解</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    newHead := reverseList(head.Next)<br>    head.Next.Next = head<br>    head.Next = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">return</span> newHead<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;Next: head&#125;<br>    <br>    <span class="hljs-comment">// 记录每一段的前驱节点</span><br>    pre := dummy<br><br>    <span class="hljs-comment">// 每次循环处理k个</span><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 找到第k个节点，作为tail</span><br>        tail := pre<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>            tail = tail.Next<br>            <span class="hljs-comment">// 如果还没有到k个，已经到了结尾，则整体反转已完成，返回头节点</span><br>            <span class="hljs-keyword">if</span> tail == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> dummy.Next<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 记录下一段链表的开头节点</span><br>        next := tail.Next<br><br>        <span class="hljs-comment">// 反转当前链表段，获取到新的head和tail</span><br>        head, tail = reverse(head, tail)<br><br>        <span class="hljs-comment">// 将head连接到上一段链表</span><br>        pre.Next = head<br><br>        <span class="hljs-comment">// 将tail连接到下一段链表</span><br>        tail.Next = next<br><br>        <span class="hljs-comment">// 本段的末尾记录为下一段的前驱</span><br>        pre = tail<br><br>        <span class="hljs-comment">// head重置为下一段的开头</span><br>        head = tail.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head, tail *ListNode)</span></span> (*ListNode, *ListNode) &#123;<br>    <span class="hljs-comment">// pre用于记录前驱节点</span><br>    <span class="hljs-keyword">var</span> pre *ListNode<br><br>    <span class="hljs-comment">// 从head节点开始处理</span><br>    curr := head<br><br>    <span class="hljs-comment">// 一直循环到pre指向最后一个节点</span><br>    <span class="hljs-keyword">for</span> pre != tail &#123;<br>        <span class="hljs-comment">// 先记录当前节点的下一个节点</span><br>        nex := curr.Next <br>        <span class="hljs-comment">// 将当前节点指向前驱节点</span><br>        curr.Next = pre<br>        <span class="hljs-comment">// pre后移</span><br>        pre = curr<br>        <span class="hljs-comment">// curr后移</span><br>        curr = nex<br>    &#125;<br>    <span class="hljs-comment">// 反转完成，tail成为新的头，head成为新的尾</span><br>    <span class="hljs-keyword">return</span> tail, head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 先排序，不然没法做</span><br>    slices.Sort(nums)<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>]&#123;<br>        <span class="hljs-comment">// 当前元素和上一个元素相同，则跳过</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i<span class="hljs-number">-1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 当前元素和后两个元素相加已经大于0，则此后所有循环肯定都大于0，直接退出</span><br>        <span class="hljs-keyword">if</span> x+nums[i+<span class="hljs-number">1</span>] + nums[i+<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-comment">// 当前元素和最后两个元素相加仍然小于0，则本轮循环中的和均小于0，跳过本轮循环</span><br>        <span class="hljs-keyword">if</span> x + nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>] + nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// j从当前元素的后一个元素开始</span><br>        j := i+<span class="hljs-number">1</span><br>        <span class="hljs-comment">// k从最后一个元素开始</span><br>        k := <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>        <br>        <span class="hljs-keyword">for</span> j &lt; k &#123;<br>            s := x + nums[j] + nums[k]<br>            <span class="hljs-comment">// 如果小于0，则增大j</span><br>            <span class="hljs-keyword">if</span> s &lt; <span class="hljs-number">0</span> &#123;<br>                j++<br>            <span class="hljs-comment">// 如果大于0，则减小k</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">0</span> &#123;<br>                k--<br>            <span class="hljs-comment">// 等于0，则找到了一个答案</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;x, nums[j], nums[k]&#125;)<br>                <span class="hljs-keyword">for</span> j++; j &lt; k &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]; j++ &#123;&#125; <span class="hljs-comment">// 跳过重复数字</span><br>                <span class="hljs-keyword">for</span> k--; k &gt; j &amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>]; k-- &#123;&#125; <span class="hljs-comment">// 跳过重复数字</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// sums[i]值的含义是，以nums[i]为结尾的所有连续子数组的最大和</span><br>    sums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-comment">// 初始时，以nums[0]为结尾的子数组就是它本身</span><br>    sums[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// ans用来记录整体最大和</span><br>    ans := sums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 从nums[1]开始遍历</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 关键代码</span><br>        <span class="hljs-comment">// 1. sums[i-1]保存了所有以nums[i-1]为结尾元素的连续子数组的最大和</span><br>        <span class="hljs-comment">// 2. nums[i]要么加入到前面的连续子数组，要么自己单独作为一个子数组</span><br>        sums[i] = max(sums[i<span class="hljs-number">-1</span>] + nums[i], nums[i])<br>        ans = max(ans, sums[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p := dummy<br>    <span class="hljs-keyword">for</span> list1 != <span class="hljs-literal">nil</span> &amp;&amp; list2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>            p.Next = list1<br>            list1 = list1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = list2<br>            list2 = list2.Next<br>        &#125;<br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = list1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        p.Next = list2<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list2<br>    &#125;<br>    <span class="hljs-keyword">if</span> list2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>        list1.Next = mergeTwoLists(list1.Next, list2)<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    list2.Next = mergeTwoLists(list2.Next, list1)<br>    <span class="hljs-keyword">return</span> list2<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br><br>    <span class="hljs-comment">// 用于记录最长回文串长度及起始位置</span><br>    maxLen := <span class="hljs-number">1</span><br>    begin := <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">// 初始化dp数组，并将dp[i][i]置为true（每个元素都可以认为是一个回文串）</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> n &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        dp[i][i] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 外层长度循环，遍历所有长度的子串</span><br>    <span class="hljs-keyword">for</span> l := <span class="hljs-number">2</span>; l &lt; n + <span class="hljs-number">1</span>; l++ &#123;<br>        <span class="hljs-comment">// 内层对起始位置进行循环，遍历所有的起始位置</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> n &#123;<br>            <span class="hljs-comment">// 计算结束位置</span><br>            j := i + l <span class="hljs-number">-1</span><br><br>            <span class="hljs-comment">// 若结束位置不合法，则直接退出本轮循环</span><br>            <span class="hljs-keyword">if</span> j &gt;= n &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br><br>            <span class="hljs-comment">// 核心代码，dp[i][j]是否为回文串，取决于</span><br>            <span class="hljs-comment">// 1. 内层dp[i+1][j-1]是回文串</span><br>            <span class="hljs-comment">// 2. s[i] == s[j]</span><br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">2</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 实时更新最长子串长度及起始位置</span><br>            <span class="hljs-keyword">if</span> dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen &#123;<br>                maxLen = j - i + <span class="hljs-number">1</span><br>                begin = i<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回最终结果</span><br>    <span class="hljs-keyword">return</span> s[begin:begin+maxLen]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 定义返回值</span><br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-comment">// q用于保存待遍历的元素</span><br>    q := []*TreeNode&#123;root&#125;<br>    <span class="hljs-comment">// q中保存的始终是同一层的元素</span><br>    <span class="hljs-comment">// 每次循环中把q中所有元素都取出，都取出后再填入下一层的元素</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>; i++ &#123;<br>        res = <span class="hljs-built_in">append</span>(res, []<span class="hljs-type">int</span>&#123;&#125;)<br>        <span class="hljs-comment">// 关键点，用临时的p来保存下层元素，待本层元素处理完后，用p替换q</span><br>        p := []*TreeNode&#123;&#125;<br>        <span class="hljs-comment">// 将q中元素全部遍历，过程中将下层子节点加入p</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(q); j++ &#123;<br>            node := q[j]<br>            res[i] = <span class="hljs-built_in">append</span>(res[i], node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 用p替换q，进入新一轮循环</span><br>        q = p<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> idx, ok := m[target-v]; ok &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;i, idx&#125;<br>        &#125;<br>        m[v] = i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    l := <span class="hljs-number">0</span><br>    r := n - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 总体是二分查找</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        <span class="hljs-comment">// 获取中间位置</span><br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-comment">// 如果命中，则返回</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-comment">// 如果左边是升序</span><br>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= nums[mid] &#123;<br>            <span class="hljs-comment">// 并且target在左边</span><br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;<br>                r = mid - <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span><br>            &#125;<br>        <span class="hljs-comment">// 如果右边是升序</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 并且target在右边</span><br>            <span class="hljs-keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="hljs-number">-1</span>] &#123;<br>                l = mid + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 深度优先搜索</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, r, c <span class="hljs-type">int</span>)</span></span> &#123;<br>    nr := <span class="hljs-built_in">len</span>(grid)<br>    nc := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 先将遍历到的元素置为0</span><br>    grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span><br>    <span class="hljs-comment">// 向上下左右都走一步，如果值为1，则往下搜索</span><br>    <span class="hljs-keyword">if</span> r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r<span class="hljs-number">-1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r<span class="hljs-number">-1</span>, c)<br>    &#125;<br>    <span class="hljs-keyword">if</span> r + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[r+<span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r+<span class="hljs-number">1</span>, c)<br>    &#125;<br>    <span class="hljs-keyword">if</span> c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r, c<span class="hljs-number">-1</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r, c+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    nr := <span class="hljs-built_in">len</span>(grid)<br>    <span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    nc := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> nc == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">var</span> numIslands <span class="hljs-type">int</span><br>    <span class="hljs-comment">// 将所有元素遍历一遍，如果遇到1就深度优先搜索</span><br>    <span class="hljs-comment">// 在深度优先搜索中，会将遍历到的元素置为0</span><br>    <span class="hljs-comment">// 最终执行的搜索次数即为岛屿数量</span><br>    <span class="hljs-keyword">for</span> r := <span class="hljs-number">0</span>; r &lt; nr; r++ &#123;<br>        <span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; nc; c++ &#123;<br>            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                numIslands++<br>                dfs(grid, r, c)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> numIslands<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 回溯法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    <span class="hljs-comment">// 对pos这个位置，使用待排列的所有数字尝试一遍</span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pos <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 如果索引到了n，则说明得到了一个全排列，将结果加入到结果集中</span><br>        <span class="hljs-keyword">if</span> pos == n &#123;<br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, nums...))<br>        &#125;<br>        <span class="hljs-comment">// 对pos这个位置尝试所有待使用元素</span><br>        <span class="hljs-keyword">for</span> i := pos; i &lt; n; i++ &#123;<br>            <span class="hljs-comment">// 把第i个位置的元素放到pos位置上</span><br>            nums[pos], nums[i] = nums[i], nums[pos]<br>            <span class="hljs-comment">// 得到pos后面所有字符的结果集</span><br>            backtrack(pos+<span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 恢复pos和i元素的初始位置，以便下一次循环使用另外的元素</span><br>            nums[pos], nums[i] = nums[i], nums[pos]<br>        &#125;<br>    &#125;<br><br>    backtrack(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-comment">// 如果字符是奇数个，则肯定不能完全匹配</span><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 记录右括号对应的左括号</span><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">byte</span>&#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-type">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果拿到了一个右括号</span><br>        <span class="hljs-keyword">if</span> v, ok := pairs[s[i]]; ok &#123;<br>            <span class="hljs-comment">// 如果栈为空，或者栈顶元素与当前右括号不匹配，就直接返回false</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != v &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            <span class="hljs-comment">// 如果匹配就把栈顶元素出栈</span><br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        <span class="hljs-comment">// 如果拿到的是左括号，就压栈</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 栈中剩余元素就是没有匹配成功的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 核心思想：第i天卖出得到的最大利润，买入价格一定是前i-1天中的最低价格</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// 记录“历史”最低价格</span><br>    minPrice := prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 记录最大利润</span><br>    maxProfit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-comment">// 更新最大利润</span><br>        maxProfit = max(maxProfit, price - minPrice)<br>        <span class="hljs-comment">// 更新历史最低价格</span><br>        minPrice = min(minPrice, price)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxProfit<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, m <span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 从后向前遍历</span><br>    <span class="hljs-comment">// p1指向nums1待排元素，p2指向nums2待排元素，tail指向要放入的位置</span><br>    <span class="hljs-keyword">for</span> p1, p2, tail := m<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>, m+n<span class="hljs-number">-1</span>; p1 &gt;=<span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>; tail-- &#123;<br>        <span class="hljs-comment">// 当前要处理的元素是什么</span><br>        <span class="hljs-keyword">var</span> cur <span class="hljs-type">int</span><br>        <span class="hljs-comment">// 如果nums1已经遍历完了</span><br>        <span class="hljs-keyword">if</span> p1 == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-comment">// 从nums2中取</span><br>            cur = nums2[p2]<br>            p2--<br>        <span class="hljs-comment">// 如果nums2已经遍历完了</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p2 == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-comment">// 从nums1中取</span><br>            cur = nums1[p1]<br>            p1--<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums1[p1] &gt; nums2[p2] &#123;<br>            cur = nums1[p1]<br>            p1--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = nums2[p2]<br>            p2--<br>        &#125;<br>        nums1[tail] = cur<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-comment">// 辅助层序遍历</span><br>    queue := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> level := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>; level++ &#123;<br>        vals := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-comment">// q接收本层元素，用于遍历，queue保存下层元素</span><br>        q := queue<br>        queue = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> q &#123;<br>            vals = <span class="hljs-built_in">append</span>(vals, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果本层为奇数层，将得到的遍历结果反转，再加入结果集</span><br>        <span class="hljs-keyword">if</span> level % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            n := <span class="hljs-built_in">len</span>(vals)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br>                vals[i], vals[n<span class="hljs-number">-1</span>-i] = vals[n<span class="hljs-number">-1</span>-i], vals[i]<br>            &#125;<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, vals)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 哈希表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    seen := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _, ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        seen[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        head = head.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 快慢指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// 慢指针每次走一步，快指针每次走两步</span><br>    <span class="hljs-comment">// 每次移动快慢指针之间的距离会加1，如果有环的话，快慢指针终会相遇</span><br>    slow, fast := head, head.Next<br>    <span class="hljs-keyword">for</span> slow != fast &#123;<br>        <span class="hljs-keyword">if</span> fast == <span class="hljs-literal">nil</span> || fast.Next == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>metrics-server源码解读</title>
    <link href="/2025/04/08/metrics-server%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <url>/2025/04/08/metrics-server%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="metrics-server源码解读"><a href="#metrics-server源码解读" class="headerlink" title="metrics-server源码解读"></a>metrics-server源码解读</h1><p>转自：<a href="https://yost.top/2020/05/17/about-metric-server/">https://yost.top/2020/05/17/about-metric-server/</a></p><h3 id="1、项目概况"><a href="#1、项目概况" class="headerlink" title="1、项目概况"></a>1、项目概况</h3><p>项目地址：<a href="https://github.com/kubernetes-sigs/metrics-server">https://github.com/kubernetes-sigs/metrics-server</a></p><p>在<code>k8s</code>集群中，如果你想要去做弹性伸缩，或者想要使用<code>kubectl top</code>命令，那么<code>metric-server</code>是你绕不开的组件。<code>metric-server</code>主要用来通过<code>aggregate api</code>向其它组件提供集群中的<code>pod</code>和<code>node</code>的<code>cpu</code>和<code>memory</code>的监控指标，弹性伸缩中的<code>podautoscaler</code>就是通过调用这个接口来查看pod的当前资源使用量来进行pod的扩缩容的。</p><p>需要注意的是：</p><ul><li><code>metric-server</code>提供的是实时的指标（实际是最近一次采集的数据，保存在内存中），并没有数据库来存储</li><li>这些数据指标并非由<code>metric-server</code>本身采集，而是由每个节点上的<code>cadvisor</code>采集，<code>metric-server</code>只是发请求给<code>cadvisor</code>并将<code>metric</code>格式的数据转换成<code>aggregate api</code></li><li>由于需要通过<code>aggregate api</code>来提供接口，需要集群中的<code>kube-apiserver</code>开启该功能（开启方法可以参考官方社区的文档）</li></ul><h3 id="2、部署方法"><a href="#2、部署方法" class="headerlink" title="2、部署方法"></a>2、部署方法</h3><p><code>metric-server</code>最佳的安装方法是通过<code>deployment</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/download/v0.3.6/components.yaml<br></code></pre></td></tr></table></figure><p>该<code>yaml</code>中主要的<code>deployment</code>参数如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-server</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">metrics-server</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">metrics-server</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-server</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">metrics-server</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">serviceAccountName:</span> <span class="hljs-string">metrics-server</span><br>      <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment"># mount in tmp so we can safely use from-scratch images and/or read-only containers</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp-dir</span><br>        <span class="hljs-attr">emptyDir:</span> &#123;&#125;<br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-server</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/metrics-server-amd64:v0.3.6</span><br>        <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>        <span class="hljs-attr">args:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">--cert-dir=/tmp</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-string">--secure-port=4443</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">main-port</span><br>          <span class="hljs-attr">containerPort:</span> <span class="hljs-number">4443</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">readOnlyRootFilesystem:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">runAsNonRoot:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-attr">runAsUser:</span> <span class="hljs-number">1000</span><br>        <span class="hljs-attr">volumeMounts:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tmp-dir</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/tmp</span><br>      <span class="hljs-attr">nodeSelector:</span><br>        <span class="hljs-attr">kubernetes.io/os:</span> <span class="hljs-string">linux</span><br>        <span class="hljs-attr">kubernetes.io/arch:</span> <span class="hljs-string">&quot;amd64&quot;</span><br></code></pre></td></tr></table></figure><p>其中还有一个值得注意的资源是一个<code>APIService</code>，这个资源主要就是将<code>metrics-server</code>注册到<code>aggregate api</code>中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apiregistration.k8s.io/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">APIService</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">v1beta1.metrics.k8s.io</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">service:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">metrics-server</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kube-system</span><br>  <span class="hljs-attr">group:</span> <span class="hljs-string">metrics.k8s.io</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">v1beta1</span><br>  <span class="hljs-attr">insecureSkipTLSVerify:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">groupPriorityMinimum:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">versionPriority:</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h3 id="3、启动参数"><a href="#3、启动参数" class="headerlink" title="3、启动参数"></a>3、启动参数</h3><table><thead><tr><th align="left">参数名称</th><th align="left">参数解释</th></tr></thead><tbody><tr><td align="left">metric-resolution</td><td align="left">周期性调用接口获取metric原始数据的时间间隔，默认60s</td></tr><tr><td align="left">kubelet-insecure-tls</td><td align="left">访问kubelet时不对其证书进行ca校验，仅测试时使用</td></tr><tr><td align="left">kubelet-port</td><td align="left">调用节点上的kubelet获取metric的端口，默认10250端口</td></tr><tr><td align="left">kubeconfig</td><td align="left">调用kube-apiserver和kubelet使用的kubeconfig文件路径</td></tr><tr><td align="left">kubelet-preferred-address-types</td><td align="left">调用kubelet使用的ip地址优先级</td></tr><tr><td align="left">kubelet-certificate-authority</td><td align="left">访问kubelet使用的ca证书</td></tr><tr><td align="left">deprecated-kubelet-completely-insecure</td><td align="left">使用非安全方式访问kubelet（即将废弃）</td></tr></tbody></table><h3 id="4、代码分析"><a href="#4、代码分析" class="headerlink" title="4、代码分析"></a>4、代码分析</h3><p>在开始走读<code>metrics-server</code>的代码之前，我们先来根据其功能来猜测一下它的代码逻辑。我们知道，通过节点上的<code>cadvisor</code>接口获取到的数据一般是这样的，包含的信息太多：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node1 ~]# curl -k https://172.17.8.101:10250/stats/summary?only_cpu_and_memory=true<br>&#123;<br>  &quot;node&quot;: &#123;<br>    &quot;nodeName&quot;: &quot;node1&quot;,<br>    &quot;systemContainers&quot;: [<br>      &#123;<br>        &quot;name&quot;: &quot;kubelet&quot;,<br>        &quot;startTime&quot;: &quot;2020-05-24T12:54:13Z&quot;,<br>        &quot;cpu&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:31Z&quot;,<br>          &quot;usageNanoCores&quot;: 20686133,<br>          &quot;usageCoreNanoSeconds&quot;: 156089526198<br>        &#125;,<br>        &quot;memory&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:31Z&quot;,<br>          &quot;usageBytes&quot;: 170590208,<br>          &quot;workingSetBytes&quot;: 122531840,<br>          &quot;rssBytes&quot;: 66949120,<br>          &quot;pageFaults&quot;: 763727,<br>          &quot;majorPageFaults&quot;: 85<br>        &#125;,<br>        &quot;userDefinedMetrics&quot;: null<br>      &#125;,<br>      &#123;<br>        &quot;name&quot;: &quot;runtime&quot;,<br>        &quot;startTime&quot;: &quot;2020-05-24T12:54:13Z&quot;,<br>        &quot;cpu&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:31Z&quot;,<br>          &quot;usageNanoCores&quot;: 20686133,<br>          &quot;usageCoreNanoSeconds&quot;: 156089526198<br>        &#125;,<br>        &quot;memory&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:31Z&quot;,<br>          &quot;usageBytes&quot;: 170590208,<br>          &quot;workingSetBytes&quot;: 122531840,<br>          &quot;rssBytes&quot;: 66949120,<br>          &quot;pageFaults&quot;: 763727,<br>          &quot;majorPageFaults&quot;: 85<br>        &#125;,<br>        &quot;userDefinedMetrics&quot;: null<br>      &#125;,<br>      &#123;<br>        &quot;name&quot;: &quot;pods&quot;,<br>        &quot;startTime&quot;: &quot;2020-05-24T12:54:13Z&quot;,<br>        &quot;cpu&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:39Z&quot;,<br>          &quot;usageNanoCores&quot;: 0,<br>          &quot;usageCoreNanoSeconds&quot;: 42207538504<br>        &#125;,<br>        &quot;memory&quot;: &#123;<br>          &quot;time&quot;: &quot;2020-05-24T14:12:39Z&quot;,<br>          &quot;availableBytes&quot;: 1910824960,<br>          &quot;usageBytes&quot;: 33480704,<br>          &quot;workingSetBytes&quot;: 16498688,<br>          &quot;rssBytes&quot;: 36864,<br>          &quot;pageFaults&quot;: 0,<br>          &quot;majorPageFaults&quot;: 0<br>        &#125;,<br>        &quot;userDefinedMetrics&quot;: null<br>      &#125;<br>    ],<br>    &quot;startTime&quot;: &quot;2020-05-24T12:52:24Z&quot;,<br>    &quot;cpu&quot;: &#123;<br>      &quot;time&quot;: &quot;2020-05-24T14:12:39Z&quot;,<br>      &quot;usageNanoCores&quot;: 888521168,<br>      &quot;usageCoreNanoSeconds&quot;: 776524490477<br>    &#125;,<br>    &quot;memory&quot;: &#123;<br>      &quot;time&quot;: &quot;2020-05-24T14:12:39Z&quot;,<br>      &quot;availableBytes&quot;: 891166720,<br>      &quot;usageBytes&quot;: 1627074560,<br>      &quot;workingSetBytes&quot;: 1036156928,<br>      &quot;rssBytes&quot;: 359944192,<br>      &quot;pageFaults&quot;: 1850284,<br>      &quot;majorPageFaults&quot;: 1987<br>    &#125;<br>  &#125;,<br>  &quot;pods&quot;: [<br>    &#123;<br>      &quot;podRef&quot;: &#123;<br>        &quot;name&quot;: &quot;metrics-server-7668599459-2jxq5&quot;,<br>        &quot;namespace&quot;: &quot;kube-system&quot;,<br>        &quot;uid&quot;: &quot;f5af876f-03de-43e5-902b-79bece68c508&quot;<br>      &#125;,<br>      &quot;startTime&quot;: &quot;2020-05-24T13:27:42Z&quot;,<br>      &quot;containers&quot;: null,<br>      &quot;cpu&quot;: &#123;<br>        &quot;time&quot;: &quot;2020-05-24T14:12:36Z&quot;,<br>        &quot;usageNanoCores&quot;: 0,<br>        &quot;usageCoreNanoSeconds&quot;: 6297886<br>      &#125;,<br>      &quot;memory&quot;: &#123;<br>        &quot;time&quot;: &quot;2020-05-24T14:12:36Z&quot;,<br>        &quot;usageBytes&quot;: 434176,<br>        &quot;workingSetBytes&quot;: 249856,<br>        &quot;rssBytes&quot;: 36864,<br>        &quot;pageFaults&quot;: 0,<br>        &quot;majorPageFaults&quot;: 0<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>而我们通过<code>metrics-server</code>获得的数据则是这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node1 ~]# curl http://172.17.8.101:8080/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/metrics-server-7668599459-2jxq5<br>&#123;<br>  &quot;kind&quot;: &quot;PodMetrics&quot;,<br>  &quot;apiVersion&quot;: &quot;metrics.k8s.io/v1beta1&quot;,<br>  &quot;metadata&quot;: &#123;<br>    &quot;name&quot;: &quot;metrics-server-7668599459-2jxq5&quot;,<br>    &quot;namespace&quot;: &quot;kube-system&quot;,<br>    &quot;selfLink&quot;: &quot;/apis/metrics.k8s.io/v1beta1/namespaces/kube-system/pods/metrics-server-7668599459-2jxq5&quot;,<br>    &quot;creationTimestamp&quot;: &quot;2020-05-24T13:27:42Z&quot;<br>  &#125;,<br>  &quot;timeStamp&quot;: &quot;2020-05-24T13:27:42Z&quot;,<br>  &quot;window&quot;: &quot;30s&quot;,<br>  &quot;containers&quot;: [<br>    &#123;<br>      &quot;name&quot;: &quot;metrics-server&quot;,<br>      &quot;usage&quot;: &#123;<br>        &quot;cpu&quot;: &quot;0&quot;,<br>        &quot;memory&quot;: &quot;424Ki&quot;<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，本质上<code>metrics-server</code>相当于做了一次数据的转换，把<code>cadvisor</code>格式的数据转换成了<code>k8s</code>的<code>api</code>的<code>json</code>格式。由此我们不难猜测，<code>metrics-server</code>的代码中必然存在这种先从metric中获取接口中的所有信息，再解析出其中的数据的过程。除此之外，我们可能也会有一个疑惑，那就是：我们给<code>metric-server</code>发送请求时，<code>metric-server</code>是马上向<code>cadvisor</code>发送请求然后解析请求中的数据再返回回来，还是<code>metrics-server</code>中已经定期从中<code>cadvisor</code>获取好数据了（可能缓存在内存中），当请求发过来时直接返回缓存中的数据。我们可以带着这个疑问直接去看源码。</p><h4 id="4-1、启动程序"><a href="#4-1、启动程序" class="headerlink" title="4.1、启动程序"></a>4.1、启动程序</h4><p><code>metric-server</code>的启动流程使用的也是<code>github.com/spf13/cobra</code>框架，对这个库感兴趣的可以去<a href="https://github.com/spf13/cobra"><code>github</code></a>上了解一下，该框架实际执行的是<code>MetricsServerOptions</code>实现的Run函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// cmd/metrics-server/app/start.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o MetricsServerOptions)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 1、生成metric-server自己的server端配置</span><br>config, err := o.Config()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>config.GenericConfig.EnableMetrics = <span class="hljs-literal">true</span><br><br><span class="hljs-comment">// 2、生成metric-server自己的client端配置</span><br>    <span class="hljs-comment">// 包含对kube-apiserver的client（获取集群node信息）和对cadvisor的client（获取原始监控数据）</span><br><span class="hljs-keyword">var</span> clientConfig *rest.Config<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(o.Kubeconfig) &gt; <span class="hljs-number">0</span> &#123;<br>loadingRules := &amp;clientcmd.ClientConfigLoadingRules&#123;ExplicitPath: o.Kubeconfig&#125;<br>loader := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, &amp;clientcmd.ConfigOverrides&#123;&#125;)<br>clientConfig, err = loader.ClientConfig()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>clientConfig, err = rest.InClusterConfig()<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to construct lister client config: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// Use protobufs for communication with apiserver</span><br>clientConfig.ContentType = <span class="hljs-string">&quot;application/vnd.kubernetes.protobuf&quot;</span><br><br><span class="hljs-comment">// 2.1、通过刚才的client配置参数创建kube-apiserver的client</span><br>kubeClient, err := kubernetes.NewForConfig(clientConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to construct lister client: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 根据client创建对应的informer，到这里与kuber-apiserver通信的部分就设置好了</span><br>informerFactory := informers.NewSharedInformerFactory(kubeClient, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 2.2、这里开始创建与节点上的metric接口相关的client</span><br>kubeletRestCfg := rest.CopyConfig(clientConfig)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(o.KubeletCAFile) &gt; <span class="hljs-number">0</span> &#123;<br>kubeletRestCfg.TLSClientConfig.CAFile = o.KubeletCAFile<br>kubeletRestCfg.TLSClientConfig.CAData = <span class="hljs-literal">nil</span><br>&#125;<br>kubeletConfig := summary.GetKubeletConfig(kubeletRestCfg, o.KubeletPort, o.InsecureKubeletTLS, o.DeprecatedCompletelyInsecureKubelet)<br>kubeletClient, err := summary.KubeletClientFor(kubeletConfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unable to construct a client to connect to the kubelets: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 设置访问node的ip的优先级（node中保存有各种address，包括InternalIP、ExternalIP等）</span><br>addrPriority := <span class="hljs-built_in">make</span>([]corev1.NodeAddressType, <span class="hljs-built_in">len</span>(o.KubeletPreferredAddressTypes))<br><span class="hljs-keyword">for</span> i, addrType := <span class="hljs-keyword">range</span> o.KubeletPreferredAddressTypes &#123;<br>addrPriority[i] = corev1.NodeAddressType(addrType)<br>&#125;<br>addrResolver := summary.NewPriorityNodeAddressResolver(addrPriority)<br>    <span class="hljs-comment">// sourceProvider是将前面的两个client合并到一起从cadvisor抓取数据</span><br>    <span class="hljs-comment">// informer负责获取集群中的节点相关的信息，kubeletClient则调用这些节点上的cadvisor接口</span><br>    <span class="hljs-comment">// 注意这里只传入了NodeLister，也就是是说只需要list node相关的信息就可以了</span><br>sourceProvider := summary.NewSummaryProvider(informerFactory.Core().V1().Nodes().Lister(), kubeletClient, addrResolver)<br>scrapeTimeout := time.Duration(<span class="hljs-type">float64</span>(o.MetricResolution) * <span class="hljs-number">0.90</span>) <span class="hljs-comment">// scrape timeout is 90% of the scrape interval</span><br>    <span class="hljs-comment">// 将抓取时间间隔放到本server的metric接口中，并创建一个sourceManager</span><br>sources.RegisterDurationMetrics(scrapeTimeout)<br>sourceManager := sources.NewSourceManager(sourceProvider, scrapeTimeout)<br><br><span class="hljs-comment">// 3、创建metricSink用来保存获取并解析出来的监控数据（仅保存在内存中）</span><br>    <span class="hljs-comment">//    需要注意的是，这里的metricSink和metricsProvider是同一个sinkMetricsProvider实例</span><br>metricSink, metricsProvider := sink.NewSinkProvider()<br><br><span class="hljs-comment">// 4、创建一个Manager用来将前面的sourceProvider和metricSink管理起来，前者抓数据，后者存数据</span><br>manager.RegisterDurationMetrics(o.MetricResolution)<br>mgr := manager.NewManager(sourceManager, metricSink, o.MetricResolution)<br><br><span class="hljs-comment">// 1.1、将刚才的metricSink传入到server的配置中去，这样http server直接从metricSink中获取数据，然后直接返回给client就可以了，不需要再去调用cadvisor查metric数据</span><br>config.ProviderConfig.Node = metricsProvider<br>config.ProviderConfig.Pod = metricsProvider<br><br><span class="hljs-comment">// 1.2、通过config给将要启动的server做一些初始化的动作，同时也将informerFactory传进去</span><br>server, err := config.Complete(informerFactory).New()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// add health checks</span><br>server.AddHealthzChecks(healthz.NamedCheck(<span class="hljs-string">&quot;healthz&quot;</span>, mgr.CheckHealth))<br><br><span class="hljs-comment">// 5、将刚才的manager运行起来（调用cadvisor的接口获取并解析数据，然后存到metricSink中）</span><br>mgr.RunUntil(stopCh)<br>    <span class="hljs-comment">// 1.3、根据1中的配置将metric-server启动起来</span><br><span class="hljs-keyword">return</span> server.GenericAPIServer.PrepareRun().Run(stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><p>从这段代码中可以看出来，数据的抓取和缓存与<code>server</code>是两个不同的处理流程，他们之间通过共享内存来配合，数据定期抓取完之后缓存到<code>metricSink</code>（其实也就是<code>metricsProvider</code>）中，而<code>server</code>收到请求时从<code>metricSink</code>中读取数据并返回给<code>client</code>。这个过程也正好回答了我们之前的问题，<code>metrics-server</code>中已经定期从中<code>cadvisor</code>获取好数据了，当请求发过来时直接返回缓存中的数据。</p><h4 id="4-2、数据抓取与缓存"><a href="#4-2、数据抓取与缓存" class="headerlink" title="4.2、数据抓取与缓存"></a>4.2、数据抓取与缓存</h4><p>4.1章节代码注释中的2&#x2F;3&#x2F;4&#x2F;5小节就是<code>metric-server</code>的数据抓取流程的启动过程，我们暂且称之为<code>manager</code>，我们看到这其中主要是起了两个<code>client</code>，一个是<code>kube-apiserver</code>的<code>client</code>用来获取集群中<code>node</code>资源，另一个client则是调用节点上<code>cadvisor</code>的接口获取节点和<code>pod</code>的<code>cpu</code>和<code>memory</code>监控数据，同时也创建了一个<code>metricSink</code>用来保存获取的监控数据。话不多说，我们来看一下这个<code>manager</code>是如何运转的。</p><p>我们将4.1章节代码注释中的4和5连在一起就是<code>manager</code>的启动过程，创建一个<code>manager</code>然后运行起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">manager.RegisterDurationMetrics(o.MetricResolution)<br>mgr := manager.NewManager(sourceManager, metricSink, o.MetricResolution)<br><br>mgr.RunUntil(stopCh)<br></code></pre></td></tr></table></figure><p>上面的启动过程实际如下，创建好的<code>manager</code>运行是其实就是周期性地执行其<code>Collect</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/manager/manager.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewManager</span><span class="hljs-params">(metricSrc sources.MetricSource, metricSink sink.MetricSink, resolution time.Duration)</span></span> *Manager &#123;<br>manager := Manager&#123;<br>source:     metricSrc, <span class="hljs-comment">// 抓取metric的interface，需要实现Collect</span><br>sink:       metricSink, <span class="hljs-comment">// 保存抓取数据的接收器，需要实现Receive</span><br>resolution: resolution, <span class="hljs-comment">// 抓取metric的时间间隔</span><br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;manager<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rm *Manager)</span></span> RunUntil(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 创建一个周期性的定时器</span><br>ticker := time.NewTicker(rm.resolution)<br><span class="hljs-keyword">defer</span> ticker.Stop()<br>rm.Collect(time.Now())<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-comment">// 周期性执行Collect</span><br><span class="hljs-keyword">case</span> startTime := &lt;-ticker.C:<br>rm.Collect(startTime) <span class="hljs-comment">// 实际周期性执行的是这里的Collect函数</span><br><span class="hljs-keyword">case</span> &lt;-stopCh:<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来看<code>Collect</code>函数中的逻辑就很简介明了了，主要做了两件事件：</p><ul><li>调用sourceManager实现的Collect函数获取metric数据</li><li>将获取到的原始metric数据解析成pod和node的数值并保存metricSink中去</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rm *Manager)</span></span> Collect(startTime time.Time) &#123;<br>rm.healthMu.Lock()<br>rm.lastTickStart = startTime<br>rm.healthMu.Unlock()<br><br>healthyTick := <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 给发request的context中设置超时时间为manager的检查周期</span><br>ctx, cancelTimeout := context.WithTimeout(context.Background(), rm.resolution)<br><span class="hljs-keyword">defer</span> cancelTimeout()<br><br>klog.V(<span class="hljs-number">6</span>).Infof(<span class="hljs-string">&quot;Beginning cycle, collecting metrics...&quot;</span>)<br>    <span class="hljs-comment">// 1、执行sourceManager实现的Collect函数获取metric数据</span><br>data, collectErr := rm.source.Collect(ctx)<br>    <br>    <span class="hljs-comment">// 省略异常处理的逻辑</span><br><br>klog.V(<span class="hljs-number">6</span>).Infof(<span class="hljs-string">&quot;...Storing metrics...&quot;</span>)<br>    <span class="hljs-comment">// 2、将获取到的原始metric数据保存到metricSink中去</span><br>recvErr := rm.sink.Receive(data)<br>    <br>    <span class="hljs-comment">// 省略异常处理的逻辑</span><br><br>    <span class="hljs-comment">// 将实际的collect处理时间放到自己的metric接口中</span><br>collectTime := time.Since(startTime)<br>tickDuration.Observe(<span class="hljs-type">float64</span>(collectTime) / <span class="hljs-type">float64</span>(time.Second))<br>klog.V(<span class="hljs-number">6</span>).Infof(<span class="hljs-string">&quot;...Cycle complete&quot;</span>)<br><br>rm.healthMu.Lock()<br>rm.lastOk = healthyTick<br>rm.healthMu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-1、获取metric数据（rm-source-Collect-ctx-）"><a href="#4-2-1、获取metric数据（rm-source-Collect-ctx-）" class="headerlink" title="4.2.1、获取metric数据（rm.source.Collect(ctx)）"></a>4.2.1、获取<code>metric</code>数据（<code>rm.source.Collect(ctx)</code>）</h5><p>获取<code>metric</code>数据本质上就是调接口获取第4章节开头说的<code>/metric</code>格式的数据，而这个接口本质上就是k8s集群中节点上的<code>cadvisor</code>（实际由<code>kubelet</code>暴露），因此这部分的逻辑就是围绕这个思路展开。</p><ul><li>首先需要知道这个集群中有哪些节点，并获取这些节点上获取<code>metric</code>的<code>ip</code>和端口</li><li>分别调用这些节点上的<code>metric</code>接口并解析其中<code>node</code>和<code>pod</code>的<code>cpu</code>和<code>memory</code>数值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/manager.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *sourceManager)</span></span> Collect(baseCtx context.Context) (*MetricsBatch, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 1、获取需要抓取数据的所有源头，即集群中节点上的cadvisor接口</span><br>sources, err := m.srcProv.GetMetricSources()<br><span class="hljs-keyword">var</span> errs []<span class="hljs-type">error</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>errs = <span class="hljs-built_in">append</span>(errs, err)<br>&#125;<br>klog.V(<span class="hljs-number">1</span>).Infof(<span class="hljs-string">&quot;Scraping metrics from %v sources&quot;</span>, <span class="hljs-built_in">len</span>(sources))<br>    <span class="hljs-comment">// 创建接受数据和错误的channel</span><br>responseChannel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *MetricsBatch, <span class="hljs-built_in">len</span>(sources))<br>errChannel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, <span class="hljs-built_in">len</span>(sources))<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(responseChannel)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(errChannel)<br>startTime := time.Now()<br>delayMs := delayPerSourceMs * <span class="hljs-built_in">len</span>(sources)<br><span class="hljs-keyword">if</span> delayMs &gt; maxDelayMs &#123;<br>delayMs = maxDelayMs<br>&#125;<br><span class="hljs-keyword">for</span> _, source := <span class="hljs-keyword">range</span> sources &#123;<br>        <span class="hljs-comment">// 2、分别起一个协程去调每个source的接口抓取数据，并写入到channel中</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(source MetricSource)</span></span> &#123;<br>            <span class="hljs-comment">// 每个协程中随机sleep一段时间，防止几个协程同时发请求造成网络拥塞</span><br>sleepDuration := time.Duration(rand.Intn(delayMs)) * time.Millisecond<br>time.Sleep(sleepDuration)<br><span class="hljs-comment">// 超时时间减去刚才sleep的时间</span><br>ctx, cancelTimeout := context.WithTimeout(baseCtx, m.scrapeTimeout-sleepDuration)<br><span class="hljs-keyword">defer</span> cancelTimeout()<br>klog.V(<span class="hljs-number">2</span>).Infof(<span class="hljs-string">&quot;Querying source: %s&quot;</span>, source)<br>            <span class="hljs-comment">// 抓取数据</span><br>metrics, err := scrapeWithMetrics(ctx, source)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>err = fmt.Errorf(<span class="hljs-string">&quot;unable to fully scrape metrics from source %s: %v&quot;</span>, source.Name(), err)<br>&#125;<br>responseChannel &lt;- metrics<br>errChannel &lt;- err<br>&#125;(source)<br>&#125;<br>res := &amp;MetricsBatch&#123;&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> sources &#123;<br>        <span class="hljs-comment">// 将抓取的数据分成node和pod的保存下来并返回</span><br>err := &lt;-errChannel<br>srcBatch := &lt;-responseChannel<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>errs = <span class="hljs-built_in">append</span>(errs, err)<br>&#125;<br><span class="hljs-keyword">if</span> srcBatch == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>res.Nodes = <span class="hljs-built_in">append</span>(res.Nodes, srcBatch.Nodes...)<br>res.Pods = <span class="hljs-built_in">append</span>(res.Pods, srcBatch.Pods...)<br>&#125;<br><br>klog.V(<span class="hljs-number">1</span>).Infof(<span class="hljs-string">&quot;ScrapeMetrics: time: %s, nodes: %v, pods: %v&quot;</span>, time.Since(startTime), <span class="hljs-built_in">len</span>(res.Nodes), <span class="hljs-built_in">len</span>(res.Pods))<br><span class="hljs-keyword">return</span> res, utilerrors.NewAggregate(errs)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到上述两个关键点的细节都封装起来了，我们一个一个来看：</p><ol><li><h6 id="获取源头m-srcProv-GetMetricSources"><a href="#获取源头m-srcProv-GetMetricSources" class="headerlink" title="获取源头m.srcProv.GetMetricSources()"></a>获取源头<code>m.srcProv.GetMetricSources()</code></h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/summary/summary.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *summaryProvider)</span></span> GetMetricSources() ([]sources.MetricSource, <span class="hljs-type">error</span>) &#123;<br>sources := []sources.MetricSource&#123;&#125;<br>    <span class="hljs-comment">// 调用k8s接口List所有节点的信息</span><br>nodes, err := p.nodeLister.List(labels.Everything())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unable to list nodes: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">var</span> errs []<span class="hljs-type">error</span><br><span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> nodes &#123;<br>        <span class="hljs-comment">// 从节点的结构体中获取这个节点的IP和name，并和kubeletClient一起组装到source中去</span><br>        <span class="hljs-comment">// 注意节点的IP时根据启动参数kubelet-preferred-address-types优先级来获取的</span><br>info, err := p.getNodeInfo(node)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>errs = <span class="hljs-built_in">append</span>(errs, fmt.Errorf(<span class="hljs-string">&quot;unable to extract connection information for node %q: %v&quot;</span>, node.Name, err))<br><span class="hljs-keyword">continue</span><br>&#125;<br>        <span class="hljs-comment">// 注意所有source的kubeletClient是共用的，端口都是一样，区别是IP不同</span><br>sources = <span class="hljs-built_in">append</span>(sources, NewSummaryMetricsSource(info, p.kubeletClient))<br>&#125;<br><span class="hljs-keyword">return</span> sources, utilerrors.NewAggregate(errs)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSummaryMetricsSource</span><span class="hljs-params">(node NodeInfo, client KubeletInterface)</span></span> sources.MetricSource &#123;<br><span class="hljs-keyword">return</span> &amp;summaryMetricsSource&#123;<br>node:          node,<br>kubeletClient: client,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h6 id="抓取数据并解析数据scrapeWithMetrics-ctx-source"><a href="#抓取数据并解析数据scrapeWithMetrics-ctx-source" class="headerlink" title="抓取数据并解析数据scrapeWithMetrics(ctx, source)"></a>抓取数据并解析数据<code>scrapeWithMetrics(ctx, source)</code></h6></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/manager.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">scrapeWithMetrics</span><span class="hljs-params">(ctx context.Context, s MetricSource)</span></span> (*MetricsBatch, <span class="hljs-type">error</span>) &#123;<br>sourceName := s.Name()<br>startTime := time.Now()<br><span class="hljs-keyword">defer</span> lastScrapeTimestamp.<br>WithLabelValues(sourceName).<br>Set(<span class="hljs-type">float64</span>(time.Now().Unix()))<br><span class="hljs-keyword">defer</span> scraperDuration.<br>WithLabelValues(sourceName).<br>Observe(<span class="hljs-type">float64</span>(time.Since(startTime)) / <span class="hljs-type">float64</span>(time.Second))<br>    <span class="hljs-comment">// 实际调用MetricSource的Collect接口</span><br><span class="hljs-keyword">return</span> s.Collect(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>s.Collect(ctx)</code>实际上就是步骤1中<code>NewSummaryMetricsSource</code>创建出来的<code>MetricSource</code>的<code>Collect</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/summary/summary.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(src *summaryMetricsSource)</span></span> Collect(ctx context.Context) (*sources.MetricsBatch, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 关键逻辑，通过当前source的kubeletClient获取节点上的metric数据，并解析到summary中</span><br>    <span class="hljs-comment">// 这里之所以把这段逻辑协程闭包是为了在GetSummary执行完之后就马上执行defer中的逻辑</span><br>summary, err := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (*stats.Summary, <span class="hljs-type">error</span>) &#123;<br>startTime := time.Now()<br><span class="hljs-keyword">defer</span> summaryRequestLatency.WithLabelValues(src.node.Name).Observe(<span class="hljs-type">float64</span>(time.Since(startTime)) / <span class="hljs-type">float64</span>(time.Second))  <span class="hljs-comment">// 马上将执行时间写入自己的metric中</span><br><span class="hljs-keyword">return</span> src.kubeletClient.GetSummary(ctx, src.node.ConnectAddress)<br>&#125;()<br>    <span class="hljs-comment">// 部分省略</span><br>res := &amp;sources.MetricsBatch&#123;<br>Nodes: <span class="hljs-built_in">make</span>([]sources.NodeMetricsPoint, <span class="hljs-number">1</span>),<br>Pods:  <span class="hljs-built_in">make</span>([]sources.PodMetricsPoint, <span class="hljs-built_in">len</span>(summary.Pods)),<br>&#125;<br>    <br>    <span class="hljs-comment">// 省略部分解析summary中node和pod数据的逻辑</span><br><br><span class="hljs-keyword">return</span> res, utilerrors.NewAggregate(errs)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Collect</code>的逻辑本质上是执行了<code>GetSummary</code>，这里起了一个<code>http client</code>，然后给<code>https://&#123;node ip&#125;:&#123;port&#125;/stats/summary?only_cpu_and_memory=true</code>发了一个<code>GET</code>请求并获取了返回的<code>body</code>体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/summary/client.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kc *kubeletClient)</span></span> GetSummary(ctx context.Context, host <span class="hljs-type">string</span>) (*stats.Summary, <span class="hljs-type">error</span>) &#123;<br>scheme := <span class="hljs-string">&quot;https&quot;</span><br><span class="hljs-keyword">if</span> kc.deprecatedNoTLS &#123;<br>scheme = <span class="hljs-string">&quot;http&quot;</span><br>&#125;<br>url := url.URL&#123;<br>Scheme:   scheme,<br>Host:     net.JoinHostPort(host, strconv.Itoa(kc.port)),<br>Path:     <span class="hljs-string">&quot;/stats/summary&quot;</span>,<br>RawQuery: <span class="hljs-string">&quot;only_cpu_and_memory=true&quot;</span>,<br>&#125;<br><br>req, err := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, url.String(), <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>summary := &amp;stats.Summary&#123;&#125;<br>client := kc.client<br><span class="hljs-keyword">if</span> client == <span class="hljs-literal">nil</span> &#123;<br>client = http.DefaultClient<br>&#125;<br>    <span class="hljs-comment">// 执行req并将response中的body体保存到summary中</span><br>err = kc.makeRequestAndGetValue(client, req.WithContext(ctx), summary)<br><span class="hljs-keyword">return</span> summary, err<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6></li></ol><p>通过4.2.1中的代码分析我们印证之前的过程，获取<code>metric</code>数据本质上就是调用<code>cadvisor</code>的接口来获取数据而已。这里我们有必要来看一下之前我们忽略掉的关键数据结构<code>MetricsBatch</code>，这是最终解析出来的包含了<code>node</code>和<code>pod</code>的<code>cpu</code>和<code>memory</code>信息的对象，也是传递给<code>metricSink</code>的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/sources/interfaces.go</span><br><span class="hljs-comment">// MetricsBatch是所有node和所有pod的metric数据</span><br><span class="hljs-keyword">type</span> MetricsBatch <span class="hljs-keyword">struct</span> &#123;<br>Nodes []NodeMetricsPoint<br>Pods  []PodMetricsPoint<br>&#125;<br><span class="hljs-comment">// NodeMetricsPoint包含这个节点的metric数据</span><br><span class="hljs-keyword">type</span> NodeMetricsPoint <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>MetricsPoint<br>&#125;<br><span class="hljs-comment">// PodMetricsPoint包含了这个pod所有容器的metric数据</span><br><span class="hljs-keyword">type</span> PodMetricsPoint <span class="hljs-keyword">struct</span> &#123;<br>Name      <span class="hljs-type">string</span><br>Namespace <span class="hljs-type">string</span><br>Containers []ContainerMetricsPoint<br>&#125;<br><span class="hljs-comment">// ContainerMetricsPoint包含这个容器的metric数据</span><br><span class="hljs-keyword">type</span> ContainerMetricsPoint <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>MetricsPoint<br>&#125;<br><span class="hljs-comment">// MetricsPoint是node和容器metric数据的基本单位，其中包含了cpu和memory度量</span><br><span class="hljs-keyword">type</span> MetricsPoint <span class="hljs-keyword">struct</span> &#123;<br>Timestamp time.Time<br><span class="hljs-comment">// CpuUsage is the CPU usage rate, in cores</span><br>CpuUsage resource.Quantity<br><span class="hljs-comment">// MemoryUsage is the working set size, in bytes.</span><br>MemoryUsage resource.Quantity<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-2、保存metric数据（rm-sink-Receive-data-）"><a href="#4-2-2、保存metric数据（rm-sink-Receive-data-）" class="headerlink" title="4.2.2、保存metric数据（rm.sink.Receive(data)）"></a>4.2.2、保存<code>metric</code>数据（<code>rm.sink.Receive(data)</code>）</h5><p>4.2.1中已经调用集群中所有节点的<code>cadvisor</code>接口并获取了所有节点和<code>pod</code>的<code>metric</code>数据，接下来就是保存到缓存中了。前面已经将获取到的数据存在了<code>data</code>（本质上就是4.2.1总结时说到的<code>MetricsBatch</code>）变量中，接下来就时对这个变量进行处理了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/provider/sink/sinkprov.go</span><br><span class="hljs-comment">// sinkMetricsProvider既实现了provider.MetricsProvider（提供server时使用）也实现了sink.MetricSink（抓取后缓存数据用）</span><br><span class="hljs-comment">// sinkMetricsProvider本质上就是两个map，一个保存node，一个保存pod</span><br><span class="hljs-keyword">type</span> sinkMetricsProvider <span class="hljs-keyword">struct</span> &#123;<br>mu    sync.RWMutex<br>nodes <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]sources.NodeMetricsPoint<br>pods  <span class="hljs-keyword">map</span>[apitypes.NamespacedName]sources.PodMetricsPoint<br>&#125;<br><span class="hljs-comment">// metric-server收到node的GET请求调用这个函数来获取metric数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sinkMetricsProvider)</span></span> GetNodeMetrics(nodes ...<span class="hljs-type">string</span>) ([]provider.TimeInfo, []corev1.ResourceList, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 代码逻辑略</span><br>&#125;<br><span class="hljs-comment">// metric-server收到pod的GET请求调用这个函数来获取metric数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sinkMetricsProvider)</span></span> GetContainerMetrics(pods ...apitypes.NamespacedName) ([]provider.TimeInfo, [][]metrics.ContainerMetrics, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 代码逻辑略，4.3节的metric-server再讲</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sinkMetricsProvider)</span></span> Receive(batch *sources.MetricsBatch) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 创建一个新的node的map，并将数据去重写入</span><br>newNodes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]sources.NodeMetricsPoint, <span class="hljs-built_in">len</span>(batch.Nodes))<br><span class="hljs-keyword">for</span> _, nodePoint := <span class="hljs-keyword">range</span> batch.Nodes &#123;<br><span class="hljs-keyword">if</span> _, exists := newNodes[nodePoint.Name]; exists &#123;<br>klog.Errorf(<span class="hljs-string">&quot;duplicate node %s received&quot;</span>, nodePoint.Name)<br><span class="hljs-keyword">continue</span><br>&#125;<br>newNodes[nodePoint.Name] = nodePoint<br>&#125;<br>    <span class="hljs-comment">// 创建一个新的pod的map，并将数据去重写入</span><br>newPods := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[apitypes.NamespacedName]sources.PodMetricsPoint, <span class="hljs-built_in">len</span>(batch.Pods))<br><span class="hljs-keyword">for</span> _, podPoint := <span class="hljs-keyword">range</span> batch.Pods &#123;<br>podIdent := apitypes.NamespacedName&#123;Name: podPoint.Name, Namespace: podPoint.Namespace&#125;<br><span class="hljs-keyword">if</span> _, exists := newPods[podIdent]; exists &#123;<br>klog.Errorf(<span class="hljs-string">&quot;duplicate pod %s received&quot;</span>, podIdent)<br><span class="hljs-keyword">continue</span><br>&#125;<br>newPods[podIdent] = podPoint<br>&#125;<br><br>p.mu.Lock()<br><span class="hljs-keyword">defer</span> p.mu.Unlock()<br>    <span class="hljs-comment">// 将刚创建的新map赋值给provider，注意之前的旧map就直接回收了</span><br>p.nodes = newNodes<br>p.pods = newPods<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到<code>sinkMetricsProvider</code>数据的结构体本质上就是两个<code>map</code>而已，而保存的逻辑也非常简单，直接创建两个新map并赋值过去就可以，并不需要处理之前的旧数据，简单粗暴。</p><h4 id="4-3、metric-server"><a href="#4-3、metric-server" class="headerlink" title="4.3、metric-server"></a>4.3、<code>metric-server</code></h4><p>在4.1节的启动程序中已经说明了<code>metric-server</code>的启动过程，经过4.2.2的代码分析之后，我们可以猜测<code>metric-server</code>本质上就是收到请求之后到<code>sinkMetricsProvider</code>的两个<code>map</code>中读取数据并返回而已。</p><p>我们回到启动程序中，这里包含了两个步骤，一个是创建好一个<code>server</code>（本质上是<code>k8s.io/apiserver</code>库的一个<code>GenericAPIServer</code>），另一个则是直接将这个<code>server</code>运行起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 关键逻辑：通过配置文件创建好对应的GenericAPIServer</span><br>server, err := config.Complete(informerFactory).New()<br><span class="hljs-comment">// 将GenericAPIServer运行起来</span><br><span class="hljs-keyword">return</span> server.GenericAPIServer.PrepareRun().Run(stopCh)<br></code></pre></td></tr></table></figure><p>由于<code>k8s.io/apiserver</code>库的原理比较复杂，暂且不表，我们只讲创建<code>GenericAPIServer</code>的创建流程并说明<code>server</code>是如何使用的。对于<code>metric-server</code>而言，需要先创建一个<code>GenericAPIServer</code>，然后将<code>metric-server</code>自己的<code>API</code>与对应的处理<code>handler</code>注册进来即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/apiserver/config.go</span><br><span class="hljs-keyword">type</span> MetricsServer <span class="hljs-keyword">struct</span> &#123;<br>*genericapiserver.GenericAPIServer<br>&#125;<br><span class="hljs-comment">// New returns a new instance of MetricsServer from the given config.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c completedConfig)</span></span> New() (*MetricsServer, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 创建一个名为&quot;metrics-server&quot;的genericServer</span><br>genericServer, err := c.CompletedConfig.New(<span class="hljs-string">&quot;metrics-server&quot;</span>, genericapiserver.NewEmptyDelegate()) <span class="hljs-comment">// completion is done in Complete, no need for a second time</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>    <span class="hljs-comment">// 关键逻辑：将metric-server的处理实体注册到genericServer中，下文继续讲解</span><br><span class="hljs-keyword">if</span> err := generic.InstallStorage(c.ProviderConfig, c.SharedInformerFactory.Core().V1(), genericServer); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> &amp;MetricsServer&#123;<br>GenericAPIServer: genericServer,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在注册<code>metric-server</code>自己的<code>API</code>时，需要先创建一个<code>APIGroup</code>（即<code>metrics.k8s.io</code>），然后将这个<code>Group</code>下面的各个资源（例如这里的<code>&quot;nodes&quot;</code>和<code>&quot;pods&quot;</code>）的<code>Storage</code>注册到<code>VersionedResourcesStorageMap</code>中，这里面最关键的就是每个资源的<code>Storage</code>需要实现处理请求的rest接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/apiserver/generic/storage.go</span><br><span class="hljs-comment">// InstallStorage构造一个metrics.k8s.io的apiGroup并注册到genericServer中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InstallStorage</span><span class="hljs-params">(providers *ProviderConfig, informers coreinf.Interface, server *genericapiserver.GenericAPIServer)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 创建一个APIGroup</span><br>info := BuildStorage(providers, informers)<br>    <span class="hljs-comment">// 将这个APIGroup注册到GenericAPIServer中</span><br><span class="hljs-keyword">return</span> server.InstallAPIGroup(&amp;info)<br>&#125;<br><br><span class="hljs-comment">// BuildStorage构造一个名为&quot;metrics.k8s.io&quot;的apiGroup</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildStorage</span><span class="hljs-params">(providers *ProviderConfig, informers coreinf.Interface)</span></span> genericapiserver.APIGroupInfo &#123;<br>    <span class="hljs-comment">// 创建一个名为&quot;metrics.k8s.io&quot;的apiGroup</span><br>apiGroupInfo := genericapiserver.NewDefaultAPIGroupInfo(metrics.GroupName, Scheme, metav1.ParameterCodec, Codecs)<br>    <span class="hljs-comment">// 创建node的storage，这个storage跟pod的类似，下文以pod为例</span><br>nodemetricsStorage := nodemetricsstorage.NewStorage(metrics.Resource(<span class="hljs-string">&quot;nodemetrics&quot;</span>), providers.Node, informers.Nodes().Lister())<br>    <span class="hljs-comment">// 创建pod的storage，这个storage中实现了收到请求之后的处理逻辑，下文继续讲解</span><br>podmetricsStorage := podmetricsstorage.NewStorage(metrics.Resource(<span class="hljs-string">&quot;podmetrics&quot;</span>), providers.Pod, informers.Pods().Lister())<br>    <span class="hljs-comment">// 将node和pod的Storage存放到map中</span><br>metricsServerResources := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]rest.Storage&#123;<br><span class="hljs-string">&quot;nodes&quot;</span>: nodemetricsStorage,<br><span class="hljs-string">&quot;pods&quot;</span>:  podmetricsStorage,<br>&#125;<br>    <span class="hljs-comment">// 在&quot;metrics.k8s.io&quot;这个apiGroup中注册&quot;v1beta1&quot;这个version的Storage处理map</span><br>apiGroupInfo.VersionedResourcesStorageMap[v1beta1.SchemeGroupVersion.Version] = metricsServerResources<br><span class="hljs-keyword">return</span> apiGroupInfo<br>&#125;<br></code></pre></td></tr></table></figure><p>这里以<code>pod</code>的<code>MetricStorage</code>的<code>Getter</code>接口为例，这里实现的<code>Get</code>函数就是当<code>metric-server</code>收到获取某个<code>pod</code>的<code>metric</code>的请求时处理该请求的Handler。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/storage/podmetrics/reststorage.go</span><br><span class="hljs-keyword">type</span> MetricStorage <span class="hljs-keyword">struct</span> &#123;<br>groupResource schema.GroupResource<br>prov          provider.PodMetricsProvider<br>podLister     v1listers.PodLister<br>&#125;<br><span class="hljs-comment">// 用来检查MetricStorage已经实现了rest的这4个接口</span><br><span class="hljs-keyword">var</span> _ rest.KindProvider = &amp;MetricStorage&#123;&#125;<br><span class="hljs-keyword">var</span> _ rest.Storage = &amp;MetricStorage&#123;&#125;<br><span class="hljs-keyword">var</span> _ rest.Getter = &amp;MetricStorage&#123;&#125;<br><span class="hljs-keyword">var</span> _ rest.Lister = &amp;MetricStorage&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStorage</span><span class="hljs-params">(groupResource schema.GroupResource, prov provider.PodMetricsProvider, podLister v1listers.PodLister)</span></span> *MetricStorage &#123;<br><span class="hljs-keyword">return</span> &amp;MetricStorage&#123;<br>groupResource: groupResource,<br>prov:          prov,<br>podLister:     podLister,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实现rest.Getter接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MetricStorage)</span></span> Get(ctx context.Context, name <span class="hljs-type">string</span>, opts *metav1.GetOptions) (runtime.Object, <span class="hljs-type">error</span>) &#123;<br>namespace := genericapirequest.NamespaceValue(ctx)<br>    <span class="hljs-comment">// 从k8s的client缓存中获取pod信息</span><br>pod, err := m.podLister.Pods(namespace).Get(name)<br>    <br>    <span class="hljs-comment">// 省略异常处理的逻辑</span><br>    <br>    <span class="hljs-comment">// 从之前的sinkMetric缓存中获取这个pod的</span><br>podMetrics, err := m.getPodMetrics(pod)<br>    <br>    <span class="hljs-comment">// 省略异常处理的逻辑</span><br>    <br><span class="hljs-keyword">return</span> &amp;podMetrics[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MetricStorage)</span></span> getPodMetrics(pods ...*v1.Pod) ([]metrics.PodMetrics, <span class="hljs-type">error</span>) &#123;<br>namespacedNames := <span class="hljs-built_in">make</span>([]apitypes.NamespacedName, <span class="hljs-built_in">len</span>(pods))<br><span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>namespacedNames[i] = apitypes.NamespacedName&#123;<br>Name:      pod.Name,<br>Namespace: pod.Namespace,<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 从缓存中获取pod的metric数据，这其实就是调用的4.2.2节中的GetContainerMetrics</span><br>timestamps, containerMetrics, err := m.prov.GetContainerMetrics(namespacedNames...)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>res := <span class="hljs-built_in">make</span>([]metrics.PodMetrics, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(pods))<br><span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        <span class="hljs-comment">// 省略pod状态不为Running和metric数据为空的continue逻辑</span><br><br>        <span class="hljs-comment">// 创建返回体的内容</span><br>res = <span class="hljs-built_in">append</span>(res, metrics.PodMetrics&#123;<br>ObjectMeta: metav1.ObjectMeta&#123;<br>Name:              pod.Name,<br>Namespace:         pod.Namespace,<br>CreationTimestamp: metav1.NewTime(time.Now()),<br>&#125;,<br>Timestamp:  metav1.NewTime(timestamps[i].Timestamp),<br>Window:     metav1.Duration&#123;Duration: timestamps[i].Window&#125;,<br>Containers: containerMetrics[i],<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> res, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们终于又回到了4.2.2中的<code>sinkMetricsProvider</code>，这不过这次是从其<code>map</code>中读取数据。在此数据抓取和<code>metric-server</code>这两部分就连到一起了，我们其实也可以把这两部分当成一个生产者消费者模式，前者负责生产数据，后者则读取数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pkg/provider/sink/sinkprov.go</span><br><span class="hljs-comment">// metric-server收到pod的GET请求调用这个函数来获取metric数据</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *sinkMetricsProvider)</span></span> GetContainerMetrics(pods ...apitypes.NamespacedName) ([]provider.TimeInfo, [][]metrics.ContainerMetrics, <span class="hljs-type">error</span>) &#123;<br>p.mu.RLock()<br><span class="hljs-keyword">defer</span> p.mu.RUnlock()<br><br>timestamps := <span class="hljs-built_in">make</span>([]provider.TimeInfo, <span class="hljs-built_in">len</span>(pods))<br>resMetrics := <span class="hljs-built_in">make</span>([][]metrics.ContainerMetrics, <span class="hljs-built_in">len</span>(pods))<br><br><span class="hljs-keyword">for</span> i, pod := <span class="hljs-keyword">range</span> pods &#123;<br>        <span class="hljs-comment">// 从pod的map中获取metric数据</span><br>metricPoint, present := p.pods[pod]<br><span class="hljs-keyword">if</span> !present &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 省略中间的处理逻辑</span><br>resMetrics[i] = contMetrics<br>&#125;<br><span class="hljs-keyword">return</span> timestamps, resMetrics, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-sync包介绍</title>
    <link href="/2025/04/06/Go-sync%E5%8C%85%E4%BB%8B%E7%BB%8D/"/>
    <url>/2025/04/06/Go-sync%E5%8C%85%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-sync包介绍"><a href="#Go-sync包介绍" class="headerlink" title="Go sync包介绍"></a>Go sync包介绍</h1><p>转自：<a href="https://segmentfault.com/a/1190000022545889">https://segmentfault.com/a/1190000022545889</a></p><p>在并发编程中同步原语也就是我们通常说的锁的主要作用是保证多个线程或者 <code>goroutine</code>在访问同一片内存时不会出现混乱的问题。<code>Go</code>语言的<code>sync</code>包提供了常见的并发编程同步原语，上一期转载的文章《<a href="https://link.segmentfault.com/?enc=TitSKVQMWEaJuZcPts3ceg==.DQeNe2dUjbZ5w8XBZWYnqG9IQ9bmqH7xPSzEs29VV09MGt1b7UbWVV9D361cVn6/9EWIIRQjWarFH9kvaUODTMIOJxOr7hvsEHpdOKVGFy6tLC+cONb4Prn1ibnUH5iw0XrF4+OvcHDtu4DBJ3vnG3gBAm7yoezP/nBtoPqkMK5HfdVxdGnSrEuWIHlNgPnU1vKykAzZ4T4SEeggLQ29AxR2OhCY0BXdBD5roFvJtj5lwTPTXCi35C5BM990jIMd+QYouz3ZiekEpGI992udCQLrGKK2K4f3dKrgZe5nozk6I6/W5cxaxjSG51Zq7aqepcgXXhPyafsXj0j69QvYog==">Golang 并发编程之同步原语</a>》中也详述了 <code>Mutex</code>、<code>RWMutex</code>、<code>WaitGroup</code>、<code>Once</code> 和 <code>Cond</code> 这些同步原语的实现原理。今天的文章里让我们回到应用层，聚焦<code>sync</code>包里这些同步原语的应用场景，同时也会介绍<code>sync</code>包中的<code>Pool</code>和<code>Map</code>的应用场景和使用方法。话不多说，让我们开始吧。</p><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p><code>sync.Mutex</code>可能是<code>sync</code>包中使用最广泛的原语。它允许在共享资源上互斥访问（不能同时访问）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">mutex := &amp;sync.Mutex&#123;&#125;<br><br>mutex.Lock()<br><span class="hljs-comment">// Update共享变量 (比如切片，结构体指针等)</span><br>mutex.Unlock()<br></code></pre></td></tr></table></figure><p>必须指出的是，在第一次被使用后，不能再对<code>sync.Mutex</code>进行复制。（<code>sync</code>包的所有原语都一样）。如果结构体具有同步原语字段，则必须通过指针传递它。</p><h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p><code>sync.RWMutex</code>是一个读写互斥锁，它提供了我们上面的刚刚看到的<code>sync.Mutex</code>的<code>Lock</code>和<code>UnLock</code>方法（因为这两个结构都实现了<code>sync.Locker</code>接口）。但是，它还允许使用<code>RLock</code>和<code>RUnlock</code>方法进行并发读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">mutex := &amp;sync.RWMutex&#123;&#125;<br><br>mutex.Lock()<br><span class="hljs-comment">// Update 共享变量</span><br>mutex.Unlock()<br><br>mutex.RLock()<br><span class="hljs-comment">// Read 共享变量</span><br>mutex.RUnlock()<br></code></pre></td></tr></table></figure><p><code>sync.RWMutex</code>允许至少一个读锁或一个写锁存在，而<code>sync.Mutex</code>允许一个读锁或一个写锁存在。</p><p>通过基准测试来比较这几个方法的性能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">BenchmarkMutexLock-4       83497579         17.7 ns/op<br>BenchmarkRWMutexLock-4     35286374         44.3 ns/op<br>BenchmarkRWMutexRLock-4    89403342         15.3 ns/op<br></code></pre></td></tr></table></figure><p>可以看到锁定&#x2F;解锁<code>sync.RWMutex</code>读锁的速度比锁定&#x2F;解锁<code>sync.Mutex</code>更快，另一方面，在<code>sync.RWMutex</code>上调用<code>Lock()</code>&#x2F; <code>Unlock()</code>是最慢的操作。</p><p>因此，只有在频繁读取和不频繁写入的场景里，才应该使用<code>sync.RWMutex</code>。</p><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p><code>sync.WaitGroup</code>也是一个经常会用到的同步原语，它的使用场景是在一个<code>goroutine</code>等待一组<code>goroutine</code>执行完成。</p><p><code>sync.WaitGroup</code>拥有一个内部计数器。当计数器等于<code>0</code>时，则<code>Wait()</code>方法会立即返回。否则它将阻塞执行<code>Wait()</code>方法的<code>goroutine</code>直到计数器等于<code>0</code>时为止。</p><p>要增加计数器，我们必须使用<code>Add(int)</code>方法。要减少它，我们可以使用<code>Done()</code>（将计数器减<code>1</code>），也可以传递负数给<code>Add</code>方法把计数器减少指定大小，<code>Done()</code>方法底层就是通过<code>Add(-1)</code>实现的。</p><p>在以下示例中，我们将启动八个<code>goroutine</code>，并等待他们完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">wg := &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++ &#123;<br>  wg.Add(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Do something</span><br>    wg.Done()<br>  &#125;()<br>&#125;<br><br>wg.Wait()<br><span class="hljs-comment">// 继续往下执行...</span><br></code></pre></td></tr></table></figure><p>每次创建<code>goroutine</code>时，我们都会使用<code>wg.Add(1)</code>来增加<code>wg</code>的内部计数器。我们也可以在<code>for</code>循环之前调用<code>wg.Add(8)</code>。</p><p>与此同时，每个<code>goroutine</code>完成时，都会使用<code>wg.Done()</code>减少<code>wg</code>的内部计数器。</p><p><code>main goroutine</code>会在八个<code>goroutine</code>都执行<code>wg.Done()</code>将计数器变为<code>0</code>后才能继续执行。</p><h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p><code>sync.Map</code>是一个并发版本的<code>Go</code>语言的<code>map</code>，我们可以：</p><ul><li>使用<code>Store(interface &#123;&#125;，interface &#123;&#125;)</code>添加元素。</li><li>使用<code>Load(interface &#123;&#125;) interface &#123;&#125;</code>检索元素。</li><li>使用<code>Delete(interface &#123;&#125;)</code>删除元素。</li><li>使用<code>LoadOrStore(interface &#123;&#125;，interface &#123;&#125;) (interface &#123;&#125;，bool)</code>检索或添加之前不存在的元素。如果键之前在<code>map</code>中存在，则返回的布尔值为<code>true</code>。</li><li>使用<code>Range</code>遍历元素。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">m := &amp;sync.Map&#123;&#125;<br><br><span class="hljs-comment">// 添加元素</span><br>m.Store(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>)<br>m.Store(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>)<br><br><span class="hljs-comment">// 获取元素1</span><br>value, contains := m.Load(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> contains &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, value.(<span class="hljs-type">string</span>))<br>&#125;<br><br><span class="hljs-comment">// 返回已存value，否则把指定的键值存储到map中</span><br>value, loaded := m.LoadOrStore(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-keyword">if</span> !loaded &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, value.(<span class="hljs-type">string</span>))<br>&#125;<br><br>m.Delete(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 迭代所有元素</span><br>m.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%d: %s\n&quot;</span>, key.(<span class="hljs-type">int</span>), value.(<span class="hljs-type">string</span>))<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>上面的程序会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">one<br>three<br>1: one<br>2: two<br></code></pre></td></tr></table></figure><p>如你所见，<code>Range</code>方法接收一个类型为<code>func(key，value interface &#123;&#125;)bool</code>的函数参数。如果函数返回了<code>false</code>，则停止迭代。有趣的事实是，即使我们在恒定时间后返回<code>false</code>，最坏情况下的时间复杂度仍为<code>O(n)</code>。</p><p>我们应该在什么时候使用<code>sync.Map</code>而不是在普通的<code>map</code>上使用<code>sync.Mutex</code>？</p><ul><li>当我们对<code>map</code>有频繁的读取和不频繁的写入时。</li><li>当多个<code>goroutine</code>读取，写入和覆盖不相交的键时。具体是什么意思呢？例如，如果我们有一个分片实现，其中包含一组4个<code>goroutine</code>，每个<code>goroutine</code>负责25％的键（每个负责的键不冲突）。在这种情况下，<code>sync.Map</code>是首选。</li></ul><h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><p><code>sync.Pool</code>是一个并发池，负责安全地保存一组对象。它有两个导出方法：</p><ul><li><code>Get() interface&#123;&#125;</code> 用来从并发池中取出元素。</li><li><code>Put(interface&#123;&#125;)</code> 将一个对象加入并发池。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">pool := &amp;sync.Pool&#123;&#125;<br><br>pool.Put(NewConnection(<span class="hljs-number">1</span>))<br>pool.Put(NewConnection(<span class="hljs-number">2</span>))<br>pool.Put(NewConnection(<span class="hljs-number">3</span>))<br><br>connection := pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>connection = pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>connection = pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">1<br>3<br>2<br></code></pre></td></tr></table></figure><p>需要注意的是<code>Get()</code>方法会从并发池中随机取出对象，无法保证以固定的顺序获取并发池中存储的对象。</p><p>还可以为<code>sync.Pool</code>指定一个创建者方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">pool := &amp;sync.Pool&#123;<br>  New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    <span class="hljs-keyword">return</span> NewConnection()<br>  &#125;,<br>&#125;<br><br>connection := pool.Get().(*Connection)<br></code></pre></td></tr></table></figure><p>这样每次调用<code>Get()</code>时，将返回由在<code>pool.New</code>中指定的函数创建的对象（在本例中为指针）。</p><p>那么什么时候使用sync.Pool？有两个用例：</p><p>第一个是当我们必须重用共享的和长期存在的对象（例如，数据库连接）时。第二个是用于优化内存分配。</p><p>让我们考虑一个写入缓冲区并将结果持久保存到文件中的函数示例。使用<code>sync.Pool</code>，我们可以通过在不同的函数调用之间重用同一对象来重用为缓冲区分配的空间。<br>第一步是检索先前分配的缓冲区（如果是第一个调用，则创建一个缓冲区，但这是抽象的）。然后，<code>defer</code>操作是将缓冲区放回<code>sync.Pool</code>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeFile</span><span class="hljs-params">(pool *sync.Pool, filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    buf := pool.Get().(*bytes.Buffer)<br><br>  <span class="hljs-keyword">defer</span> pool.Put(buf)<br><br>    <span class="hljs-comment">// Reset 缓存区，不然会连接上次调用时保存在缓存区里的字符串foo</span><br>    <span class="hljs-comment">// 编程foofoo 以此类推</span><br>    buf.Reset()<br><br>    buf.WriteString(<span class="hljs-string">&quot;foo&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> ioutil.WriteFile(filename, buf.Bytes(), <span class="hljs-number">0644</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p><code>sync.Once</code>是一个简单而强大的原语，可确保一个函数仅执行一次。在下面的示例中，只有一个<code>goroutine</code>会显示输出消息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">once := &amp;sync.Once&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>    i := i<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            fmt.Printf(<span class="hljs-string">&quot;first %d\n&quot;</span>, i)<br>        &#125;)<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用了<code>Do(func ())</code>方法来指定只能被调用一次的部分。</p><h2 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h2><p><code>sync.Cond</code>可能是<code>sync</code>包提供的同步原语中最不常用的一个，它用于发出信号（一对一）或广播信号（一对多）到<code>goroutine</code>。让我们考虑一个场景，我们必须向一个<code>goroutine</code>指示共享切片的第一个元素已更新。创建<code>sync.Cond</code>需要<code>sync.Locker</code>对象（<code>sync.Mutex</code>或<code>sync.RWMutex</code>）：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">cond := sync.<span class="hljs-built_in">NewCond</span>(&amp;sync.Mutex&#123;&#125;)<br></code></pre></td></tr></table></figure><p>然后，让我们编写负责显示切片的第一个元素的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printFirstElement</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, cond *sync.Cond)</span></span> &#123;<br>    cond.L.Lock()<br>    cond.Wait()<br>    fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, s[<span class="hljs-number">0</span>])<br>    cond.L.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>cond.L</code>访问内部的互斥锁。一旦获得了锁，我们将调用<code>cond.Wait()</code>，这会让当前<code>goroutine</code>在收到信号前一直处于阻塞状态。</p><p>让我们回到<code>main goroutine</code>。我们将通过传递共享切片和先前创建的<code>sync.Cond</code>来创建<code>printFirstElement</code>池。然后我们调用<code>get()</code>函数，将结果存储在<code>s[0]</code>中并发出信号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; runtime.NumCPU(); i++ &#123;<br>    <span class="hljs-keyword">go</span> printFirstElement(s, cond)<br>&#125;<br><br>i := get()<br>cond.L.Lock()<br>s[<span class="hljs-number">0</span>] = i<br>cond.Signal()<br>cond.L.Unlock()<br></code></pre></td></tr></table></figure><p>这个信号会解除一个<code>goroutine</code>的阻塞状态，解除阻塞的<code>goroutine</code>将会显示<code>s[0]</code>中存储的值。</p><p>但是，有的人可能会争辩说我们的代码破坏了<code>Go</code>的最基本原则之一：</p><blockquote><p>不要通过共享内存进行通信；而是通过通信共享内存。</p></blockquote><p>确实，在这个示例中，最好使用<code>channel</code>来传递<code>get()</code>返回的值。但是我们也提到了<code>sync.Cond</code>也可以用于广播信号。我们修改一下上面的示例，把<code>Signal()</code>调用改为调用<code>Broadcast()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">i := get()<br>cond.L.Lock()<br>s[<span class="hljs-number">0</span>] = i<br>cond.Broadcast()<br>cond.L.Unlock()<br></code></pre></td></tr></table></figure><p>在这种情况下，所有goroutine都将被触发。<br>众所周知，<code>channel</code>里的元素只会由一个<code>goroutine</code>接收到。通过<code>channel</code>模拟广播的唯一方法是关闭<code>channel</code>。</p><blockquote><p>当一个channel被关闭后，channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。</p></blockquote><p>但是这种方式只能广播一次。因此，尽管存在很大争议，但这无疑是<code>sync.Cond</code>的一个有趣的功能。</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes之client-go之informer工作原理源码解析</title>
    <link href="/2025/04/03/kubernetes%E4%B9%8Bclient-go%E4%B9%8Binformer%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/04/03/kubernetes%E4%B9%8Bclient-go%E4%B9%8Binformer%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.haohtml.com/archives/32179/">https://blog.haohtml.com/archives/32179/</a></p><h1 id="kubernetes-之-client-go-之-informer-工作原理源码解析"><a href="#kubernetes-之-client-go-之-informer-工作原理源码解析" class="headerlink" title="kubernetes 之 client-go 之 informer 工作原理源码解析"></a>kubernetes 之 client-go 之 informer 工作原理源码解析</h1><p>本文主要介绍有关 <code>client go</code> 架构实现原理，在整个client-go架构中有一个很重要的组件就是 <code>informer</code>，本节我们重点对其进行一些介绍。</p><h1 id="Informer-机制"><a href="#Informer-机制" class="headerlink" title="Informer 机制"></a>Informer 机制</h1><p>采用 k8s HTTP API 可以查询集群中所有的资源对象并 Watch 其变化，但大量的 HTTP 调用会对 API Server 造成较大的负荷，而且网络调用可能存在较大的延迟。除此之外，开发者还需要在程序中处理资源的缓存，HTTP 链接出问题后的重连等。为了解决这些问题并简化 Controller 的开发工作，K8s 在 client go 中提供了一个 <code>informer</code> 客户端库，可以视其为一个组件。</p><p>在 Kubernetes 中，<code>Informer</code> 可以用于监视 Kubernetes API 服务器中的资源并将它们的当前状态缓存到本地(<code>index -&gt; store)</code> ，这样就避免了客户端不断地向 API 服务器发送请求，直接从本地即可。</p><p>相比直接采用 HTTP Watch，使用 Kubernetes Informer 有以下优势：</p><ul><li>减少 API 服务器的负载：通过在本地缓存资源信息，Informer 减少了需要向 API 服务器发出的请求数量。这可以防止由于 API 服务器过载而影响整个集群的性能。</li><li>提高应用程序性能：使用缓存的数据，客户端应用程序可以快速访问资源信息，而无需等待 API 服务器响应。这可以提高应用程序性能并减少延迟。</li><li>简化代码：Informer 提供了一种更简单、更流畅的方式来监视 Kubernetes 中的资源更改。客户端应用程序可以使用现有的 Informer 库来处理这些任务，而无需编写复杂的代码来管理与 API 服务器的连接并处理更新。</li><li>更高的可靠性：由于 Informer 在本地缓存数据，因此即使 API 服务器不可用或存在问题，它们也可以继续工作。这可以确保客户端应用程序即使在底层 Kubernetes 基础结构出现问题时也能保持功能。</li></ul><p>下面一起看一下 client-go 库的实现原理</p><h1 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h1><p>我们先看一下来自 <a href="https://github.com/kubernetes/sample-controller/blob/master/docs/images/client-go-controller-interaction.jpeg">官方</a> 的 <code>client-go</code> 架构图</p><p><img src="/2025/04/03/kubernetes%E4%B9%8Bclient-go%E4%B9%8Binformer%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/client-go-controller-interaction.jpeg" alt="client-go-controller-interaction.jpeg"></p><p>整个架构图分上、下两部分，其中上部分为 <code>client-go</code> 的实现，而下部分是我们自己要实现的 <code>Custom Controller</code>，每部分由不同的组件组成，上下两部分通过虚线连接起来。其介绍请参考 <a href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md">https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md</a></p><blockquote><p>有时候 <code>Controller</code> 也被叫做 <code>Operator</code>，这两个术语的混用有时让人感到迷惑。 <code>Controller</code> 是一个通用的术语，凡是遵循 “Watch K8s 资源并根据资源变化进行调谐” 模式的控制程序都可以叫做 <code>Controller</code>。而 <code>Operator</code> 是一种专用的 <code>Controller</code>，用于在 Kubernetes 中管理一些复杂的 <strong>有状态</strong> 的应用程序。例如在 Kubernetes 中管理 MySQL 数据库的 MySQL Operator。</p></blockquote><p>在实现 <code>controller</code> 时一般在 <code>Informer</code> 配置回调函数 <code>Callbacks（ResourceEventHandlers）</code>来实现 <code>Informer</code> 和 <code>Custom Controller</code> 上下两部分之间的通讯，这个在上面的链接里均有介绍。如果上图不容易理解的话，也可以参考下面两张架构图。<img src="https://blogstatic.haohtml.com/uploads/2023/04/d2b5ca33bd970f64a6301fa75ae2eb22-3.png" alt="img"><img src="https://blogstatic.haohtml.com/uploads/2023/04/d2b5ca33bd970f64a6301fa75ae2eb22-2.png" alt="img"></p><p>注意这里写入 <code>workqueue</code> 队列的是API对象的 <code>key</code>， 即 <code>namespace/name</code>；接着在控制循环 <code>Control Loop</code> 里先从 <code>workqueue</code> 读取这个 <code>key</code>；然后根据 <code>key</code>从 <code>indexer</code> 缓存里读取对象。如果对象不存在则说明前面是通过 <code>DeleteFunc</code> 写入的，则需要删除key， 否则进行其它处理，执行控制器模式里的对比“<code>期望状态</code>” 和 “<code>实际状态</code>”的逻辑了。</p><p>下面根据官网给出的架构图，我们一起看一下它的实现代码。</p><h1 id="架构实现源码分析"><a href="#架构实现源码分析" class="headerlink" title="架构实现源码分析"></a>架构实现源码分析</h1><p>这里以官方提供的 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/examples/workqueue/README.md">workqueue</a> 示例为例，按照上方的架构图对其 <strong>每一个步骤</strong> 进行源码分析</p><p>入口函数为 main函数中的 <code>go controller.Run(1, stop)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>...<br><br><span class="hljs-comment">// create the pod watcher</span><br>podListWatcher := cache.NewListWatchFromClient(clientset.CoreV1().RESTClient(), <span class="hljs-string">&quot;pods&quot;</span>, v1.NamespaceDefault, fields.Everything())<br><br><span class="hljs-comment">// create the workqueue</span><br>queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())<br><br><span class="hljs-comment">// 创建 indexer 和 informer</span><br>indexer, informer := cache.NewIndexerInformer(podListWatcher, &amp;v1.Pod&#123;&#125;, <span class="hljs-number">0</span>, cache.ResourceEventHandlerFuncs&#123;&#125;<br><br>controller := NewController(queue, indexer, informer)<br><br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(stop)<br><span class="hljs-keyword">go</span> controller.Run(<span class="hljs-number">1</span>, stop)<br><br><span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewController</span><span class="hljs-params">(queue workqueue.RateLimitingInterface, indexer cache.Indexer, informer cache.Controller)</span></span> *Controller &#123;<br><span class="hljs-keyword">return</span> &amp;Controller&#123;<br>informer: informer,<br>indexer:  indexer,<br>queue:    queue,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建的是一个 <code>pods</code> 类型的 <code>ListWatch</code>, 接着创建了一个带 <strong>限速率</strong> 功能的 <code>workqueue</code>（底层queue 的实现对应代码为 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/util/workqueue/queue.go#L64-L88%EF%BC%89">https://github.com/kubernetes/client-go/blob/v12.0.0/util/workqueue/queue.go#L64-L88）</a>, 然后调用 <code>cache.NewIndexInformer</code> 来创建 <code>indexer</code> 和 <code>informer</code>。</p><p>这里的 <code>workqueue</code> 主要是在 <code>ResoureEventHandlers</code> 回调时调用，对应的是第 <code>7) Enqueue Object Key</code> 步骤。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> Run(threadiness <span class="hljs-type">int</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">defer</span> runtime.HandleCrash()<br><br><span class="hljs-comment">// Let the workers stop when we are done</span><br><span class="hljs-keyword">defer</span> c.queue.ShutDown()<br>klog.Info(<span class="hljs-string">&quot;Starting Pod controller&quot;</span>)<br><br><span class="hljs-comment">// 启用 informer 服务</span><br><span class="hljs-keyword">go</span> c.informer.Run(stopCh)<br><br><span class="hljs-comment">// Wait for all involved caches to be synced, before processing items from the queue is started</span><br><span class="hljs-keyword">if</span> !cache.WaitForCacheSync(stopCh, c.informer.HasSynced) &#123;<br>runtime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;Timed out waiting for caches to sync&quot;</span>))<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// 业务逻辑回调 c.runWorker</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadiness; i++ &#123;<br><span class="hljs-keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)<br>&#125;<br><br>&lt;-stopCh<br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先调用 <code>go c.informer.Run()</code> 来启用 informer 服务，让其在一个单独的 <code>goroutine</code> 运行， 其实现对应架构图中的 1~7 步骤。</p><p>接着再调用 <code>go wait.Until(c.runWorker, time.Second, stopCh)</code> 来实现自定义控制器的逻辑，其对应架构图中的 8~9 步骤。</p><p>下面我们先看一下 <code>informer</code> 服务的实现 （ <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/controller.go#L97-L125%EF%BC%89%E3%80%82">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/controller.go#L97-L125）。</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br><br>    <span class="hljs-comment">// 首先创建 Reflector</span><br>    r := NewReflector(<br>        c.config.ListerWatcher,<br>        c.config.ObjectType,<br>        c.config.Queue,<br>        c.config.FullResyncPeriod,<br>    )<br><br><br>    <span class="hljs-comment">// 启用 Reflector 服务</span><br>    wg.StartWithChannel(stopCh, r.Run)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>首先创建一个 <code>Reflector</code> 对象，并注入 <code>podListWatcher</code> 和 <code>Delta Fifo Queue</code> 队列， 其中 <code>ObjectType</code> 为 <code>&amp;v1.Pod&#123;&#125;</code>，接着启用 <code>Reflector</code> 服务（<a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/reflector.go#L119-L128%EF%BC%89">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/reflector.go#L119-L128）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/reflector.go</span><br><span class="hljs-comment">// Run starts a watch and handles watch events. Will restart the watch if it is closed.</span><br><span class="hljs-comment">// Run will exit when stopCh is closed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> Run(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    <span class="hljs-comment">// 启用 ListAndWatch</span><br>    wait.Until(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err := r.ListAndWatch(stopCh); err != <span class="hljs-literal">nil</span> &#123;<br>            utilruntime.HandleError(err)<br>        &#125;<br>    &#125;, r.period, stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着看一下 <code>r.ListAndWatch()</code> 实现 （<a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/reflector.go#L156-L307%EF%BC%89">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/reflector.go#L156-L307）</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// It returns error if ListAndWatch didn&#x27;t even try to initialize watch.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> ListAndWatch(stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><br>    <span class="hljs-comment">// 当前为客户端首次请求资源的情况</span><br>    <span class="hljs-keyword">if</span> err := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>                    panicCh &lt;- r<br>                &#125;<br>            &#125;()<br><br>            <span class="hljs-comment">// 1. 向 apiserver 发送请求</span><br>            <span class="hljs-comment">// 如果支持 listerWatcher，则尝试以 chunks 的方式获取资源列表; 否则第一个列表就返回完整的响应</span><br>            pager := pager.New(pager.SimplePageFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(opts metav1.ListOptions)</span></span> (runtime.Object, <span class="hljs-type">error</span>) &#123;<br>                <span class="hljs-keyword">return</span> r.listerWatcher.List(opts)<br>            &#125;))<br>            <span class="hljs-keyword">if</span> r.WatchListPageSize != <span class="hljs-number">0</span> &#123;<br>                pager.PageSize = r.WatchListPageSize<br>            &#125;<br>            <span class="hljs-comment">// Pager falls back to full list if paginated list calls fail due to an &quot;Expired&quot; error.</span><br>            list, err = pager.List(context.Background(), options)<br>            <span class="hljs-built_in">close</span>(listCh)<br>        &#125;()<br><br>        <span class="hljs-comment">// 2. 读取响应 以 channel通道的方式获取上面 goroutine 的响应结果</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-stopCh:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">case</span> r := &lt;-panicCh:<br>            <span class="hljs-built_in">panic</span>(r)<br>        <span class="hljs-keyword">case</span> &lt;-listCh:<br>        &#125;<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: Failed to list %v: %v&quot;</span>, r.name, r.expectedType, err)<br>        &#125;<br><br>        <span class="hljs-comment">// 3.1 从响应结果列表里获取版本号信息</span><br>        listMetaInterface, err := meta.ListAccessor(list)<br>        resourceVersion = listMetaInterface.GetResourceVersion()<br><br>        items, err := meta.ExtractList(list)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: Unable to understand list result %#v (%v)&quot;</span>, r.name, list, err)<br>        &#125;<br><br>        <span class="hljs-comment">// 3.2 根据上次获取的版本号同步最新记录, 更新 Store(Delta FIIO queue) 为最新内容</span><br>        <span class="hljs-keyword">if</span> err := r.syncWith(items, resourceVersion); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: Unable to sync list result: %v&quot;</span>, r.name, err)<br>        &#125;<br><br>        <span class="hljs-comment">// 3.3 更新最新版本号</span><br>        r.setLastSyncResourceVersion(resourceVersion)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br><br>    <span class="hljs-comment">// 非首次则根据版本号来获取最新变更资源</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// give the stopCh a chance to stop the loop, even in case of continue statements further down on errors</span><br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-stopCh:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">default</span>:<br>        &#125;<br><br>        timeoutSeconds := <span class="hljs-type">int64</span>(minWatchTimeout.Seconds() * (rand.Float64() + <span class="hljs-number">1.0</span>))<br>        options = metav1.ListOptions&#123;<br>            ResourceVersion: resourceVersion,<br>            TimeoutSeconds: &amp;timeoutSeconds,<br>            AllowWatchBookmarks: <span class="hljs-literal">false</span>,<br>        &#125;<br><br>        <span class="hljs-comment">// 根据版本号获取最新资源，并将更新信息写入 Delta Fifo Queue</span><br>        w, err := r.listerWatcher.Watch(options)<br>        <span class="hljs-keyword">if</span> err := r.watchHandler(w, &amp;resourceVersion, resyncerrc, stopCh); err != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">if</span> err != errorStopRequested &#123;<br>                klog.Warningf(<span class="hljs-string">&quot;%s: watch of %v ended with: %v&quot;</span>, r.name, r.expectedType, err)<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于首次访问 <code>apiserver</code>，如果支持 <code>listerWatcher</code> 的话，则以 <code>chunk</code> 的方式获取资源 ，否则一次性获取完整的资源信息，然后再从响应结果里读取当前资源信息号。</p><p>当获取资源列表后，对于以后更新的资源，则需要根据 <code>上次的版本号</code> 来监控以后变更的资源，这样就可以只监控后续变更的资源即可，大大减少数据的传输，即这里是以 <code>增量</code> 方式获取资源，后续的操作从这个 <code>增量队列</code> 里获取资源信息即可。</p><p>上面这些对应的正是架构图中的 <code>1) List &amp; Watch</code> 步骤。</p><p>我们再看一下 <code>r.watchHandler</code> 的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// watchHandler watches w and keeps *resourceVersion up to date.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Reflector)</span></span> watchHandler(w watch.Interface, resourceVersion *<span class="hljs-type">string</span>, errc <span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>, stopCh &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><br>    ...<br><br>loop:<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-stopCh:<br>            <span class="hljs-keyword">return</span> errorStopRequested<br>        <span class="hljs-keyword">case</span> err := &lt;-errc:<br>            <span class="hljs-keyword">return</span> err<br>        <span class="hljs-keyword">case</span> event, ok := &lt;-w.ResultChan():<br>            <span class="hljs-keyword">if</span> !ok &#123;<br>                <span class="hljs-keyword">break</span> loop<br>            &#125;<br>            <span class="hljs-keyword">if</span> event.Type == watch.Error &#123;<br>                <span class="hljs-keyword">return</span> apierrs.FromObject(event.Object)<br>            &#125;<br>            <span class="hljs-keyword">if</span> e, a := r.expectedType, reflect.TypeOf(event.Object); e != <span class="hljs-literal">nil</span> &amp;&amp; e != a &#123;<br>                utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: expected type %v, but watch event object had type %v&quot;</span>, r.name, e, a))<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            meta, err := meta.Accessor(event.Object)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, r.name, event))<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            newResourceVersion := meta.GetResourceVersion()<br><br>            <span class="hljs-comment">// 更新 Delta Fifo Queue</span><br>            <span class="hljs-keyword">switch</span> event.Type &#123;<br>            <span class="hljs-keyword">case</span> watch.Added:<br>                <span class="hljs-comment">// 对应 tools/cache/delta_fifo.go#L171-L178</span><br>                err := r.store.Add(event.Object)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                    utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to add watch event object (%#v) to store: %v&quot;</span>, r.name, event.Object, err))<br>                &#125;<br>            <span class="hljs-keyword">case</span> watch.Modified:<br>                err := r.store.Update(event.Object)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                    utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to update watch event object (%#v) to store: %v&quot;</span>, r.name, event.Object, err))<br>                &#125;<br>            <span class="hljs-keyword">case</span> watch.Deleted:<br>                err := r.store.Delete(event.Object)<br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                    utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to delete watch event object (%#v) from store: %v&quot;</span>, r.name, event.Object, err))<br>                &#125;<br>            <span class="hljs-keyword">case</span> watch.Bookmark:<br>                <span class="hljs-comment">// A `Bookmark` means watch has synced here, just update the resourceVersion</span><br>            <span class="hljs-keyword">default</span>:<br>                utilruntime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;%s: unable to understand watch event %#v&quot;</span>, r.name, event))<br>            &#125;<br>            *resourceVersion = newResourceVersion<br>            r.setLastSyncResourceVersion(newResourceVersion)<br>            eventCount++<br>        &#125;<br>    &#125;<br><br>    watchDuration := r.clock.Since(start)<br>    <span class="hljs-keyword">if</span> watchDuration &lt; <span class="hljs-number">1</span>*time.Second &amp;&amp; eventCount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;very short watch: %s: Unexpected watch close - watch lasted less than a second and no items received&quot;</span>, r.name)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里只是对增量队列 <code>Delta Fifo queue</code> 里的资源进行了更新操作，其实现代码见 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/delta_fifo.go#L171-L220">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/delta_fifo.go#L171-L220</a> ， 其对应的正是 <code>2）Add Object</code> 这一步。</p><p>对于 <code>3）Pop Object</code> 这个操作入口函数为 <code>processLoop</code> ( <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/controller.go#L139-L161">https://github.com/kubernetes/client-go/blob/v12.0.0/tools/cache/controller.go#L139-L161</a>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *controller)</span></span> processLoop() &#123;<br><span class="hljs-keyword">for</span> &#123;<br><br><span class="hljs-comment">// 从 Delta Fifo Queue 读取对象</span><br>obj, err := c.config.Queue.Pop(PopProcessFunc(c.config.Process))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err == FIFOClosedError &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> c.config.RetryOnError &#123;<br><span class="hljs-comment">// This is the safe way to re-enqueue.</span><br>c.config.Queue.AddIfNotPresent(obj)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其增量队列Pop实现见</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/delta_fifo.go</span><br><span class="hljs-comment">// Pop returns a &#x27;Deltas&#x27;, which has a complete list of all the things</span><br><span class="hljs-comment">// that happened to the object (deltas) while it was sitting in the queue.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *DeltaFIFO)</span></span> Pop(process PopProcessFunc) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>    f.lock.Lock()<br>    <span class="hljs-keyword">defer</span> f.lock.Unlock()<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(f.queue) == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 阻塞方式获取一个对象</span><br>            <span class="hljs-comment">// When the queue is empty, invocation of Pop() is blocked until new item is enqueued.</span><br>            <span class="hljs-comment">// When Close() is called, the f.closed is set and the condition is broadcasted.</span><br>            <span class="hljs-comment">// Which causes this loop to continue and return from the Pop().</span><br>            <span class="hljs-keyword">if</span> f.IsClosed() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, FIFOClosedError<br>            &#125;<br><br>            f.cond.Wait()<br>        &#125;<br><br>        <span class="hljs-comment">// f.queue 是一个slice, 这里获取首个元素后并更新这个切片</span><br>        id := f.queue[<span class="hljs-number">0</span>]<br>        f.queue = f.queue[<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">if</span> f.initialPopulationCount &gt; <span class="hljs-number">0</span> &#123;<br>            f.initialPopulationCount--<br>        &#125;<br><br>        <span class="hljs-comment">// 将id作为key从items这个 map 中获取 Deltas 信息</span><br>        item, ok := f.items[id]<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            <span class="hljs-comment">// Item may have been deleted subsequently.</span><br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-built_in">delete</span>(f.items, id)<br><br>        <span class="hljs-comment">// 这里 process 是下一步的进入</span><br>        err := process(item)<br>        <span class="hljs-keyword">if</span> e, ok := err.(ErrRequeue); ok &#123;<br>            f.addIfNotPresent(id, item)<br>            err = e.Err<br>        &#125;<br>        <span class="hljs-comment">// Don&#x27;t need to copyDeltas here, because we&#x27;re transferring</span><br>        <span class="hljs-comment">// ownership to the caller.</span><br>        <span class="hljs-keyword">return</span> item, err<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <code>process</code> 函数在这里是作为一个参数传递过来的，其声明位置为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /tools/cache/controller.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInformer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    lw ListerWatcher,</span></span><br><span class="hljs-params"><span class="hljs-function">    objType runtime.Object,</span></span><br><span class="hljs-params"><span class="hljs-function">    resyncPeriod time.Duration,</span></span><br><span class="hljs-params"><span class="hljs-function">    h ResourceEventHandler,</span></span><br><span class="hljs-params"><span class="hljs-function">    clientState Store,</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> Controller &#123;<br>    ...<br><br>    cfg := &amp;Config&#123;<br>        ...<br><br>        Process: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>            <span class="hljs-comment">// from oldest to newest</span><br>            <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> obj.(Deltas) &#123;<br>                <span class="hljs-keyword">switch</span> d.Type &#123;<br>                <span class="hljs-keyword">case</span> Sync, Added, Updated:<br>                    <span class="hljs-keyword">if</span> old, exists, err := clientState.Get(d.Object); err == <span class="hljs-literal">nil</span> &amp;&amp; exists &#123;<br>                        <span class="hljs-comment">// 对应第 4） 和 5) 步骤</span><br>                        <span class="hljs-keyword">if</span> err := clientState.Update(d.Object); err != <span class="hljs-literal">nil</span> &#123;<br>                            <span class="hljs-keyword">return</span> err<br>                        &#125;<br>                        h.OnUpdate(old, d.Object)<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> err := clientState.Add(d.Object); err != <span class="hljs-literal">nil</span> &#123;<br>                            <span class="hljs-keyword">return</span> err<br>                        &#125;<br>                        h.OnAdd(d.Object)<br>                    &#125;<br>                <span class="hljs-keyword">case</span> Deleted:<br>                    <span class="hljs-keyword">if</span> err := clientState.Delete(d.Object); err != <span class="hljs-literal">nil</span> &#123;<br>                        <span class="hljs-keyword">return</span> err<br>                    &#125;<br>                    h.OnDelete(d.Object)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;,<br>    &#125;<br>        <span class="hljs-keyword">return</span> New(cfg)<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的是 <code>Config.Process</code> 这个函数。</p><p>对于架构图中的 <code>4)Add Object</code> 和 <code>5）Store Object &amp; Key</code> 对应的则是对 <code>clientState</code> 的调用。</p><p>而 <code>6）Dispatch Event Handler functions</code> 则为对 对象 <code>h</code> 的调用，它是一个实现了 <code>Resource Event Handlers</code> 接口的结构体，它有三个实现方法 <code>h.OnAdd</code> 、<code>h.OnUpdate</code> 和 <code>h.OnDelete</code>，而这三个方法原型已在 main 函数里实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ...<br><br>    <span class="hljs-comment">// Bind the workqueue to a cache with the help of an informer. This way we make sure that</span><br>    <span class="hljs-comment">// whenever the cache is updated, the pod key is added to the workqueue.</span><br>    <span class="hljs-comment">// Note that when we finally process the item from the workqueue, we might see a newer version</span><br>    <span class="hljs-comment">// of the Pod than the version which was responsible for triggering the update.</span><br>    indexer, informer := cache.NewIndexerInformer(podListWatcher, &amp;v1.Pod&#123;&#125;, <span class="hljs-number">0</span>, cache.ResourceEventHandlerFuncs&#123;<br>        AddFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        UpdateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(old <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(<span class="hljs-built_in">new</span>)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        DeleteFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            <span class="hljs-comment">// IndexerInformer uses a delta queue, therefore for deletes we have to use this</span><br>            <span class="hljs-comment">// key function.</span><br>            key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>    &#125;, cache.Indexers&#123;&#125;)<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用的结构体名为 <code>cache.ResourceEventHandlerFuncs</code> ()</p><p>在 main 函数里的 <code>queue.Add(key)</code> 则对应的是步骤 <code>7) Enqueue Object key</code>, 将 <code>key</code> 写入一个 <code>workqueue</code> 队列。</p><p>而对于 <code>8）Get key</code> 则对应的是 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/examples/workqueue/main.go#L51-L67">controller.processNextItem()</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> processNextItem() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// Wait until there is a new item in the working queue</span><br><span class="hljs-comment">// 对应 8 步骤，从wprkqueue 里读取一个 key</span><br>key, quit := c.queue.Get()<br><span class="hljs-keyword">if</span> quit &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// Tell the queue that we are done with processing this key. This unblocks the key for other workers</span><br><span class="hljs-comment">// This allows safe parallel processing because two pods with the same key are never processed in</span><br><span class="hljs-comment">// parallel.</span><br><span class="hljs-keyword">defer</span> c.queue.Done(key)<br><br><span class="hljs-comment">// Invoke the method containing the business logic</span><br>err := c.syncToStdout(key.(<span class="hljs-type">string</span>))<br><br><span class="hljs-comment">// 出错，重试 5 次</span><br><span class="hljs-comment">// Handle the error if something went wrong during the execution of the business logic</span><br>c.handleErr(err, key)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从 <code>workqueue</code> 里获取一个key， 通过 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/examples/workqueue/main.go#L69-L88">controller.syncToStdout()</a> <code>9) Get Object for key</code>处理。最后调用 <code>c.queue.Done()</code> 表示当前 <code>key</code> 处理完毕。</p><p>而 <code>9) Get Object for key</code> 对应 <a href="https://github.com/kubernetes/client-go/blob/v12.0.0/examples/workqueue/main.go#L69-L88">controller.syncToStdout()</a> 函数的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /examples/workqueue/main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> syncToStdout(key <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 对应步骤 9，从 index 里读取对象</span><br>obj, exists, err := c.indexer.GetByKey(key)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>klog.Errorf(<span class="hljs-string">&quot;Fetching object with key %s from store failed with %v&quot;</span>, key, err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !exists &#123;<br><span class="hljs-comment">// Below we will warm up our cache with a Pod, so that we will see a delete for one pod</span><br>fmt.Printf(<span class="hljs-string">&quot;Pod %s does not exist anymoren&quot;</span>, key)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Note that you also have to check the uid if you have a local controlled resource, which</span><br><span class="hljs-comment">// is dependent on the actual instance, to detect that a Pod was recreated with the same name</span><br>fmt.Printf(<span class="hljs-string">&quot;Sync/Add/Update for Pod %sn&quot;</span>, obj.(*v1.Pod).GetName())<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到对 <code>workqueue</code> 的写入与读取全部在 <code>Custom Controller</code> 部分来实现的，有时候对一个对象处理会出现失败的情况，这种情况下就需要对其 key 进行 <code>RateLimited</code> 了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// handleErr checks if an error happened and makes sure we will retry later.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> handleErr(err <span class="hljs-type">error</span>, key <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Forget about the #AddRateLimited history of the key on every successful synchronization.</span><br><span class="hljs-comment">// This ensures that future processing of updates for this key is not delayed because of</span><br><span class="hljs-comment">// an outdated error history.</span><br>c.queue.Forget(key)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// This controller retries 5 times if something goes wrong. After that, it stops trying.</span><br><span class="hljs-keyword">if</span> c.queue.NumRequeues(key) &lt; <span class="hljs-number">5</span> &#123;<br>klog.Infof(<span class="hljs-string">&quot;Error syncing pod %v: %v&quot;</span>, key, err)<br><br><span class="hljs-comment">// Re-enqueue the key rate limited. Based on the rate limiter on the</span><br><span class="hljs-comment">// queue and the re-enqueue history, the key will be processed later again.</span><br>c.queue.AddRateLimited(key)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c.queue.Forget(key)<br><span class="hljs-comment">// Report to an external entity that, even after several retries, we could not successfully process this key</span><br>runtime.HandleError(err)<br>klog.Infof(<span class="hljs-string">&quot;Dropping pod %q out of the queue: %v&quot;</span>, key, err)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>queue.AddRateLimted(key)</code> 表示 <strong>过一段时间</strong> 将当前 key重新写入 <code>workqueue</code> 里，同时累计当前key的重试次数, 如果重试多次（当前示例为5次）仍失败的话，则调用 <code>runtime.HandleError(err)</code> 处理。</p><p><code>c.queue.Forget</code> 表示一旦key完成，则清除其重试记录，避免影响下次重试，可以看出来 <code>Forget</code> 是对重试行为的处理，这个与 <code>c.queue.Done()</code> 的作用是不一样的。</p><p>至此整个架构图中的每个步骤我们基本介绍完了，对于部分细节问题可能还需要花一些时间进行消化。</p><h1 id="SharedInformer"><a href="#SharedInformer" class="headerlink" title="SharedInformer"></a>SharedInformer</h1><p>如果在一个应用中有多处相互独立的业务逻辑都需要监控同一种资源对象，用户会编写多个 <code>Informer</code> 来进行处理。这会导致应用中发起对 K8s <code>API Server</code> 同一资源的多次 <code>ListAndWatch</code> 调用，并且每一个 <code>Informer</code> 中都有一份单独的本地缓存，增加了内存占用。</p><p>K8s 在 <code>client go</code> 中基于 <code>Informer</code> 之上再次做了一层封装，提供了 <code>SharedInformer</code> 机制。采用 <code>SharedInformer</code> 后，客户端对同一种资源对象只会有一个对 <code>API Server</code> 的 <code>ListAndWatch</code> 调用，多个 <code>Informer</code> 也会共用同一份缓存，减少了对 <code>API Server</code> 的请求，提高了性能。</p><p>而对 <code>SharedInformer</code> 对象的获取一般是通过 <em><code>SharedInformerFactory</code></em> 工厂模式来获取</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SharedInformerFactory provides shared informers for resources in all known</span><br><span class="hljs-comment">// API group versions.</span><br></code></pre></td></tr></table></figure><p>在内部通过调用 <code>InformerFor()</code> 方法从 <code>cache</code> 中获取某一资源对应的 <code>Informer</code>，如果缓存中不存在，则需要通过指定的函数先创建并加入缓存，然后返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// client-go/informers/factory.go#L1870-L208</span><br><span class="hljs-comment">// InternalInformerFor returns the SharedIndexInformer for obj using an internal client.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *sharedInformerFactory)</span></span> InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer &#123;<br>f.lock.Lock()<br><span class="hljs-keyword">defer</span> f.lock.Unlock()<br><br>informerType := reflect.TypeOf(obj)<br>informer, exists := f.informers[informerType]<br><span class="hljs-keyword">if</span> exists &#123;<br><span class="hljs-keyword">return</span> informer<br>&#125;<br><br>resyncPeriod, exists := f.customResync[informerType]<br><span class="hljs-keyword">if</span> !exists &#123;<br>resyncPeriod = f.defaultResync<br>&#125;<br><br>informer = newFunc(f.client, resyncPeriod)<br>f.informers[informerType] = informer<br><br><span class="hljs-keyword">return</span> informer<br>&#125;<br></code></pre></td></tr></table></figure><p>这里所谓的 <code>cache</code> 其实就是一个 <code>map</code> 对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sharedInformerFactory <span class="hljs-keyword">struct</span> &#123;<br>        informers <span class="hljs-keyword">map</span>[reflect.Type]cache.SharedIndexInformer<br>&#125;<br></code></pre></td></tr></table></figure><p>对于自定义控制器开发，即可以直接选择使用 <a href="https://github.com/kubernetes-sigs/controller-runtime">Controller Runtime</a> (<a href="https://github.com/kubernetes-sigs/controller-runtime/blob/main/examples/README.md">官方Example</a>)库开发，也可以基于 <a href="https://github.com/operator-framework/operator-sdk">Operator SDK</a>. 开发，还可以基于 <a href="https://book.kubebuilder.io/">kubebuilder</a> 开发框架，其中后两者都会使用 Controller Runtime 库，而 kubebuiler 作为一款开发框架，由于其对开发者极其友好，因此是目前最优先的考虑，参考  <a href="https://book.kubebuilder.io/quick-start.html">Kubebuilder’s Quick Start</a> 了解其用法。</p><p><strong><code>CRD</code> 、<code>CR</code> 和 <code>控制器</code> 的区别</strong><img src="https://blogstatic.haohtml.com/uploads/2023/08/d2b5ca33bd970f64a6301fa75ae2eb22-1.png" alt="img"></p><p><code>CRD</code> 用于定义自定义资源类型, 如果程序开发中定义的类对象，脱离了控制器没有任何意义； <code>CR</code> （Custom Resource）是 <code>CRD</code> 定义的资源的实例化对象，是用户自定义的资源类型的具体实例，类似于根据类实例化了一个对象。<img src="https://blogstatic.haohtml.com/uploads/2023/08/d2b5ca33bd970f64a6301fa75ae2eb22-2.png" alt="img"></p><p><code>自定义控制器</code> 用于管理和控制<code>CRD</code>所定义的自定义资源的行为，类似于 <code>针对实例化对象</code> 的一些基本信息做出相应的动作或行为（实现期望状态与实际状态一致）的控制器。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在Kubernetes开发中，<code>client-go</code> 和 <code>Informers</code> 是两个密切相关的概念。</p><p><code>client-go</code> 是 Kubernetes 官方提供的Go语言客户端库，用于与 <code>Kubernetes API</code> 进行通信。它封装了对 <code>Kubernetes API</code> 的各种操作，包括创建、获取、更新和删除资源等，提供了一组简单易用的API接口，方便开发人员进行与Kubernetes集群的交互。</p><p>而 <code>Informers</code> 是 <code>client-go</code> 库中的一部分，它是一种实现了缓存和事件通知机制的机制。<code>Informers</code> 通过监听 Kubernetes <code>API Server</code>上的资源变更事件，将这些事件转换为相应的通知，提供给开发人员使用。这样，开发人员就可以在自己的应用程序中使用Informers来获取最新的资源信息，并进行相应的操作。</p><p>使用 <code>Informers</code> 的好处是，避免了频繁地向 Kubernetes <code>API Server</code> 发送请求来获取最新的资源信息，而是通过缓存和事件通知来获取并同步资源的变更。这样可以减轻Kubernetes <code>API Server</code> 的负担，提高应用程序的性能和效率。</p><p>因此，可以说 <code>client-go</code> 是Kubernetes开发中与 <code>API Server</code> 进行交互的核心组件，而<code>Informers</code> 是 <code>client-go</code> 的一部分，提供了缓存和事件通知的机制，方便开发人员使用。在使用 <code>client-go</code> 进行Kubernetes开发时，可以选择是否使用 <code>Informers</code> 来获取最新的资源信息。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a><strong>参考文章</strong></h1><ul><li><a href="https://github.com/kubernetes-sigs/controller-runtime/blob/main/examples/README.md">https://github.com/kubernetes-sigs/controller-runtime/blob/main/examples/README.md</a></li><li><a href="https://time.geekbang.org/column/article/42076">深入解析声明式API（二）：编写自定义控制器</a></li><li><a href="https://blog.csdn.net/weixin_37546425/article/details/118758066">kubebuilder之一：kubernetes operator工作原理</a></li><li><a href="https://www.cnblogs.com/charlieroro/p/10330390.html">kubernetes client-go解析</a></li><li><a href="https://hliangzhao.cn/articles/000001640262318a67c149f524b43a6b2796c4ae753cf2b000">自定义资源对象与控制器的实现</a></li><li><a href="https://so.csdn.net/so/search?q=%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAkubernetes%E4%B9%8Bclient-go&t=blog&u=weixin_42663840">深入浅出kubernetes之client-go</a></li><li><a href="https://mp.weixin.qq.com/s/TyA1bNXLQs1mXzZbw2PHfw?vid=1688850245817352&deviceid=6239469c-f992-42d3-a9b7-4313801e1c91&version=4.1.3.6008&platform=win">Kubernetes Controller 机制详解（一）</a></li><li><a href="https://github.com/kubernetes/kubernetes/blob/master/staging/README.md">官方所有依赖仓库清单</a></li><li><a href="https://github.com/kubernetes-sigs/kubebuilder">https://github.com/kubernetes-sigs/kubebuilder</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Client-go源码分析之ListerWatcher</title>
    <link href="/2025/04/02/Client-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListerWatcher/"/>
    <url>/2025/04/02/Client-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListerWatcher/</url>
    
    <content type="html"><![CDATA[<h2 id="一-背景"><a href="#一-背景" class="headerlink" title="一 背景"></a>一 背景</h2><p>kubernetes所有API对象都存储在etcd中，并只能通过apiserver访问。如果很多客户端频繁的列举全量对象（比如列举所有的Pod），这会造成apiserver不堪重负。</p><p>ListerWatcher是Lister和Watcher的结合体，ListerWatcher负责列举全量对象，Watcher负责监视（本文将watch翻译为监视）对象的增量变化。</p><p>通过客户端缓存，至在没有任何状态变化的情况下只需要读取本地缓存即可，减少对API-server的压力效率提升显而易见。通过列举全量对象完成本地缓存，而监视增量则是为了及时的将apiserver的状态变化更新到本地缓存。所以，在apiserver与客户端之间绝大部分传输的是对象的增量变化，当然在异常的情况下还是要重新列举一次全量对象。</p><p>本文值得客户端本地缓存就是Indexer，client-go不仅实现了缓存，同时还加了索引，进一步提升了检索效率。</p><h2 id="二-ListerWatcher"><a href="#二-ListerWatcher" class="headerlink" title="二 ListerWatcher"></a>二 ListerWatcher</h2><p>Kubernetes 控制面 (control plane) 的核心是 **API 服务器 (API server)**。API 服务器负责提供 HTTP API，以供用户，集群中的不同部分和集群外部组件相互通信。控制器也不例外，所有控制器都通过 API 获取集群的当前状态，也通过 API 对集群状态进行修改。</p><p>list-watch，作为k8s系统中统一的异步消息传递方式，对系统的性能、数据一致性起到关键性的作用。</p><p><img src="/2025/04/02/Client-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListerWatcher/20220120151429.png" alt="img"></p><p>值得一提的是，Kubernetes 提供了 watch 机制方便客户端实时获取集群状态，有了这个接口，控制器才得以无延迟（准确地说是低延迟）地对状态变更作出响应。这里指的 “状态变更”，就是我们常说的**事件 (event)**。</p><h3 id="2-1-EventType"><a href="#2-1-EventType" class="headerlink" title="2.1 EventType"></a>2.1 EventType</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// EventType defines the possible types of events.</span><br><span class="hljs-keyword">type</span> EventType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>Added    EventType = <span class="hljs-string">&quot;ADDED&quot;</span><br>Modified EventType = <span class="hljs-string">&quot;MODIFIED&quot;</span><br>Deleted  EventType = <span class="hljs-string">&quot;DELETED&quot;</span><br>Bookmark EventType = <span class="hljs-string">&quot;BOOKMARK&quot;</span><br>Error    EventType = <span class="hljs-string">&quot;ERROR&quot;</span><br>)<br></code></pre></td></tr></table></figure><h3 id="2-2-ListerWatcher定义"><a href="#2-2-ListerWatcher定义" class="headerlink" title="2.2 ListerWatcher定义"></a>2.2 ListerWatcher定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 复制代码</span><br><span class="hljs-comment">// client-go/tools/cache/listwatch.go</span><br><span class="hljs-comment">// Lister is any object that knows how to perform an initial list.</span><br><span class="hljs-keyword">type</span> Lister <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// List should return a list type object; the Items field will be extracted, and the</span><br><span class="hljs-comment">// ResourceVersion field will be used to start the watch in the right place.</span><br>List(options metav1.ListOptions) (runtime.Object, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// Watcher is any object that knows how to start a watch on a resource.</span><br><span class="hljs-keyword">type</span> Watcher <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Watch should begin a watch at the specified version.</span><br>Watch(options metav1.ListOptions) (watch.Interface, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-comment">// ListerWatcher is any object that knows how to perform an initial list and start a watch on a resource.</span><br><span class="hljs-keyword">type</span> ListerWatcher <span class="hljs-keyword">interface</span> &#123;<br>Lister<br>Watcher<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-创建ListWatcher对象"><a href="#2-3-创建ListWatcher对象" class="headerlink" title="2.3 创建ListWatcher对象"></a>2.3 创建ListWatcher对象</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewListWatchFromClient creates a new ListWatch from the specified client, resource, namespace and field selector.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewListWatchFromClient</span><span class="hljs-params">(c Getter, resource <span class="hljs-type">string</span>, namespace <span class="hljs-type">string</span>, fieldSelector fields.Selector)</span></span> *ListWatch &#123;<br>optionsModifier := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(options *metav1.ListOptions)</span></span> &#123;<br>options.FieldSelector = fieldSelector.String()<br>&#125;<br><span class="hljs-keyword">return</span> NewFilteredListWatchFromClient(c, resource, namespace, optionsModifier)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三-小试牛刀"><a href="#三-小试牛刀" class="headerlink" title="三 小试牛刀"></a>三 小试牛刀</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl proxy</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进行listwatch default名称空间下的pods</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl <span class="hljs-string">&quot;127.0.0.1:8001/api/v1/namespaces/default/pods?watch=1&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建pod进行观察</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">kubectl run nginx --image=nginx</span><br>&#123;&quot;type&quot;:&quot;ADDED&quot;,&quot;object&quot;:&#123;&quot;kind&quot;:&quot;Pod&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;metadata&quot;:&#123;&quot;name&quot;:&quot;nginx&quot;,&quot;namespace&quot;:&quot;default&quot;,&quot;uid&quot;:&quot;8d0548ce-fb67-4b71-93ec-59ad67b429d9&quot;,&quot;resourceVersion&quot;:&quot;2925331&quot;,&quot;creationTimestamp&quot;:&quot;2022-01-20T07:32:22Z&quot;,&quot;labels&quot;:&#123;&quot;run&quot;:&quot;nginx&quot;&#125;,&quot;managedFields&quot;:[&#123;&quot;manager&quot;:&quot;kubectl-run&quot;,&quot;operation&quot;:&quot;Update&quot;,&quot;apiVersion&quot;:&quot;v1&quot;,&quot;time&quot;:&quot;2022-01-20T07:32:22Z&quot;,&quot;fieldsType&quot;:&quot;FieldsV1&quot;,&quot;fieldsV1&quot;:&#123;&quot;f:metadata&quot;:&#123;&quot;f:labels&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:run&quot;:&#123;&#125;&#125;&#125;,&quot;f:spec&quot;:&#123;&quot;f:containers&quot;:&#123;&quot;k:&#123;\&quot;name\&quot;:\&quot;nginx\&quot;&#125;&quot;:&#123;&quot;.&quot;:&#123;&#125;,&quot;f:image&quot;:&#123;&#125;,&quot;f:imagePullPolicy&quot;:&#123;&#125;,&quot;f:name&quot;:&#123;&#125;,&quot;f:resources&quot;:&#123;&#125;,&quot;f:terminationMessagePath&quot;:&#123;&#125;,&quot;f:terminationMessagePolicy&quot;:&#123;&#125;&#125;&#125;,&quot;f:dnsPolicy&quot;:&#123;&#125;,&quot;f:enableServiceLinks&quot;:&#123;&#125;,&quot;f:restartPolicy&quot;:&#123;&#125;,&quot;f:schedulerName&quot;:&#123;&#125;,&quot;f:securityContext&quot;:&#123;&#125;,&quot;f:terminationGracePeriodSeconds&quot;:&#123;&#125;&#125;&#125;&#125;]&#125;,&quot;spec&quot;:&#123;&quot;volumes&quot;:[&#123;&quot;name&quot;:&quot;kube-api-access-nc5v8&quot;,&quot;projected&quot;:&#123;&quot;sources&quot;:[&#123;&quot;serviceAccountToken&quot;:&#123;&quot;expirationSeconds&quot;:3607,&quot;path&quot;:&quot;token&quot;&#125;&#125;,&#123;&quot;configMap&quot;:&#123;&quot;name&quot;:&quot;kube-root-ca.crt&quot;,&quot;items&quot;:[&#123;&quot;key&quot;:&quot;ca.crt&quot;,&quot;path&quot;:&quot;ca.crt&quot;&#125;]&#125;&#125;,&#123;&quot;downwardAPI&quot;:&#123;&quot;items&quot;:[&#123;&quot;path&quot;:&quot;namespace&quot;,&quot;fieldRef&quot;:&#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;fieldPath&quot;:&quot;metadata.namespace&quot;&#125;&#125;]&#125;&#125;],&quot;defaultMode&quot;:420&#125;&#125;],&quot;containers&quot;:[&#123;&quot;name&quot;:&quot;nginx&quot;,&quot;image&quot;:&quot;nginx&quot;,&quot;resources&quot;:&#123;&#125;,&quot;volumeMounts&quot;:[&#123;&quot;name&quot;:&quot;kube-api-access-nc5v8&quot;,&quot;readOnly&quot;:true,&quot;mountPath&quot;:&quot;/var/run/secrets/kubernetes.io/serviceaccount&quot;&#125;],&quot;terminationMessagePath&quot;:&quot;/dev/termination-log&quot;,&quot;terminationMessagePolicy&quot;:&quot;File&quot;,&quot;imagePullPolicy&quot;:&quot;Always&quot;&#125;],&quot;restartPolicy&quot;:&quot;Always&quot;,&quot;terminationGracePeriodSeconds&quot;:30,&quot;dnsPolicy&quot;:&quot;ClusterFirst&quot;,&quot;serviceAccountName&quot;:&quot;default&quot;,&quot;serviceAccount&quot;:&quot;default&quot;,&quot;securityContext&quot;:&#123;&#125;,&quot;schedulerName&quot;:&quot;default-scheduler&quot;,&quot;tolerations&quot;:[&#123;&quot;key&quot;:&quot;node.kubernetes.io/not-ready&quot;,&quot;operator&quot;:&quot;Exists&quot;,&quot;effect&quot;:&quot;NoExecute&quot;,&quot;tolerationSeconds&quot;:300&#125;,&#123;&quot;key&quot;:&quot;node.kubernetes.io/unreachable&quot;,&quot;operator&quot;:&quot;Exists&quot;,&quot;effect&quot;:&quot;NoExecute&quot;,&quot;tolerationSeconds&quot;:300&#125;],&quot;priority&quot;:0,&quot;enableServiceLinks&quot;:true,&quot;preemptionPolicy&quot;:&quot;PreemptLowerPriority&quot;&#125;,&quot;status&quot;:&#123;&quot;phase&quot;:&quot;Pending&quot;,&quot;qosClass&quot;:&quot;BestEffort&quot;&#125;&#125;&#125;<br></code></pre></td></tr></table></figure><h2 id="四-代码实现"><a href="#四-代码实现" class="headerlink" title="四 代码实现"></a>四 代码实现</h2><p>编写代码对default名称空间下的configmap进行list watch。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br><span class="hljs-string">&quot;k8s.io/apimachinery/pkg/api/meta&quot;</span><br>metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><span class="hljs-string">&quot;k8s.io/apimachinery/pkg/fields&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/tools/cache&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br><span class="hljs-string">&quot;k8s.io/client-go/util/homedir&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Must</span><span class="hljs-params">(e <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(e)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitClientSet</span><span class="hljs-params">()</span></span> (*kubernetes.Clientset, <span class="hljs-type">error</span>) &#123;<br>kubeconfig := filepath.Join(homedir.HomeDir(), <span class="hljs-string">&quot;.kube&quot;</span>, <span class="hljs-string">&quot;config&quot;</span>)<br>restConfig, err := clientcmd.BuildConfigFromFlags(<span class="hljs-string">&quot;&quot;</span>, kubeconfig)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> kubernetes.NewForConfig(restConfig)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitListerWatcher</span><span class="hljs-params">(clientSet *kubernetes.Clientset, resource, namespace <span class="hljs-type">string</span>, fieldSelector fields.Selector)</span></span> cache.ListerWatcher &#123;<br>restClient := clientSet.CoreV1().RESTClient()<br><span class="hljs-keyword">return</span> cache.NewListWatchFromClient(restClient, resource, namespace, fieldSelector)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>clientSet, err := InitClientSet()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 什么常量</span><br>resource := <span class="hljs-string">&quot;configmaps&quot;</span><br>namespace := <span class="hljs-string">&quot;default&quot;</span><br><br>configMapListerWatcher := InitListerWatcher(clientSet, resource, namespace, fields.Everything())<br><br><span class="hljs-comment">// 1. list操作</span><br>listObj, err := configMapListerWatcher.List(metav1.ListOptions&#123;&#125;)<br><br><span class="hljs-comment">// meta 包封装了一些处理 runtime.Object 对象的方法，屏蔽了反射和类型转换的过程，</span><br><span class="hljs-comment">// 提取出的 items 类型为 []runtime.Object</span><br>items, err := meta.ExtractList(listObj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>Must(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;list result:&quot;</span>)<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br>configmaps, ok := item.(*v1.ConfigMap)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;namespace: %s, resource name:%s\n&quot;</span>, configmaps.Namespace, configmaps.Name)<br>&#125;<br><br><span class="hljs-comment">// 2. watch 操作</span><br>listMetaInterface, err := meta.ListAccessor(listObj)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>Must(err)<br>&#125;<br>resourceVersion := listMetaInterface.GetResourceVersion()<br><br>watchObj, err := configMapListerWatcher.Watch(metav1.ListOptions&#123;<br>ResourceVersion: resourceVersion,<br>&#125;)<br><br><span class="hljs-comment">// 接收信号</span><br>stopCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal)<br>signal.Notify(stopCh, os.Interrupt)<br>fmt.Println(<span class="hljs-string">&quot;Start watching...&quot;</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-stopCh:<br>fmt.Println(<span class="hljs-string">&quot;exit&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> event, ok := &lt;-watchObj.ResultChan():<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;Broken channel&quot;</span>)<br><span class="hljs-keyword">break</span><br>&#125;<br>configmaps, ok := event.Object.(*v1.ConfigMap)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;eventType: %s, watch obj:%s\n&quot;</span>, event.Type, configmaps.Name)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行创建configmap测试</p><p><img src="/2025/04/02/Client-go%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BListerWatcher/20220120153657.png" alt="img"></p><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h2><ul><li>ListerWatcher就是为SharedIndexInformer列举全量对象、监视对象增量变化设计的接口，实现就是Clientset的List和Watch函数；</li><li>SharedIndexInformer利用ListerWatcher实现了本地缓存与apiserver之间的状态一致性；</li><li>不仅可以提升客户端访问API对象的效率，同时可以将对象的增量变化回调给使用者；</li><li>从原理上讲，可以用etcd的clientv3.Client实现ListerWatcher，SharedIndexInformer同步etcd的对象，这样一些简单的醒目就可以复用SharedIndexInformer了，毕竟不是所有的项目都需要一个apiserver；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中的Defer必掌握的7知识点</title>
    <link href="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang中的Defer必掌握的7知识点"><a href="#Golang中的Defer必掌握的7知识点" class="headerlink" title="Golang中的Defer必掌握的7知识点"></a>Golang中的Defer必掌握的7知识点</h1><p>转自：<a href="https://www.yuque.com/aceld/golang/qnubsg">https://www.yuque.com/aceld/golang/qnubsg</a></p><p>知识点1：defer的执行顺序</p><p>多个defer出现的时候，它是一个“栈”的关系，也就是先进后出。一个函数中，写在前面的defer会比写在后面的defer调用的晚。</p><p>示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> func1()<br>    <span class="hljs-keyword">defer</span> func2()<br>    <span class="hljs-keyword">defer</span> func3()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/1651037338287-fd17c81d-a1ad-4bc7-ae7e-eec8a264af5f.webp" alt="112-defer2.jpeg"></p><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">C<br>B<br>A<br></code></pre></td></tr></table></figure><h3 id="知识点2-defer与return谁先谁后"><a href="#知识点2-defer与return谁先谁后" class="headerlink" title="知识点2: defer与return谁先谁后"></a>知识点2: defer与return谁先谁后</h3><p>示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deferFunc</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;defer func called&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnFunc</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;return func called&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnAndDefer</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><br>    <span class="hljs-keyword">defer</span> deferFunc()<br><br>    <span class="hljs-keyword">return</span> returnFunc()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    returnAndDefer()<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">return</span> func called<br>defer func called<br></code></pre></td></tr></table></figure><p>结论为：<strong>return之后的语句先执行，defer后的语句后执行</strong></p><h3 id="知识点3：函数的返回值初始化"><a href="#知识点3：函数的返回值初始化" class="headerlink" title="知识点3：函数的返回值初始化"></a>知识点3：函数的返回值初始化</h3><p>该知识点不属于defer本身，但是调用的场景却与defer有联系，所以也算是defer必备了解的知识点之一。</p><p>如 ： <code>func DeferFunc1(i int) (t int) &#123;&#125;</code><br>其中返回值<code>t int</code>，这个<code>t</code>会在函数起始处被初始化为对应类型的零值并且作用域为整个函数。</p><p><img src="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/1651037374393-f3e9c019-5990-41a0-8774-d73d0a805a25.png" alt="img"></p><p>示例代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br><br>    fmt.Println(<span class="hljs-string">&quot;t = &quot;</span>, t)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    DeferFunc11(<span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">t =  <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>证明，<strong>只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见</strong>。</p><h3 id="知识点4-有名函数返回值遇见defer情况"><a href="#知识点4-有名函数返回值遇见defer情况" class="headerlink" title="知识点4: 有名函数返回值遇见defer情况"></a>知识点4: 有名函数返回值遇见defer情况</h3><p>在没有defer的情况下，其实函数的返回就是与return一致的，但是有了defer就不一样了。</p><p>我们通过<strong>知识点2</strong>得知，先return，再defer，所以在执行完return之后，还要再执行defer里的语句，依然可以修改本应该返回的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">returnButDefer</span><span class="hljs-params">()</span></span> (t <span class="hljs-type">int</span>) &#123;  <span class="hljs-comment">//t初始化0， 并且作用域为该函数全域</span><br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t = t * <span class="hljs-number">10</span><br>    &#125;()<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(returnButDefer())<br>&#125;<br></code></pre></td></tr></table></figure><p>该<code>returnButDefer()</code>本应的返回值是<code>1</code>，但是在return之后，又被defer的匿名func函数执行，所以<code>t=t*10</code>被执行，最后<code>returnButDefer()</code>返回给上层<code>main()</code>的结果为<code>10</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go run test.go<br>10<br></code></pre></td></tr></table></figure><h3 id="知识点5-defer遇见panic"><a href="#知识点5-defer遇见panic" class="headerlink" title="知识点5: defer遇见panic"></a>知识点5: defer遇见panic</h3><p>我们知道，能够触发defer的是遇见return(或函数体到末尾)和遇见panic。</p><p>根据<strong>知识点2</strong>，我们知道，defer遇见return情况如下：</p><p><img src="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/1651037399517-3b0df721-59da-4ce2-8cd2-2c178b7fa355.jpeg" alt="img"></p><p>那么，遇到panic时，遍历本协程的defer链表，并执行defer。在执行defer过程中:遇到recover则停止panic，返回recover处继续往下执行。如果没有遇到recover，遍历完本协程的defer链表后，向stderr抛出panic信息。</p><p><img src="/2025/04/01/Golang%E4%B8%AD%E7%9A%84Defer%E5%BF%85%E6%8E%8C%E6%8F%A1%E7%9A%847%E7%9F%A5%E8%AF%86%E7%82%B9/1651037430519-67ffce42-f7eb-4698-8190-618c89274e2f.jpeg" alt="img"></p><h4 id="A-defer遇见panic，但是并不捕获异常的情况"><a href="#A-defer遇见panic，但是并不捕获异常的情况" class="headerlink" title="A. defer遇见panic，但是并不捕获异常的情况"></a>A. defer遇见panic，但是并不捕获异常的情况</h4><p>test10.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    defer_call()<br><br>    fmt.Println(<span class="hljs-string">&quot;main 正常结束&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defer_call</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之前1&quot;</span>) &#125;()<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之前2&quot;</span>) &#125;()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;异常内容&quot;</span>)  <span class="hljs-comment">//触发defer出栈</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之后，永远执行不到&quot;</span>) &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">defer: panic 之前2<br>defer: panic 之前1<br>panic: 异常内容<br>//... 异常堆栈信息<br></code></pre></td></tr></table></figure><h4 id="B-defer遇见panic，并捕获异常"><a href="#B-defer遇见panic，并捕获异常" class="headerlink" title="B. defer遇见panic，并捕获异常"></a>B. defer遇见panic，并捕获异常</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    defer_call()<br><br>    fmt.Println(<span class="hljs-string">&quot;main 正常结束&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defer_call</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;defer: panic 之前1, 捕获异常&quot;</span>)<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(err)<br>        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之前2, 不捕获&quot;</span>) &#125;()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;异常内容&quot;</span>)  <span class="hljs-comment">//触发defer出栈</span><br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Println(<span class="hljs-string">&quot;defer: panic 之后, 永远执行不到&quot;</span>) &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span>: <span class="hljs-built_in">panic</span> 之前<span class="hljs-number">2</span>, 不捕获<br><span class="hljs-keyword">defer</span>: <span class="hljs-built_in">panic</span> 之前<span class="hljs-number">1</span>, 捕获异常<br>异常内容<br>main 正常结束<br></code></pre></td></tr></table></figure><p><strong>defer 最大的功能是 panic 后依然有效</strong><br>所以defer可以保证你的一些资源一定会被关闭，从而避免一些异常出现的问题。</p><h3 id="知识点6-defer中包含panic"><a href="#知识点6-defer中包含panic" class="headerlink" title="知识点6: defer中包含panic"></a>知识点6: defer中包含panic</h3><p>编译执行下面代码会出现什么?</p><p>test16.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>  &#123;<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>       <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span>&#123;<br>           fmt.Println(err)<br>       &#125;<span class="hljs-keyword">else</span> &#123;<br>           fmt.Println(<span class="hljs-string">&quot;fatal&quot;</span>)<br>       &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;defer panic&quot;</span>)<br>    &#125;()<br><br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">defer panic<br></code></pre></td></tr></table></figure><p><strong>分析</strong></p><p><strong>panic仅有最后一个可以被revover捕获</strong>。</p><p>触发<code>panic(&quot;panic&quot;)</code>后defer顺序出栈执行，第一个被执行的defer中 会有<code>panic(&quot;defer panic&quot;)</code>异常语句，这个异常将会覆盖掉main中的异常<code>panic(&quot;panic&quot;)</code>，最后这个异常被第二个执行的defer捕获到。</p><h3 id="知识点7-defer下的函数参数包含子函数"><a href="#知识点7-defer下的函数参数包含子函数" class="headerlink" title="知识点7: defer下的函数参数包含子函数"></a>知识点7: defer下的函数参数包含子函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function</span><span class="hljs-params">(index <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><br>    fmt.Println(index)<br><br>    <span class="hljs-keyword">return</span> index<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> function(<span class="hljs-number">1</span>, function(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">defer</span> function(<span class="hljs-number">2</span>, function(<span class="hljs-number">4</span>, <span class="hljs-number">0</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，有4个函数，他们的index序号分别为1，2，3，4。</p><p>那么这4个函数的先后执行顺序是什么呢？这里面有两个defer， 所以defer一共会压栈两次，先进栈1，后进栈2。 那么在压栈function1的时候，需要连同函数地址、函数形参一同进栈，那么为了得到function1的第二个参数的结果，所以就需要先执行function3将第二个参数算出，那么function3就被第一个执行。同理压栈function2，就需要执行function4算出function2第二个参数的值。然后函数结束，先出栈fuction2、再出栈function1.</p><p>所以顺序如下：</p><ul><li>defer压栈function1，压栈函数地址、形参1、形参2(调用function3) –&gt; 打印3</li><li>defer压栈function2，压栈函数地址、形参1、形参2(调用function4) –&gt; 打印4</li><li>defer出栈function2, 调用function2 –&gt; 打印2</li><li>defer出栈function1, 调用function1–&gt; 打印1</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">3<br>4<br>2<br>1<br></code></pre></td></tr></table></figure><h3 id="练习：defer面试真题"><a href="#练习：defer面试真题" class="headerlink" title="练习：defer面试真题"></a>练习：defer面试真题</h3><p>了解以上6个defer的知识点，我们来验证一下网上的真题吧。</p><p>下面代码输出什么？</p><p>test11.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    t = i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    t := i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc3</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += i<br>    &#125;()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc4</span><span class="hljs-params">()</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        fmt.Println(i)<br>        fmt.Println(t)<br>    &#125;(t)<br>    t = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(DeferFunc1(<span class="hljs-number">1</span>))<br>    fmt.Println(DeferFunc2(<span class="hljs-number">1</span>))<br>    fmt.Println(DeferFunc3(<span class="hljs-number">1</span>))<br>    DeferFunc4()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="练习题分析"><a href="#练习题分析" class="headerlink" title="练习题分析"></a>练习题分析</h3><h4 id="DeferFunc1"><a href="#DeferFunc1" class="headerlink" title="DeferFunc1"></a>DeferFunc1</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc1</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    t = i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>将返回值t赋值为传入的i，此时t为1</li><li>执行return语句将t赋值给t（等于啥也没做）</li><li>执行defer方法，将t + 3 &#x3D; 4</li><li>函数返回 4<br>因为t的作用域为整个函数所以修改有效。</li></ol><h4 id="DeferFunc2"><a href="#DeferFunc2" class="headerlink" title="DeferFunc2"></a>DeferFunc2</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    t := i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>创建变量t并赋值为1</li><li>执行return语句，注意这里是将t赋值给返回值，此时返回值为1（这个返回值并不是t）</li><li>执行defer方法，将t + 3 &#x3D; 4</li><li>函数返回返回值1</li></ol><p>也可以按照如下代码理解:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc2</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (result <span class="hljs-type">int</span>) &#123;<br>    t := i<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += <span class="hljs-number">3</span><br>    &#125;()<br>    <span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码return的时候相当于将t赋值给了result，当defer修改了t的值之后，对result是不会造成影响的。</p><h4 id="DeferFunc3"><a href="#DeferFunc3" class="headerlink" title="DeferFunc3"></a>DeferFunc3</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc3</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t += i<br>    &#125;()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>首先执行return将返回值t赋值为2</li><li>执行defer方法将t + 1</li><li>最后返回 3</li></ol><h4 id="DeferFunc4"><a href="#DeferFunc4" class="headerlink" title="DeferFunc4"></a>DeferFunc4</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DeferFunc4</span><span class="hljs-params">()</span></span> (t <span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        fmt.Println(i)<br>        fmt.Println(t)<br>    &#125;(t)<br>    t = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>初始化返回值t为零值 0</li><li>首先执行defer的第一步，赋值defer中的func入参t为0</li><li>执行defer的第二步，将defer压栈</li><li>将t赋值为1</li><li>执行return语句，将返回值t赋值为2</li><li>执行defer的第三步，出栈并执行<br>因为在入栈时defer执行的func的入参已经赋值了，此时它作为的是一个形式参数，所以打印为0；相对应的因为最后已经将t的值修改为2，所以再打印一个2</li></ol><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a><strong>结果</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">4<br>1<br>3<br>0<br>2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解client-go中的indexer</title>
    <link href="/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/"/>
    <url>/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解client-go中的indexer"><a href="#深入理解client-go中的indexer" class="headerlink" title="深入理解client-go中的indexer"></a>深入理解client-go中的indexer</h1><p>转自：<a href="https://cloud.tencent.com/developer/article/1692517?cps_key=1d358d18a7a17b4a6df8d67a62fd3d3d">https://cloud.tencent.com/developer/article/1692517?cps_key=1d358d18a7a17b4a6df8d67a62fd3d3d</a></p><p><img src="/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/640.png" alt="图片"></p><p>前面我们讲到 <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://mp.weixin.qq.com/s?__biz=MzU4MjQ0MTU4Ng==&mid=2247485864&idx=1&sn=2011dfed276fe75a767d1e55f7d979ce&chksm=fdb906b5cace8fa3a01b911ac1004f6d6b57d8e0ae0d9a0e0746cdfa988947cc0e37ad2a980c&scene=21%23wechat_redirect&objectId=1692517&objectType=1&isNewArticle=undefined">DeltaFIFO 中的元素通过 Pop 函数弹出后</a>，在指定的回调函数中将元素添加到了 Indexer 中。Indexer 是什么？字面意思是索引器，它就是 Informer 中的 LocalStore 部分，我们可以和<a href="https://cloud.tencent.com/product/tencentdb-catalog?from_column=20065&from=20065">数据库</a>进行类比，数据库是建立在存储之上的，索引也是构建在存储之上，只是和数据做了一个映射，使得按照某些条件查询速度会非常快，所以说 Indexer 本身也是一个存储，只是它在存储的基础上扩展了索引功能。从 Indexer 接口的定义可以证明这一点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/indexer.go</span><br><br><span class="hljs-comment">// Indexer 使用多个索引扩展了 Store，并限制了每个累加器只能容纳当前对象</span><br><span class="hljs-comment">// 这里有3种字符串需要说明：</span><br><span class="hljs-comment">// 1. 一个存储键，在 Store 接口中定义（其实就是对象键）</span><br><span class="hljs-comment">// 2. 一个索引的名称（相当于索引分类名称）</span><br><span class="hljs-comment">// 3. 索引键，由 IndexFunc 生成，可以是一个字段值或从对象中计算出来的任何字符串</span><br><span class="hljs-keyword">type</span> Indexer <span class="hljs-keyword">interface</span> &#123;<br> Store  <span class="hljs-comment">// 继承了 Store 存储接口，所以说 Indexer 也是存储</span><br> <span class="hljs-comment">// indexName 是索引类名称，obj 是对象，计算 obj 在 indexName 索引类中的索引键，然后通过索引键把所有的对象取出来</span><br>  <span class="hljs-comment">// 获取 obj 对象在索引类中的索引键相匹配的对象</span><br> Index(indexName <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) ([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br> <span class="hljs-comment">// indexKey 是 indexName 索引分类中的一个索引键</span><br>  <span class="hljs-comment">// 函数返回 indexKey 指定的所有对象键 IndexKeys </span><br> IndexKeys(indexName, indexedValue <span class="hljs-type">string</span>) ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br> ListIndexFuncValues(indexName <span class="hljs-type">string</span>) []<span class="hljs-type">string</span><br> ByIndex(indexName, indexedValue <span class="hljs-type">string</span>) ([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br> GetIndexers() Indexers<br> <span class="hljs-comment">// 添加新的索引在存储中</span><br> AddIndexers(newIndexers Indexers) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Indexer"><a href="#Indexer" class="headerlink" title="Indexer"></a><strong>Indexer</strong></h3><p>在去查看 Indexer 的接口具体实现之前，我们需要了解 Indexer 中几个非常重要的概念：<code>Indices</code>、<code>Index</code>、<code>Indexers</code> 及 <code>IndexFunc</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/indexer.go</span><br><br><span class="hljs-comment">// 用于计算一个对象的索引键集合</span><br><span class="hljs-keyword">type</span> IndexFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// 索引键与对象键集合的映射</span><br><span class="hljs-keyword">type</span> Index <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]sets.String<br><br><span class="hljs-comment">// 索引器名称（或者索引分类）与 IndexFunc 的映射，相当于存储索引的各种分类</span><br><span class="hljs-keyword">type</span> Indexers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]IndexFunc<br><br><span class="hljs-comment">// 索引器名称与 Index 索引的映射</span><br><span class="hljs-keyword">type</span> Indices <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Index<br></code></pre></td></tr></table></figure><p>这4个数据结构的命名非常容易让大家混淆，直接查看源码也不是那么容易的。这里我们来仔细解释下。首先什么叫索引，索引就是为了快速查找的，比如我们需要查找某个节点上的所有 Pod，那就让 Pod 按照节点名称排序列举出来，对应的就是 Index 这个类型，具体的就是 <code>map[node]sets.pod</code>，但是如何去查找可以有多种方式，就是上面的 Indexers 这个类型的作用。我们可以用一个比较具体的示例来解释他们的关系和含义，如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br> <span class="hljs-string">&quot;fmt&quot;</span><br><br> v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br> <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/api/meta&quot;</span><br> metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br> <span class="hljs-string">&quot;k8s.io/client-go/tools/cache&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br> NamespaceIndexName = <span class="hljs-string">&quot;namespace&quot;</span><br> NodeNameIndexName  = <span class="hljs-string">&quot;nodeName&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NamespaceIndexFunc</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br> m, err := meta.Accessor(obj)<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;&quot;</span>&#125;, fmt.Errorf(<span class="hljs-string">&quot;object has no meta: %v&quot;</span>, err)<br> &#125;<br> <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;m.GetNamespace()&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NodeNameIndexFunc</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br> pod, ok := obj.(*v1.Pod)<br> <span class="hljs-keyword">if</span> !ok &#123;<br>  <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;&#125;, <span class="hljs-literal">nil</span><br> &#125;<br> <span class="hljs-keyword">return</span> []<span class="hljs-type">string</span>&#123;pod.Spec.NodeName&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> index := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers&#123;<br>  NamespaceIndexName: NamespaceIndexFunc,<br>  NodeNameIndexName:  NodeNameIndexFunc,<br> &#125;)<br><br> pod1 := &amp;v1.Pod&#123;<br>  ObjectMeta: metav1.ObjectMeta&#123;<br>   Name:      <span class="hljs-string">&quot;index-pod-1&quot;</span>,<br>   Namespace: <span class="hljs-string">&quot;default&quot;</span>,<br>  &#125;,<br>  Spec: v1.PodSpec&#123;NodeName: <span class="hljs-string">&quot;node1&quot;</span>&#125;,<br> &#125;<br> pod2 := &amp;v1.Pod&#123;<br>  ObjectMeta: metav1.ObjectMeta&#123;<br>   Name:      <span class="hljs-string">&quot;index-pod-2&quot;</span>,<br>   Namespace: <span class="hljs-string">&quot;default&quot;</span>,<br>  &#125;,<br>  Spec: v1.PodSpec&#123;NodeName: <span class="hljs-string">&quot;node2&quot;</span>&#125;,<br> &#125;<br> pod3 := &amp;v1.Pod&#123;<br>  ObjectMeta: metav1.ObjectMeta&#123;<br>   Name:      <span class="hljs-string">&quot;index-pod-3&quot;</span>,<br>   Namespace: <span class="hljs-string">&quot;kube-system&quot;</span>,<br>  &#125;,<br>  Spec: v1.PodSpec&#123;NodeName: <span class="hljs-string">&quot;node2&quot;</span>&#125;,<br> &#125;<br><br> _ = index.Add(pod1)<br> _ = index.Add(pod2)<br> _ = index.Add(pod3)<br><br> <span class="hljs-comment">// ByIndex 两个参数：IndexName（索引器名称）和 indexKey（需要检索的key）</span><br> pods, err := index.ByIndex(NamespaceIndexName, <span class="hljs-string">&quot;default&quot;</span>)<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-built_in">panic</span>(err)<br> &#125;<br> <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>  fmt.Println(pod.(*v1.Pod).Name)<br> &#125;<br><br> fmt.Println(<span class="hljs-string">&quot;==========================&quot;</span>)<br><br> pods, err = index.ByIndex(NodeNameIndexName, <span class="hljs-string">&quot;node2&quot;</span>)<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-built_in">panic</span>(err)<br> &#125;<br> <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods &#123;<br>  fmt.Println(pod.(*v1.Pod).Name)<br> &#125;<br><br>&#125;<br><br><span class="hljs-comment">// 输出结果为：</span><br>index-pod<span class="hljs-number">-1</span><br>index-pod<span class="hljs-number">-2</span><br>==========================<br>index-pod<span class="hljs-number">-2</span><br>index-pod<span class="hljs-number">-3</span><br></code></pre></td></tr></table></figure><p>在上面的示例中首先通过 NewIndexer 函数实例化 Indexer 对象，第一个参数就是用于计算资源对象键的函数，这里我们使用的是 <code>MetaNamespaceKeyFunc</code> 这个默认的对象键函数；第二个参数是 Indexers，也就是存储索引器，上面我们知道 <code>Indexers</code> 的定义为 <code>map[string]IndexFunc</code>，为什么要定义成一个 map 呢？我们可以类比数据库中，我们要查询某项数据，索引的方式是不是多种多样啊？为了扩展，Kubernetes 中就使用一个 map 来存储各种各样的存储索引器，至于存储索引器如何生成，就使用一个 <code>IndexFunc</code> 暴露出去，给使用者自己实现即可。</p><p>这里我们定义的了两个索引键生成函数：<code>NamespaceIndexFunc</code> 与 <code>NodeNameIndexFunc</code>，一个根据资源对象的命名空间来进行索引，一个根据资源对象所在的节点进行索引。然后定义了3个 Pod，前两个在 default 命名空间下面，另外一个在 kube-system 命名空间下面，然后通过 <code>index.Add</code> 函数添加这3个 Pod 资源对象。然后通过 <code>index.ByIndex</code> 函数查询在名为 <code>namespace</code> 的索引器下面匹配索引键为 <code>default</code> 的 Pod 列表。也就是查询 default 这个命名空间下面的所有 Pod，这里就是前两个定义的 Pod。</p><p>对上面的示例如果我们理解了，那么就很容易理解上面定义的4个数据结构了：</p><ul><li>IndexFunc：索引器函数，用于计算一个资源对象的索引值列表，上面示例是指定命名空间为索引值结果，当然我们也可以根据需求定义其他的，比如根据 Label 标签、Annotation 等属性来生成索引值列表。</li><li>Index：存储数据，对于上面的示例，我们要查找某个命名空间下面的 Pod，那就要让 Pod 按照其命名空间进行索引，对应的 Index 类型就是 <code>map[namespace]sets.pod</code>。</li><li>Indexers：存储索引器，key 为索引器名称，value 为索引器的实现函数，上面的示例就是 <code>map[&quot;namespace&quot;]MetaNamespaceIndexFunc</code>。</li><li>Indices：存储缓存器，key 为索引器名称，value 为缓存的数据，对于上面的示例就是 <code>map[&quot;namespace&quot;]map[namespace]sets.pod</code>。</li></ul><p>可能最容易混淆的是 Indexers 和 Indices 这两个概念，因为平时很多时候我们没有怎么区分二者的关系，这里我们可以这样理解：Indexers 是存储索引（生成索引键）的，Indices 里面是存储的真正的数据（对象键），这样可能更好理解。</p><p><img src="/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/658k4cmdot.png" alt="img"></p><p><img src="/2025/04/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3client-go%E4%B8%AD%E7%9A%84indexer/640-1743599934675-3.webp" alt="图片"></p><p>按照上面的理解我们可以得到上面示例的索引数据如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Indexers 就是包含的所有索引器(分类)以及对应实现</span><br>Indexers: &#123;  <br>  <span class="hljs-string">&quot;namespace&quot;</span>: NamespaceIndexFunc,<br>  <span class="hljs-string">&quot;nodeName&quot;</span>: NodeNameIndexFunc,<br>&#125;<br><span class="hljs-comment">// Indices 就是包含的所有索引分类中所有的索引数据</span><br>Indices: &#123;<br> <span class="hljs-string">&quot;namespace&quot;</span>: &#123;  <span class="hljs-comment">//namespace 这个索引分类下的所有索引数据</span><br>  <span class="hljs-string">&quot;default&quot;</span>: [<span class="hljs-string">&quot;pod-1&quot;</span>, <span class="hljs-string">&quot;pod-2&quot;</span>],  <span class="hljs-comment">// Index 就是一个索引键下所有的对象键列表</span><br>  <span class="hljs-string">&quot;kube-system&quot;</span>: [<span class="hljs-string">&quot;pod-3&quot;</span>]   <span class="hljs-comment">// Index</span><br> &#125;,<br> <span class="hljs-string">&quot;nodeName&quot;</span>: &#123;  <span class="hljs-comment">//nodeName 这个索引分类下的所有索引数据(对象键列表)</span><br>  <span class="hljs-string">&quot;node1&quot;</span>: [<span class="hljs-string">&quot;pod-1&quot;</span>],  <span class="hljs-comment">// Index</span><br>  <span class="hljs-string">&quot;node2&quot;</span>: [<span class="hljs-string">&quot;pod-2&quot;</span>, <span class="hljs-string">&quot;pod-3&quot;</span>]  <span class="hljs-comment">// Index</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadSafeMap"><a href="#ThreadSafeMap" class="headerlink" title="ThreadSafeMap"></a><strong>ThreadSafeMap</strong></h3><p>上面我们理解了 Indexer 中的几个重要的数据类型，下面我们来看下 Indexer 接口的具体实现 cache，位于文件 <code>k8s.io/client-go/tools/cache/store.go</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// [k8s.io/client-go/tools/cache/store.go](http://k8s.io/client-go/tools/cache/store.go)</span><br><br><span class="hljs-comment">// cache 用一个 ThreadSafeStore 和一个关联的 KeyFunc 来实现 Indexer</span><br><span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;<br> <span class="hljs-comment">// cacheStorage 是一个线程安全的存储</span><br> cacheStorage ThreadSafeStore<br>  <span class="hljs-comment">// keyFunc 用于计算对象键</span><br> keyFunc KeyFunc<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到这个 cache 包含一个 <code>ThreadSafeStore</code> 的属性，这是一个并发安全的存储，因为是存储，所以自然就有存储相关的增、删、改、查等操作，Indexer 就是在 ThreadSafeMap 基础上进行封装的，实现了索引相关的功能。接下来我们先来看看 ThreadSafeStore 的定义，位于 <code>k8s.io/client-go/tools/cache/thread_safe_store.go</code> 文件中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ThreadSafeStore <span class="hljs-keyword">interface</span> &#123;<br> Add(key <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;)<br> Update(key <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;)<br> Delete(key <span class="hljs-type">string</span>)<br> Get(key <span class="hljs-type">string</span>) (item <span class="hljs-keyword">interface</span>&#123;&#125;, exists <span class="hljs-type">bool</span>)<br> List() []<span class="hljs-keyword">interface</span>&#123;&#125;<br> ListKeys() []<span class="hljs-type">string</span><br> Replace(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">string</span>)<br> Index(indexName <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) ([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br> IndexKeys(indexName, indexKey <span class="hljs-type">string</span>) ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br> ListIndexFuncValues(name <span class="hljs-type">string</span>) []<span class="hljs-type">string</span><br> ByIndex(indexName, indexKey <span class="hljs-type">string</span>) ([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br> GetIndexers() Indexers<br><br> AddIndexers(newIndexers Indexers) <span class="hljs-type">error</span><br> Resync() <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从接口的定义可以看出 ThreadSafeStore 和 Index 基本上差不多，但还是有一些区别的，这个接口是需要通过对象键来进行索引的。接下来我们来看看这个接口的具体实现 threadSafeMap 的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// threadSafeMap 实现了 ThreadSafeStore</span><br><span class="hljs-keyword">type</span> threadSafeMap <span class="hljs-keyword">struct</span> &#123;<br> lock  sync.RWMutex<br>  <span class="hljs-comment">// 存储资源对象数据，key(对象键) 通过 keyFunc 得到</span><br>  <span class="hljs-comment">// 这就是真正存储的数据（对象键 -&gt; 对象）</span><br> items <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<br><br> <span class="hljs-comment">// indexers 索引分类与索引键函数的映射</span><br> indexers Indexers<br> <span class="hljs-comment">// indices 通过索引可以快速找到对象键</span><br> indices Indices<br>&#125;<br></code></pre></td></tr></table></figure><p>不要把索引键和对象键搞混了，索引键是用于对象快速查找的；对象键是对象在存储中的唯一命名，对象是通过名字+对象的方式存储的。接下来我们来仔细看下接口的具体实现，首先还是比较简单的 Add、Delete、Update 几个函数的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// 添加对象</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> Add(key <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br> c.lock.Lock()<br> <span class="hljs-keyword">defer</span> c.lock.Unlock()<br>  <span class="hljs-comment">// 获取老的对象</span><br> oldObject := c.items[key]<br>  <span class="hljs-comment">// 写入新的对象，items 中存的是 objKey -&gt; obj 的映射</span><br> c.items[key] = obj<br>  <span class="hljs-comment">// 添加了新的对象，所以要更新索引</span><br> c.updateIndices(oldObject, obj, key)<br>&#125;<br><br><span class="hljs-comment">// 更新对象，可以看到实现和 Add 是一样的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> Update(key <span class="hljs-type">string</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br> c.lock.Lock()<br> <span class="hljs-keyword">defer</span> c.lock.Unlock()<br> oldObject := c.items[key]<br> c.items[key] = obj<br> c.updateIndices(oldObject, obj, key)<br>&#125;<br><br><span class="hljs-comment">// 删除对象</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> Delete(key <span class="hljs-type">string</span>) &#123;<br> c.lock.Lock()<br> <span class="hljs-keyword">defer</span> c.lock.Unlock()<br>  <span class="hljs-comment">// 判断对象是否存在，存在才执行删除操作</span><br> <span class="hljs-keyword">if</span> obj, exists := c.items[key]; exists &#123;<br>    <span class="hljs-comment">// 删除对象索引</span><br>  c.deleteFromIndices(obj, key)<br>    <span class="hljs-comment">// 删除对象本身</span><br>  <span class="hljs-built_in">delete</span>(c.items, key)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到基本的实现比较简单，就是添加、更新、删除对象数据后，然后更新或删除对应的索引，所以我们需要查看下更新或删除索引的具体实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// updateIndices 更新索引</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> updateIndices(oldObj <span class="hljs-keyword">interface</span>&#123;&#125;, newObj <span class="hljs-keyword">interface</span>&#123;&#125;, key <span class="hljs-type">string</span>) &#123;<br> <span class="hljs-comment">// 如果有旧的对象，需要先从索引中删除这个对象</span><br> <span class="hljs-keyword">if</span> oldObj != <span class="hljs-literal">nil</span> &#123;<br>  c.deleteFromIndices(oldObj, key)<br> &#125;<br>  <span class="hljs-comment">// 循环所有的索引器</span><br> <span class="hljs-keyword">for</span> name, indexFunc := <span class="hljs-keyword">range</span> c.indexers &#123;<br>    <span class="hljs-comment">// 获取对象的索引键</span><br>  indexValues, err := indexFunc(newObj)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;unable to calculate an index entry for key %q on index %q: %v&quot;</span>, key, name, err))<br>  &#125;<br>    <span class="hljs-comment">// 得到当前索引器的索引</span><br>  index := c.indices[name]<br>  <span class="hljs-keyword">if</span> index == <span class="hljs-literal">nil</span> &#123;<br>      <span class="hljs-comment">// 没有对应的索引，则初始化一个索引</span><br>   index = Index&#123;&#125;<br>   c.indices[name] = index<br>  &#125;<br>    <span class="hljs-comment">// 循环所有的索引键</span><br>  <span class="hljs-keyword">for</span> _, indexValue := <span class="hljs-keyword">range</span> indexValues &#123;<br>      <span class="hljs-comment">// 得到索引键对应的对象键列表</span><br>   set := index[indexValue]<br>   <span class="hljs-keyword">if</span> set == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 没有对象键列表则初始化一个空列表</span><br>    set = sets.String&#123;&#125;<br>    index[indexValue] = set<br>   &#125;<br>      <span class="hljs-comment">// 将对象键插入到集合中，方便索引</span><br>   set.Insert(key)<br>  &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">// deleteFromIndices 删除对象索引</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *threadSafeMap)</span></span> deleteFromIndices(obj <span class="hljs-keyword">interface</span>&#123;&#125;, key <span class="hljs-type">string</span>) &#123;<br> <span class="hljs-comment">// 循环所有的索引器</span><br> <span class="hljs-keyword">for</span> name, indexFunc := <span class="hljs-keyword">range</span> c.indexers &#123;<br>  <span class="hljs-comment">// 获取删除对象的索引键列表</span><br>  indexValues, err := indexFunc(obj)<br>  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;unable to calculate an index entry for key %q on index %q: %v&quot;</span>, key, name, err))<br>  &#125;<br>  <span class="hljs-comment">// 获取当前索引器的索引</span><br>  index := c.indices[name]<br>  <span class="hljs-keyword">if</span> index == <span class="hljs-literal">nil</span> &#123;<br>   <span class="hljs-keyword">continue</span><br>  &#125;<br>  <span class="hljs-comment">// 循环所有索引键</span><br>  <span class="hljs-keyword">for</span> _, indexValue := <span class="hljs-keyword">range</span> indexValues &#123;<br>   <span class="hljs-comment">// 获取索引键对应的对象键列表</span><br>   set := index[indexValue]<br>   <span class="hljs-keyword">if</span> set != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 从对象键列表中删除当前要删除的对象键</span><br>    set.Delete(key)<br><br>    <span class="hljs-comment">// 如果当集合为空的时候不删除set，那么具有高基数的短生命资源的 indices 会导致未使用的空集合随时间增加内存。</span><br>    <span class="hljs-comment">// `kubernetes/kubernetes/issues/84959`.</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(set) == <span class="hljs-number">0</span> &#123;<br>     <span class="hljs-built_in">delete</span>(index, indexValue)<br>    &#125;<br>   &#125;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加索引和删除索引的实现都挺简单的，其实主要还是要对 indices、indexs 这些数据结构非常了解，这样就非常容易了，我们可以将 indexFunc 当成当前对象的命名空间来看待，这样对于上面的索引更新和删除的理解就肯定没问题了。</p><p>然后接下来就是几个查询相关的接口实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// 获取对象</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">Get</span>(key string) (item interface&#123;&#125;, exists bool) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()  <span class="hljs-comment">// 只需要读锁</span><br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <span class="hljs-comment">// 直接从 map 中读取值</span><br> item, exists = c.<span class="hljs-property">items</span>[key]<br> <span class="hljs-keyword">return</span> item, exists<br>&#125;<br><br><span class="hljs-comment">// 对象列举</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">List</span>() []interface&#123;&#125; &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br> list := <span class="hljs-title function_">make</span>([]interface&#123;&#125;, <span class="hljs-number">0</span>, <span class="hljs-title function_">len</span>(c.<span class="hljs-property">items</span>))<br> <span class="hljs-keyword">for</span> _, item := range c.<span class="hljs-property">items</span> &#123;<br>  list = <span class="hljs-title function_">append</span>(list, item)<br> &#125;<br> <span class="hljs-keyword">return</span> list<br>&#125;<br><br><span class="hljs-comment">// 返回 threadSafeMap 中所有的对象键列表</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">ListKeys</span>() []string &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br> list := <span class="hljs-title function_">make</span>([]string, <span class="hljs-number">0</span>, <span class="hljs-title function_">len</span>(c.<span class="hljs-property">items</span>))<br> <span class="hljs-keyword">for</span> key := range c.<span class="hljs-property">items</span> &#123;<br>  list = <span class="hljs-title function_">append</span>(list, key)<br> &#125;<br> <span class="hljs-keyword">return</span> list<br>&#125;<br><br><span class="hljs-comment">// 替换所有对象，相当于重新构建索引</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">Replace</span>(items map[string]interface&#123;&#125;, resourceVersion string) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">Lock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">Unlock</span>()<br>  <span class="hljs-comment">// 直接覆盖之前的对象</span><br> c.<span class="hljs-property">items</span> = items<br><br> <span class="hljs-comment">// 重新构建索引</span><br> c.<span class="hljs-property">indices</span> = <span class="hljs-title class_">Indices</span>&#123;&#125;<br> <span class="hljs-keyword">for</span> key, item := range c.<span class="hljs-property">items</span> &#123;<br>    <span class="hljs-comment">// 更新元素的索引</span><br>  c.<span class="hljs-title function_">updateIndices</span>(nil, item, key)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后接下来就是和索引相关的几个接口实现，第一个就是 Index 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// 通过指定的索引器和对象获取符合这个对象特征的所有对象</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">Index</span>(indexName string, obj interface&#123;&#125;) ([]interface&#123;&#125;, error) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <span class="hljs-comment">// 获得索引器 indexName 的索引键计算函数</span><br> indexFunc := c.<span class="hljs-property">indexers</span>[indexName]<br> <span class="hljs-keyword">if</span> indexFunc == nil &#123;<br>  <span class="hljs-keyword">return</span> nil, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;Index with name %s does not exist&quot;</span>, indexName)<br> &#125;<br>  <span class="hljs-comment">// 获取指定 obj 对象的索引键</span><br> indexedValues, err := <span class="hljs-title function_">indexFunc</span>(obj)<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> nil, err<br> &#125;<br>  <span class="hljs-comment">// 获得索引器 indexName 的所有索引</span><br> index := c.<span class="hljs-property">indices</span>[indexName]<br> <br>  <span class="hljs-comment">// 用来存储对象键的集合</span><br> <span class="hljs-keyword">var</span> storeKeySet sets.<span class="hljs-property">String</span><br> <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(indexedValues) == <span class="hljs-number">1</span> &#123;<br>    <span class="hljs-comment">// 大多数情况下只有一个值匹配（默认获取的索引键就是对象的 namespace）</span><br>    <span class="hljs-comment">// 直接拿到这个索引键的对象键集合</span><br>  storeKeySet = index[indexedValues[<span class="hljs-number">0</span>]]<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 由于有多个索引键，则可能有重复的对象键出现，索引需要去重</span><br>  storeKeySet = sets.<span class="hljs-property">String</span>&#123;&#125;<br>    <span class="hljs-comment">// 循环索引键</span><br>  <span class="hljs-keyword">for</span> _, indexedValue := range indexedValues &#123;<br>      <span class="hljs-comment">// 循环索引键下面的对象键，因为要去重</span><br>   <span class="hljs-keyword">for</span> key := range index[indexedValue] &#123;<br>    storeKeySet.<span class="hljs-title class_">Insert</span>(key)<br>   &#125;<br>  &#125;<br> &#125;<br>  <span class="hljs-comment">// 拿到了所有的对象键集合过后，循环拿到所有的对象集合</span><br> list := <span class="hljs-title function_">make</span>([]interface&#123;&#125;, <span class="hljs-number">0</span>, storeKeySet.<span class="hljs-title class_">Len</span>())<br> <span class="hljs-keyword">for</span> storeKey := range storeKeySet &#123;<br>  list = <span class="hljs-title function_">append</span>(list, c.<span class="hljs-property">items</span>[storeKey])<br> &#125;<br> <span class="hljs-keyword">return</span> list, nil<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 Index 函数就是获取一个指定对象的索引键，然后把这个索引键下面的所有的对象全部获取到，比如我们要获取一个 Pod 所在命名空间下面的所有 Pod，如果更抽象一点，就是符合对象<em>某些特征</em>的所有对象，而这个特征就是我们指定的索引键函数计算出来的。然后接下来就是一个比较重要的 ByIndex 函数的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// 和上面的 Index 函数类似，只是是直接指定的索引键</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">ByIndex</span>(indexName, indexedValue string) ([]interface&#123;&#125;, error) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <br>  <span class="hljs-comment">// 获得索引器 indexName 的索引键计算函数</span><br> indexFunc := c.<span class="hljs-property">indexers</span>[indexName]<br> <span class="hljs-keyword">if</span> indexFunc == nil &#123;<br>  <span class="hljs-keyword">return</span> nil, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;Index with name %s does not exist&quot;</span>, indexName)<br> &#125;<br>  <span class="hljs-comment">// 获得索引器 indexName 的所有索引</span><br> index := c.<span class="hljs-property">indices</span>[indexName]<br>  <span class="hljs-comment">// 获取指定索引键的所有所有对象键</span><br> set := index[indexedValue]<br>  <span class="hljs-comment">// 然后根据对象键遍历获取对象</span><br> list := <span class="hljs-title function_">make</span>([]interface&#123;&#125;, <span class="hljs-number">0</span>, set.<span class="hljs-title class_">Len</span>())<br> <span class="hljs-keyword">for</span> key := range set &#123;<br>  list = <span class="hljs-title function_">append</span>(list, c.<span class="hljs-property">items</span>[key])<br> &#125;<br><br> <span class="hljs-keyword">return</span> list, nil<br>&#125;<br></code></pre></td></tr></table></figure><p>可以很清楚地看到 ByIndex 函数和 Index 函数比较类似，但是更简单了，直接获取一个指定的索引键的全部资源对象。然后是其他几个索引相关的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/thread_safe_store.go</span><br><br><span class="hljs-comment">// IndexKeys 和上面的 ByIndex 几乎是一样的，只是这里是直接返回对象键列表</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">IndexKeys</span>(indexName, indexedValue string) ([]string, error) &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <span class="hljs-comment">// 获取索引器 indexName 的索引键计算函数</span><br> indexFunc := c.<span class="hljs-property">indexers</span>[indexName]<br> <span class="hljs-keyword">if</span> indexFunc == nil &#123;<br>  <span class="hljs-keyword">return</span> nil, fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;Index with name %s does not exist&quot;</span>, indexName)<br> &#125;<br>  <span class="hljs-comment">// 获取索引器 indexName 的所有索引</span><br> index := c.<span class="hljs-property">indices</span>[indexName]<br> <span class="hljs-comment">// 直接获取指定索引键的对象键集合</span><br> set := index[indexedValue]<br> <span class="hljs-keyword">return</span> set.<span class="hljs-title class_">List</span>(), nil<br>&#125;<br><br><span class="hljs-comment">// 获取索引器下面的所有索引键</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">ListIndexFuncValues</span>(indexName string) []string &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RLock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">RUnlock</span>()<br>  <span class="hljs-comment">// 获取索引器 indexName 的所有索引</span><br> index := c.<span class="hljs-property">indices</span>[indexName]<br> names := <span class="hljs-title function_">make</span>([]string, <span class="hljs-number">0</span>, <span class="hljs-title function_">len</span>(index))<br>  <span class="hljs-comment">// 遍历索引得到索引键</span><br> <span class="hljs-keyword">for</span> key := range index &#123;<br>  names = <span class="hljs-title function_">append</span>(names, key)<br> &#125;<br> <span class="hljs-keyword">return</span> names<br>&#125;<br><br><span class="hljs-comment">// 直接返回 indexers</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">GetIndexers</span>() <span class="hljs-title class_">Indexers</span> &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">indexers</span><br>&#125;<br><br><span class="hljs-comment">// 添加一个新的 Indexers</span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">AddIndexers</span>(newIndexers <span class="hljs-title class_">Indexers</span>) error &#123;<br> c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">Lock</span>()<br> defer c.<span class="hljs-property">lock</span>.<span class="hljs-title class_">Unlock</span>()<br><br> <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(c.<span class="hljs-property">items</span>) &gt; <span class="hljs-number">0</span> &#123;<br>  <span class="hljs-keyword">return</span> fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;cannot add indexers to running index&quot;</span>)<br> &#125;<br>  <span class="hljs-comment">// 获取旧的索引器和新的索引器keys</span><br> oldKeys := sets.<span class="hljs-title class_">StringKeySet</span>(c.<span class="hljs-property">indexers</span>)<br> newKeys := sets.<span class="hljs-title class_">StringKeySet</span>(newIndexers)<br>  <br>  <span class="hljs-comment">// 如果包含新的索引器，则提示冲突</span><br> <span class="hljs-keyword">if</span> oldKeys.<span class="hljs-title class_">HasAny</span>(newKeys.<span class="hljs-title class_">List</span>()...) &#123;<br>  <span class="hljs-keyword">return</span> fmt.<span class="hljs-title class_">Errorf</span>(<span class="hljs-string">&quot;indexer conflict: %v&quot;</span>, oldKeys.<span class="hljs-title class_">Intersection</span>(newKeys))<br> &#125;<br>  <span class="hljs-comment">// 将新的索引器添加到 Indexers 中</span><br> <span class="hljs-keyword">for</span> k, v := range newIndexers &#123;<br>  c.<span class="hljs-property">indexers</span>[k] = v<br> &#125;<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-comment">// 没有真正实现 Resync 操作 </span><br><span class="hljs-title function_">func</span> (c *threadSafeMap) <span class="hljs-title class_">Resync</span>() error &#123;<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们就将 ThreadSafeMap 的实现进行了分析说明。整体来说比较方便，一个就是将对象数据存入到一个 map 中，然后就是维护索引，方便根据索引来查找到对应的对象。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a><strong>cache</strong></h3><p>接下来再回过头去看 cache 的实现就非常简单了，因为 cache 就是对 ThreadSafeStore 的一个再次封装，很多操作都是直接调用的 <code>ThreadSafeStore</code> 的操作实现的，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// k8s.io/client-go/tools/cache/store.go</span><br><br><span class="hljs-comment">// Add 插入一个元素到 cache 中</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Add</span>(obj interface&#123;&#125;) error &#123;<br> key, err := c.<span class="hljs-title function_">keyFunc</span>(obj)  <span class="hljs-comment">// 生成对象键</span><br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">KeyError</span>&#123;obj, err&#125;<br> &#125;<br>  <span class="hljs-comment">// 将对象添加到底层的 ThreadSafeStore 中</span><br> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Add</span>(key, obj)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-comment">// 更新cache中的对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Update</span>(obj interface&#123;&#125;) error &#123;<br> key, err := c.<span class="hljs-title function_">keyFunc</span>(obj)<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">KeyError</span>&#123;obj, err&#125;<br> &#125;<br> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Update</span>(key, obj)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-comment">// 删除cache中的对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Delete</span>(obj interface&#123;&#125;) error &#123;<br> key, err := c.<span class="hljs-title function_">keyFunc</span>(obj)<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">KeyError</span>&#123;obj, err&#125;<br> &#125;<br> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Delete</span>(key)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-comment">// 得到cache中所有的对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">List</span>() []interface&#123;&#125; &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">List</span>()<br>&#125;<br><br><span class="hljs-comment">// 得到cache中所有的对象键</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">ListKeys</span>() []string &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">ListKeys</span>()<br>&#125;<br><br><span class="hljs-comment">// 得到cache中的Indexers</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">GetIndexers</span>() <span class="hljs-title class_">Indexers</span> &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">GetIndexers</span>()<br>&#125;<br><br><span class="hljs-comment">// 得到对象obj与indexName索引器关联的所有对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Index</span>(indexName string, obj interface&#123;&#125;) ([]interface&#123;&#125;, error) &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Index</span>(indexName, obj)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">IndexKeys</span>(indexName, indexKey string) ([]string, error) &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">IndexKeys</span>(indexName, indexKey)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">ListIndexFuncValues</span>(indexName string) []string &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">ListIndexFuncValues</span>(indexName)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">ByIndex</span>(indexName, indexKey string) ([]interface&#123;&#125;, error) &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">ByIndex</span>(indexName, indexKey)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">AddIndexers</span>(newIndexers <span class="hljs-title class_">Indexers</span>) error &#123;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">AddIndexers</span>(newIndexers)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Get</span>(obj interface&#123;&#125;) (item interface&#123;&#125;, exists bool, err error) &#123;<br> key, err := c.<span class="hljs-title function_">keyFunc</span>(obj)<br> <span class="hljs-keyword">if</span> err != nil &#123;<br>  <span class="hljs-keyword">return</span> nil, <span class="hljs-literal">false</span>, <span class="hljs-title class_">KeyError</span>&#123;obj, err&#125;<br> &#125;<br> <span class="hljs-keyword">return</span> c.<span class="hljs-title class_">GetByKey</span>(key)<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">GetByKey</span>(key string) (item interface&#123;&#125;, exists bool, err error) &#123;<br> item, exists = c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Get</span>(key)<br> <span class="hljs-keyword">return</span> item, exists, nil<br>&#125;<br><br><span class="hljs-comment">// 替换cache中所有的对象</span><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Replace</span>(list []interface&#123;&#125;, resourceVersion string) error &#123;<br> items := <span class="hljs-title function_">make</span>(map[string]interface&#123;&#125;, <span class="hljs-title function_">len</span>(list))<br> <span class="hljs-keyword">for</span> _, item := range list &#123;<br>  key, err := c.<span class="hljs-title function_">keyFunc</span>(item)<br>  <span class="hljs-keyword">if</span> err != nil &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-title class_">KeyError</span>&#123;item, err&#125;<br>  &#125;<br>  items[key] = item<br> &#125;<br> c.<span class="hljs-property">cacheStorage</span>.<span class="hljs-title class_">Replace</span>(items, resourceVersion)<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br><br><span class="hljs-title function_">func</span> (c *cache) <span class="hljs-title class_">Resync</span>() error &#123;<br> <span class="hljs-keyword">return</span> nil<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 cache 没有自己独特的实现方式，都是调用的包含的 <code>ThreadSafeStore</code> 操作接口。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>前面我们已经知道了 Reflector 通过 ListAndWatch 把数据传入 DeltaFIFO 后，经过 DeltaFIFO 的 Pop 函数将资源对象存入到了本地的一个存储 Indexer 中，而这个底层真正的存储其实就是上面的 ThreadSafeStore。</p><p>要理解 Indexer 组件，最主要就是要把索引、索引器（索引分类）、索引键、对象键这几个概念弄清楚，有时候确实容易混乱，我们将上面的示例理解了应该就很好理解了，比如我们按照命名空间来进行索引，可以简单的理解为这个 Indexer 就是简单的把相同命名空间的对象放在一个集合中，然后基于命名空间来查找对象。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pod创建过程</title>
    <link href="/2025/03/31/pod%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/03/31/pod%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="简述Pod创建过程"><a href="#简述Pod创建过程" class="headerlink" title="简述Pod创建过程"></a><a href="https://www.cnblogs.com/love-DanDan/p/18402153">简述Pod创建过程</a></h2><p>在Kubernetes（K8s）中，Pod是最基本的部署单位，其创建过程涉及多个步骤。以下是Pod创建的简要流程：</p><h3 id="1-定义Pod规范"><a href="#1-定义Pod规范" class="headerlink" title="1. 定义Pod规范"></a>1. <strong>定义Pod规范</strong></h3><p>用户通过YAML或JSON文件定义Pod的规格（spec），包括容器镜像、环境变量、存储卷等信息。</p><h3 id="2-提交请求"><a href="#2-提交请求" class="headerlink" title="2. 提交请求"></a>2. <strong>提交请求</strong></h3><p>用户使用<code>kubectl</code>命令行工具或K8s API将Pod的定义提交给Kubernetes集群。</p><h3 id="3-API-Server接收请求"><a href="#3-API-Server接收请求" class="headerlink" title="3. API Server接收请求"></a>3. <strong>API Server接收请求</strong></h3><ul><li><strong>API Server</strong>接收来自用户的请求，并将Pod的定义存储在<strong>etcd</strong>中。</li><li>它会验证请求的有效性，并返回相应的状态。</li></ul><h3 id="4-调度（Scheduling）"><a href="#4-调度（Scheduling）" class="headerlink" title="4. 调度（Scheduling）"></a>4. <strong>调度（Scheduling）</strong></h3><ul><li><strong>Scheduler</strong>会监控新的Pod创建请求，根据资源需求和节点的可用资源（如CPU、内存）进行调度。</li><li>Scheduler选择一个合适的工作节点，并将Pod的信息发送到该节点的Kubelet。</li></ul><h3 id="5-Kubelet处理请求"><a href="#5-Kubelet处理请求" class="headerlink" title="5. Kubelet处理请求"></a>5. <strong>Kubelet处理请求</strong></h3><ul><li>工作节点上的<strong>Kubelet</strong>接收到调度信息后，开始根据Pod的定义创建容器。</li><li>Kubelet会与容器运行时（如Docker或containerd）进行交互，拉取所需的容器镜像并启动容器。</li></ul><h3 id="6-网络配置"><a href="#6-网络配置" class="headerlink" title="6. 网络配置"></a>6. <strong>网络配置</strong></h3><ul><li>Kubelet为Pod分配一个IP地址，并配置网络，以便Pod内的容器能够相互通信以及与外部世界进行通信。</li></ul><h3 id="7-容器启动"><a href="#7-容器启动" class="headerlink" title="7. 容器启动"></a>7. <strong>容器启动</strong></h3><ul><li>一旦容器被创建并启动，Kubelet会检查容器的健康状态（如配置的健康检查）并确保容器正常运行。</li></ul><h3 id="8-更新状态"><a href="#8-更新状态" class="headerlink" title="8. 更新状态"></a>8. <strong>更新状态</strong></h3><ul><li>Kubelet将Pod的状态更新回API Server，表示Pod已成功创建并运行。</li></ul><h3 id="9-监控与管理"><a href="#9-监控与管理" class="headerlink" title="9. 监控与管理"></a>9. <strong>监控与管理</strong></h3><ul><li>K8s控制面（Controller Manager等）会持续监控Pod的状态，确保其与期望状态一致。如果Pod崩溃或停止，K8s会自动重启或重新调度Pod。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Pod的创建过程是一个高度自动化和协调的过程，涉及用户定义、调度、容器创建和状态监控等多个环节。通过这一过程，K8s能够高效地管理容器化应用的生命周期。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s平台排错一览图</title>
    <link href="/2025/03/31/k8s%E5%B9%B3%E5%8F%B0%E6%8E%92%E9%94%99%E4%B8%80%E8%A7%88%E5%9B%BE/"/>
    <url>/2025/03/31/k8s%E5%B9%B3%E5%8F%B0%E6%8E%92%E9%94%99%E4%B8%80%E8%A7%88%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s排错一览图"><a href="#k8s排错一览图" class="headerlink" title="k8s排错一览图"></a>k8s排错一览图</h1><p>转自：<a href="https://dbwu.tech/posts/k8s/source_code/pod_create/">https://dbwu.tech/posts/k8s/source_code/pod_create/</a></p><p><img src="/2025/03/31/k8s%E5%B9%B3%E5%8F%B0%E6%8E%92%E9%94%99%E4%B8%80%E8%A7%88%E5%9B%BE/k8s-pod-debug-flow.jpeg" alt="Pod Debug 流程图"></p>]]></content>
    
    
    
    <tags>
      
      <tag>k8szh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang实现M:N生产者消费者模型</title>
    <link href="/2025/03/31/Golang%E5%AE%9E%E7%8E%B0M-N%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/31/Golang%E5%AE%9E%E7%8E%B0M-N%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang实现M-N生产者消费者队列（带5秒超时丢弃机制）"><a href="#Golang实现M-N生产者消费者队列（带5秒超时丢弃机制）" class="headerlink" title="Golang实现M:N生产者消费者队列（带5秒超时丢弃机制）"></a>Golang实现M:N生产者消费者队列（带5秒超时丢弃机制）</h1><p>下面是一个完整的Go实现，包含M个生产者和N个消费者的队列系统，生产者和消费者都有5秒超时丢弃机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Task <span class="hljs-keyword">struct</span> &#123;<br>ID       <span class="hljs-type">int</span><br>Data     <span class="hljs-keyword">interface</span>&#123;&#125;<br>produced time.Time<br>&#125;<br><br><span class="hljs-keyword">type</span> Queue <span class="hljs-keyword">struct</span> &#123;<br>tasks      <span class="hljs-keyword">chan</span> Task<br>timeout    time.Duration<br>producerWg sync.WaitGroup<br>consumerWg sync.WaitGroup<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewQueue</span><span class="hljs-params">(bufferSize <span class="hljs-type">int</span>, timeout time.Duration)</span></span> *Queue &#123;<br><span class="hljs-keyword">return</span> &amp;Queue&#123;<br>tasks:   <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Task, bufferSize),<br>timeout: timeout,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Producer 生产者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Producer(id <span class="hljs-type">int</span>, ctx context.Context) &#123;<br><span class="hljs-keyword">defer</span> q.producerWg.Done()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 模拟生产任务</span><br>task := Task&#123;<br>ID:       rand.Intn(<span class="hljs-number">1000</span>),<br>Data:     fmt.Sprintf(<span class="hljs-string">&quot;Data from producer %d&quot;</span>, id),<br>produced: time.Now(),<br>&#125;<br><br><span class="hljs-comment">// 尝试发送任务，带超时</span><br>ctxSend, cancel := context.WithTimeout(ctx, q.timeout)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> q.tasks &lt;- task:<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d produced task %d\n&quot;</span>, id, task.ID)<br><span class="hljs-keyword">case</span> &lt;-ctxSend.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d timeout, discarding task %d\n&quot;</span>, id, task.ID)<br>&#125;<br>cancel()<br><br><span class="hljs-comment">// 模拟生产间隔</span><br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1500</span>)) * time.Millisecond)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Consumer 消费者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *Queue)</span></span> Consumer(id <span class="hljs-type">int</span>, ctx context.Context) &#123;<br><span class="hljs-keyword">defer</span> q.consumerWg.Done()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// 尝试接收任务，带超时</span><br>ctxRecv, cancel := context.WithTimeout(ctx, q.timeout)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> task := &lt;-q.tasks:<br><span class="hljs-comment">// 检查任务是否已经超时（从生产到消费）</span><br><span class="hljs-keyword">if</span> time.Since(task.produced) &gt; q.timeout &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d discarded expired task %d (age: %v)\n&quot;</span>, <br>id, task.ID, time.Since(task.produced))<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 处理任务</span><br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d processing task %d: %v\n&quot;</span>, id, task.ID, task.Data)<br><span class="hljs-comment">// 模拟处理时间</span><br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">2000</span>)) * time.Millisecond)<br><span class="hljs-keyword">case</span> &lt;-ctxRecv.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d timeout waiting for task\n&quot;</span>, id)<br>&#125;<br>cancel()<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 配置参数</span><br><span class="hljs-keyword">const</span> (<br>producerCount = <span class="hljs-number">3</span><br>consumerCount = <span class="hljs-number">2</span><br>bufferSize    = <span class="hljs-number">10</span><br>timeout       = <span class="hljs-number">5</span> * time.Second<br>runtime       = <span class="hljs-number">20</span> * time.Second<br>)<br><br><span class="hljs-comment">// 创建队列</span><br>queue := NewQueue(bufferSize, timeout)<br><br><span class="hljs-comment">// 创建上下文，用于控制goroutine退出</span><br>ctx, cancel := context.WithTimeout(context.Background(), runtime)<br><span class="hljs-keyword">defer</span> cancel()<br><br><span class="hljs-comment">// 启动生产者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= producerCount; i++ &#123;<br>queue.producerWg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> queue.Producer(i, ctx)<br>&#125;<br><br><span class="hljs-comment">// 启动消费者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= consumerCount; i++ &#123;<br>queue.consumerWg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> queue.Consumer(i, ctx)<br>&#125;<br><br><span class="hljs-comment">// 等待所有生产者和消费者退出</span><br>queue.producerWg.Wait()<br><span class="hljs-built_in">close</span>(queue.tasks) <span class="hljs-comment">// 关闭通道，消费者可以退出</span><br>queue.consumerWg.Wait()<br><br>fmt.Println(<span class="hljs-string">&quot;All producers and consumers exited&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><ol><li><strong>生产者超时机制</strong>：<ul><li>每个生产者尝试将任务放入队列时，有5秒的超时限制</li><li>如果5秒内无法放入队列（队列满），则丢弃该任务</li></ul></li><li><strong>消费者超时机制</strong>：<ul><li>每个消费者尝试从队列获取任务时，有5秒的超时限制</li><li>如果5秒内没有获取到任务，则继续尝试</li></ul></li><li><strong>任务过期检查</strong>：<ul><li>消费者获取任务后，会检查任务从生产到现在是否已超过5秒</li><li>如果超过，则直接丢弃该任务</li></ul></li><li><strong>优雅退出</strong>：<ul><li>使用context控制所有goroutine的退出</li><li>主程序运行20秒后自动关闭</li></ul></li></ol><h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><p>程序输出示例（部分）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Producer <span class="hljs-number">1</span> produced <span class="hljs-keyword">task</span> <span class="hljs-number">81</span><br>Producer <span class="hljs-number">2</span> produced <span class="hljs-keyword">task</span> <span class="hljs-number">887</span><br>Consumer <span class="hljs-number">1</span> processing <span class="hljs-keyword">task</span> <span class="hljs-number">81</span>: Data <span class="hljs-keyword">from</span> producer <span class="hljs-number">1</span><br>Consumer <span class="hljs-number">2</span> processing <span class="hljs-keyword">task</span> <span class="hljs-number">887</span>: Data <span class="hljs-keyword">from</span> producer <span class="hljs-number">2</span><br>Producer <span class="hljs-number">3</span> produced <span class="hljs-keyword">task</span> <span class="hljs-number">847</span><br>Producer <span class="hljs-number">1</span> timeout, discarding <span class="hljs-keyword">task</span> <span class="hljs-number">318</span><br>Consumer <span class="hljs-number">1</span> timeout waiting <span class="hljs-keyword">for</span> <span class="hljs-keyword">task</span><br>Consumer <span class="hljs-number">2</span> processing <span class="hljs-keyword">task</span> <span class="hljs-number">847</span>: Data <span class="hljs-keyword">from</span> producer <span class="hljs-number">3</span><br>...<br>All producers and consumers exited<br></code></pre></td></tr></table></figure><p>这个实现提供了完整的M:N生产者消费者模型，并确保了生产者和消费者都有5秒的超时丢弃机制。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-channel实现原理</title>
    <link href="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://zhuanlan.zhihu.com/p/597232906">https://zhuanlan.zhihu.com/p/597232906</a></p><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-0f42d64ad820157d0bcf6370ded4abb0_1440w.jpg" alt="img"></p><p>用过 go 的都知道 <a href="https://zhida.zhihu.com/search?content_id=220851325&content_type=Article&match_order=1&q=channel&zhida_source=entity">channel</a>，无需多言，直接开整！</p><h2 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1 核心数据结构"></a>1 核心数据结构</h2><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-33e6558c73c76c439818cb4477bfb14a_1440w.jpg" alt="img"></p><h3 id="1-1-hchan"><a href="#1-1-hchan" class="headerlink" title="1.1 hchan"></a>1.1 hchan</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>    qcount   <span class="hljs-type">uint</span>           <span class="hljs-comment">// total data in the queue</span><br>    dataqsiz <span class="hljs-type">uint</span>           <span class="hljs-comment">// size of the circular queue</span><br>    buf      unsafe.Pointer <span class="hljs-comment">// points to an array of dataqsiz elements</span><br>    elemsize <span class="hljs-type">uint16</span><br>    closed   <span class="hljs-type">uint32</span><br>    elemtype *_type <span class="hljs-comment">// element type</span><br>    sendx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// send index</span><br>    recvx    <span class="hljs-type">uint</span>   <span class="hljs-comment">// receive index</span><br>    recvq    waitq  <span class="hljs-comment">// list of recv waiters</span><br>    sendq    waitq  <span class="hljs-comment">// list of send waiters</span><br><br>    lock mutex<br>&#125;<br></code></pre></td></tr></table></figure><p>hchan： channel 数据结构</p><p>（1）qcount：当前 channel 中存在多少个元素；</p><p>（2）dataqsize: 当前 channel 能存放的元素容量；</p><p>（3）buf：channel 中用于存放元素的环形缓冲区；</p><p>（4）elemsize：channel 元素类型的大小；</p><p>（5）closed：标识 channel 是否关闭；</p><p>（6）elemtype：channel 元素类型；</p><p>（7）sendx：发送元素进入环形缓冲区的 index；</p><p>（8）recvx：接收元素所处的环形缓冲区的 index；</p><p>（9）recvq：因接收而陷入阻塞的协程队列；</p><p>（10）sendq：因发送而陷入阻塞的协程队列；</p><h3 id="1-2-waitq"><a href="#1-2-waitq" class="headerlink" title="1.2 waitq"></a>1.2 waitq</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> waitq <span class="hljs-keyword">struct</span> &#123;<br>    first *sudog<br>    last  *sudog<br>&#125;<br></code></pre></td></tr></table></figure><p>waitq：阻塞的协程队列</p><p>（1）first：队列头部</p><p>（2）last：队列尾部</p><h3 id="1-3-sudog"><a href="#1-3-sudog" class="headerlink" title="1.3 sudog"></a>1.3 sudog</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> sudog <span class="hljs-keyword">struct</span> &#123;<br>    g *g<br><br>    next *sudog<br>    prev *sudog<br>    elem unsafe.Pointer <span class="hljs-comment">// data element (may point to stack)</span><br>    <span class="hljs-comment">// ...</span><br>    c        *hchan <br>&#125;<br></code></pre></td></tr></table></figure><p>sudog：用于包装协程的节点</p><p>（1）g：<a href="https://zhida.zhihu.com/search?content_id=220851325&content_type=Article&match_order=1&q=goroutine&zhida_source=entity">goroutine</a>，协程；</p><p>（2）next：队列中的下一个节点；</p><p>（3）prev：队列中的前一个节点；</p><p>（4）elem: 读取&#x2F;写入 channel 的数据的容器;</p><p>（5）c：标识与当前 sudog 交互的 chan.</p><h2 id="2-构造器函数"><a href="#2-构造器函数" class="headerlink" title="2 构造器函数"></a>2 构造器函数</h2><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-112b94a7ac698ee34d0b4a7c5641f388_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size <span class="hljs-type">int</span>)</span></span> *hchan &#123;<br>    elem := t.elem<br><br>    <span class="hljs-comment">// ...</span><br>    mem, overflow := math.MulUintptr(elem.size, <span class="hljs-type">uintptr</span>(size))<br>    <span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;makechan: size out of range&quot;</span>))<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> c *hchan<br>    <span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> mem == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">// Queue or element size is zero.</span><br>        c = (*hchan)(mallocgc(hchanSize, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>    <span class="hljs-keyword">case</span> elem.ptrdata == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment">// Elements do not contain pointers.</span><br>        <span class="hljs-comment">// Allocate hchan and buf in one call.</span><br>        c = (*hchan)(mallocgc(hchanSize+mem, <span class="hljs-literal">nil</span>, <span class="hljs-literal">true</span>))<br>        c.buf = add(unsafe.Pointer(c), hchanSize)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// Elements contain pointers.</span><br>        c = <span class="hljs-built_in">new</span>(hchan)<br>        c.buf = mallocgc(mem, elem, <span class="hljs-literal">true</span>)<br>    &#125;<br><br>    c.elemsize = <span class="hljs-type">uint16</span>(elem.size)<br>    c.elemtype = elem<br>    c.dataqsiz = <span class="hljs-type">uint</span>(size)<br>    <br>    lockInit(&amp;c.lock, lockRankHchan)<br><br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）判断申请内存空间大小是否越界，mem 大小为 element 类型大小与 element 个数相乘后得到，仅当无缓冲型 channel 时，因个数为 0 导致大小为 0；</p><p>（2）根据类型，初始 channel，分为 无缓冲型、有缓冲元素为 struct 型、有缓冲元素为 pointer 型 channel;</p><p>（3）倘若为无缓冲型，则仅申请一个大小为默认值 96 的空间；</p><p>（4）如若有缓冲的 struct 型，则一次性分配好 96 + mem 大小的空间，并且调整 chan 的 buf 指向 mem 的起始位置；</p><p>（5）倘若为有缓冲的 pointer 型，则分别申请 chan 和 buf 的空间，两者无需连续；</p><p>（6）对 channel 的其余字段进行初始化，包括元素类型大小、元素类型、容量以及锁的初始化.</p><h2 id="3-写流程"><a href="#3-写流程" class="headerlink" title="3 写流程"></a>3 写流程</h2><h3 id="3-1-两类异常情况处理"><a href="#3-1-两类异常情况处理" class="headerlink" title="3.1 两类异常情况处理"></a>3.1 两类异常情况处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>    chansend(c, elem, <span class="hljs-literal">true</span>, getcallerpc())<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>        gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>        throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>    &#125;<br><br><br>    lock(&amp;c.lock)<br><br><br>    <span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>        unlock(&amp;c.lock)<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;send on closed channel&quot;</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）对于未初始化的 chan，写入操作会引发死锁；</p><p>（2）对于已关闭的 chan，写入操作会引发 panic.</p><h3 id="3-2-case1：写时存在阻塞读协程"><a href="#3-2-case1：写时存在阻塞读协程" class="headerlink" title="3.2 case1：写时存在阻塞读协程"></a>3.2 case1：写时存在阻塞读协程</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-aeebdcfb97a933e7ab5a6629a9ec385c_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// ...</span><br><br>    lock(&amp;c.lock)<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// Found a waiting receiver. We pass the value we want to send</span><br>        <span class="hljs-comment">// directly to the receiver, bypassing the channel buffer (if any).</span><br>        send(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）从阻塞度协程队列中取出一个 goroutine 的封装对象 sudog；</p><p>（3）在 send 方法中，会基于 memmove 方法，直接将元素拷贝交给 sudog 对应的 goroutine；</p><p>（4）在 send 方法中会完成解锁动作.</p><h3 id="3-3-case2：写时无阻塞读协程但环形缓冲区仍有空间"><a href="#3-3-case2：写时无阻塞读协程但环形缓冲区仍有空间" class="headerlink" title="3.3 case2：写时无阻塞读协程但环形缓冲区仍有空间"></a>3.3 case2：写时无阻塞读协程但环形缓冲区仍有空间</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-bbf306ebfd01a163e961ac366edd7f21_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    lock(&amp;c.lock)<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> c.qcount &lt; c.dataqsiz &#123;<br>        <span class="hljs-comment">// Space is available in the channel buffer. Enqueue the element to send.</span><br>        qp := chanbuf(c, c.sendx)<br>        typedmemmove(c.elemtype, qp, ep)<br>        c.sendx++<br>        <span class="hljs-keyword">if</span> c.sendx == c.dataqsiz &#123;<br>            c.sendx = <span class="hljs-number">0</span><br>        &#125;<br>        c.qcount++<br>        unlock(&amp;c.lock)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）将当前元素添加到环形缓冲区 sendx 对应的位置；</p><p>（3）sendx++;</p><p>（4）qcount++;</p><p>（4）解锁，返回.</p><h3 id="3-4-case3：写时无阻塞读协程且环形缓冲区无空间"><a href="#3-4-case3：写时无阻塞读协程且环形缓冲区无空间" class="headerlink" title="3.4 case3：写时无阻塞读协程且环形缓冲区无空间"></a>3.4 case3：写时无阻塞读协程且环形缓冲区无空间</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-0add82424b36cbd0a5edf54d115cf4db_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chansend</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>, callerpc <span class="hljs-type">uintptr</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    lock(&amp;c.lock)<br><br>    <span class="hljs-comment">// ...</span><br>    gp := getg()<br>    mysg := acquireSudog()<br>    mysg.elem = ep<br>    mysg.g = gp<br>    mysg.c = c<br>    gp.waiting = mysg<br>    c.sendq.enqueue(mysg)<br>    <br>    atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="hljs-number">2</span>)<br>    <br>    gp.waiting = <span class="hljs-literal">nil</span><br>    closed := !mysg.success<br>    gp.param = <span class="hljs-literal">nil</span><br>    mysg.c = <span class="hljs-literal">nil</span><br>    releaseSudog(mysg)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）构造封装当前 goroutine 的 sudog 对象；</p><p>（3）完成指针指向，建立 sudog、goroutine、channel 之间的指向关系；</p><p>（4）把 sudog 添加到当前 channel 的阻塞写协程队列中；</p><p>（5）park 当前协程；</p><p>（6）倘若协程从 park 中被唤醒，则回收 sudog（sudog能被唤醒，其对应的元素必然已经被读协程取走）；</p><p>（7）解锁，返回</p><h3 id="3-5-写流程整体串联"><a href="#3-5-写流程整体串联" class="headerlink" title="3.5 写流程整体串联"></a>3.5 写流程整体串联</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-152528930008eb3508fcb0b5ffe480a3_1440w.jpg" alt="img"></p><h2 id="4-读流程"><a href="#4-读流程" class="headerlink" title="4 读流程"></a>4 读流程</h2><h3 id="4-1-异常-case1：读空-channel"><a href="#4-1-异常-case1：读空-channel" class="headerlink" title="4.1 异常 case1：读空 channel"></a>4.1 异常 case1：读空 channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>        gopark(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="hljs-number">2</span>)<br>        throw(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）park 挂起，引起死锁；</p><h3 id="4-2-异常-case2：channel-已关闭且内部无元素"><a href="#4-2-异常-case2：channel-已关闭且内部无元素" class="headerlink" title="4.2 异常 case2：channel 已关闭且内部无元素"></a>4.2 异常 case2：channel 已关闭且内部无元素</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>  <br>    lock(&amp;c.lock)<br><br><br>    <span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> c.qcount == <span class="hljs-number">0</span> &#123;<br>            unlock(&amp;c.lock)<br>            <span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>                typedmemclr(c.elemtype, ep)<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-comment">// The channel has been closed, but the channel&#x27;s buffer have data.</span><br>    &#125; <br><br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>（1）直接解锁返回即可</p><h3 id="4-3-case3：读时有阻塞的写协程"><a href="#4-3-case3：读时有阻塞的写协程" class="headerlink" title="4.3 case3：读时有阻塞的写协程"></a>4.3 case3：读时有阻塞的写协程</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-867428e66aeded401bb24ef760d99269_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>   <br>    lock(&amp;c.lock)<br><br><br>    <span class="hljs-comment">// Just found waiting sender with not closed.</span><br>    <span class="hljs-keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="hljs-literal">nil</span> &#123;<br>        recv(c, sg, ep, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>     &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recv</span><span class="hljs-params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="hljs-keyword">func</span>()</span></span>, skip <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> c.dataqsiz == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// copy data from sender</span><br>recvDirect(c.elemtype, sg, ep)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Queue is full. Take the item at the</span><br><span class="hljs-comment">// head of the queue. Make the sender enqueue</span><br><span class="hljs-comment">// its item at the tail of the queue. Since the</span><br><span class="hljs-comment">// queue is full, those are both the same slot.</span><br>qp := chanbuf(c, c.recvx)<br><span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>typedmemmove(c.elemtype, ep, qp)<br>&#125;<br><br>typedmemmove(c.elemtype, qp, sg.elem)<br>c.recvx++<br><span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>c.recvx = <span class="hljs-number">0</span><br>&#125;<br>c.sendx = c.recvx <span class="hljs-comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span><br>&#125;<br>sg.elem = <span class="hljs-literal">nil</span><br>gp := sg.g<br>unlockf()<br>gp.param = unsafe.Pointer(sg)<br>sg.success = <span class="hljs-literal">true</span><br>goready(gp, skip+<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）从阻塞写协程队列中获取到一个写协程；</p><p>（3）倘若 channel 无缓冲区，则直接读取写协程元素，并唤醒写协程；</p><p>（4）倘若 channel 有缓冲区，则读取缓冲区头部元素，并将写协程元素写入缓冲区尾部后唤醒写写成；</p><p>（5）解锁，返回.</p><h3 id="4-4-case4：读时无阻塞写协程且缓冲区有元素"><a href="#4-4-case4：读时无阻塞写协程且缓冲区有元素" class="headerlink" title="4.4 case4：读时无阻塞写协程且缓冲区有元素"></a>4.4 case4：读时无阻塞写协程且缓冲区有元素</h3><p><img src="https://pic1.zhimg.com/v2-354eb67a148726103d12d08b9d5c3b04_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><br><br>    lock(&amp;c.lock)<br><br><br>    <span class="hljs-keyword">if</span> c.qcount &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// Receive directly from queue</span><br>        qp := chanbuf(c, c.recvx)<br>        <span class="hljs-keyword">if</span> ep != <span class="hljs-literal">nil</span> &#123;<br>            typedmemmove(c.elemtype, ep, qp)<br>        &#125;<br>        typedmemclr(c.elemtype, qp)<br>        c.recvx++<br>        <span class="hljs-keyword">if</span> c.recvx == c.dataqsiz &#123;<br>            c.recvx = <span class="hljs-number">0</span><br>        &#125;<br>        c.qcount--<br>        unlock(&amp;c.lock)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）获取到 recvx 对应位置的元素；</p><p>（3）recvx++</p><p>（4）qcount–</p><p>（5）解锁，返回</p><h3 id="4-5-case5：读时无阻塞写协程且缓冲区无元素"><a href="#4-5-case5：读时无阻塞写协程且缓冲区无元素" class="headerlink" title="4.5 case5：读时无阻塞写协程且缓冲区无元素"></a>4.5 case5：读时无阻塞写协程且缓冲区无元素</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-b3070eedf5f179b7a7515dc0ec5892d0_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv</span><span class="hljs-params">(c *hchan, ep unsafe.Pointer, block <span class="hljs-type">bool</span>)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br>    lock(&amp;c.lock)<br><br>    gp := getg()<br>    mysg := acquireSudog()<br>    mysg.elem = ep<br>    gp.waiting = mysg<br>    mysg.g = gp<br>    mysg.c = c<br>    gp.param = <span class="hljs-literal">nil</span><br>    c.recvq.enqueue(mysg)<br>    atomic.Store8(&amp;gp.parkingOnChan, <span class="hljs-number">1</span>)<br>    gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="hljs-number">2</span>)<br><br>    gp.waiting = <span class="hljs-literal">nil</span><br>    success := mysg.success<br>    gp.param = <span class="hljs-literal">nil</span><br>    mysg.c = <span class="hljs-literal">nil</span><br>    releaseSudog(mysg)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>, success<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）加锁；</p><p>（2）构造封装当前 goroutine 的 sudog 对象；</p><p>（3）完成指针指向，建立 sudog、goroutine、channel 之间的指向关系；</p><p>（4）把 sudog 添加到当前 channel 的阻塞读协程队列中；</p><p>（5）park 当前协程；</p><p>（6）倘若协程从 park 中被唤醒，则回收 sudog（sudog能被唤醒，其对应的元素必然已经被写入）；</p><p>（7）解锁，返回</p><h3 id="4-6-读流程整体串联"><a href="#4-6-读流程整体串联" class="headerlink" title="4.6 读流程整体串联"></a>4.6 读流程整体串联</h3><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-26a783d36cc511f5d57706cb2076d526_1440w.jpg" alt="img"></p><h2 id="5-阻塞与非阻塞模式"><a href="#5-阻塞与非阻塞模式" class="headerlink" title="5 阻塞与非阻塞模式"></a>5 阻塞与非阻塞模式</h2><p>在上述源码分析流程中，均是以阻塞模式为主线进行讲述，忽略非阻塞模式的有关处理逻辑.</p><p>此处阐明两个问题：</p><p>（1）非阻塞模式下，流程逻辑有何区别？</p><p>（2）何时会进入非阻塞模式？</p><h3 id="5-1-非阻塞模式逻辑区别"><a href="#5-1-非阻塞模式逻辑区别" class="headerlink" title="5.1 非阻塞模式逻辑区别"></a>5.1 非阻塞模式逻辑区别</h3><p>非阻塞模式下，读&#x2F;写 channel 方法通过一个 bool 型的响应参数，用以标识是否读取&#x2F;写入成功.</p><p>（1）所有需要使得当前 goroutine 被挂起的操作，在非阻塞模式下都会返回 false；</p><p>（2）所有是的当前 goroutine 会进入死锁的操作，在非阻塞模式下都会返回 false；</p><p>（3）所有能立即完成读取&#x2F;写入操作的条件下，非阻塞模式下会返回 true.</p><h3 id="5-2-何时进入非阻塞模式"><a href="#5-2-何时进入非阻塞模式" class="headerlink" title="5.2 何时进入非阻塞模式"></a>5.2 何时进入非阻塞模式</h3><p>默认情况下，读&#x2F;写 channel 都是阻塞模式，只有在 select 语句组成的多路复用分支中，与 channel 的交互会变成非阻塞模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">select</span>&#123;<br>  <span class="hljs-keyword">case</span> &lt;- ch:<br>  <span class="hljs-keyword">default</span>:<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-代码一览"><a href="#5-3-代码一览" class="headerlink" title="5.3 代码一览"></a>5.3 代码一览</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectnbsend</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span> chansend(c, elem, <span class="hljs-literal">false</span>, getcallerpc())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectnbrecv</span><span class="hljs-params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">return</span> chanrecv(c, elem, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 select 语句包裹的多路复用分支中，读和写 channel 操作会被汇编为 selectnbrecv 和 selectnbsend 方法，底层同样复用 chanrecv 和 chansend 方法，但此时由于第三个入参 block 被设置为 false，导致后续会走进非阻塞的处理分支.</p><h2 id="6-两种读-channel-的协议"><a href="#6-两种读-channel-的协议" class="headerlink" title="6 两种读 channel 的协议"></a>6 两种读 channel 的协议</h2><p>读取 channel 时，可以根据第二个 bool 型的返回值用以判断当前 channel 是否已处于关闭状态：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>got1 := &lt;- ch<br>got2,ok := &lt;- ch<br></code></pre></td></tr></table></figure><p>实现上述功能的原因是，两种格式下，读 channel 操作会被汇编成不同的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv1</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;<br>    chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>&#125;<br><br><br><span class="hljs-comment">//go:nosplit</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chanrecv2</span><span class="hljs-params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="hljs-type">bool</span>) &#123;<br>    _, received = chanrecv(c, elem, <span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-关闭"><a href="#7-关闭" class="headerlink" title="7 关闭"></a>7 关闭</h2><p><img src="/2025/03/31/Golang-channel%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/v2-46c42a11be76b1e553f5ee79acbcacab_1440w.jpg" alt="img"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closechan</span><span class="hljs-params">(c *hchan)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> c == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of nil channel&quot;</span>))<br>    &#125;<br><br>    lock(&amp;c.lock)<br>    <span class="hljs-keyword">if</span> c.closed != <span class="hljs-number">0</span> &#123;<br>        unlock(&amp;c.lock)<br>        <span class="hljs-built_in">panic</span>(plainError(<span class="hljs-string">&quot;close of closed channel&quot;</span>))<br>    &#125;<br><br>    c.closed = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">var</span> glist gList<br>    <span class="hljs-comment">// release all readers</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        sg := c.recvq.dequeue()<br>        <span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> sg.elem != <span class="hljs-literal">nil</span> &#123;<br>            typedmemclr(c.elemtype, sg.elem)<br>            sg.elem = <span class="hljs-literal">nil</span><br>        &#125;<br>        gp := sg.g<br>        gp.param = unsafe.Pointer(sg)<br>        sg.success = <span class="hljs-literal">false</span><br>        glist.push(gp)<br>    &#125;<br><br>    <span class="hljs-comment">// release all writers (they will panic)</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        sg := c.sendq.dequeue()<br>        <span class="hljs-keyword">if</span> sg == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        sg.elem = <span class="hljs-literal">nil</span><br>        gp := sg.g<br>        gp.param = unsafe.Pointer(sg)<br>        sg.success = <span class="hljs-literal">false</span><br>        glist.push(gp)<br>    &#125;<br>    unlock(&amp;c.lock)<br><br>    <span class="hljs-comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span><br>    <span class="hljs-keyword">for</span> !glist.empty() &#123;<br>        gp := glist.pop()<br>        gp.schedlink = <span class="hljs-number">0</span><br>        goready(gp, <span class="hljs-number">3</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（1）关闭未初始化过的 channel 会 panic；</p><p>（2）加锁；</p><p>（3）重复关闭 channel 会 panic；</p><p>（4）将阻塞读协程队列中的协程节点统一添加到 glist；</p><p>（5）将阻塞写协程队列中的协程节点统一添加到 glist；</p><p>（6）唤醒 glist 当中的所有协程.</p><h2 id="8-一道考题"><a href="#8-一道考题" class="headerlink" title="8 一道考题"></a>8 一道考题</h2><p>要求实现一个 map：</p><p>（1）面向高并发；</p><p>（2）只存在插入和查询操作 O(1)；</p><p>（3）查询时，若 key 存在，直接返回 val；若 key 不存在，阻塞直到 key val 对被放入后，获取 val 返回； 等待指定时长仍未放入，返回超时错误；</p><p>（4）写出真实代码，不能有死锁或者 panic 风险.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyConcurrentMap <span class="hljs-keyword">struct</span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span>Put(k,v <span class="hljs-type">int</span>)&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span>Get(k <span class="hljs-type">int</span>, maxWaitingDuration time.Duration)(<span class="hljs-type">int</span>,<span class="hljs-type">error</span>)&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="高并发阻塞式-Map-实现"><a href="#高并发阻塞式-Map-实现" class="headerlink" title="高并发阻塞式 Map 实现"></a>高并发阻塞式 Map 实现</h1><p>下面是一个满足所有要求的 <code>MyConcurrentMap</code> 实现，它使用 Go 的 <code>sync.RWMutex</code> 和 <code>sync.Cond</code> 来实现高效的并发控制和阻塞等待功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyConcurrentMap <span class="hljs-keyword">struct</span> &#123;<br>mu    sync.RWMutex<br>data  <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span><br>conds <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*sync.Cond<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewMyConcurrentMap</span><span class="hljs-params">()</span></span> *MyConcurrentMap &#123;<br><span class="hljs-keyword">return</span> &amp;MyConcurrentMap&#123;<br>data:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>),<br>conds: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*sync.Cond),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span> Put(k, v <span class="hljs-type">int</span>) &#123;<br>m.mu.Lock()<br><span class="hljs-keyword">defer</span> m.mu.Unlock()<br><br><span class="hljs-comment">// 放入数据</span><br>m.data[k] = v<br><br><span class="hljs-comment">// 如果有等待该key的goroutine，则通知它们</span><br><span class="hljs-keyword">if</span> cond, ok := m.conds[k]; ok &#123;<br>cond.Broadcast()<br><span class="hljs-comment">// 通知后删除cond，避免内存泄漏</span><br><span class="hljs-built_in">delete</span>(m.conds, k)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MyConcurrentMap)</span></span> Get(k <span class="hljs-type">int</span>, maxWaitingDuration time.Duration) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>m.mu.RLock()<br><span class="hljs-comment">// 先快速检查一次</span><br><span class="hljs-keyword">if</span> val, ok := m.data[k]; ok &#123;<br>m.mu.RUnlock()<br><span class="hljs-keyword">return</span> val, <span class="hljs-literal">nil</span><br>&#125;<br>m.mu.RUnlock()<br><br>m.mu.Lock()<br><span class="hljs-comment">// 再次检查，防止在解锁和加锁之间有Put操作</span><br><span class="hljs-keyword">if</span> val, ok := m.data[k]; ok &#123;<br>m.mu.Unlock()<br><span class="hljs-keyword">return</span> val, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 为当前key创建cond（如果不存在）</span><br>cond, ok := m.conds[k]<br><span class="hljs-keyword">if</span> !ok &#123;<br>cond = sync.NewCond(&amp;m.mu)<br>m.conds[k] = cond<br>&#125;<br><br><span class="hljs-comment">// 设置超时</span><br>timeout := time.After(maxWaitingDuration)<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-keyword">var</span> val <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br><span class="hljs-comment">// 启动goroutine等待条件</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// 再次检查，防止在等待前已经有Put操作</span><br><span class="hljs-keyword">if</span> v, exists := m.data[k]; exists &#123;<br>val = v<br><span class="hljs-keyword">return</span><br>&#125;<br><br>cond.Wait() <span class="hljs-comment">// 等待通知</span><br><br><span class="hljs-comment">// 被唤醒后检查是否有值</span><br><span class="hljs-keyword">if</span> v, exists := m.data[k]; exists &#123;<br>val = v<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br>m.mu.Unlock()<br><span class="hljs-keyword">return</span> val, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> &lt;-timeout:<br><span class="hljs-comment">// 超时，需要取消等待</span><br>cond.Broadcast() <span class="hljs-comment">// 唤醒所有等待此条件的goroutine</span><br>m.mu.Unlock()<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;timeout waiting for key&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ol><li><strong>并发控制</strong>：<ul><li>使用 <code>sync.RWMutex</code> 实现读写锁，允许多个读操作并发执行</li><li>写操作（Put）获取排他锁</li></ul></li><li><strong>阻塞等待</strong>：<ul><li>使用 <code>sync.Cond</code> 实现条件变量，当 key 不存在时让 Get 操作等待</li><li>每个 key 有自己的条件变量，避免不必要的唤醒</li></ul></li><li><strong>超时处理</strong>：<ul><li>使用 <code>select</code> 和 <code>time.After</code> 实现超时控制</li><li>超时后返回错误并取消等待</li></ul></li><li><strong>内存管理</strong>：<ul><li>在 Put 操作后清理条件变量，避免内存泄漏</li><li>使用 defer 确保锁被释放</li></ul></li><li><strong>双重检查</strong>：<ul><li>Get 操作中进行了两次检查，防止在锁转换间隙有 Put 操作</li></ul></li></ol><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">m := NewMyConcurrentMap()<br><br><span class="hljs-comment">// 并发Put</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    time.Sleep(<span class="hljs-number">100</span> * time.Millisecond)<br>    m.Put(<span class="hljs-number">1</span>, <span class="hljs-number">42</span>)<br>&#125;()<br><br><span class="hljs-comment">// 并发Get</span><br>val, err := m.Get(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>*time.Millisecond)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Value:&quot;</span>, val) <span class="hljs-comment">// 输出 Value: 42</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个实现满足所有要求，并且没有死锁或 panic 的风险。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用kubebuilder实现一个operator</title>
    <link href="/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/"/>
    <url>/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://qingwave.github.io/how-to-write-a-k8s-operator/">https://qingwave.github.io/how-to-write-a-k8s-operator/</a></p><p>Kubernetes 提供了众多的扩展功能，比如 CRD、CRI、CSI 等等，强大的扩展功能让 k8s 迅速占领市场。<a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/">Operator</a>模式可以实现 CRD 并管理自定义资源的生命周期，本文基于<a href="https://kubebuilder.io/">kubebuilder</a>快速实现一个 Operator，示例源码见<a href="https://github.com/qingwave/mygame">mygame</a>。</p><h2 id="Kubebuilder"><a href="#Kubebuilder" class="headerlink" title="Kubebuilder"></a>Kubebuilder</h2><p><code>kubebuilder</code>是一个官方提供快速实现 Operator 的工具包，可快速生成 k8s 的 CRD、Controller、Webhook，用户只需要实现业务逻辑。</p><blockquote><p>类似工具还有<a href="https://sdk.operatorframework.io/">operader-sdk</a>，目前正在与<code>Kubebuilder</code>融合</p></blockquote><p>kubebuilder 封装了<code>controller-runtime</code>与<code>controller-tools</code>，通过<code>controller-gen</code>来生产代码，简化了用户创建 Operator 的步骤。</p><p>一般创建 Operator 流程如下：</p><ol><li>创建工作目录，初始化项目</li><li>创建 API，填充字段</li><li>创建 Controller，编写核心协调逻辑(Reconcile)</li><li>创建 Webhook，实现接口，可选</li><li>验证测试</li><li>发布到集群中</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>我们准备创建一个 2048 的游戏，对外可以提供服务，也能方便地扩缩容。</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>首先你需要有 Kubernetes、Docker、Golang 相关环境。 Linux 下安装 kubebuilder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L -o kubebuilder https://go.kubebuilder.io/dl/latest/$(go <span class="hljs-built_in">env</span> GOOS)/$(go <span class="hljs-built_in">env</span> GOARCH)<br><span class="hljs-built_in">chmod</span> +x kubebuilder &amp;&amp; <span class="hljs-built_in">mv</span> kubebuilder /usr/local/bin/<br></code></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mkdir -<span class="hljs-selector-tag">p</span> ~/work/mygame &amp;&amp; cd $_<br>kubebuilder init <span class="hljs-attr">--domain</span> qingwave<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span> <span class="hljs-attr">--repo</span> qingwave<span class="hljs-selector-class">.github</span>.io/mygame<br></code></pre></td></tr></table></figure><h3 id="创建-API"><a href="#创建-API" class="headerlink" title="创建 API"></a>创建 API</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">kubebuilder create api <span class="hljs-attr">--group</span> myapp <span class="hljs-attr">--version</span> v1 <span class="hljs-attr">--kind</span> Game<br><br>Create Resource <span class="hljs-selector-attr">[y/n]</span><br><span class="hljs-attribute">y</span> #生成CR<br>Create Controller <span class="hljs-selector-attr">[y/n]</span><br><span class="hljs-attribute">y</span> #生成Controller<br></code></pre></td></tr></table></figure><p>目录结构如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">├── api<br>│   └── <span class="hljs-built_in">v1</span> <span class="hljs-comment"># CRD定义</span><br>├── <span class="hljs-keyword">bin</span><br><span class="hljs-keyword"></span>│   └── controller-gen<br>├── <span class="hljs-built_in">config</span><br>│   ├── crd <span class="hljs-comment"># crd配置</span><br>│   ├── default<br>│   ├── manager <span class="hljs-comment"># operator部署文件</span><br>│   ├── prometheus<br>│   ├── rbac<br>│   └── samples <span class="hljs-comment"># cr示例</span><br>├── controllers<br>│   ├── game_controller.go <span class="hljs-comment"># controller逻辑</span><br>│   └── suite_test.go<br>├── Dockerfile<br>├── go.mod<br>├── go.sum<br>├── hack<br>│   └── <span class="hljs-keyword">boilerplate.go.txt </span><span class="hljs-comment"># 头文件模板</span><br>├── main.go <span class="hljs-comment"># 项目主函数</span><br>├── Makefile<br>└── PROJECT <span class="hljs-comment">#项目元数据</span><br></code></pre></td></tr></table></figure><h3 id="编写-API"><a href="#编写-API" class="headerlink" title="编写 API"></a>编写 API</h3><p>在<code>mygame/api/v1/game_types.go</code>定义我们需要的字段</p><p><code>Spec</code>配置如下</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> <span class="hljs-type">GameSpec</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Number of desired pods. This is a pointer to distinguish between explicit</span><br><span class="hljs-comment">// zero and not specified. Defaults to 1.</span><br><span class="hljs-comment">// +optional</span><br><span class="hljs-comment">//+kubebuilder:default:=1</span><br><span class="hljs-comment">//+kubebuilder:validation:Minimum:=1</span><br><span class="hljs-type">Replicas</span> *<span class="hljs-built_in">int32</span> `json:<span class="hljs-string">&quot;replicas,omitempty&quot;</span> protobuf:<span class="hljs-string">&quot;varint,1,opt,name=replicas&quot;</span>`<br><br><span class="hljs-comment">// Docker image name</span><br><span class="hljs-comment">// +optional</span><br><span class="hljs-type">Image</span> <span class="hljs-built_in">string</span> `json:<span class="hljs-string">&quot;image,omitempty&quot;</span>`<br><br><span class="hljs-comment">// Ingress Host name</span><br><span class="hljs-type">Host</span> <span class="hljs-built_in">string</span> `json:<span class="hljs-string">&quot;host,omitempty&quot;</span>`<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>kubebuilder:default</code>可以设置默认值</p></blockquote><p><code>Status</code>定义如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const (<br>Running  = &quot;Running&quot;<br>Pending  = &quot;Pending&quot;<br>NotReady = &quot;NotReady&quot;<br>Failed   = &quot;Failed&quot;<br>)<br><br><span class="hljs-keyword">type</span> GameStatus struct &#123;<br>// Phase <span class="hljs-keyword">is</span> the phase <span class="hljs-keyword">of</span> guestbook<br>Phase string `<span class="hljs-type">json</span>:&quot;phase,omitempty&quot;`<br><br>// replicas <span class="hljs-keyword">is</span> the number <span class="hljs-keyword">of</span> Pods created <span class="hljs-keyword">by</span> the StatefulSet controller.<br>Replicas int32 `<span class="hljs-type">json</span>:&quot;replicas&quot;`<br><br>// readyReplicas <span class="hljs-keyword">is</span> the number <span class="hljs-keyword">of</span> Pods created <span class="hljs-keyword">by</span> the StatefulSet controller that have a Ready Condition.<br>ReadyReplicas int32 `<span class="hljs-type">json</span>:&quot;readyReplicas&quot;`<br><br>// LabelSelector <span class="hljs-keyword">is</span> label selectors <span class="hljs-keyword">for</span> query <span class="hljs-keyword">over</span> pods that should match the <span class="hljs-keyword">replica</span> count used <span class="hljs-keyword">by</span> HPA.<br>LabelSelector string `<span class="hljs-type">json</span>:&quot;labelSelector,omitempty&quot;`<br>&#125;<br></code></pre></td></tr></table></figure><p>另外需要添加<code>scale</code>接口</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>+kubebuilder<span class="hljs-function">:subresource</span><span class="hljs-function">:scale</span><span class="hljs-function">:specpath</span>=<span class="hljs-string">.spec.replicas</span>,statuspath=<span class="hljs-string">.status.replicas</span>,selectorpath=<span class="hljs-string">.status.labelSelector</span><br></code></pre></td></tr></table></figure><p>添加<code>kubectl</code>展示参数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;Phase&quot;,<span class="hljs-keyword">type</span>=&quot;string&quot;,JSONPath=&quot;.status.phase&quot;,description=&quot;The phase of game.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;Host&quot;,<span class="hljs-keyword">type</span>=&quot;string&quot;,JSONPath=&quot;.spec.host&quot;,description=&quot;The Host Address.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;DESIRED&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.spec.replicas&quot;,description=&quot;The desired number of pods.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;CURRENT&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.status.replicas&quot;,description=&quot;The number of currently all pods.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;READY&quot;,<span class="hljs-keyword">type</span>=&quot;integer&quot;,JSONPath=&quot;.status.readyReplicas&quot;,description=&quot;The number of pods ready.&quot;<br>//+kubebuilder:printcolumn:<span class="hljs-type">name</span>=&quot;AGE&quot;,<span class="hljs-keyword">type</span>=&quot;date&quot;,JSONPath=&quot;.metadata.creationTimestamp&quot;,description=&quot;CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.&quot;<br></code></pre></td></tr></table></figure><h3 id="编写-Controller-逻辑"><a href="#编写-Controller-逻辑" class="headerlink" title="编写 Controller 逻辑"></a>编写 Controller 逻辑</h3><p>Controller 的核心逻辑在<code>Reconcile</code>中，我们只需要填充自己的业务逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GameReconciler)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="hljs-type">error</span>) &#123;<br>logger := log.FromContext(ctx)<br>logger.Info(<span class="hljs-string">&quot;revice reconcile event&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><br><span class="hljs-comment">// 获取game对象</span><br>game := &amp;myappv1.Game&#123;&#125;<br><span class="hljs-keyword">if</span> err := r.Get(ctx, req.NamespacedName, game); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)<br>&#125;<br><br>  <span class="hljs-comment">// 如果处在删除中直接跳过</span><br><span class="hljs-keyword">if</span> game.DeletionTimestamp != <span class="hljs-literal">nil</span> &#123;<br>logger.Info(<span class="hljs-string">&quot;game in deleting&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br>  <span class="hljs-comment">// 同步资源，如果资源不存在创建deployment、ingress、service，并更新status</span><br><span class="hljs-keyword">if</span> err := r.syncGame(ctx, game); err != <span class="hljs-literal">nil</span> &#123;<br>logger.Error(err, <span class="hljs-string">&quot;failed to sync game&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, req.String())<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>添加 rbac 配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>apps,resources<span class="hljs-operator">=</span>deployments,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>apps,resources<span class="hljs-operator">=</span>deployments<span class="hljs-operator">/</span>status,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;<span class="hljs-keyword">update</span>;patch<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>core,resources<span class="hljs-operator">=</span>services,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-operator">+</span>kubebuilder:rbac:<span class="hljs-keyword">groups</span><span class="hljs-operator">=</span>networking,resources<span class="hljs-operator">=</span>ingresses,verbs<span class="hljs-operator">=</span><span class="hljs-keyword">get</span>;list;watch;<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>;patch;<span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><p>具体<code>syncGame</code>逻辑如下</p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">func (r *GameReconciler) syncGame(ctx context.Context, obj *myappv1.Game) error &#123;<br><span class="hljs-attribute">logger</span> := log<span class="hljs-variable">.FromContext</span>(ctx)<br><br>game := obj<span class="hljs-variable">.DeepCopy</span>()<br>name := types<span class="hljs-variable">.NamespacedName</span>&#123;<br>Namespace: game<span class="hljs-variable">.Namespace</span>,<br>Name:      game<span class="hljs-variable">.Name</span>,<br>&#125;<br><br>  // 构造owner<br>owner := []metav1<span class="hljs-variable">.OwnerReference</span>&#123;<br>&#123;<br>APIVersion:         game<span class="hljs-variable">.APIVersion</span>,<br>Kind:               game<span class="hljs-variable">.Kind</span>,<br>Name:               game<span class="hljs-variable">.Name</span>,<br>Controller:         pointer<span class="hljs-variable">.BoolPtr</span>(true),<br>BlockOwnerDeletion: pointer<span class="hljs-variable">.BoolPtr</span>(true),<br>UID:                game<span class="hljs-variable">.UID</span>,<br>&#125;,<br>&#125;<br><br>labels := game<span class="hljs-variable">.Labels</span><br>labels[gameLabelName] = game<span class="hljs-variable">.Name</span><br>meta := metav1<span class="hljs-variable">.ObjectMeta</span>&#123;<br>Name:            game<span class="hljs-variable">.Name</span>,<br>Namespace:       game<span class="hljs-variable">.Namespace</span>,<br>Labels:          labels,<br>OwnerReferences: owner,<br>&#125;<br><br>  // 获取对应deployment, 如不存在则创建<br>deploy := &amp;appsv1<span class="hljs-variable">.Deployment</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">if !errors.IsNotFound(err) &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">deploy = &amp;appsv1.Deployment&#123;</span><br><span class="hljs-attribute">ObjectMeta</span>: meta,<br>Spec:       getDeploymentSpec(game, labels),<br>&#125;<br>if err := r<span class="hljs-variable">.Create</span>(ctx, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">logger.Info(&quot;create deployment success&quot;, &quot;name&quot;, name.String())</span><br><span class="hljs-attribute">&#125; else &#123;</span><br><span class="hljs-attribute">    // 如果存在对比和game生成的deployment是否一致，不一致则更新</span><br><span class="hljs-attribute">want</span> := getDeploymentSpec(game, labels)<br>get := getSpecFromDeployment(deploy)<br>if !reflect<span class="hljs-variable">.DeepEqual</span>(want, get) &#123;<br>deploy = &amp;appsv1<span class="hljs-variable">.Deployment</span>&#123;<br>ObjectMeta: meta,<br>Spec:       want,<br>&#125;<br>if err := r<span class="hljs-variable">.Update</span>(ctx, deploy); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">return err</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">logger.Info(&quot;update deployment success&quot;, &quot;name&quot;, name.String())</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  //service创建</span><br><span class="hljs-attribute">svc</span> := &amp;corev1<span class="hljs-variable">.Service</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, svc); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">  ...</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">  // ingress创建</span><br><span class="hljs-attribute">ing</span> := &amp;networkingv1<span class="hljs-variable">.Ingress</span>&#123;&#125;<br>if err := r<span class="hljs-variable">.Get</span>(ctx, name, ing); <span class="hljs-attribute">err != nil &#123;</span><br><span class="hljs-attribute">...</span><br><span class="hljs-attribute">&#125;</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">newStatus</span> := myappv1<span class="hljs-variable">.GameStatus</span>&#123;<br>Replicas:      *game<span class="hljs-variable">.Spec</span><span class="hljs-variable">.Replicas</span>,<br>ReadyReplicas: deploy<span class="hljs-variable">.Status</span><span class="hljs-variable">.ReadyReplicas</span>,<br>&#125;<br><br>if newStatus<span class="hljs-variable">.Replicas</span> == newStatus<span class="hljs-variable">.ReadyReplicas</span> &#123;<br>newStatus<span class="hljs-variable">.Phase</span> = myappv1<span class="hljs-variable">.Running</span><br>&#125; else &#123;<br>newStatus<span class="hljs-variable">.Phase</span> = myappv1<span class="hljs-variable">.NotReady</span><br>&#125;<br><br>  // 更新状态<br>if !reflect<span class="hljs-variable">.DeepEqual</span>(game<span class="hljs-variable">.Status</span>, newStatus) &#123;<br>game<span class="hljs-variable">.Status</span> = newStatus<br>logger<span class="hljs-variable">.Info</span>(&quot;update game status&quot;, &quot;name&quot;, name<span class="hljs-variable">.String</span>())<br>return r<span class="hljs-variable">.Client</span><span class="hljs-variable">.Status</span>()<span class="hljs-variable">.Update</span>(ctx, game)<br>&#125;<br><br>return nil<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下生成的 controller 只监听自定义资源，在示例中我们也需要监听<code>game</code>的子资源，如监听<code>deployment</code>是否符合预期</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SetupWithManager sets up the controller with the Manager.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *GameReconciler)</span></span> SetupWithManager(mgr ctrl.Manager) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 创建controller</span><br>c, err := controller.New(<span class="hljs-string">&quot;game-controller&quot;</span>, mgr, controller.Options&#123;<br>Reconciler:              r,<br>MaxConcurrentReconciles: <span class="hljs-number">3</span>, <span class="hljs-comment">//controller运行的worker数</span><br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">//监听自定义资源</span><br><span class="hljs-keyword">if</span> err := c.Watch(&amp;source.Kind&#123;Type: &amp;myappv1.Game&#123;&#125;&#125;, &amp;handler.EnqueueRequestForObject&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">//监听deployment,将owner信息即game namespace/name添加到队列</span><br><span class="hljs-keyword">if</span> err := c.Watch(&amp;source.Kind&#123;Type: &amp;appsv1.Deployment&#123;&#125;&#125;, &amp;handler.EnqueueRequestForOwner&#123;<br>OwnerType:    &amp;myappv1.Game&#123;&#125;,<br>IsController: <span class="hljs-literal">true</span>,<br>&#125;); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="部署验证"><a href="#部署验证" class="headerlink" title="部署验证"></a>部署验证</h3><p>安装 CRD</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">make <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>本地运行 operator</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> <span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><p>修改 sample 文件<code>config/samples/myapp_v1_game.yaml</code></p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">apiVersion:</span> myapp.qingwave.github.io/v1<br><span class="hljs-symbol">kind:</span> Game<br><span class="hljs-symbol">metadata:</span><br><span class="hljs-symbol">  name:</span> game-sample<br><span class="hljs-symbol">spec:</span><br><span class="hljs-symbol">  replicas:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">  image:</span> alexwhen/docker<span class="hljs-number">-2048</span><br><span class="hljs-symbol">  host:</span> mygame.io<br></code></pre></td></tr></table></figure><p>部署<code>game-sample</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">kubectl apply -f config/samples/myapp_v1_game.yaml<br></code></pre></td></tr></table></figure><p>查看<code>game</code>自定义资源状态</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 查看game</span><br><span class="hljs-attribute">kubectl</span> get game<br><span class="hljs-attribute">NAME</span>          PHASE     HOST        DESIRED   CURRENT   READY   AGE<br><span class="hljs-attribute">game</span>-sample   Running   mygame.io   <span class="hljs-number">1</span>         <span class="hljs-number">1</span>         <span class="hljs-number">1</span>       <span class="hljs-number">6</span>m<br><br><span class="hljs-comment"># 查看deploy</span><br><span class="hljs-attribute">kubectl</span> get deploy game-sample<br><span class="hljs-attribute">NAME</span>          READY   UP-TO-DATE   AVAILABLE   AGE<br><span class="hljs-attribute">game</span>-sample   <span class="hljs-number">1</span>/<span class="hljs-number">1</span>     <span class="hljs-number">1</span>            <span class="hljs-number">1</span>           <span class="hljs-number">6</span>m<br><br><span class="hljs-comment"># 查看ingress</span><br><span class="hljs-attribute">kubectl</span> get ing game-sample<br><span class="hljs-attribute">NAME</span>          CLASS    HOSTS       ADDRESS        PORTS   AGE<br><span class="hljs-attribute">game</span>-sample   &lt;none&gt;   mygame.io   <span class="hljs-number">192.168.49.2</span>   <span class="hljs-number">80</span>      <span class="hljs-number">7</span>m<br></code></pre></td></tr></table></figure><p>验证应用，在<code>/etc/hosts</code>中添加<code>&lt;Ingress ADDRESS Ip&gt; mygame.io</code>，访问浏览器如下图所示<img src="/2025/03/30/%E4%BD%BF%E7%94%A8kubebuilder%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAoperator/crd_mygame.png" alt="2048"></p><p>验证扩容</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kubectl</span> scale games.myapp.qingwave.github.io game-sample --replicas <span class="hljs-number">2</span><br><span class="hljs-attribute">game</span>.myapp.qingwave.github.io/game-sample scaled<br><br><span class="hljs-comment"># 扩容后</span><br><span class="hljs-attribute">kubectl</span> get games.myapp.qingwave.github.io<br><span class="hljs-attribute">NAME</span>          PHASE     HOST        DESIRED   CURRENT   READY   AGE<br><span class="hljs-attribute">game</span>-sample   Running   mygame.io   <span class="hljs-number">2</span>         <span class="hljs-number">2</span>         <span class="hljs-number">2</span>       <span class="hljs-number">7</span>m<br></code></pre></td></tr></table></figure><p>如需部署<code>Operator</code>到集群中，可参考官方文档，制作镜像并上传，运行<code>make deploy</code></p><h3 id="Webhook"><a href="#Webhook" class="headerlink" title="Webhook"></a>Webhook</h3><p>通常我们需要与 CR 自定义资源设置部分字段的默认值，或者验证字段是否合法，这就需要自己实现<code>Webhook</code>，<code>Kubebuilder</code>也提供了<code>Webhook</code>的功能。</p><p>通过设置<code>--defaulting</code>可创建<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">mutatingadmissionwebhook</a>类型准入控制器，用来修改传入资源；参数<code>--programmatic-validation</code>可创建<a href="https://kubernetes.io/zh/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">validatingadmissionwebhook</a>，用来验证传入资源</p><blockquote><p>在资源创建、修改时<code>apiserver</code>会通过 http 调用<code>webhook</code>提供的接口，所以会带来额外开销，简单的验证工作可通过<code>//+kubebuilder:validation</code>注解，直接通过<code>openapi</code>验证，性能更好</p></blockquote><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">kubebuilder create webhook</span> <span class="hljs-literal">--</span><span class="hljs-comment">group myapp</span> <span class="hljs-literal">--</span><span class="hljs-comment">version v1</span> <span class="hljs-literal">--</span><span class="hljs-comment">kind Game</span> <span class="hljs-literal">--</span><span class="hljs-comment">defaulting</span> <span class="hljs-literal">--</span><span class="hljs-comment">programmatic</span><span class="hljs-literal">-</span><span class="hljs-comment">validation</span><br></code></pre></td></tr></table></figure><p>生成文件在<code>api/v1/game_webhook.go</code></p><p><code>Default</code>接口可实现修改资源，根据 kubebuilder 注释,当<code>game</code>资源<code>create</code>与<code>update</code>时，调用这个接口</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//+kubebuilder:webhook:<span class="hljs-type">path</span>=/mutate-myapp-qingwave-github-io-v1-game,mutating=<span class="hljs-keyword">true</span>,failurePolicy=fail,sideEffects=<span class="hljs-keyword">None</span>,<span class="hljs-keyword">groups</span>=myapp.qingwave.github.io,resources=games,verbs=<span class="hljs-keyword">create</span>;<span class="hljs-keyword">update</span>,versions=v1,<span class="hljs-type">name</span>=mgame.kb.io,admissionReviewVersions=&#123;v1,v1beta1&#125;<br>const (<br>defaultImage = `alexwhen/docker<span class="hljs-number">-2048</span>`<br>)<br><br>// <span class="hljs-keyword">Default</span> implements webhook.Defaulter so a webhook will be registered <span class="hljs-keyword">for</span> the <span class="hljs-keyword">type</span><br>func (r *Game) <span class="hljs-keyword">Default</span>() &#123;<br>gamelog.<span class="hljs-keyword">Info</span>(&quot;default&quot;, &quot;name&quot;, r.Name)<br><br>// 设置默认镜像<br><span class="hljs-keyword">if</span> r.Spec.Image == &quot;&quot; &#123;<br>r.Spec.Image = defaultImage<br>&#125;<br><br>// 设置默认Host<br><span class="hljs-keyword">if</span> r.Spec.Host == &quot;&quot; &#123;<br>r.Spec.Host = fmt.Sprintf(&quot;%s.%s.mygame.io&quot;, r.Name, r.Namespace)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的通过<code>ValidateCreate</code>、<code>ValidateUpdate</code>可实现<code>validating webhook</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Game)</span></span> ValidateCreate() <span class="hljs-type">error</span> &#123;<br>gamelog.Info(<span class="hljs-string">&quot;validate create&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, r.Name)<br><br><span class="hljs-comment">// Host不能包括通配符</span><br><span class="hljs-keyword">if</span> strings.Contains(r.Spec.Host, <span class="hljs-string">&quot;*&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;host should not contain *&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>本地验证 webhook 需要配置证书，在集群中测试更方便点，可参考官方文档。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经实现了一个功能完全的<code>game-operator</code>，可以管理<code>game</code>资源的生命周期，创建&#x2F;更新 game 时会自动创建<code>deployment、service、ingress</code>等资源，当<code>deployment</code>被误删或者误修改时也可以自动回复到期望状态，也实现了<code>scale</code>接口。</p><p>通过<code>kubebuiler</code>大大简化了开发<code>operator</code>的成本，我们只需要关心业务逻辑即可，不需要再手动去创建<code>client/controller</code>等，但同时<code>kubebuilder</code>生成的代码中屏蔽了很多细节，比如<code>controller</code>的最大 worker 数、同步时间、队列类型等参数设置，只有了解<code>operator</code>的原理才更好应用于生产。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="https://book.kubebuilder.io/">https://book.kubebuilder.io/</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s证书</title>
    <link href="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/"/>
    <url>/2025/03/30/k8s%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.zhaohuabing.com/post/2020-05-19-k8s-certificate/">https://www.zhaohuabing.com/post/2020-05-19-k8s-certificate/</a></p><p>接触 Kubernetes 以来，我经常看到 Kubernetes 在不同的地方使用了证书（Certificate），在 Kubernetes 安装和组件启动参数中也需要配置大量证书相关的参数。但是 Kubernetes 的文档在解释这些证书的工作机制方面做得并不是太好。经过大量的相关阅读和分析工作后，我基本弄清楚了 Kubernetes 中证书的使用方式。在本文中，我将试图以一种比官方文档更容易理解的方式来说明 Kubernetes 中证书相关的工作机制，如果你也存在这方面的疑惑，希望这篇文章对你有所帮助。</p><h1 id="Kubernetes-组件的认证方式"><a href="#Kubernetes-组件的认证方式" class="headerlink" title="Kubernetes 组件的认证方式"></a>Kubernetes 组件的认证方式</h1><p>首先让我们来看一下 Kubernetes 中的组件：在 Kubernetes 中包含多个以独立进程形式运行的组件，这些组件之间通过 HTTP&#x2F;GRPC 相互通信，以协同完成集群中应用的部署和管理工作。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/components-of-kubernetes.png" alt="img">kubernetes 组件，图片来源<a href="https://kubernetes.io/zh/docs/concepts/overview/components/">kubernetes.io</a></p><p>从图中可以看到，Kubernetes 控制平面中包含了 etctd，kube-api-server，kube-scheduler，kube-controller-manager 等组件，这些组件会相互进行远程调用，例如 kube-api-server 会调用 etcd 接口存储数据，kube-controller-manager 会调用 kube-api-server 接口查询集群中的对象状态；同时，kube-api-server 也会和在工作节点上的 kubelet 和 kube-proxy 进行通信，以在工作节点上部署和管理应用。</p><p>以上这些组件之间的相互调用都是通过网络进行的。在进行网络通信时，通信双方需要验证对方的身份，以避免恶意第三方伪造身份窃取信息或者对系统进行攻击。为了相互验证对方的身份，通信双方中的任何一方都需要做下面两件事情：</p><ul><li>向对方提供标明自己身份的一个证书</li><li>验证对方提供的身份证书是否合法，是否伪造的？</li></ul><p>在 Kubernetes 中使用了数字证书来提供身份证明，我们可以把数字证书简单理解为我们在日常生活中使用的“身份证”，上面标注了证书拥有者的身份信息，例如名称，所属组织机构等。为了保证证书的权威性，会采用一个通信双方都信任的 CA（证书机构，Certificate Authority）来颁发证书。这就类似于现实生活中颁发“身份证”的政府机构。数字证书中最重要的内容实际上是证书拥有者的公钥，该公钥代表了用户的身份。本文假设读者已经了解数字证书和 CA 的基本原理，如果你对此不太清楚，或者希望重新温习一下相关知识，可以先阅读一下这篇文章<a href="https://zhaohuabing.com/post/2020-03-19-pki">《数字证书原理》</a>。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/ca.png" alt="img"></p><p>CA （证书机构），图片来源<a href="https://www.trustauth.cn/ca-question/1791.html">www.trustauth.cn</a></p><p>在 Kubernetes 的组件之间进行通信时，数字证书的验证是在协议层面通过 TLS 完成的，除了需要在建立通信时提供相关的证书和密钥外，在应用层面并不需要进行特殊处理。采用 TLS 进行验证有两种方式：</p><ul><li>服务器单向认证：只需要服务器端提供证书，客户端通过服务器端证书验证服务的身份，但服务器并不验证客户端的身份。这种情况一般适用于对 Internet 开放的服务，例如搜索引擎网站，任何客户端都可以连接到服务器上进行访问，但客户端需要验证服务器的身份，以避免连接到伪造的恶意服务器。</li><li>双向 TLS 认证：除了客户端需要验证服务器的证书，服务器也要通过客户端证书验证客户端的身份。这种情况下服务器提供的是敏感信息，只允许特定身份的客户端访问。</li></ul><p>在 Kubernetes 中，各个组件提供的接口中包含了集群的内部信息。如果这些接口被非法访问，将影响集群的安全，因此组件之间的通信需要采用双向 TLS 认证。即客户端和服务器端都需要验证对方的身份信息。在两个组件进行双向认证时，会涉及到下面这些证书相关的文件：</p><ul><li>服务器端证书：服务器用于证明自身身份的数字证书，里面主要包含了服务器端的公钥以及服务器的身份信息。</li><li>服务器端私钥：服务器端证书中包含的公钥所对应的私钥。公钥和私钥是成对使用的，在进行 TLS 验证时，服务器使用该私钥来向客户端证明自己是服务器端证书的拥有者。</li><li>客户端证书：客户端用于证明自身身份的数字证书，里面主要包含了客户端的公钥以及客户端的身份信息。</li><li>客户端私钥：客户端证书中包含的公钥所对应的私钥，同理，客户端使用该私钥来向服务器端证明自己是客户端证书的拥有者。</li><li>服务器端 CA 根证书：签发服务器端证书的 CA 根证书，客户端使用该 CA 根证书来验证服务器端证书的合法性。</li><li>客户端端 CA 根证书：签发客户端证书的 CA 根证书，服务器端使用该 CA 根证书来验证客户端证书的合法性。</li></ul><p>下面这张来自<a href="https://medium.com/sitewards/the-magic-of-tls-x509-and-mutual-authentication-explained-b2162dec4401">The magic of TLS, X509 and mutual authentication explained</a> 文章中的图形象地解释了双向 TLS 认证的原理。如果你需要了解更多关于 TLS 认证的原理，可以阅读一下 medium 上的原文。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/mutual-tls.png" alt="img"></p><p>图片来源<a href="https://medium.com/sitewards/the-magic-of-tls-x509-and-mutual-authentication-explained-b2162dec4401">The magic of TLS, X509 and mutual authentication explained</a></p><h1 id="Kubernetes-中使用到的CA和证书"><a href="#Kubernetes-中使用到的CA和证书" class="headerlink" title="Kubernetes 中使用到的CA和证书"></a>Kubernetes 中使用到的CA和证书</h1><p>Kubernetes 中使用了大量的证书，本文不会试图覆盖到所有可能使用到的证书，但会讨论到主要的证书。理解了这些证书的使用方法和原理后，也能很快理解其他可能遇到的证书文件。下图标识出了在 kubernetes 中主要使用到的证书和其使用的位置：</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/kubernetes-certificate-usage.png" alt="img"></p><p>Kubernetes 中使用到的主要证书</p><p>上图中使用序号对证书进行了标注。图中的箭头表明了组件的调用方向，箭头所指方向为服务提供方，另一头为服务调用方。为了实现 TLS 双向认证，服务提供方需要使用一个服务器证书，服务调用方则需要提供一个客户端证书，并且双方都需要使用一个 CA 证书来验证对方提供的证书。为了简明起见，上图中只标注了证书使用方提供的证书，并没有标注证书的验证方验证使用的 CA 证书。图中标注的这些证书的作用分别如下：</p><ol><li>etcd 集群中各个节点之间相互通信使用的证书。由于一个 etctd 节点既为其他节点提供服务，又需要作为客户端访问其他节点，因此该证书同时用作服务器证书和客户端证书。</li><li>etcd 集群向外提供服务使用的证书。该证书是服务器证书。</li><li>kube-apiserver 作为客户端访问 etcd 使用的证书。该证书是客户端证书。</li><li>kube-apiserver 对外提供服务使用的证书。该证书是服务器证书。</li><li>kube-controller-manager 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kube-scheduler 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kube-proxy 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kubelet 作为客户端访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>管理员用户通过 kubectl 访问 kube-apiserver 使用的证书,该证书是客户端证书。</li><li>kubelet 对外提供服务使用的证书。该证书是服务器证书。</li><li>kube-apiserver 作为客户端访问 kubelet 采用的证书。该证书是客户端证书。</li><li>kube-controller-manager 用于生成和验证 service-account token 的证书。该证书并不会像其他证书一样用于身份认证，而是将证书中的公钥&#x2F;私钥对用于 service account token 的生成和验证。kube-controller-manager 会用该证书的私钥来生成 service account token，然后以 secret 的方式加载到 pod 中。pod 中的应用可以使用该 token 来访问 kube-apiserver， kube-apiserver 会使用该证书中的公钥来验证请求中的 token。我们将在文中稍后部分详细介绍该证书的使用方法。</li></ol><p>通过这张图，对证书机制比较了解的读者可能已经看出，我们其实可以使用多个不同的 CA 来颁发这些证书。只要在通信的组件中正确配置用于验证对方证书的 CA 根证书，就可以使用不同的 CA 来颁发不同用途的证书。但我们一般建议采用统一的 CA 来颁发 kubernetes 集群中的所有证书，这是因为采用一个集群根 CA 的方式比采用多个 CA 的方式更容易管理，可以避免多个CA 导致的复杂的证书配置、更新等问题，减少由于证书配置错误导致的集群故障。</p><h1 id="Kubernetes-中的证书配置"><a href="#Kubernetes-中的证书配置" class="headerlink" title="Kubernetes 中的证书配置"></a>Kubernetes 中的证书配置</h1><p>前面我们介绍了 Kubernetes 集群中主要使用到的证书。下面我们分别看一下如何将这些证书及其对应的私钥和 CA 根证书需要配置到 Kubernetes 中各个组件中，以供各个组件进行使用。这里假设使用一个集群根 CA 来颁发所有相关证书，因此涉及到 CA 的配置对应的证书文件名都是相同的。</p><h2 id="etcd-证书配置"><a href="#etcd-证书配置" class="headerlink" title="etcd 证书配置"></a>etcd 证书配置</h2><p>需要在 etcd 的启动命令行中配置以下证书相关参数：</p><ul><li>etcd 对外提供服务的服务器证书及私钥。</li><li>etcd 节点之间相互进行认证的 peer 证书、私钥以及验证 peer 的 CA。</li><li>etcd 验证访问其服务的客户端的 CA。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/etcd \\<br>  --cert-file=/etc/etcd/kube-etcd.pem \\                   <span class="hljs-comment"># 对外提供服务的服务器证书</span><br>  --key-file=/etc/etcd/kube-etcd-key.pem \\                <span class="hljs-comment"># 服务器证书对应的私钥</span><br>  --peer-cert-file=/etc/etcd/kube-etcd-peer.pem \\         <span class="hljs-comment"># peer 证书，用于 etcd 节点之间的相互访问</span><br>  --peer-key-file=/etc/etcd/kube-etcd-peer-key.pem \\      <span class="hljs-comment"># peer 证书对应的私钥</span><br>  --trusted-ca-file=/etc/etcd/cluster-root-ca.pem \\       <span class="hljs-comment"># 用于验证访问 etcd 服务器的客户端证书的 CA 根证书</span><br>  --peer-trusted-ca-file=/etc/etcd/cluster-root-ca.pem\\   <span class="hljs-comment"># 用于验证 peer 证书的 CA 根证书</span><br>  ...<br></code></pre></td></tr></table></figure><h2 id="kube-apiserver-证书配置"><a href="#kube-apiserver-证书配置" class="headerlink" title="kube-apiserver 证书配置"></a>kube-apiserver 证书配置</h2><p>需要在 kube-apiserver 中配置以下证书相关参数：</p><ul><li>kube-apiserver 对外提供服务的服务器证书及私钥。</li><li>kube-apiserver 访问 etcd 所需的客户端证书及私钥。</li><li>kube-apiserver 访问 kubelet 所需的客户端证书及私钥。</li><li>验证访问其服务的客户端的 CA。</li><li>验证 etcd 服务器证书的 CA 根证书。</li><li>验证 service account token 的公钥。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-apiserver \\ <br>  --tls-cert-file=/var/lib/kubernetes/kube-apiserver.pem \\                             <span class="hljs-comment"># 用于对外提供服务的服务器证书</span><br>  --tls-private-key-file=/var/lib/kubernetes/kube-apiserver-key.pem \\                  <span class="hljs-comment"># 服务器证书对应的私钥</span><br>  --etcd-certfile=/var/lib/kubernetes/kube-apiserver-etcd-client.pem \\                 <span class="hljs-comment"># 用于访问 etcd 的客户端证书</span><br>  --etcd-keyfile=/var/lib/kubernetes/kube-apiserver-etcd-client-key.pem \\              <span class="hljs-comment"># 用于访问 etcd 的客户端证书的私钥</span><br>  --kubelet-client-certificate=/var/lib/kubernetes/kube-apiserver-kubelet-client.pem \\ <span class="hljs-comment"># 用于访问 kubelet 的客户端证书</span><br>  --kubelet-client-key=/var/lib/kubernetes/kube-apiserver-kubelet-client-key.pem \\     <span class="hljs-comment"># 用于访问 kubelet 的客户端证书的私钥</span><br>  --client-ca-file=/var/lib/kubernetes/cluster-root-ca.pem \\                           <span class="hljs-comment"># 用于验证访问 kube-apiserver 的客户端的证书的 CA 根证书</span><br>  --etcd-cafile=/var/lib/kubernetes/cluster-root-ca.pem \\                              <span class="hljs-comment"># 用于验证 etcd 服务器证书的 CA 根证书  </span><br>  --kubelet-certificate-authority=/var/lib/kubernetes/cluster-root-ca.pem \\            <span class="hljs-comment"># 用于验证 kubelet 服务器证书的 CA 根证书</span><br>  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\                 <span class="hljs-comment"># 用于验证 service account token 的公钥</span><br>  ...<br></code></pre></td></tr></table></figure><h2 id="采用-kubeconfig-访问-kube-apiserver"><a href="#采用-kubeconfig-访问-kube-apiserver" class="headerlink" title="采用 kubeconfig 访问 kube-apiserver"></a>采用 kubeconfig 访问 kube-apiserver</h2><p>Kubernetes 中的各个组件，包括kube-controller-mananger、kube-scheduler、kube-proxy、kubelet等，采用一个kubeconfig 文件中配置的信息来访问 kube-apiserver。该文件中包含了 kube-apiserver 的地址，验证 kube-apiserver 服务器证书的 CA 证书，自己的客户端证书和私钥等访问信息。</p><p>在一个使用 minikube 安装的集群中，生成的 kubeconfig 配置文件如下所示，这四个文件分别为 admin 用户， kube-controller-mananger、kubelet 和 kube-scheduler 的kubeconfig配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /etc/kubernetes/<br>admin.conf  controller-manager.conf  kubelet.conf  scheduler.conf<br></code></pre></td></tr></table></figure><p>我们打开 controller-manager.conf 来看一下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">clusters:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">cluster:</span> <br>    <span class="hljs-comment"># 用于验证 kube-apiserver 服务器证书的 CA 根证书 </span><br>    <span class="hljs-attr">certificate-authority-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lCQVRBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwdGFXNXAKYTNWaVpVTkJNQjRYRFRJd01ETXdOekF3TXpjeE1Wb1hEVE13TURNd05qQXdNemN4TVZvd0ZURVRNQkVHQTFVRQpBeE1LYldsdWFXdDFZbVZEUVRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTTczCkdIMWxqNkxEUm1FLy9hQ2cvNUlmampKYy8zOGcyMVpITXJDMkx5RGVqZWhrdWUwZFB1WTJ0L2JjTjJYM1dGNEsKaWNzNmhhWnBDbFVxL3pteVRITWhhZnlmVVF5MDFJZmhDV2I5NXI4akpHZ2NyU3U3UUtXM3ZOd1Z1TmhJNmd6SApSWW45Ry82VHJKTjdOMWRjejNmMlU1OFRjUHVCQzZOUzVTc1JmemFSczVDZnd0UTNaa2czQUFVYTlQSDZFVmtDCkIvRGR1bXBialZGakMwSllOWlFVNTlGNUxDeHJ0bEYvOUJsSVhnZGw0ZlNCNzQ0ZW1UelcySEZQek9lTklYYnUKYTJPa0FFTDdJc3hSRTFBaEFKZ1h6cFNmdi9paDBuMEJpQ1VaV1hLZjg2UjZJL2xlK2docG51c21kTXUwbkNEUApHMm9laXhRTit5NzFQU2tGcGdzQ0F3RUFBYU5DTUVBd0RnWURWUjBQQVFIL0JBUURBZ0trTUIwR0ExVWRKUVFXCk1CUUdDQ3NHQVFVRkJ3TUNCZ2dyQmdFRkJRY0RBVEFQQmdOVkhSTUJBZjhFQlRBREFRSC9NQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFCaWpXYlpPNU9uaU9lNHRHUlQvRGFXaFBkY2ZwbE8vcVQ5WkFqU1hXZU41TStubExQZQpGV1NLRGRWU1NzajJ6UVdMU3A1Vjc3MkFoa2NYQlM0a2ZiY2ZCTUl2ejVsYXJZeHgxcnduTzZLbVZSTHdkNUNkCnRER2RjUjF0UzdqeTRSV05ISlAyNWZhZHB5TE9KVzJlZkdLRmRiSnZyRjljekV1ODR5a1drdThtVnNNa0RzTXkKbnVFNGtXblNvODgweFpxVG9QN01qM3hkRlNYYWdoNytwK3FMazk1VjhBNTRUNmRKa2VjSGg4SzdNYVRxdWVOVgpzOVhuZDA2WEJGQWFCVXRsSGZybmRXUzhmaTQ5dTY0NEFWOWJHclNYRnR1Q0lydnIxVkY2d0R3dEJYZi9UUStrCkx3Zk1oNVZDVWt1bEJqWEpqK1ZvRnBLZm5Qck9nbEExZzRtUgotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://localhost:8443</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes</span><br><span class="hljs-attr">contexts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">context:</span><br>    <span class="hljs-attr">cluster:</span> <span class="hljs-string">kubernetes</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">system:kube-controller-manager</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-controller-manager@kubernetes</span><br><span class="hljs-attr">current-context:</span> <span class="hljs-string">system:kube-controller-manager@kubernetes</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Config</span><br><span class="hljs-attr">preferences:</span> &#123;&#125;<br><span class="hljs-attr">users:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">system:kube-controller-manager</span><br>  <span class="hljs-attr">user:</span><br>    <span class="hljs-comment"># 用于访问 kube-apiserver 的客户端证书</span><br>    <span class="hljs-attr">client-certificate-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM1ekNDQWMrZ0F3SUJBZ0lJZVE4aDNXSlNmZEF3RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2JXbHVhV3QxWW1WRFFUQWVGdzB5TURBek1EY3dNRE0zTVRGYUZ3MHlNVEExTVRrd05qVTNNemxhTUNreApKekFsQmdOVkJBTVRIbk41YzNSbGJUcHJkV0psTFdOdmJuUnliMnhzWlhJdGJXRnVZV2RsY2pDQ0FTSXdEUVlKCktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU5DTzJpTEZzNGRTTW9sR2plN2tjY1VFbURDVjEvbWQKV1p1cS9DT0RvV1p2Uy80clNrOXNsaFQvektIVTVkVmg3SFV4TGNWU1RkQXZScGEwN3dXK3h2eWlDR3Y5UmMyVAp0bkFnUFFhQ2VkOC8zZlFpMzI1QmZCZVl4UjRTTm8raEM1b0ZYYkhpdC9OWWlQTVMvM1hFOGVCc0dEZCtjd1pzCnhNTDZzc0pJNzVOSmNXckV3eXlMbzIrb1JSRmJ2TlpJWFRZekJpRGd3QkZxNUkzZVA5QTl2d29rUG5STFBSdlYKQU9SV3hUZDMyblJLOTY1SU9uV25mNzY0bHhSeEV6bHIyS09rSzc5NlVJWTlyL0lYOWdGQjNqbGZFK1lBOE5VLwpuV2x3cElNL0ZpMk9hL1hjNnQzNUJHSnNXcTR4bHQ5RDdqS3V2bTNONmJlanJPOFZNODU5QU44Q0F3RUFBYU1uCk1DVXdEZ1lEVlIwUEFRSC9CQVFEQWdXZ01CTUdBMVVkSlFRTU1Bb0dDQ3NHQVFVRkJ3TUNNQTBHQ1NxR1NJYjMKRFFFQkN3VUFBNElCQVFCZVg4QmVuTlJoUTVWaVpMMjRxcWxIMjRlMDVyYWVVTFZJQlQzWE90cmdQcXF1WXRGWgptRG9naEpuSW05aVVMcHFTTUxHMlJrQ0RBMEk2Rit0SGVFVHRMRDlNdjA2N1huQ2VCclhkTFVTYzkwaHNZWm1KClNsVG11c21TZGUxUXJsRnFxQVRZY2VCVWgwM0lSbXZIL1BtS21va1FUZDZER0paVVVhM3ducEN6Nko4aGcySGwKWlZFaURKcHNoeXNBaVdCUWZBN01TRlFlb0poSjhUdHgzdEhNZDlaaHlmcVVHOVByUGJkMUlBQTIrRlVudXRsNwpoRmdZdTBxbG5aZFZCWE9JM1dvZndWZ2dDTEQrbFVCeGgzNVhLNStxYXhWNVlDTit0ZTNFeDJERHVmRW1UV0FoCkwwUVNTc0RTZGd0Vi9TNFhvV2xQcXU0Q2lRVnZydUg3WHkxMwotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==</span><br>    <span class="hljs-comment"># 客户端证书对应的私钥</span><br>    <span class="hljs-attr">client-key-data:</span> <span class="hljs-string">LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBMEk3YUlzV3poMUl5aVVhTjd1Unh4UVNZTUpYWCtaMVptNnI4STRPaFptOUwvaXRLClQyeVdGUC9Nb2RUbDFXSHNkVEV0eFZKTjBDOUdsclR2QmI3Ry9LSUlhLzFGelpPMmNDQTlCb0o1M3ovZDlDTGYKYmtGOEY1akZIaEkyajZFTG1nVmRzZUszODFpSTh4TC9kY1R4NEd3WU4zNXpCbXpFd3ZxeXdranZrMGx4YXNURApMSXVqYjZoRkVWdTgxa2hkTmpNR0lPREFFV3JramQ0LzBEMi9DaVErZEVzOUc5VUE1RmJGTjNmYWRFcjNya2c2CmRhZC92cmlYRkhFVE9XdllvNlFydjNwUWhqMnY4aGYyQVVIZU9WOFQ1Z0R3MVQrZGFYQ2tnejhXTFk1cjlkenEKM2ZrRVlteGFyakdXMzBQdU1xNitiYzNwdDZPczd4VXp6bjBBM3dJREFRQUJBb0lCQVFDRDVMT2pKZkJoZGVRcgoySWpPT1g2Um9GUTI5YXgrV2JwZnJnU0MyUzNyUUJ1SkJBdWNxd2xIQW5hQktjaW41NlBJZ1c5MnlKUVpRcXliCmhwVmF4c25FM3h3QVgwNFRzb1MvNkVOdnFIZzJiWWVLYTd0dFdOQ0hnNysxUXNOcWxlaG1ZVnBkc3dtdVJhRm0KUis5eXBUaHFPeklkZGtSOEhiRlp0WDN6VEhqbVpYaUhGdlIvMFhYK1BVbDR6SllSWjlCbVBnY2Ric2tSTldScgo0Qk8wUmlQQWRKVEo2VHZLMGhxT1g1UHo4ekl3S1ZzYjdyYndUdXArTGs4eWNCVUd3Q1N3RzEyanVNQW1kYkJJClZmdmlFK1VYRHRIQXdLWXlnMEhCVitJVlEvcVNwSVJ1WXQ4SmY1MWVKN1VEbHhiN3ZRTStEYVNsNjVaMVNyWUcKQU9UTGpPVkJBb0dCQU5PYzB0OG5ybmhUR3V0MGhMdVp6SWs4ekFranhYYWtiSURlZi9XeXlQdW94Z3J2ZGMzcwpsbHV0U3hSOFV4WGVuQjBLZFpnYnNoc1ozeW9GbEI0YThTMzI1UFRsYm9xOVB0TDRaOFBzczQ3L0l1bHYxTk10CnZzZjdKZ1FuaFRCVndkdjN6OXFpdml6bjB4Mk9CdURxdzNSYXcvWEhwRy9RczJ5WmF4S29GNW9SQW9HQkFQeE8KQVBDUXQ2Q2swOFF2WTE4VjFLQXA0d2h1YWEyMS9MeC9rZUZJSURRd0tZZnFHRGdBWUYvQzJUbC9xc29TMXAvTwpFcFVkVkRBNHVpblFVbnFhNGg0a0JOYjRXTFhrSXhRdXdjWHdJNjRMNWR3ZWJHalhxUWUwbnkxQkhkTmU2Z0dqClorbit4OUJLWnJmcEliYkQ2blpYUUREbS9jZWYyWU5NVWRqVWpudnZBb0dBQnlIMUZhSi94ZngvSHNxWm9yMG4KWU1UVTE4WUY1TjdiN1dnU2hoU1ZvNjNucHZ5MVN0Q2JyTkZsZzNaQlVxNWpNck5ralZENXF1SXZYSG85cU5vZApvUC8rYmFiQ0dCa1M0Z2VQYjlJdHB6ZEFWUC80KzNsQ1FmbGNLYTJ2VnBhOVp3MnVTdDlMYTdZUXJxRlg2QUxoCnZhMUZoNlpJQzZETU8yL2NaUStYWkJFQ2dZQnNGMHNGeFNvMlU0YzZISWM1SEZRc2plVnJIa3ArRm1LQnF6R24KVDB3a3I2R0xUZm8wTzgwT0daOFFxQ1pXVGozTzF1MVZIdXlMZ0RJWmFkdDhGVkRjVXRnVDlPK2tkV21sNHVZMwpVOHNsYklsOGhUZ3lybm9IQ0JYTndJRHpwazBnaUk0alRIajBQbnZGUE1hcDAwTm1rYmk1ZXF5czBrblFtMmpSCk9UY1Yxd0tCZ0RNUWZSVlNNNXlGcjVIalJ4UXcwRDdrUWhONDlLbngrMWs2bWRORWJ6VG9rQ1RRcWlSeUJQdGgKcjlqZk0rRXFZcnZ1elRmRVpiS1VBMEZac09yeStxMHpXb29mTURLajFGV3BaTXJBSmdxdDFlcWtFbVFrVi8vSApQMzF3ejZDa1RneDdJby9iZ09PbmhsbUplU3NHaXpqenV2TjFEcWtjNVR3M3oxUSs1dmxmCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg==</span><br></code></pre></td></tr></table></figure><p>可以看到，访问 kube-apiserver 所需要的相关证书内容已经被采用 base64 编码写入了文件中。其他几个文件中的内容也是类似的，只是配置的用户名和客户端证书有所不同。</p><p>在启动这些组件时，需要在参数中指出 kubeconfig 文件的路径，例如 kube-controller-manager 的启动命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-controller-manager \\<br>--kubeconfig=/etc/kubernetes/controller-manager.conf <br><span class="hljs-comment"># 下面几个证书和访问 kube-apiserver 无关，我们会在后面介绍到</span><br>--cluster-signing-cert-file=/var/lib/kubernetes/cluster-root-ca.pem             <span class="hljs-comment"># 用于签发证书的 CA 根证书</span><br>--cluster-signing-key-file=/var/lib/kubernetes/cluster-root-ca-key.pem          <span class="hljs-comment"># 用于签发证书的 CA 根证书的私钥  </span><br>--service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem  <span class="hljs-comment"># 用于对 service account token 进行签名的私钥</span><br>... <br></code></pre></td></tr></table></figure><h2 id="Service-Account-证书"><a href="#Service-Account-证书" class="headerlink" title="Service Account 证书"></a>Service Account 证书</h2><p>Kubernetes 中有两类用户，一类为 user account，一类为 service account。 service account 主要被 pod 用于访问 kube-apiserver。 在为一个 pod 指定了 service account 后，kubernetes 会为该 service account 生成一个 JWT token，并使用 secret 将该 service account token 加载到 pod 上。pod 中的应用可以使用 service account token 来访问 api server。service account 证书被用于生成和验证 service account token。该证书的用法和前面介绍的其他证书不同，因为实际上使用的是其公钥和私钥，而并不需要对证书进行验证。</p><p>我们可以看到 service account 证书的公钥和私钥分别被配置到了 kube-apiserver 和 kube-controller-manager 的命令行参数中，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-apiserver \\ <br>  --service-account-key-file=/var/lib/kubernetes/service-account.pem \\          <span class="hljs-comment"># 用于验证 service account token 的公钥</span><br>  ...<br>  <br> /usr/local/bin/kube-controller-manager \\<br> --service-account-private-key-file=/var/lib/kubernetes/service-account-key.pem  <span class="hljs-comment"># 用于对 service account token 进行签名的私钥</span><br> ... <br></code></pre></td></tr></table></figure><p>下图展示了 kubernetes 中生成、使用和验证 service account token 的过程。</p><p><img src="/2025/03/30/k8s%E8%AF%81%E4%B9%A6/service-account-token.png" alt="img"></p><h3 id="认证方法：客户端证书还是-token-？"><a href="#认证方法：客户端证书还是-token-？" class="headerlink" title="认证方法：客户端证书还是 token ？"></a>认证方法：客户端证书还是 token ？</h3><p>我们可以看到，Kubernetes 提供了两种客户端认证的方法，控制面组件采用的是客户端数字证书;而在集群中部署的应用则采用了 service account token 的方式。为什么 Kubernetes 不为 service account 也生成一个证书，并采用该证书进行身份认证呢？ 实际上 Istio 就是这样做的，Istio 会自动为每个 service account 生成一个证书，并使用该证书来在 pod 中的应用之间建立双向 tls 认证。我没有找到 Kubernetes 这个设计决策的相关说明，如果你知道原因或对此有自己的见解，欢迎联系我进行探讨。</p><h2 id="Kubernetes-证书签发"><a href="#Kubernetes-证书签发" class="headerlink" title="Kubernetes 证书签发"></a>Kubernetes 证书签发</h2><p>Kubernetes 提供了一个 <code>certificates.k8s.io</code> API，可以使用配置的 CA 根证书来签发用户证书。该 API 由 kube-controller-manager 实现，其签发证书使用的根证书在下面的命令行中进行配置。我们希望 Kubernetes 采用集群根 CA 来签发用户证书，因此在 kube-controller-manager 的命令行参数中将相关参数配置为了集群根 CA。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/local/bin/kube-controller-manager \\<br>--cluster-signing-cert-file=/var/lib/kubernetes/cluster-root-ca.pem             <span class="hljs-comment"># 用于签发证书的 CA 根证书</span><br>--cluster-signing-key-file=/var/lib/kubernetes/cluster-root-ca-key.pem          <span class="hljs-comment"># 用于签发证书的 CA 根证书的私钥  </span><br>... <br></code></pre></td></tr></table></figure><p>关于更多 Kubernetes 证书签发 API 的内容，可以参见 <a href="https://kubernetes.io/zh/docs/tasks/tls/managing-tls-in-a-cluster/">管理集群中的 TLS 认证</a>。</p><h2 id="使用-TLS-bootstrapping-简化-Kubelet-证书制作"><a href="#使用-TLS-bootstrapping-简化-Kubelet-证书制作" class="headerlink" title="使用 TLS bootstrapping 简化 Kubelet 证书制作"></a>使用 TLS bootstrapping 简化 Kubelet 证书制作</h2><p>在安装 Kubernetes 时，我们需要为每一个工作节点上的 Kubelet 分别生成一个证书。由于工作节点可能很多，手动生成 Kubelet 证书的过程会比较繁琐。为了解决这个问题，Kubernetes 提供了 <a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS bootstrapping </a>的方式来简化 Kubelet 证书的生成过程。其原理是预先提供一个 bootstrapping token，kubelet 采用该 bootstrapping token 进行客户端验证，调用 kube-apiserver 的证书签发 API 来生成 自己需要的证书。要启用该功能，需要在 kube-apiserver 中启用 <code>--enable-bootstrap-token-auth</code> ，并创建一个 kubelet 访问 kube-apiserver 使用的 bootstrap token secret。如果使用 kubeadmin 安装，可以使用 <code>kubeadm token create</code>命令来创建 token。</p><p>采用TLS bootstrapping 生成证书的流程如下：</p><ol><li>调用 kube-apiserver 生成一个 bootstrap token。</li><li>将该 bootstrap token 写入到一个 kubeconfig 文件中，作为 kubelet 调用 kube-apiserver 的客户端验证方式。</li><li>通过 <code>--bootstrap-kubeconfig</code> 启动参数将 bootstrap token 传递给 kubelet 进程。</li><li>Kubelet 采用bootstrap token 调用 kube-apiserver API，生成自己所需的服务器和客户端证书。</li><li>证书生成后，Kubelet 采用生成的证书和 kube-apiserver 进行通信，并删除本地的 kubeconfig 文件，以避免 bootstrap token 泄漏风险。</li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Kubernetes 中使用了大量的证书来确保集群的安全，弄清楚这些证书的用途和配置方法将有助于我们深入理解 kubernetes 的安装过程和组件的配置。本文是笔者在学习 过程中整理的 Kubernetes 集群中主要使用到的证书，由于笔者对 Kubernetes 的理解有限，文章中难免存在部分错误，欢迎指正。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://kubernetes.io/zh/docs/setup/best-practices/certificates/">Kubernetes PKI 证书和要求</a></li><li><a href="https://github.com/kelseyhightower/kubernetes-the-hard-wa">kubernetes the hard way</a></li><li><a href="https://blog.51cto.com/13210651/2361208">Kubernetes 之 二进制安装(二) 证书详解</a></li><li><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">TLS bootstrapping</a></li><li><a href="https://zhaohuabing.com/post/2020-03-19-pki/">数字证书原理</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s-选主-实战验证</title>
    <link href="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/"/>
    <url>/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s-选主-实战验证"><a href="#k8s-选主-实战验证" class="headerlink" title="k8s-选主-实战验证"></a>k8s-选主-实战验证</h1><p>转自：<a href="https://blog.csdn.net/boling_cavalry/article/details/132129123">https://blog.csdn.net/boling_cavalry/article/details/132129123</a></p><h4 id="本篇概览"><a href="#本篇概览" class="headerlink" title="本篇概览"></a>本篇概览</h4><p>•本文是《client-go实战》系列的第十二篇，又有一个精彩的知识点在本章呈现：选主(leader-election)•在解释什么是选主之前，咱们先来看一个场景（有真实适用场景的技术，学起来才有动力），如下图所示（稍后有详细说明）</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/230a3f9ae9a956d7d112c28c02a38ff4.png" alt="Image 32: 在这里插入图片描述"></p><p>上图所描述的业务场景是个普通的controller应用：</p><p>1.右侧是人工操作，通过kubectl命令修改了service资源2.左侧的业务应用订阅了service的变化，在收到service变更的事件后，对pod进行写操作（例如将收到事件的时间写入pod的label）</p><p>•以上的业务应用就是个很普通的controller，很简单，运行起来也没啥问题，但是，如果这个业务应用有多个实例呢？</p><h4 id="多实例的问题"><a href="#多实例的问题" class="headerlink" title="多实例的问题"></a>多实例的问题</h4><p>•所谓多个实例，就是同样的业务应用我们运行了多个进程（例如三个），为什么多个进程？同一个应用运行多个进程不是很正常么？横向扩容不就是多进程嘛•多个进程运行的时候，如果service发生变化，那么每个进程都会去修改pod的label，这不是我们想要的（只要修改一次就行了）•所以，如何解决这个问题呢？三个进程都是同一套代码，都会订阅service的变化，但是最终只修改一次pod•经验丰富的您应该会想到分布式锁，三个进程去抢分布式锁，抢到的负责更新，没错，这是一个正确的解法•但是，分布式锁需要引入相关组件吧，redis的setnx，或者mysql的乐观锁，这样就需要维护新的组件了•其实这在kubernetes是个很典型的问题，毕竟pod多实例在kubernetes是常态了，所以当然也有官方的解法，页就是本文的主题：选主(leader-election)</p><h4 id="选主-leader-election"><a href="#选主-leader-election" class="headerlink" title="选主(leader-election)"></a>选主(leader-election)</h4><p>•说到这里您应该能理解选主的含义了：多个进程竞争某个key的leader，咱们可以把特定的代码放在竞争成功后再执行，由于同一时刻只有一个进程可以竞争成功，这就相当于在不引入额外组件的情况下，只用client-go就实现了分布式锁•由于选主只是个特定的小知识点，本篇就没什么多余的理论要研究了，接下来直接开始实战，编码实现一个功能来说明选主的用法•实战的业务需求如下</p><p>1.开发一个应用，该应用同时运行多个进程2.当kubernetes的指定namespace下的service发生变化时，在pod的label中记录这个service的变化时间3.每次serivce变化，pod的label只能修改一次（尽管此时有多个进程）</p><p>•让我们少些套路，多一点真诚，不说废话，直接开始动手实战吧</p><h4 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h4><p>•如果您不想编写代码，也可以从GitHub上直接下载，地址和链接信息如下表所示(<a href="https://github.com/zq2599/blog/_demos)%EF%BC%9A">https://github.com/zq2599/blog\_demos)：</a></p><table><thead><tr><th>名称</th><th>链接</th><th>备注</th></tr></thead><tbody><tr><td>项目主页</td><td><a href="https://github.com/zq2599/blog/_demos">https://github.com/zq2599/blog\_demos</a></td><td>该项目在GitHub上的主页</td></tr><tr><td>git仓库地址(https)</td><td><a href="https://github.com/zq2599/blog/_demos.git">https://github.com/zq2599/blog\_demos.git</a></td><td>该项目源码的仓库地址，https协议</td></tr><tr><td>git仓库地址(ssh)</td><td><a href="mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#111;&#109;</a>:zq2599&#x2F;blog_demos.git</td><td>该项目源码的仓库地址，ssh协议</td></tr></tbody></table><p>•这个git项目中有多个文件夹，本篇的源码在leader-tutorials文件夹下，如下图黄框所示：</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/fc33e0f2da6fec4b7043fc97415dd155.png" alt="Image 33: 在这里插入图片描述"></p><h4 id="提前了解选主的代码"><a href="#提前了解选主的代码" class="headerlink" title="提前了解选主的代码"></a>提前了解选主的代码</h4><p>•接下来会开发一个完整的controller应用，以此来说明选主功能•如果您觉得完整应用的代码太多，懒得看，只想了解选主部分，那就在此提前将整个工程中选主相关的代码贴出来•核心代码如下所示，先创建锁对象，就像分布式锁一样，总要有个key，然后执行leaderelection.RunOrDie方法参与选主，一旦有了结果，OnNewLeader方法会被回调，这时候通过自身id和leader的id比较就知道是不是自己了，另外，当OnStartedLeading被执行的时候，就意味着当前进程就是leader，并且可以立即开始执行只有leader才能做的事情了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// startLeaderElection 选主的核心逻辑代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startLeaderElection</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, stop <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]创建选主所需的锁对象&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 创建锁对象</span><br>    lock := &amp;resourcelock.LeaseLock&#123;<br>        LeaseMeta: metav1.ObjectMeta&#123;<br>            Name:      <span class="hljs-string">&quot;leader-tutorials&quot;</span>,<br>            Namespace: NAMESPACE,<br>        &#125;,<br>        Client: clientset.CoordinationV1(),<br>        LockConfig: resourcelock.ResourceLockConfig&#123;<br>            Identity: processIndentify,<br>        &#125;,<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始选主&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 启动选主操作</span><br>    leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;<br>        Lock:            lock,<br>        ReleaseOnCancel: <span class="hljs-literal">true</span>,<br>        LeaseDuration:   <span class="hljs-number">10</span> * time.Second,<br>        RenewDeadline:   <span class="hljs-number">5</span> * time.Second,<br>        RetryPeriod:     <span class="hljs-number">2</span> * time.Second,<br>        Callbacks: leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]当前进程是leader，只有leader才能执行的业务逻辑立即开始&quot;</span>, processIndentify)<br>                <span class="hljs-comment">// 在这里写入选主成功的代码，</span><br>                <span class="hljs-comment">// 就像抢分布式锁一样，当前进程选举成功的时候，这的代码就会被执行，</span><br>                <span class="hljs-comment">// 所以，在这里填写抢锁成功的业务逻辑吧，本例中就是监听service变化，然后修改pod的label</span><br>                CreateAndStartController(ctx, clientset, &amp;v1.Service&#123;&#125;, <span class="hljs-string">&quot;services&quot;</span>, NAMESPACE, stop)<br>            &#125;,<br>            OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-comment">// 失去了leader时的逻辑</span><br>                klog.Infof(<span class="hljs-string">&quot;[%s]失去leader身份，不再是leader了&quot;</span>, processIndentify)<br>                os.Exit(<span class="hljs-number">0</span>)<br>            &#125;,<br>            OnNewLeader: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span> &#123;<br>                <span class="hljs-comment">// 收到通知，知道最终的选举结果</span><br>                <span class="hljs-keyword">if</span> identity == processIndentify &#123;<br>                    klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，当前进程就是leader&quot;</span>, processIndentify)<br>                    <span class="hljs-comment">// I just got the lock</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，leader是 : [%s]&quot;</span>, processIndentify, identity)<br>            &#125;,<br>        &#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实战：部署service和deployment"><a href="#实战：部署service和deployment" class="headerlink" title="实战：部署service和deployment"></a>实战：部署service和deployment</h4><p>•首先请准备好k8s环境，这在《client-go实战之六:时隔两年，刷新版本继续实战》里面已有详细说明•然后把本次实战所需的service和deployment部署好，- 所有要部署的内容我都集中在这个名为nginx-deployment-service.yaml脚本中了</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">client-go-tutorials</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>      <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>        <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>        <span class="hljs-comment"># 这是第一个业务自定义label，指定了mysql的语言类型是c语言</span><br>        <span class="hljs-attr">language:</span> <span class="hljs-string">c</span><br>        <span class="hljs-comment"># 这是第二个业务自定义label，指定了这个pod属于哪一类服务，nginx属于web类</span><br>        <span class="hljs-attr">business-service-type:</span> <span class="hljs-string">web</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>          <span class="hljs-attr">resources:</span><br>            <span class="hljs-attr">limits:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.5&quot;</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">128Mi</span><br>            <span class="hljs-attr">requests:</span><br>              <span class="hljs-attr">cpu:</span> <span class="hljs-string">&quot;0.1&quot;</span><br>              <span class="hljs-attr">memory:</span> <span class="hljs-string">64Mi</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">client-go-tutorials</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx-app</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">front-end</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30011</span><br></code></pre></td></tr></table></figure><p>•先执行以下命令创建namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create namespace client-go-tutorials<br></code></pre></td></tr></table></figure><p>•再执行以下命令即可完成资源的创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f nginx-deployment-service.yaml<br></code></pre></td></tr></table></figure><p>•来查看一下资源情况，如下图，service和pod都创建好了，准备工作完成，可以开始编码了</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/73fa79a5cf8315f15417361895009780.png" alt="Image 36: 在这里插入图片描述"></p><h4 id="编码：准备工程"><a href="#编码：准备工程" class="headerlink" title="编码：准备工程"></a>编码：准备工程</h4><p>•执行命令名为go mod init leader-tutorials，新建module•确保您的goproxy是正常的•执行命令go get k8s.io&#x2F;<a href="mailto:&#x63;&#x6c;&#105;&#x65;&#110;&#116;&#x2d;&#103;&#x6f;&#x40;&#118;&#x30;&#x2e;&#x32;&#x32;&#46;&#x38;">&#x63;&#x6c;&#105;&#x65;&#110;&#116;&#x2d;&#103;&#x6f;&#x40;&#118;&#x30;&#x2e;&#x32;&#x32;&#46;&#x38;</a>，下载client-go的指定版本•现在工程已经准备好了，接着就是具体的编码</p><h4 id="编码：梳理"><a href="#编码：梳理" class="headerlink" title="编码：梳理"></a>编码：梳理</h4><p>•咱们按照开发顺序开始写代码，如果您看过欣宸的《client-go实战》系列，此刻对使用client-go开发简易版controller应该很熟悉了，这里再简单提一下开发的流程</p><p>1.将controller完整的写出来，功能是监听service，一旦有变化就更新pod的label2.在主控逻辑中，根据选主结果决定是否启动步骤1中的controller</p><p>•下面开始写代码</p><h4 id="编码：controller"><a href="#编码：controller" class="headerlink" title="编码：controller"></a>编码：controller</h4><p>•新建controller.go文件•在controller.go中增加常量和数据结构的定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br><br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/fields&quot;</span><br>    objectruntime <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/runtime&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/types&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/util/runtime&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/util/wait&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/cache&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/util/workqueue&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    LABLE_SERVICE_UPDATE_TIME = <span class="hljs-string">&quot;service-update-time&quot;</span> <span class="hljs-comment">// 这个label用来记录service的更新时间</span><br>)<br><br><span class="hljs-comment">// 自定义controller数据结构，嵌入了真实的控制器</span><br><span class="hljs-keyword">type</span> Controller <span class="hljs-keyword">struct</span> &#123;<br>    ctx       context.Context<br>    clientset *kubernetes.Clientset<br>    <span class="hljs-comment">// 本地缓存，关注的对象都会同步到这里</span><br>    indexer cache.Indexer<br>    <span class="hljs-comment">// 消息队列，用来触发对真实对象的处理事件</span><br>    queue workqueue.RateLimitingInterface<br>    <span class="hljs-comment">// 实际运行运行的控制器</span><br>    informer cache.Controller<br>&#125;<br></code></pre></td></tr></table></figure><p>•然后是controller的套路代码，主要是从队列中不断获取数据并处理的逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// processNextItem 不间断从队列中取得数据并处理</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> processNextItem() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 注意，队列里面不是对象，而是key，这是个阻塞队列，会一直等待</span><br>    key, quit := c.queue.Get()<br>    <span class="hljs-keyword">if</span> quit &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// Tell the queue that we are done with processing this key. This unblocks the key for other workers</span><br>    <span class="hljs-comment">// This allows safe parallel processing because two pods with the same key are never processed in</span><br>    <span class="hljs-comment">// parallel.</span><br>    <span class="hljs-keyword">defer</span> c.queue.Done(key)<br><br>    <span class="hljs-comment">// 注意，这里的syncToStdout应该是业务代码，处理对象变化的事件</span><br>    err := c.updatePodsLabel(key.(<span class="hljs-type">string</span>))<br><br>    <span class="hljs-comment">// 如果前面的业务逻辑遇到了错误，就在此处理</span><br>    c.handleErr(err, key)<br><br>    <span class="hljs-comment">// 外面的调用逻辑是：返回true就继续调用processNextItem方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// runWorker 这是个无限循环，不断地从队列取出数据处理</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> runWorker() &#123;<br>    <span class="hljs-keyword">for</span> c.processNextItem() &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// handleErr 如果前面的业务逻辑执行出现错误，就在此集中处理错误，本例中主要是重试次数的控制</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> handleErr(err <span class="hljs-type">error</span>, key <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// Forget about the #AddRateLimited history of the key on every successful synchronization.</span><br>        <span class="hljs-comment">// This ensures that future processing of updates for this key is not delayed because of</span><br>        <span class="hljs-comment">// an outdated error history.</span><br>        c.queue.Forget(key)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果重试次数未超过5次，就继续重试</span><br>    <span class="hljs-keyword">if</span> c.queue.NumRequeues(key) &lt; <span class="hljs-number">5</span> &#123;<br>        klog.Infof(<span class="hljs-string">&quot;Error syncing pod %v: %v&quot;</span>, key, err)<br><br>        <span class="hljs-comment">// Re-enqueue the key rate limited. Based on the rate limiter on the</span><br>        <span class="hljs-comment">// queue and the re-enqueue history, the key will be processed later again.</span><br>        c.queue.AddRateLimited(key)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 代码走到这里，意味着有错误并且重试超过了5次，应该立即丢弃</span><br>    c.queue.Forget(key)<br>    <span class="hljs-comment">// 这种连续五次重试还未成功的错误，交给全局处理逻辑</span><br>    runtime.HandleError(err)<br>    klog.Infof(<span class="hljs-string">&quot;Dropping pod %q out of the queue: %v&quot;</span>, key, err)<br>&#125;<br><br><span class="hljs-comment">// Run 开始常规的控制器模式（持续响应资源变化事件）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> Run(threadiness <span class="hljs-type">int</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>    <span class="hljs-keyword">defer</span> runtime.HandleCrash()<br><br>    <span class="hljs-comment">// Let the workers stop when we are done</span><br>    <span class="hljs-keyword">defer</span> c.queue.ShutDown()<br>    klog.Info(<span class="hljs-string">&quot;Starting Pod controller&quot;</span>)<br><br>    <span class="hljs-keyword">go</span> c.informer.Run(stopCh)<br><br>    <span class="hljs-comment">// Wait for all involved caches to be synced, before processing items from the queue is started</span><br>    <span class="hljs-comment">// 刚开始启动，从api-server一次性全量同步所有数据</span><br>    <span class="hljs-keyword">if</span> !cache.WaitForCacheSync(stopCh, c.informer.HasSynced) &#123;<br>        runtime.HandleError(fmt.Errorf(<span class="hljs-string">&quot;timed out waiting for caches to sync&quot;</span>))<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 支持多个线程并行从队列中取得数据进行处理</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; threadiness; i++ &#123;<br>        <span class="hljs-keyword">go</span> wait.Until(c.runWorker, time.Second, stopCh)<br>    &#125;<br><br>    &lt;-stopCh<br>    klog.Info(<span class="hljs-string">&quot;Stopping Pod controller&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>•从上述代码可见，监听的资源发生变化时，调用的是updatePodsLabel方法，此方法的作用就是查找该namespace下的所有pod，依次用patch的方式更新pod的label</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// updatePodsLabel 这是业务逻辑代码，一旦service发生变化，就修改pod的label，将service的变化事件记录进去</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> updatePodsLabel(key <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 开始进入controller的业务逻辑</span><br>    klog.Infof(<span class="hljs-string">&quot;[%s]这里是controller的业务逻辑，key [%s]&quot;</span>, processIndentify, key)<br>    <span class="hljs-comment">// 从本地缓存中取出完整的对象</span><br>    _, exists, err := c.indexer.GetByKey(key)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Errorf(<span class="hljs-string">&quot;[%s]根据key[%s]从本地缓存获取对象失败 : %v&quot;</span>, processIndentify, key, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> !exists &#123;<br>        klog.Infof(<span class="hljs-string">&quot;[%s]对象不存在，key [%s]，这是个删除事件&quot;</span>, processIndentify, key)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        klog.Infof(<span class="hljs-string">&quot;[%s]对象存在，key [%s]，这是个新增或修改事件&quot;</span>, processIndentify, key)<br>    &#125;<br><br>    <span class="hljs-comment">// 代码走到这里，表示监听的对象发生了变化，</span><br>    <span class="hljs-comment">// 按照业务设定，需要修改pod的指定label,</span><br>    <span class="hljs-comment">// 准备好操作pod的接口</span><br>    podInterface := c.clientset.CoreV1().Pods(NAMESPACE)<br><br>    <span class="hljs-comment">// 远程取得最新的pod列表</span><br>    pods, err := podInterface.List(c.ctx, metav1.ListOptions&#123;&#125;)<br><br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Errorf(<span class="hljs-string">&quot;[%s]远程获取pod列表失败 : %v&quot;</span>, processIndentify, err)<br>        <span class="hljs-keyword">return</span> err<br>    &#125;<br><br>    <span class="hljs-comment">// 将service的变化时间写入pod的指定label，这里先获取当前时间</span><br>    updateTime := time.Now().Format(<span class="hljs-string">&quot;20060102150405&quot;</span>)<br>    <span class="hljs-comment">// 准备patch对象</span><br>    patchData := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>        <span class="hljs-string">&quot;metadata&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>            <span class="hljs-string">&quot;labels&quot;</span>: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br>                LABLE_SERVICE_UPDATE_TIME: updateTime,<br>            &#125;,<br>        &#125;,<br>    &#125;<br><br>    <span class="hljs-comment">// 转为byte数组，稍后更新pod的时候，就用这个数组进行patch更新</span><br>    patchByte, _ := json.Marshal(patchData)<br><br>    <span class="hljs-comment">// 遍历所有pod，逐个更新label</span><br>    <span class="hljs-keyword">for</span> _, pod := <span class="hljs-keyword">range</span> pods.Items &#123;<br>        podName := pod.Name<br>        klog.Infof(<span class="hljs-string">&quot;[%s]正在更新pod [%s]&quot;</span>, processIndentify, podName)<br><br>        _, err := podInterface.Patch(c.ctx, podName, types.MergePatchType, patchByte, metav1.PatchOptions&#123;&#125;)<br><br>        <span class="hljs-comment">// 失败就返回，会导致整体重试</span><br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            klog.Infof(<span class="hljs-string">&quot;[%s]更新pod [%s]失败, %v&quot;</span>, processIndentify, podName, err)<br>            <span class="hljs-keyword">return</span> err<br>        &#125;<br><br>        klog.Infof(<span class="hljs-string">&quot;[%s]更新pod [%s]成功&quot;</span>, processIndentify, podName)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>•到这里，controller的代码已经写得七七八八了，还剩创建controller对象以及运行informer的代码，这里将它们集中封装在一个方法中，一旦这个方法被调用，就意味着controller会被创建，然后监听service变化再更新pod的label的逻辑就会被执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateAndStartController 为了便于外部使用，这里将controller的创建和启动封装在一起</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateAndStartController</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, objType objectruntime.Object, resource <span class="hljs-type">string</span>, namespace <span class="hljs-type">string</span>, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-comment">// ListWatcher用于获取数据并监听资源的事件</span><br>    podListWatcher := cache.NewListWatchFromClient(clientset.CoreV1().RESTClient(), resource, NAMESPACE, fields.Everything())<br><br>    <span class="hljs-comment">// 限速队列，里面存的是有事件发生的对象的身份信息，而非对象本身</span><br>    queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())<br><br>    <span class="hljs-comment">// 创建本地缓存并对指定类型的资源开始监听</span><br>    <span class="hljs-comment">// 注意，如果业务上有必要，其实可以将新增、修改、删除等事件放入不同队列，然后分别做针对性处理，</span><br>    <span class="hljs-comment">// 但是，controller对应的模式，主要是让status与spec达成一致，也就是说增删改等事件，对应的都是查到实际情况，令其与期望情况保持一致，</span><br>    <span class="hljs-comment">// 因此，多数情况下增删改用一个队列即可，里面放入变化的对象的身份，至于处理方式只有一种：查到实际情况，令其与期望情况保持一致</span><br>    indexer, informer := cache.NewIndexerInformer(podListWatcher, objType, <span class="hljs-number">0</span>, cache.ResourceEventHandlerFuncs&#123;<br>        AddFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 再次注意：这里放入队列的并非对象，而是对象的身份，作用是仅仅告知消费方，该对象有变化，</span><br>                <span class="hljs-comment">// 至于有什么变化，需要消费方自行判断，然后再做针对性处理</span><br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        UpdateFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(old <span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-built_in">new</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.MetaNamespaceKeyFunc(<span class="hljs-built_in">new</span>)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>        DeleteFunc: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(obj <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>            key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)<br>            <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>                queue.Add(key)<br>            &#125;<br>        &#125;,<br>    &#125;, cache.Indexers&#123;&#125;)<br><br>    controller := &amp;Controller&#123;<br>        ctx:       ctx,<br>        clientset: clientset,<br>        informer:  informer,<br>        indexer:   indexer,<br>        queue:     queue,<br>    &#125;<br><br>    <span class="hljs-keyword">go</span> controller.Run(<span class="hljs-number">1</span>, stopCh)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编码：主控程序（选主逻辑也在里面）"><a href="#编码：主控程序（选主逻辑也在里面）" class="headerlink" title="编码：主控程序（选主逻辑也在里面）"></a>编码：主控程序（选主逻辑也在里面）</h4><p>•本文是讲选主(leader-election)的，前面做了这么多铺垫，主角该上场了，新建main.go文件•定义常量，以及全局变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;flag&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;path/filepath&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/google/uuid&quot;</span><br>    v1 <span class="hljs-string">&quot;k8s.io/api/core/v1&quot;</span><br>    metav1 <span class="hljs-string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span><br><br>    <span class="hljs-string">&quot;k8s.io/client-go/kubernetes&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/leaderelection&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/tools/leaderelection/resourcelock&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/client-go/util/homedir&quot;</span><br>    <span class="hljs-string">&quot;k8s.io/klog/v2&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>    NAMESPACE = <span class="hljs-string">&quot;client-go-tutorials&quot;</span><br>)<br><br><span class="hljs-comment">// 用于表明当前进程身份的全局变量，目前用的是uuid</span><br><span class="hljs-keyword">var</span> processIndentify <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>•先把套路的代码写了，就是client-go初始化的那部分，以及main方法，里面是整个程序的启动和业务调用流程，可见选主有关的代码都放在名为startLeaderElection的方法中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// initOrDie client有关的初始化操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initOrDie</span><span class="hljs-params">()</span></span> *kubernetes.Clientset &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始初始化kubernetes客户端相关对象&quot;</span>, processIndentify)<br>    <span class="hljs-keyword">var</span> kubeconfig *<span class="hljs-type">string</span><br>    <span class="hljs-keyword">var</span> master <span class="hljs-type">string</span><br><br>    <span class="hljs-comment">// 试图取到当前账号的家目录</span><br>    <span class="hljs-keyword">if</span> home := homedir.HomeDir(); home != <span class="hljs-string">&quot;&quot;</span> &#123;<br>        <span class="hljs-comment">// 如果能取到，就把家目录下的.kube/config作为默认配置文件</span><br>        kubeconfig = flag.String(<span class="hljs-string">&quot;kubeconfig&quot;</span>, filepath.Join(home, <span class="hljs-string">&quot;.kube&quot;</span>, <span class="hljs-string">&quot;config&quot;</span>), <span class="hljs-string">&quot;(optional) absolute path to the kubeconfig file&quot;</span>)<br>        master = <span class="hljs-string">&quot;&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果取不到，就没有默认配置文件，必须通过kubeconfig参数来指定</span><br>        flag.StringVar(kubeconfig, <span class="hljs-string">&quot;kubeconfig&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;absolute path to the kubeconfig file&quot;</span>)<br>        flag.StringVar(&amp;master, <span class="hljs-string">&quot;master&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;master url&quot;</span>)<br>        flag.Parse()<br>    &#125;<br><br>    config, err := clientcmd.BuildConfigFromFlags(master, *kubeconfig)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Fatal(err)<br>    &#125;<br><br>    clientset, err := kubernetes.NewForConfig(config)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        klog.Fatal(err)<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]kubernetes客户端相关对象创建成功&quot;</span>, processIndentify)<br>    <span class="hljs-keyword">return</span> clientset<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 一次性确定当前进程身份</span><br>    processIndentify = uuid.New().String()<br><br>    <span class="hljs-comment">// 准备一个带cancel的context，这样在主程序退出的时候，可以将停止的信号传递给业务</span><br>    ctx, cancel := context.WithCancel(context.Background())<br>    <span class="hljs-comment">// 这个是用来停止controller的</span><br>    stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br>    <span class="hljs-comment">// 主程序结束的时候，下面的操作可以将业务逻辑都停掉</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-built_in">close</span>(stop)<br>        cancel()<br>    &#125;()<br><br>    <span class="hljs-comment">// 初始化clientSet配置，因为是启动阶段，所以必须初始化成功，否则进程退出</span><br>    clientset := initOrDie()<br><br>    <span class="hljs-comment">// 在一个新的协程中执行选主逻辑，以及选主成功的后的逻辑</span><br>    <span class="hljs-keyword">go</span> startLeaderElection(ctx, clientset, stop)<br><br>    <span class="hljs-comment">// 这里可以继续做其他事情</span><br>    klog.Infof(<span class="hljs-string">&quot;选主的协程已经在运行，接下来可以执行其他业务 [%s]&quot;</span>, processIndentify)<br><br>    <span class="hljs-keyword">select</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>•最后是选主的代码，如下所示，先创建锁对象，就像分布式锁一样，总要有个key，然后执行leaderelection.RunOrDie方法参与选主，一旦有了结果，OnNewLeader方法会被回调，这时候通过自身id和leader的id比较就知道是不是自己了，另外，当OnStartedLeading被执行的时候，就意味着当前进程就是leader，并且可以立即开始执行只有leader才能做的事情了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// startLeaderElection 选主的核心逻辑代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startLeaderElection</span><span class="hljs-params">(ctx context.Context, clientset *kubernetes.Clientset, stop <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]创建选主所需的锁对象&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 创建锁对象</span><br>    lock := &amp;resourcelock.LeaseLock&#123;<br>        LeaseMeta: metav1.ObjectMeta&#123;<br>            Name:      <span class="hljs-string">&quot;leader-tutorials&quot;</span>,<br>            Namespace: NAMESPACE,<br>        &#125;,<br>        Client: clientset.CoordinationV1(),<br>        LockConfig: resourcelock.ResourceLockConfig&#123;<br>            Identity: processIndentify,<br>        &#125;,<br>    &#125;<br>    klog.Infof(<span class="hljs-string">&quot;[%s]开始选主&quot;</span>, processIndentify)<br>    <span class="hljs-comment">// 启动选主操作</span><br>    leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;<br>        Lock:            lock,<br>        ReleaseOnCancel: <span class="hljs-literal">true</span>,<br>        LeaseDuration:   <span class="hljs-number">10</span> * time.Second,<br>        RenewDeadline:   <span class="hljs-number">5</span> * time.Second,<br>        RetryPeriod:     <span class="hljs-number">2</span> * time.Second,<br>        Callbacks: leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]当前进程是leader，只有leader才能执行的业务逻辑立即开始&quot;</span>, processIndentify)<br>                <span class="hljs-comment">// 在这里写入选主成功的代码，</span><br>                <span class="hljs-comment">// 就像抢分布式锁一样，当前进程选举成功的时候，这的代码就会被执行，</span><br>                <span class="hljs-comment">// 所以，在这里填写抢锁成功的业务逻辑吧，本例中就是监听service变化，然后修改pod的label</span><br>                CreateAndStartController(ctx, clientset, &amp;v1.Service&#123;&#125;, <span class="hljs-string">&quot;services&quot;</span>, NAMESPACE, stop)<br>            &#125;,<br>            OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>                <span class="hljs-comment">// 失去了leader时的逻辑</span><br>                klog.Infof(<span class="hljs-string">&quot;[%s]失去leader身份，不再是leader了&quot;</span>, processIndentify)<br>                os.Exit(<span class="hljs-number">0</span>)<br>            &#125;,<br>            OnNewLeader: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span> &#123;<br>                <span class="hljs-comment">// 收到通知，知道最终的选举结果</span><br>                <span class="hljs-keyword">if</span> identity == processIndentify &#123;<br>                    klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，当前进程就是leader&quot;</span>, processIndentify)<br>                    <span class="hljs-comment">// I just got the lock</span><br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                klog.Infof(<span class="hljs-string">&quot;[%s]选主结果出来了，leader是 : [%s]&quot;</span>, processIndentify, identity)<br>            &#125;,<br>        &#125;,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>•上述代码中，请注意LeaderElectionConfig对象的几个重要字段，例如LeaseDuration、RenewDeadline、RetryPeriod这些，是和选主时候的续租、超时、重试相关，需要按照您的实际网络情况进行调整•现在代码写完了，可以开始验证了</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>•这里捋一下验证的步骤</p><p>1.构建项目，生产二进制文件2.执行此二进制文件，启动三个进程3.观察日志，应该有一个进程选举成功，另外两个只会在日志输出选主结果4.修改service资源，再去观察日志，发现leader进程会输出日志，再检查pod的label，发现已经修改5.用ctrl+C命令将leader进程退出，可见另外两个进程会有一个成为新的leader6.再次修改service资源，新的leader会负责更新pod的label</p><p>•接下来开始操作</p><p>1.执行命令go build，对当前工程进行编译构建，得到二进制文件leader-tutorials2.打开三个终端窗口，输入同样的命令.&#x2F;leader-tutorials，选主成功的进程日志如下，之前操作过的残留，所以没有一开始就选主成功，而是等了几秒后才成为leader，一旦成为leader，全量同步service会触发一次pod的更新操作</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/cf656b2b31af8deecf6f3006945138e9.png" alt="Image 44: 在这里插入图片描述"></p><p>•再去看另外两个进程的日志，可见已经识别到leader的身份，于是就没有执行controller的逻辑</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/aca4a7a4b411ea9367898a8bf8243fe0.png" alt="Image 45: 在这里插入图片描述"></p><p>•现在去修改service，用命令kubectl edit service nginx-service -n client-go-tutorials编辑，我这里是给service增加了一个label，如下图所示<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/baf02a2ee6822724c9eef9c0afad8fc9.png" alt="Image 46: 在这里插入图片描述"></p><p>•此刻，leader进程会监听到service变化，下图黄色箭头以下的内容就是处理pod的日志<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/c9616846888ce5759fb84403e098f77f.png" alt="Image 47: 在这里插入图片描述"></p><p>•去看另外两个进程的日志，不会有任何变化，因为controller都没有•执行以下命令查看pod的修改情况(注意pod的名字要从您自己的环境复制)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl describe pod nginx-deployment-78f6b696d9-cr47w -n client-go-tutorials<br></code></pre></td></tr></table></figure><p>•可以看到pod的label有变化，如下图黄色箭头所示，这和上面的leader日志的时间是一致的</p><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/818ef75c8437ca25ac96894630b5b080.png" alt="Image 48: 在这里插入图片描述"></p><p>•目前leader进程工作正常，再来试试leader进程退出后的情况，用ctrl+C终止leader进程•再去看另外两个进程的日志，发现其中一个成功成为新的leader<br><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB-%E5%AE%9E%E6%88%98%E9%AA%8C%E8%AF%81/56e49cc164c374ce25a764dc04a04f50.png" alt="Image 49: 在这里插入图片描述"></p><p>•验证完成，都符合预期•至此，client-go的选主功能实战就完成了，如果您在寻找kubernetes原生的分布式锁方案，希望本篇能给您一些参考</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k8s-选主</title>
    <link href="/2025/03/27/k8s-%E9%80%89%E4%B8%BB/"/>
    <url>/2025/03/27/k8s-%E9%80%89%E4%B8%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="k8s-选主"><a href="#k8s-选主" class="headerlink" title="k8s-选主"></a>k8s-选主</h1><p>选主是为了在多副本的情况下，避免同一个操作被所有副本分别执行一次（实际只需要执行一次）。</p><p>所以将只需要执行一次的逻辑封装进一个函数，在执行这个函数之前，先进行选主，只有成为leader的副本才会执行该函数。</p><p>实际应用中，可以将自定义的controller逻辑封装起来，只在选主成功的副本里运行controller。其余的副本什么也不做，只是待命而已。这样在leader挂了之后，能快速的切换leader，保证业务逻辑快速恢复。</p><p>转自：<a href="https://qiankunli.github.io/2021/01/13/kubernetes_leader_election.html">https://qiankunli.github.io/2021/01/13/kubernetes_leader_election.html</a></p><p>假设run 是真正的业务逻辑，加入选主逻辑之后，将run挂在 <code>election.RunOrDie</code> 的 OnStartedLeading 回调上。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts">election.RunOrDie(election.LeaderElectionConfig<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">Lock:</span>          rl,<br><span class="hljs-symbol">LeaseDuration:</span> leaseDuration,<br><span class="hljs-symbol">RenewDeadline:</span> renewDuration,<br><span class="hljs-symbol">RetryPeriod:</span>   retryPeriod,<br><span class="hljs-symbol">Callbacks:</span> election.LeaderCallbacks<span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">OnStartedLeading:</span> run,<span class="hljs-comment">// 业务逻辑</span><br><span class="hljs-symbol">OnStoppedLeading:</span> func() <span class="hljs-punctuation">&#123;</span><br>log.Fatalf(<span class="hljs-string">&quot;leader election lost&quot;</span>)<br><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-punctuation">&#125;</span>)<br><span class="hljs-comment">// 笔者觉得应该函数封装下，直接 election.RunOrDie(rl,leaseDuration,renewDuration,retryPeriod,run)</span><br></code></pre></td></tr></table></figure><h2 id="选主原理"><a href="#选主原理" class="headerlink" title="选主原理"></a>选主原理</h2><p><strong>leaderelection 主要是利用了k8s API操作的原子性实现了一个分布式锁</strong>，在不断的竞争中进行选举。选中为leader的实体才会执行具体的业务代码。</p><p>代码结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">k8s.io/client-<span class="hljs-keyword">go</span>/tools/leaderelection<br>    /resourcelock<br>        /configmaplock.<span class="hljs-keyword">go</span><br>        /endpointslock.<span class="hljs-keyword">go</span><br>        /<span class="hljs-keyword">interface</span>.<span class="hljs-keyword">go</span>  <span class="hljs-comment">// 定义了锁的操作接口</span><br>        /leaselock.<span class="hljs-keyword">go</span><br>    /leaderelection.<span class="hljs-keyword">go</span><br>    /metrics.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure><p><img src="/2025/03/27/k8s-%E9%80%89%E4%B8%BB/leader_election.png" alt="img"></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><a href="http://www.xuyasong.com/?p=2037">K8S 中 scheduler 组件的选主逻辑</a>锁的存在形式：configmap&#x2F;endpoint 的annotation 上，key &#x3D; <code>control-plane.alpha.kubernetes.io/leader</code>， 值对应了 LeaderElectionRecord struct，记录了当前leader 的Identity 以及renewTime</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">apiVersion</span>: v1<br><span class="hljs-attribute">kind</span>: Endpoints<br><span class="hljs-attribute">metadata</span>:<br>  <span class="hljs-attribute">annotations</span>:<br>    <span class="hljs-attribute">control</span>-plane.alpha.kubernetes.io/leader: &#x27;&#123;<span class="hljs-string">&quot;holderIdentity&quot;</span>:<span class="hljs-string">&quot;instance-o24xykos-3_1ad55d32-2abe-49f7-9d68-33ec5eadb906&quot;</span>,<span class="hljs-string">&quot;leaseDurationSeconds&quot;</span>:<span class="hljs-number">15</span>,<span class="hljs-string">&quot;acquireTime&quot;</span>:<span class="hljs-string">&quot;2020-04-23T06:45:07Z&quot;</span>,<span class="hljs-string">&quot;renewTime&quot;</span>:<span class="hljs-string">&quot;2020-04-25T07:55:58Z&quot;</span>,<span class="hljs-string">&quot;leaderTransitions&quot;</span>:<span class="hljs-number">1</span>&#125;&#x27;<br>  <span class="hljs-attribute">creationTimestamp</span>: <span class="hljs-string">&quot;2020-04-22T12:05:29Z&quot;</span><br>  <span class="hljs-attribute">name</span>: kube-scheduler<br>  <span class="hljs-attribute">namespace</span>: kube-system<br>  <span class="hljs-attribute">resourceVersion</span>: <span class="hljs-string">&quot;467853&quot;</span><br>  <span class="hljs-attribute">selfLink</span>: /api/v1/namespaces/kube-system/endpoints/kube-scheduler<br>  <span class="hljs-attribute">uid</span>: f3535807-<span class="hljs-number">0575</span>-<span class="hljs-number">483</span>f-<span class="hljs-number">8471</span>-f8d4fd9eeac6<br></code></pre></td></tr></table></figure><p>“锁”即annotation value 记录了 leader 的一些信息</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">&#123;<br>    &quot;holderIdentity&quot;: &quot;instance-o24xykos<span class="hljs-string">-3</span>_1ad55d32<span class="hljs-string">-2</span>abe<span class="hljs-string">-49</span>f7<span class="hljs-string">-9</span>d68<span class="hljs-string">-33</span>ec5eadb906&quot;, <br>    &quot;leaseDurationSeconds&quot;: 15, <br>    &quot;acquireTime&quot;: &quot;2020<span class="hljs-string">-04</span><span class="hljs-string">-23</span>T06:45:07Z&quot;, <br>    &quot;renewTime&quot;: &quot;2020<span class="hljs-string">-04</span><span class="hljs-string">-25</span>T07:55:58Z&quot;, <br>    &quot;leaderTransitions&quot;: 1<br>&#125;<br></code></pre></td></tr></table></figure><p>代码体现</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs elm">// k8s.io/client-go/tools/leaderelection/resourcelock/interface.go<br><span class="hljs-keyword">type</span> <span class="hljs-type">Interface</span> interface &#123;<br>// <span class="hljs-type">Get</span> returns the <span class="hljs-type">LeaderElectionRecord</span><br><span class="hljs-type">Get</span>() (*<span class="hljs-type">LeaderElectionRecord</span>, error)<br>// <span class="hljs-type">Create</span> attempts to create a <span class="hljs-type">LeaderElectionRecord</span><br><span class="hljs-type">Create</span>(ler <span class="hljs-type">LeaderElectionRecord</span>) error<br>// <span class="hljs-type">Update</span> will update and existing <span class="hljs-type">LeaderElectionRecord</span><br>    <span class="hljs-type">Update</span>(ler <span class="hljs-type">LeaderElectionRecord</span>) error<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>kubernetes 的 update 是原子的、安全的</strong>：Kubernetes 通过定义资源版本字段实现了乐观并发控制，资源版本 (ResourceVersion)字段包含在 Kubernetes 对象的元数据 (Metadata)中。这个字符串格式的字段标识了对象的内部版本号，其取值来自 etcd 的 modifiedindex，且当对象被修改时，该字段将随之被修改。值得注意的是该字段由服务端维护</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> ObjectMeta <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a   resource or set of resources.Clients must treat these values as opaque and passed unmodified   back to the server.They may only be valid for a particular resource or set of resources.</span><br>    <span class="hljs-comment">// Populated by the system.Read-only.</span><br>    ResourceVersion <span class="hljs-keyword">string</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>所谓的选主，就是看哪个follower能将自己的信息更新到 object 的annotation 上</strong>。</p><h3 id="选主逻辑"><a href="#选主逻辑" class="headerlink" title="选主逻辑"></a>选主逻辑</h3><ol><li>leader 每隔RetryPeriod时间会通过tryAcquireOrRenew续约, 如果续约失败, 还会进行再次尝试. 一直到尝试的总时间超过RenewDeadline后该client就会失去leadership.</li><li>follower 获得leadership需要的等待LeaseDuration 时间.</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// client-go/tools/leaderelection/leaderelection.go</span><br>func <span class="hljs-built_in">RunOrDie</span>(ctx context<span class="hljs-selector-class">.Context</span>, lec LeaderElectionConfig) &#123;<br>le, err := <span class="hljs-built_in">NewLeaderElector</span>(lec)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">if</span> lec<span class="hljs-selector-class">.WatchDog</span> != nil &#123;<br>lec<span class="hljs-selector-class">.WatchDog</span><span class="hljs-selector-class">.SetLeaderElection</span>(le)<br>&#125;<br>le<span class="hljs-selector-class">.Run</span>(ctx)<br>&#125;<br><span class="hljs-comment">// 等待，直到ctx 取消/成为leader再失去leader 后返回</span><br>func (le *LeaderElector) <span class="hljs-built_in">Run</span>(ctx context.Context) &#123;<br>defer <span class="hljs-built_in">func</span>() &#123;<br>runtime<span class="hljs-selector-class">.HandleCrash</span>()<br>le<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.Callbacks</span><span class="hljs-selector-class">.OnStoppedLeading</span>()<br>    &#125;()<br>    <span class="hljs-comment">// 等待，除非成为leader（返回true） 或者ctx 取消（返回false）</span><br><span class="hljs-keyword">if</span> !le<span class="hljs-selector-class">.acquire</span>(ctx) &#123;<br>return <br>&#125;<br>ctx, cancel := context<span class="hljs-selector-class">.WithCancel</span>(ctx)<br>defer <span class="hljs-built_in">cancel</span>()<br>    go le<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.Callbacks</span><span class="hljs-selector-class">.OnStartedLeading</span>(ctx)<span class="hljs-comment">// 执行业务方法</span><br>    <span class="hljs-comment">// 成为leader后周期性续期，如果ctx 取消或失去leader 则立即返回</span><br>le<span class="hljs-selector-class">.renew</span>(ctx)<br>&#125;<br></code></pre></td></tr></table></figure><p>选主核心逻辑</p><ol><li>没有lock，抢占&#x2F;Create</li><li>已有lock，但是别人的，租约没过期则退出 再试，过期则抢占&#x2F;Update</li><li>已有lock，自己的，续期&#x2F;Update</li></ol><p>函数返回 True 说明本 goroutine 已成功抢占到锁，获得租约合同，成为 leader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(le *LeaderElector)</span></span> tryAcquireOrRenew() <span class="hljs-type">bool</span> &#123;<br>now := metav1.Now()<br>leaderElectionRecord := rl.LeaderElectionRecord&#123;...&#125;<br><span class="hljs-comment">// 1. obtain or create the ElectionRecord</span><br>oldLeaderElectionRecord, err := le.config.Lock.Get()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 获取锁信息失败则直接返回</span><br><span class="hljs-keyword">if</span> !errors.IsNotFound(err) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        <span class="hljs-comment">// 锁不存在则创建，创建失败则返回</span><br><span class="hljs-keyword">if</span> err = le.config.Lock.Create(leaderElectionRecord); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        <span class="hljs-comment">// 创建lock成功 即第一次选主抢占leader 成功，则返回</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">// 2. Record obtained, check the Identity &amp; Time</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(oldLeaderElectionRecord.HolderIdentity) &gt; <span class="hljs-number">0</span> &amp;&amp; le.observedTime.Add(le.config.LeaseDuration).After(now.Time) &amp;&amp;!le.IsLeader() &#123; <span class="hljs-comment">// 其他leader 未过期</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// 3. We&#x27;re going to try to update. The leaderElectionRecord is set to it&#x27;s default</span><br><span class="hljs-comment">// here. Let&#x27;s correct it before updating.</span><br><span class="hljs-keyword">if</span> le.IsLeader() &#123;<br>leaderElectionRecord.AcquireTime = oldLeaderElectionRecord.AcquireTime<br>leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>leaderElectionRecord.LeaderTransitions = oldLeaderElectionRecord.LeaderTransitions + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-comment">// update the lock itself</span><br><span class="hljs-keyword">if</span> err = le.config.Lock.Update(leaderElectionRecord); err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过LeaderCallbacks 感知leader 状态变化。回调OnStartedLeading 和 OnNewLeader 都会另起协程执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LeaderCallbacks <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// OnStartedLeading is called when a LeaderElector client starts leading</span><br>    <span class="hljs-comment">// 当选主逻辑退出时，会通过 context 传给OnStartedLeading</span><br>OnStartedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(context.Context)</span></span><br><span class="hljs-comment">// OnStoppedLeading is called when a LeaderElector client stops leading</span><br>OnStoppedLeading <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-comment">// OnNewLeader is called when the client observes a leader that is not the previously observed leader. This includes the first observed leader when the client starts.</span><br>OnNewLeader <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><p>k8s scheduler 调度器的执行入口是 <code>sched.Run</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// k8s.io/kubernetes/cmd/kube-scheduler/app/server.go</span><br>func <span class="hljs-keyword">Run</span>(ctx context.Context, <span class="hljs-keyword">cc</span> schedulerserverconfig.CompletedConfig, outOfTreeRegistryOptions ...Option) <span class="hljs-keyword">error</span> &#123;<br>    ...<br>    <span class="hljs-comment">// If leader election is enabled, runCommand via LeaderElector until done and exit.</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">cc</span>.LeaderElection != nil &#123;<br>        <span class="hljs-keyword">cc</span>.LeaderElection.Callbacks = leaderelection.LeaderCallbacks&#123;<br>            OnStartedLeading: sched.<span class="hljs-keyword">Run</span>,    <span class="hljs-comment">// 本节点成为leader时运行</span><br>            OnStoppedLeading: func() &#123;<br>                klog.Fatalf(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>            &#125;,<br>        &#125;<br>        leaderElector, <span class="hljs-keyword">err</span> := leaderelection.NewLeaderElector(*<span class="hljs-keyword">cc</span>.LeaderElection)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;<br>            <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;couldn&#x27;t create leader elector: %v&quot;</span>, <span class="hljs-keyword">err</span>)<br>        &#125;<br>        leaderElector.<span class="hljs-keyword">Run</span>(ctx)<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;lost lease&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 如果未开启选主</span><br>    sched.<span class="hljs-keyword">Run</span>(ctx)<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;finished without leader elect&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>k8s controller-manager 的选主逻辑</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// Run runs the KubeControllerManagerOptions.  This should never exit.</span><br>func <span class="hljs-built_in">Run</span>(c *config<span class="hljs-selector-class">.CompletedConfig</span>, stopCh &lt;-chan struct&#123;&#125;) error &#123;<br>    ...<br>    run := <span class="hljs-built_in">func</span>(ctx context.Context) &#123;<br>        ...<br>    &#125;<br>    ...<br>    rl, err := resourcelock<span class="hljs-selector-class">.New</span>(c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.ResourceLock</span>,...)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>klog<span class="hljs-selector-class">.Fatalf</span>(<span class="hljs-string">&quot;error creating lock: %v&quot;</span>, err)<br>    &#125;<br>    leaderelection<span class="hljs-selector-class">.RunOrDie</span>(context<span class="hljs-selector-class">.TODO</span>(), leaderelection.LeaderElectionConfig&#123;<br>Lock:          rl,<br>LeaseDuration: c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.LeaseDuration</span><span class="hljs-selector-class">.Duration</span>,<br>RenewDeadline: c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.RenewDeadline</span><span class="hljs-selector-class">.Duration</span>,<br>RetryPeriod:   c<span class="hljs-selector-class">.ComponentConfig</span><span class="hljs-selector-class">.Generic</span><span class="hljs-selector-class">.LeaderElection</span><span class="hljs-selector-class">.RetryPeriod</span><span class="hljs-selector-class">.Duration</span>,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: run,<br>OnStoppedLeading: <span class="hljs-built_in">func</span>() &#123;<br>klog<span class="hljs-selector-class">.Fatalf</span>(<span class="hljs-string">&quot;leaderelection lost&quot;</span>)<br>&#125;,<br>&#125;,<br>WatchDog: electionChecker,<br>Name:     <span class="hljs-string">&quot;kube-controller-manager&quot;</span>,<br>    &#125;)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unreachable&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>controller-runtime 是k8s 为支持自定义Controller 写的公共库，入口代码即为<code>Controller.Start</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cm *controllerManager)</span></span> Start(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br>    ...<br>    <span class="hljs-comment">// 启动不用选主的任务</span><br>    <span class="hljs-keyword">go</span> cm.startNonLeaderElectionRunnables()<br><span class="hljs-keyword">if</span> cm.resourceLock != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 如果resourceLock 不为空， 表示需要选主，启动选主逻辑</span><br>err := cm.startLeaderElection()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<br>&#125; <br>    ...<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cm *controllerManager)</span></span> startLeaderElection() (err <span class="hljs-type">error</span>) &#123;<br>l, err := leaderelection.NewLeaderElector(leaderelection.LeaderElectionConfig&#123;<br>Lock:          cm.resourceLock,<br>Callbacks: leaderelection.LeaderCallbacks&#123;<br>OnStartedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(_ context.Context)</span></span> &#123;<br>cm.startLeaderElectionRunnables()   <span class="hljs-comment">// 启动需要选主的任务</span><br>&#125;,<br>OnStoppedLeading: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>cm.errSignal.SignalError(fmt.Errorf(<span class="hljs-string">&quot;leader election lost&quot;</span>))<br>&#125;,<br>&#125;,<br>&#125;)<br>ctx, cancel := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-cm.internalStop:<br>cancel()<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>&#125;<br>&#125;()<br><span class="hljs-comment">// Start the leader elector process</span><br><span class="hljs-keyword">go</span> l.Run(ctx)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从示例中可以看到</p><ol><li>选主一般是一次性的，成为leader 后即执行核心业务逻辑，或者说业务逻辑由OnStartedLeading 触发。</li><li>如果成为leader 后失去leader，则主协程执行结束。</li></ol><p>scheduler 和 controller-manager 部署在容器中，所以主协程执行结束后，一般会自动重启。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang实现生产者消费者模型</title>
    <link href="/2025/03/25/golang%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/25/golang%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="golang实现生产者消费者模型"><a href="#golang实现生产者消费者模型" class="headerlink" title="golang实现生产者消费者模型"></a>golang实现生产者消费者模型</h1><p>使用context实现优雅退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">producer</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">int</span>, jobs <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; ; i++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">500</span>)) * time.Millisecond)<br>job := id*<span class="hljs-number">100</span> + i<br>jobs &lt;- job<br>fmt.Printf(<span class="hljs-string">&quot;Producer %d produced job %d\n&quot;</span>, id, job)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">consumer</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d exiting\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> job, ok := &lt;-jobs:<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d: channel closed\n&quot;</span>, id)<br><span class="hljs-keyword">return</span><br>&#125;<br>time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">1000</span>)) * time.Millisecond)<br>fmt.Printf(<span class="hljs-string">&quot;Consumer %d processed job %d\n&quot;</span>, id, job)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>rand.Seed(time.Now().UnixNano())<br><br><span class="hljs-keyword">const</span> numProducers = <span class="hljs-number">3</span><br><span class="hljs-keyword">const</span> numConsumers = <span class="hljs-number">2</span><br><br>jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">10</span>)<br>ctx, cancel := context.WithCancel(context.Background())<br><br><span class="hljs-comment">// 启动生产者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= numProducers; i++ &#123;<br><span class="hljs-keyword">go</span> producer(ctx, i, jobs)<br>&#125;<br><br><span class="hljs-comment">// 启动消费者</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= numConsumers; i++ &#123;<br><span class="hljs-keyword">go</span> consumer(ctx, i, jobs)<br>&#125;<br><br><span class="hljs-comment">// 运行一段时间后停止</span><br>time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;Stopping producers and consumers...&quot;</span>)<br>cancel() <span class="hljs-comment">// 发送停止信号</span><br><span class="hljs-built_in">close</span>(jobs) <span class="hljs-comment">// 关闭channel</span><br><br><span class="hljs-comment">// 等待一段时间让goroutine退出</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;All done&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang GC</title>
    <link href="/2025/03/25/Golang-GC/"/>
    <url>/2025/03/25/Golang-GC/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GC"><a href="#Golang-GC" class="headerlink" title="Golang GC"></a>Golang GC</h1><p>转自: <a href="https://www.yuque.com/aceld/golang/zhzanb">https://www.yuque.com/aceld/golang/zhzanb</a></p><p>本节为重点章节</p><p><img src="/2025/03/25/Golang-GC/1650786480776-52768cf0-0457-4875-a390-543ed516861f.webp" alt="Image 1: 标题.jpeg"></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV1wz4y1y7Kd">https://www.bilibili.com/video/BV1wz4y1y7Kd</a></p><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。GC过程中无需程序员手动执行。GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。</p><p>Golang在GC的演进过程中也经历了很多次变革，本文将按照一下顺序介绍：</p><ul><li>Go V1.3之前的标记-清除(mark and sweep)算法，缺点</li><li>Go V1.5的三色并发标记法</li><li>Go V1.5的三色标记为什么需要STW</li></ul><p>●Go V1.5的三色并发标记法<br>●Go V1.5的三色标记为什么需要STW<br>●Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 )<br>●Go V1.8混合写屏障机制<br>●Go V1.8混合写屏障机制的全场景分析</p><h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>接下来我们来看一下在Golang1.3之前的时候主要用的普通的标记-清除算法，此算法主要有两个主要的步骤：</p><p>●标记(Mark phase)<br>●清除(Sweep phase)</p><p>1 标记清除算法的具体步骤</p><p>第一步，暂停程序业务逻辑, 分类出可达和不可达的对象，然后做上标记。</p><p><img src="/2025/03/25/Golang-GC/1650787873045-d038fe47-4898-4b07-9e16-007bebb6fb9c.webp" alt="Image 2: 44-GC1.png"></p><p>图中表示是程序与对象的可达关系，目前程序的可达对象有对象1-2-3，对象4-7等五个对象。</p><p>第二步, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p><p><img src="/2025/03/25/Golang-GC/1650787891194-883ec541-5f13-4934-9274-080e5f44cf5e.webp" alt="Image 3: 42-GC2.png"></p><p>所以对象1-2-3、对象4-7等五个对象被做上标记。</p><p>第三步,  标记完了之后，然后开始清除未标记的对象. 结果如下。</p><p><img src="/2025/03/25/Golang-GC/1650787913616-ecf21ee2-c247-4401-9d3e-5e2fa278726f.webp" alt="Image 4: 45-GC3.png"></p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 STW(stop the world)，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，所以STW也是一些回收机制最大的难题和希望优化的点。所以在执行第三步的这段时间，程序会暂定停止任何工作，卡在那等待回收执行完毕。</p><p>第四步, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p><p>以上便是标记-清除（mark and sweep）回收的算法。</p><h2 id="二、-标记-清除-mark-and-sweep-的缺点"><a href="#二、-标记-清除-mark-and-sweep-的缺点" class="headerlink" title="二、 标记-清除(mark and sweep)的缺点"></a>二、 标记-清除(mark and sweep)的缺点</h2><p>标记清除算法明了，过程鲜明干脆，但是也有非常严重的问题。</p><p>●STW，stop the world；让程序暂停，程序出现卡顿 (重要问题)；<br>●标记需要扫描整个heap；<br>●清除数据会产生heap碎片。</p><p>Go V1.3版本之前就是以上来实施的,  在执行GC的基本流程就是首先启动STW暂停，然后执行标记，再执行数据回收，最后停止STW，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1650787936233-9002040d-220b-4af6-8e51-75d7887569b4.webp" alt="Image 5: 53-STW1.png"></p><p>从上图来看，全部的GC时间都是包裹在STW范围之内的，这样貌似程序暂停的时间过长，影响程序的运行性能。所以Go V1.3 做了简单的优化,将STW的步骤提前, 减少STW暂停的时间范围.如下所示</p><p><img src="/2025/03/25/Golang-GC/1650788071197-26a29703-0fb5-43f4-afc5-87a35fc78a4b.webp" alt="Image 6: 54-STW2.png"></p><p>上图主要是将STW的步骤提前了一步，因为在Sweep清除的时候，可以不需要STW停止，因为这些对象已经是不可达对象了，不会出现回收写冲突等问题。</p><p>但是无论怎么优化，Go V1.3都面临这个一个重要问题，就是mark-and-sweep 算法会暂停整个程序 。</p><p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用三色并发标记法来优化这个问题.</p><h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，所谓三色标记法实际上就是通过三个阶段的标记来确定清楚的对象都有哪些？我们来看一下具体的过程。</p><p>第一步 , 每次新创建的对象，默认的颜色都是标记为“白色”，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035738281-051f7a89-e07f-418c-ad0e-7cb94ef1a3b8.webp" alt="Image 7: 46-GC4.png"></p><p>上图所示，我们的程序可抵达的内存对象关系如左图所示，右边的标记表，是用来记录目前每个对象的标记颜色分类。这里面需要注意的是，所谓“程序”，则是一些对象的根节点集合。所以我们如果将“程序”展开，会得到类似如下的表现形式，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035821416-b0ad644e-ef8e-440a-bbf4-b9e24a7e0257.webp" alt="Image 8: 47-GC5.jpeg"></p><p>第二步, 每次GC回收开始, 会从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035842467-7341846f-6dee-4f8b-ad37-dc9723aa6407.webp" alt="Image 9: 48-GC6.jpeg"></p><p>这里 要注意的是，本次遍历是一次遍历，非递归形式，是从程序抽次可抵达的对象遍历一层，如上图所示，当前可抵达的对象是对象1和对象4，那么自然本轮遍历结束，对象1和对象4就会被标记为灰色，灰色标记表就会多出这两个对象。</p><p>第三步, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035859950-96053775-24f7-4bdc-a1fb-295747055b3e.webp" alt="Image 10: 49-GC7.jpeg"></p><p>这一次遍历是只扫描灰色对象，将灰色对象的第一层遍历可抵达的对象由白色变为灰色，如：对象2、对象7. 而之前的灰色对象1和对象4则会被标记为黑色，同时由灰色标记表移动到黑色标记表中。</p><p>第四步, 重复第三步, 直到灰色中无任何对象，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035907012-927d6cbc-686b-4f81-a1de-097ac7598a8e.webp" alt="Image 11: 50-GC8.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651035916208-9c293dc0-8988-4180-a9b7-412e2599af0e.webp" alt="Image 12: 51-GC9.jpeg"></p><p>当我们全部的可达对象都遍历完后，灰色标记表将不再存在灰色对象，目前全部内存的数据只有两种颜色，黑色和白色。那么黑色对象就是我们程序逻辑可达（需要的）对象，这些数据是目前支撑程序正常业务运行的，是合法的有用数据，不可删除，白色的对象是全部不可达对象，目前程序逻辑并不依赖他们，那么白色对象就是内存中目前的垃圾数据，需要被清除。</p><p>第五步: 回收所有的白色标记表的对象. 也就是回收垃圾，如图所示。 以上我们将全部的白色对象进行删除回收，</p><p><img src="/2025/03/25/Golang-GC/1651035960263-e50436a6-4a3c-48f9-82cb-bb5729d71116.webp" alt="Image 13: 52-GC10.jpeg"></p><p>剩下的就是全部依赖的黑色对象。</p><p>以上便是三色并发标记法，不难看出，我们上面已经清楚的体现三色的特性。但是这里面可能会有很多并发流程均会被扫描，执行并发流程的内存可能相互依赖，为了在GC过程中保证数据的安全，我们在开始三色标记之前就会加上STW，在扫描确定黑白对象之后再放开STW。但是很明显这样的GC扫描的性能实在是太低了。</p><p>那么Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p><h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>先抛砖引玉，我们加入如果没有STW，那么也就不会再存在性能上的问题，那么接下来我们假设如果三色标记法不加入STW会发生什么事情？ 我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性，我们来看看一个场景，如果三色标记法, 标记过程不使用STW将会发生什么事情?</p><p>我们把初始状态设置为已经经历了第一轮扫描，目前黑色的有对象1和对象4， 灰色的有对象2和对象7，其他的为白色对象，且对象2是通过指针p指向对象3的，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651035994109-83972e84-be65-4950-b9bf-a48b676856a5.webp" alt="Image 14: 55-三色标记问题1.jpeg"></p><p>现在如何三色标记过程不启动STW，那么在GC扫描过程中，任意的对象均可能发生读写操作，如图所示，在还没有扫描到对象2的时候，已经标记为黑色的对象4，此时创建指针q，并且指向白色的对象3。</p><p><img src="/2025/03/25/Golang-GC/1651036029588-29e317e6-8f92-41ca-a28e-65153913d227.webp" alt="Image 15: 56-三色标记问题2.jpeg"></p><p>与此同时灰色的对象2将指针p移除，那么白色的对象3实则就是被挂在了已经扫描完成的黑色的对象4下，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036292354-f70d8185-66a2-4478-9036-b4de940285c5.webp" alt="Image 16: 57-三色标记问题3.jpeg"></p><p>然后我们正常指向三色标记的算法逻辑，将所有灰色的对象标记为黑色，那么对象2和对象7就被标记成了黑色，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036347628-d63c17c4-7cee-4149-8ce9-13cc11bbd343.webp" alt="Image 17: 58-三色标记问题4.jpeg"></p><p>那么就执行了三色标记的最后一步，将所有白色对象当做垃圾进行回收，如图所示。</p><p><img src="/2025/03/25/Golang-GC/1651036362636-5a98e196-e1cd-49fc-9542-1cb0772a41c4.webp" alt="Image 18: 59-三色标记问题5.jpeg"></p><p>但是最后我们才发现，本来是对象4合法引用的对象3，却被GC给“误杀”回收掉了。</p><p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p><p>●条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)<br>●条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色) 如果当以上两个条件同时满足时，就会出现对象丢失现象!</p><p>并且，如图所示的场景中，如果示例中的白色对象3还有很多下游对象的话, 也会一并都清理掉。</p><p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是STW的过程有明显的资源浪费，对所有的用户程序都有很大影响。那么是否可以在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？答案是可以的，我们只要使用一种机制，尝试去破坏上面的两个必要条件就可以了。</p><h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。  这两种方式就是“强三色不变式”和“弱三色不变式”。</p><p>(1) “强-弱” 三色不变式</p><p>●强三色不变式</p><p>不存在黑色对象引用到白色对象的指针。</p><p><img src="/2025/03/25/Golang-GC/1651036383192-cb6b9fe9-4946-47da-bb9a-643f0c38a654.webp" alt="Image 19: 60-三色标记问题6.jpeg"></p><p>强三色不变色实际上是强制性的不允许黑色对象引用白色对象，这样就不会出现有白色对象被误删的情况。</p><p>●弱三色不变式</p><p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p><p><img src="/2025/03/25/Golang-GC/1651036404003-e0ea569e-7a8a-4d9f-a08f-4bb9ed5c64ed.webp" alt="Image 20: 61-三色标记问题7.jpeg"></p><p>弱三色不变式强调，黑色对象可以引用白色对象，但是这个白色对象必须存在其他灰色对象对它的引用，或者可达它的链路上游存在灰色对象。 这样实则是黑色对象引用白色对象，白色对象处于一个危险被删除的状态，但是上游灰色对象的引用，可以保护该白色对象，使其安全。</p><p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</p><p>(2)  插入屏障</p><p>具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p><p>满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p>伪码如下:</p><p>场景：</p><p>这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, 栈和堆. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在栈空间的对象操作中不使用. 而仅仅使用在堆空间对象的操作中.</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="/2025/03/25/Golang-GC/1651036442131-91f36e55-5c94-4931-a140-58ff5627c681.webp" alt="Image 21: 62-三色标记插入写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036449149-2fb53d7c-d351-4305-84a8-7a1b51806ce4.webp" alt="Image 22: 63-三色标记插入写屏障2.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036456806-6b1aeb27-831d-43d9-a79e-4dad49fea07d.webp" alt="Image 23: 64-三色标记插入写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036465710-e260440e-b53d-4f76-a826-842e28666efe.webp" alt="Image 24: 65-三色标记插入写屏障4.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036474130-755abe1f-d070-47e6-93cf-7aa129489206.webp" alt="Image 25: 66-三色标记插入写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036481384-c4e44929-09e4-4a05-81bb-b5e9ed195982.webp" alt="Image 26: 67-三色标记插入写屏障6.jpeg"></p><p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9).  所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p><p><img src="/2025/03/25/Golang-GC/1651036522462-5e0c1ea9-e136-45c8-9648-bf691b270431.webp" alt="Image 27: 68-三色标记插入写屏障7.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036531031-d37d4239-9b13-4d0e-a9cc-d7bc230d56a8.webp" alt="Image 28: 69-三色标记插入写屏障9.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036538543-d84895c0-451d-4c49-9c67-f77dcf5a3ae9.webp" alt="Image 29: 70-三色标记插入写屏障10.jpeg"></p><p>最后将栈和堆空间 扫描剩余的全部 白色节点清除.  这次STW大约的时间在10~100ms间.</p><p><img src="/2025/03/25/Golang-GC/1651036559017-4564c417-9059-415c-aa81-d9504ac4e00b.webp" alt="Image 30: 71-三色标记插入写屏障11.jpeg"></p><p>(3)  删除屏障</p><p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p><p>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p><p>伪代码：</p><p>场景：</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p><img src="/2025/03/25/Golang-GC/1651036621717-80ea507c-99a9-4e61-9bde-b4cd33f478f4.webp" alt="Image 31: 72-三色标记删除写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036629775-bc69d08e-c270-46ad-b82b-5ad0d0bdcb64.webp" alt="Image 32: 73-三色标记删除写屏障2.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036637089-52a0fc99-7805-40d0-aee7-4124017e90c8.webp" alt="Image 33: 74-三色标记删除写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036644794-05a69ec6-70c9-44c7-9493-44028ba4df7f.webp" alt="Image 34: 75-三色标记删除写屏障4.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036653171-57e34942-2091-4d76-83f3-0b084ebd577d.webp" alt="Image 35: 76-三色标记删除写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036660503-4f49f494-8ede-45dd-8a4c-bfa5499b307a.webp" alt="Image 36: 77-三色标记删除写屏障6.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036668136-8592bd0f-2210-48d9-b43d-7c4a2e16a287.webp" alt="Image 37: 78-三色标记删除写屏障7.jpeg"></p><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p><p>● 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；● 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。<br>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。<br>(1) 混合写屏障规则</p><p>具体操作:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p>满足: 变形的弱三色不变式.</p><p>伪代码：</p><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p><p>(2) 混合写屏障的具体场景分析</p><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p><p>GC开始：扫描栈区，将可达对象全部标记为黑</p><p><img src="/2025/03/25/Golang-GC/1651036708530-f7c50de5-6a63-45dc-baef-f53b1b42eb62.webp" alt="Image 38: 79-三色标记混合写屏障1.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036716310-65729a9c-d8df-40ce-9c2b-d35228278791.webp" alt="Image 39: 80-三色标记混合写屏障2.jpeg"></p><p>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036737874-a2f71441-c4f9-4f74-8c8a-c5a53bd35d4c.webp" alt="Image 40: 81-三色标记混合写屏障3.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036745104-24b7bf17-27b9-4531-97b7-48c5b7e64fac.webp" alt="Image 41: 82-三色标记混合写屏障4.jpeg"></p><p>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036778055-bda31c21-45dc-4602-9241-11a33b6393a6.webp" alt="Image 42: 83-三色标记混合写屏障5.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036785024-0edb665e-7b4b-46e3-b8cf-1d4ff02e73cd.webp" alt="Image 43: 84-三色标记混合写屏障6.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036791814-78eed337-a9ac-42d9-bcd8-99a21c01111c.webp" alt="Image 44: 85-三色标记混合写屏障7.jpeg"></p><p>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036826144-893174fb-0111-4838-9f7d-38fe2f89648a.webp" alt="Image 45: 86-三色标记混合写屏障8.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036833484-a18064d9-1329-42d7-8687-8a029542e85e.webp" alt="Image 46: 87-三色标记混合写屏障9.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036840569-f50df9db-5219-48fe-83ff-c3545ed4dec4.webp" alt="Image 47: 88-三色标记混合写屏障10.jpeg"></p><p>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</p><p>伪代码</p><p><img src="/2025/03/25/Golang-GC/1651036859560-21a75ea4-ee66-46ae-81bc-ce4e697c3814.webp" alt="Image 48: 89-三色标记混合写屏障11.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036864959-929ec428-e8d8-48a9-aaeb-e2589723ec62.webp" alt="Image 49: 90-三色标记混合写屏障12.jpeg"></p><p><img src="/2025/03/25/Golang-GC/1651036876957-976a0ac6-6c82-4eca-88f3-10180782281c.webp" alt="Image 50: 91-三色标记混合写屏障13.jpeg"></p><p>Golang中的混合写屏障满足弱三色不变式，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>你觉得怎么样才是好产品</title>
    <link href="/2025/03/25/%E4%BD%A0%E8%A7%89%E5%BE%97%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E6%98%AF%E5%A5%BD%E4%BA%A7%E5%93%81/"/>
    <url>/2025/03/25/%E4%BD%A0%E8%A7%89%E5%BE%97%E6%80%8E%E4%B9%88%E6%A0%B7%E6%89%8D%E6%98%AF%E5%A5%BD%E4%BA%A7%E5%93%81/</url>
    
    <content type="html"><![CDATA[<h1 id="如何回答”你觉得怎么样才是好产品”的面试问题"><a href="#如何回答”你觉得怎么样才是好产品”的面试问题" class="headerlink" title="如何回答”你觉得怎么样才是好产品”的面试问题"></a>如何回答”你觉得怎么样才是好产品”的面试问题</h1><p>在程序员面试中被问到”你觉得怎么样才是好产品”时，这是一个展示你技术思维与产品思维结合能力的好机会。以下是一个结构化的回答框架：</p><h2 id="1-从用户角度出发"><a href="#1-从用户角度出发" class="headerlink" title="1. 从用户角度出发"></a>1. 从用户角度出发</h2><p>“我认为一个好产品首先要解决真实用户的痛点。它应该：</p><ul><li>满足目标用户的核心需求（刚需）</li><li>提供简单直观的用户体验</li><li>在使用过程中让用户感到愉悦而不是挫败</li></ul><p>比如Slack之所以成功，就是因为它解决了团队沟通中的信息碎片化问题，而且使用起来非常直观。”</p><h2 id="2-加入技术视角"><a href="#2-加入技术视角" class="headerlink" title="2. 加入技术视角"></a>2. 加入技术视角</h2><p>“从技术实现角度看，好产品还应该具备：</p><ul><li><strong>稳定性</strong>：少崩溃、少bug</li><li><strong>性能</strong>：响应快速，不卡顿</li><li><strong>可扩展性</strong>：能随着用户增长而扩展</li><li><strong>安全性</strong>：保护用户数据和隐私</li></ul><p>例如微信在保证海量用户同时在线时的稳定性表现就非常出色。”</p><h2 id="3-商业可持续性"><a href="#3-商业可持续性" class="headerlink" title="3. 商业可持续性"></a>3. 商业可持续性</h2><p>“好产品还需要具备商业可持续性：</p><ul><li>有清晰的盈利模式</li><li>用户获取成本(CA)低于用户生命周期价值(LTV)</li><li>能形成竞争壁垒</li></ul><p>像Notion通过免费增值模式(Freemium)既获得了大量用户，又实现了盈利。”</p><h2 id="4-数据驱动迭代"><a href="#4-数据驱动迭代" class="headerlink" title="4. 数据驱动迭代"></a>4. 数据驱动迭代</h2><p>“真正的好产品会：</p><ul><li>建立完善的数据指标体系</li><li>通过A&#x2F;B测试持续优化</li><li>根据用户反馈快速迭代</li></ul><p>比如抖音的推荐算法就是通过持续的数据分析和优化，才达到如此精准的个性化推荐。”</p><h2 id="5-结合应聘公司产品"><a href="#5-结合应聘公司产品" class="headerlink" title="5. 结合应聘公司产品"></a>5. 结合应聘公司产品</h2><p>“特别是对于贵公司的产品[XXX]，我认为它很好地体现了这些特质，比如…[具体举例]。如果我有机会加入，我希望能在[某个技术方面]做出贡献，帮助产品变得更好。”</p><h2 id="回答技巧"><a href="#回答技巧" class="headerlink" title="回答技巧"></a>回答技巧</h2><ol><li><strong>结构化表达</strong>：使用清晰的逻辑框架(如上述几点)</li><li><strong>举例说明</strong>：引用知名产品或该公司产品为例</li><li><strong>展现技术深度</strong>：作为程序员，要展示你从技术角度对产品的理解</li><li><strong>适度谦虚</strong>：”这是我目前的理解，当然好产品的标准可能还有很多…”</li><li><strong>关联岗位</strong>：最后可以关联到你应聘的岗位如何帮助打造好产品</li></ol><p>记住，面试官问这个问题不仅是考察你的产品思维，也在观察你的沟通表达能力和逻辑思维能力。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang GMP模型</title>
    <link href="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-GMP模型"><a href="#Golang-GMP模型" class="headerlink" title="Golang GMP模型"></a>Golang GMP模型</h1><p>转自：<a href="https://www.yuque.com/aceld/golang/srxd6d">https://www.yuque.com/aceld/golang/srxd6d</a></p><p>本节为重点章节 本章节含视频版:</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650775952013-f19f9c96-b995-42d6-bc9c-8b1e73b602d8.webp" alt="Image 1: GPM封面.png"></p><p>视频链接地址：<a href="https://www.bilibili.com/video/BV19r4y1w7Nx">https://www.bilibili.com/video/BV19r4y1w7Nx</a></p><h2 id="一、Golang“调度器”的由来？"><a href="#一、Golang“调度器”的由来？" class="headerlink" title="一、Golang“调度器”的由来？"></a>一、Golang“调度器”的由来？</h2><h3 id="1-单进程时代不需要调度器"><a href="#1-单进程时代不需要调度器" class="headerlink" title="(1) 单进程时代不需要调度器"></a>(1) 单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是“单进程时代”</p><p>一切的程序只能串行发生。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776039816-a8a5efb6-06be-4984-bfb0-7565c14b0a61.webp" alt="Image 2: 5-单进程操作系统.png"></p><p>早期的单进程操作系统，面临2个问题：</p><p>1.单一的执行流程，计算机只能一个任务一个任务处理。</p><p>2.进程阻塞所带来的CPU时间浪费。</p><p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p><p>后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p><h3 id="2-多进程-线程时代有了调度器需求"><a href="#2-多进程-线程时代有了调度器需求" class="headerlink" title="(2)多进程&#x2F;线程时代有了调度器需求"></a>(2)多进程&#x2F;线程时代有了调度器需求</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776059361-384f6fb5-e2b1-4f99-8701-f57694aa8ecb.webp" alt="Image 3: 6-多进程操作系统.png"></p><p>在多进程&#x2F;多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p><p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p><p>怎么才能提高CPU的利用率呢？</p><p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776077730-2a6860a3-0466-4df9-925d-9ecd5cb9ad7d.webp" alt="Image 4: 7-cpu切换浪费成本.png"></p><p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p><h3 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3) 协程来提高CPU利用率"></a>(3) 协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。</p><p>大量的进程&#x2F;线程出现了新的问题</p><p>●高内存占用<br>●调度的高消耗CPU</p><p>好了，然后工程师们就发现，其实一个线程分为<strong>“内核态“线程和”用户态“线程</strong>。</p><p><strong>一个“用户态线程”必须要绑定一个“内核态线程”</strong>，但是**CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)**。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776112186-eff4e8b8-8742-44cd-a828-db1653649ee7.webp" alt="Image 5: 8-线程的内核和用户态.png"></p><p>这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”.</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776128796-5b795bfb-3289-4f6b-85a0-f24399dfc79c.webp" alt="Image 6: 9-协程和线程.png"></p><p>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p><p>之后，我们就看到了有3中协程和线程的映射关系：</p><p>N:1关系</p><p>N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上</p><p>缺点：</p><p>●某个程序用不了硬件的多核加速能力<br>●一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776145617-04763b3d-1b15-42c7-9653-cde21bcc98bc.webp" alt="Image 7: 10-N-1关系.png"></p><p>1:1 关系</p><p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，</p><p>缺点：</p><p>●协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776180139-043037ed-cb5b-4c24-9fcf-691a05db17f9.webp" alt="Image 8: 11-1-1.png"></p><p>M:N关系</p><p>M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776193242-4fecd540-5cbb-4f2d-8121-5312dbc6958a.webp" alt="Image 9: 12-m-n.png"></p><p>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p><h3 id="4-Go语言的协程goroutine"><a href="#4-Go语言的协程goroutine" class="headerlink" title="(4) Go语言的协程goroutine"></a>(4) Go语言的协程goroutine</h3><p>Go为了提供更容易使用的并发方法，使用了goroutine和channel。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被runtime调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p><p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。</p><p>Goroutine特点：</p><p>●占用内存更小（几kb）<br>●调度更灵活(runtime调度)</p><h3 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5) 被废弃的goroutine调度器"></a>(5) 被废弃的goroutine调度器</h3><p>好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p><p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p><p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776259684-6015cb7b-b33e-47f9-b241-185c57dc2745.webp" alt="Image 10: 13-gm.png"></p><p>下面我们来看看被废弃的golang调度器是如何实现的？</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776272668-ac680807-d927-4c10-9e1d-3960bdabd0e3.webp" alt="Image 11: 14-old调度器.png"></p><p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局G队列是有互斥锁进行保护的。</p><p>老调度器有几个缺点：</p><ol><li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。</li><li>M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li><li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li></ol><h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。</p><p>在新调度器中，除了M(thread)和G(goroutine)，又引进了P(Processor)。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776288599-36c23cc6-3d25-4f6f-8f80-83bd43aa6dec.webp" alt="Image 12: 15-gmp.png"></p><p>Processor，它包含了运行goroutine的资源，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p><h3 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1) GMP模型"></a>(1) GMP模型</h3><p>在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776301442-fb76123c-8d0e-4375-af35-b5728a5b1bc7.webp" alt="Image 13: 16-GMP-调度.png"></p><ol><li>全局队列（Global Queue）：存放等待运行的G。</li><li>P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li><li>P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。</li><li>M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li></ol><p>Goroutine调度器和OS调度器是通过M结合起来的，<strong>每个M都代表了1个内核线程</strong>，OS调度器负责把内核线程分配到CPU的核上执行。</p><p>有关P和M的个数问题</p><p>1、P的数量：</p><p>●由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行。</p><p>2、M的数量:</p><p>●go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。<br>●runtime&#x2F;debug中的SetMaxThreads函数，设置M的最大数量<br>●一个M阻塞了，会创建新的M。</p><p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p><p>P和M何时会被创建</p><p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p><p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p><h3 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2) 调度器的设计策略"></a>(2) 调度器的设计策略</h3><p>复用线程：避免频繁的创建、销毁线程，而是对线程的复用。</p><p>1）work stealing机制</p><p>当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。</p><p>2）hand off机制</p><p>当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。</p><p>利用并行：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS &#x3D; 核数&#x2F;2，则最多利用了一半的CPU核进行并行。</p><p>抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p><p>全局G队列：在新的调度器中依然有全局G队列，当P的本地队列为空时，优先从全局队列获取，如果全局队列为空时则通过work stealing机制从其他P的本地队列偷取G。</p><h3 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func()  调度流程"></a>(3) go func()  调度流程</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776333419-50d3a922-bd53-4bff-b0b6-280e6abc5d74.webp" alt="Image 14: 18-go-func调度周期.jpeg"></p><p>从上图我们可以分析出几个结论：</p><p>1、我们通过 go func()来创建一个goroutine；</p><p>2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；</p><p>3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；</p><p>4、一个M调度G执行的过程是一个循环机制；</p><p>5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在等待执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；</p><p>6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。</p><h3 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4) 调度器的生命周期"></a>(4) 调度器的生命周期</h3><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776346389-ab0ffa04-c707-4ec8-a810-0929533fd00c.webp" alt="Image 15: 17-pic-go调度器生命周期.png"></p><p>特殊的M0和G0</p><p>M0</p><p>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p><p>G0</p><p>G0是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p><p>我们来跟踪一段代码</p><p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p><p>也会经历如上图所示的过程：</p><ol><li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li><li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li><li>示例代码中的main函数是main.main，runtime中也有1个main函数——runtime.main，代码经过编译后，runtime.main会调用main.main，程序启动时会为runtime.main创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li><li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li><li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li><li>M运行G</li><li>G退出，再次回到M获取可运行的G，这样重复下去，直到main.main退出，runtime.main执行Defer和Panic处理，或调用runtime.exit退出程序。</li></ol><p>调度器的生命周期几乎占满了一个Go程序的一生，runtime.main的goroutine执行之前都是为调度器做准备工作，runtime.main的goroutine运行，才是调度器的真正开始，直到runtime.main结束而结束。</p><h3 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5) 可视化GMP编程"></a>(5) 可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据。</p><p>方式1：go tool trace</p><p>trace记录了运行时的信息，能提供可视化的Web页面。</p><p>简单测试代码：main函数创建trace，trace会运行在单独的goroutine中，然后main打印”Hello World”退出。</p><p>trace.go</p><p>运行程序</p><p>会得到一个trace.out文件，然后我们可以用一个工具打开，来分析这个文件。</p><p>我们可以通过浏览器打开<a href="http://127.0.0.1:33479网址，点击view">http://127.0.0.1:33479网址，点击view</a> trace 能够看见可视化的调度流程。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776395564-f4f1ba06-1af0-4842-a241-8ea7e56b0612.webp" alt="Image 16: 19-go-trace1.png"></p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776402701-9db41a28-ffc9-4702-8cd1-6670f8cd0d28.webp" alt="Image 17: 20-go-trace2.png"></p><p>G信息</p><p>点击Goroutines那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776424129-7608477e-4b67-40f3-8782-a0eb346ef8eb.webp" alt="Image 18: 20-go-trace3.png"></p><p>一共有两个G在程序中，一个是特殊的G0，是每个M必须有的一个初始化的G，这个我们不必讨论。</p><p>其中G1应该就是main goroutine(执行main函数的协程)，在一段时间内处于可运行和运行的状态。</p><p>M信息</p><p>点击Threads那一行可视化的数据条，我们会看到一些详细的信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776444325-d259c370-0aa5-4650-a5fd-2449190c97a1.webp" alt="Image 19: 22-go-trace4.png"></p><p>一共有两个M在程序中，一个是特殊的M0，用于初始化使用，这个我们不必讨论。</p><p>P信息</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776459340-7053a162-0e39-4955-b0e6-d4714171be3a.webp" alt="Image 20: 23-go-trace5.png"></p><p>G1中调用了main.main，创建了trace goroutine g18。G1运行在P1上，G18运行在P0上。</p><p>这里有两个P，我们知道，一个P必须绑定一个M才能调度G。</p><p>我们在来看看上面的M信息。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776484643-1c8841a4-01a1-4948-a8a7-616678fb5317.webp" alt="Image 21: 24-go-trace6.png"></p><p>我们会发现，确实G18在P0上被运行的时候，确实在Threads行多了一个M的数据，点击查看如下：</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776494915-1d38f0bf-cbd8-4958-ae55-1144a86e50a2.webp" alt="Image 22: 25-go-trace7.png"></p><p>多了一个M2应该就是P0为了执行G18而动态创建的M2.</p><p>方式2：Debug trace</p><p>编译</p><p>通过Debug方式运行</p><p>●SCHED：调试信息输出标志字符串，代表本行是goroutine调度器的输出；<br>●0ms：即从程序启动到输出这行日志的时间；<br>●gomaxprocs: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；<br>●idleprocs: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；<br>●threads: os threads&#x2F;M的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；<br>●spinningthreads: 处于自旋状态的os thread数量；<br>●idlethread: 处于idle状态的os thread的数量；<br>●runqueue&#x3D;0： Scheduler全局队列中G的数量；<br>●[0 0]: 分别为2个P的local queue中的G的数量。</p><p>下一篇，我们来继续详细的分析GMP调度原理的一些场景问题。</p><h2 id="三、Go调度器调度场景过程全解析"><a href="#三、Go调度器调度场景过程全解析" class="headerlink" title="三、Go调度器调度场景过程全解析"></a>三、Go调度器调度场景过程全解析</h2><p>(1)场景1</p><p>P拥有G1，M1获取P后开始运行G1，G1使用go func()创建了G2，为了局部性G2优先加入到P的本地队列。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776522560-a33b69e2-2842-4132-8cbe-f2bad017bc7e.webp" alt="Image 23: 26-gmp场景1.png"></p><p>(2)场景2</p><p>G1运行完成后(函数：goexit)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：schedule）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：execute)。实现了线程M1的复用。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776536644-c6fba007-d952-4a22-8939-ca1a898a5c3c.webp" alt="Image 24: 27-gmp场景2.png"></p><p>(3)场景3</p><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776549767-57ceac17-5504-46ac-af56-0dba59359e8b.webp" alt="Image 25: 28-gmp场景3.png"></p><p>(4)场景4</p><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行负载均衡(把P1中本地队列中前一半的G，还有新创建G转移到全局队列)</p><p>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776570176-d9d5abd4-3a48-461c-a43c-6ef504c4038f.webp" alt="Image 26: 29-gmp场景4.png"></p><p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。<br>(5)场景5</p><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776584395-dfb9c26b-b0a8-4c17-b46e-649302df87d5.webp" alt="Image 27: 30-gmp场景5.png"></p><p>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。<br>(6)场景6</p><p>规定：在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776600276-58bdcec4-00e6-4f24-89c8-e4f01fd1d9fb.webp" alt="Image 28: 31-gmp场景6.png"></p><p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程（没有G但为运行状态的线程，不断寻找G）。<br>(7)场景7</p><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：findrunnable()）。M2从全局队列取的G数量符合下面的公式：</p><p>相关源码参考:</p><p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是从全局队列到P本地队列的负载均衡。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650776688586-9207de08-5203-403f-8857-42942e84dcb1.webp" alt="Image 29: 32-gmp场景7.001.jpeg"></p><p>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。<br>(8)场景8</p><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777780659-cef000df-3d46-4fd5-b0ed-3dc466bf1cd2.webp" alt="Image 30: 33-gmp场景8.png"></p><p>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。<br>(9)场景9</p><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于自旋状态，它们不断寻找goroutine。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777794441-a7ed7fc2-e495-4022-a3b6-581930e5acd0.webp" alt="Image 31: 34-gmp场景9.png"></p><p>为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们希望当有新goroutine创建时，立刻能有M运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有GOMAXPROCS个自旋的线程(当前例子中的GOMAXPROCS&#x3D;4，所以一共4个P)，多余的没事做线程会让他们休眠。<br>(10)场景10</p><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;&#x3D;P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了阻塞的系统调用，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777810926-ca4030f3-f29a-4211-8722-677b229be440.webp" alt="Image 32: 35-gmp场景10.png"></p><p>(11)场景11</p><p>G8创建了G9，假如G8进行了非阻塞系统调用。</p><p><img src="/2025/03/24/Golang-GMP%E6%A8%A1%E5%9E%8B/1650777823944-25f0ea1a-3431-457e-b4cf-342654a953b6.webp" alt="Image 33: 36-gmp场景11.png"></p><p>M2和P2会解绑，但M2会记住P2，然后G8和M2进入系统调用状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go Map</title>
    <link href="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Map"><a href="#Go-Map" class="headerlink" title="Go Map"></a>Go Map</h1><p>map 是一种key-value的键值对存储结构，其中key不能重复，底层用<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=hash%E8%A1%A8&zhida_source=entity">hash表</a>存储。</p><p>平日里我们一般是这样使用map的：</p><blockquote><p>&#x2F;&#x2F; 创建<br>&#x2F;&#x2F; map[KeyType]ValueType<br>var m map[int]int<br>m :&#x3D; make(map[int]int)<br>m :&#x3D; map[int]int{<br>1: 1,<br>2: 2,<br>}<br>&#x2F;&#x2F; 读取<br>i :&#x3D; m[1]<br>v, ok :&#x3D; m[1]<br>​<br>&#x2F;&#x2F; 遍历<br>for key, value :&#x3D; range m {<br>println(“Key: “, key, “Value: “, value)<br>}<br>​<br>&#x2F;&#x2F; 删除<br>delete(m, 1)</p></blockquote><p>map的数据结构在源码结构中的关键字段如下，在<code>src/runtime/map.go</code>中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    count     <span class="hljs-type">int</span>    <span class="hljs-comment">// 元素的个数</span><br>    B         <span class="hljs-type">uint8</span>  <span class="hljs-comment">// buckets 数组的长度就是 2^B 个</span><br>    overflow <span class="hljs-type">uint16</span> <span class="hljs-comment">// 溢出桶的数量</span><br><br>    buckets    unsafe.Pointer <span class="hljs-comment">// 2^B个桶对应的数组指针</span><br>    oldbuckets unsafe.Pointer  <span class="hljs-comment">// 发生扩容时，记录扩容前的buckets数组指针</span><br><br>    extra *mapextra <span class="hljs-comment">//用于保存溢出桶的地址</span><br>&#125;<br><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>    overflow    *[]*bmap<br>    oldoverflow *[]*bmap<br><br>    nextOverflow *bmap<br>&#125;<br><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [bucketCnt]<span class="hljs-type">uint8</span><br>&#125;<br><br><span class="hljs-comment">//在编译期间会产生新的结构体</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    tophash [<span class="hljs-number">8</span>]<span class="hljs-type">uint8</span> <span class="hljs-comment">//存储哈希值的高8位</span><br>    data    <span class="hljs-type">byte</span>[<span class="hljs-number">1</span>]  <span class="hljs-comment">//key value数据:key/key/key/.../value/value/value...</span><br>    overflow *bmap   <span class="hljs-comment">//溢出bucket的地址</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了便于理解源码的结构，我们提炼关键字段并转换为图形模式：</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-a8fbef952441e788d882d0656c2cf091_1440w.jpg" alt="img"></p><p>在go的map实现中，它的底层结构体是hmap，hmap里维护着若干个bucket数组 (即桶数组)。</p><p>Bucket数组中每个元素都是bmap结构，也即每个bucket（桶）都是bmap结构，【ps：后文为了语义一致，和方便理解，就不再提bmap了，统一叫作桶】 每个桶中保存了8个kv对，如果8个满了，又来了一个key落在了这个桶里，会使用overflow连接下一个桶(溢出桶)。</p><h2 id="map中数据操作"><a href="#map中数据操作" class="headerlink" title="map中数据操作"></a><strong>map中数据操作</strong></h2><p>了解了map的数据结构后，下面让我们学习一下在map中存取数据的过程：</p><h3 id="GET获取数据"><a href="#GET获取数据" class="headerlink" title="GET获取数据"></a><strong>GET获取数据</strong></h3><p><strong>假设当前 B&#x3D;4 即桶数量为2^B&#x3D;16个</strong>，要从map中获取k4对应的value</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>参考上图，k4的get流程可以归纳为如下几步：</strong></p><p>①<strong>计算k4的hash值</strong>。[由于当前主流机都是64位操作系统，所以计算结果有64个比特位]</p><p>②<strong>通过最后的“B”位来确定在哪号桶</strong>，此时B为4，所以取k4对应哈希值的后4位，也就是0101，0101用十进制表示为5，所以在5号桶）</p><p>③<strong>根据k4对应的hash值前8位快速确定是在这个桶的哪个位置</strong>（额外说明一下，在bmap中存放了每个key对应的tophash，是key的哈希值前8位),一旦发现前8位一致，则会执行下一步</p><p>④<strong>对比key完整的hash是否匹配</strong>，如果匹配则获取对应value</p><p>⑤<strong>如果都没有找到，就去连接的下一个溢出桶中找</strong></p><p>有很多同学会问这里为什么要多维护一个tophash，即hash前8位？</p><p>这是因为tophash可以快速确定key是否正确，也可以把它理解成一种缓存措施，如果前8位都不对了，后面就没有必要比较了。</p><h3 id="PUT存放数据"><a href="#PUT存放数据" class="headerlink" title="PUT存放数据"></a><strong>PUT存放数据</strong></h3><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-c289a260a1d233fd862d79eef50fdf76_1440w.jpg" alt="img"></p><p>img</p><p><strong>map的赋值流程可总结位如下几步：</strong></p><p>①<strong>通过key的hash值后“B”位确定是哪一个桶</strong>，图中示例为4号桶。</p><p>② 遍历当前桶，通过key的tophash和hash值，防止key重复，然后<strong>找到第一个可以插入的位置</strong>，即空位置处存储数据。</p><p>③如果<strong>当前桶元素已满，会通过overflow链接创建一个新的桶</strong>，来存储数据。</p><p><strong>关于hash冲突</strong>：当两个不同的 key 落在同一个桶中，就是发生了哈希冲突。冲突的解决手段是采用链表法：在 桶 中，从前往后找到第一个空位进行插入。如果8个kv满了，那么当前桶就会连接到下一个溢出桶（bmap）。</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a><strong>扩容</strong></h3><h3 id="扩容的方式"><a href="#扩容的方式" class="headerlink" title="扩容的方式"></a><strong>扩容的方式</strong></h3><p>扩容有两种，一种是等量扩容，另一种是2倍扩容</p><ul><li><strong>相同容量扩容</strong></li></ul><p>由于map中不断的put和delete key，桶中可能会出现很多断断续续的空位，这些空位会导致连接的bmap溢出桶很长，导致扫描时间边长。这种扩容实际上是一种整理，把后置位的数据整理到前面。<strong>这种情况下，元素会发生重排，但不会换桶。</strong></p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-2ecbb8a8c52d395061f67e41620b1504_1440w.jpg" alt="img"></p><p>img</p><ul><li><strong>2倍容量扩容</strong></li></ul><p>这种2倍扩容是由于当前桶数组确实不够用了，<strong>发生这种扩容时，元素会重排，可能会发生桶迁移</strong>。</p><p>如图中所示，扩容前B&#x3D;2,扩容后B&#x3D;3，假设一元素key的hash值后三位为101，那么由上文的介绍可知，在扩容前，由hash值的后两位来决定几号桶，即 01 所以元素在1号桶。 在扩容发生后，由hash值得后三位来决定几号桶，即101所以元素会迁移到5号桶。</p><p><img src="/2025/03/22/go-map%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/v2-d38e6d960012d58d4192f904985a4ca1_1440w.jpg" alt="img"></p><p>img</p><h2 id="发生扩容的条件"><a href="#发生扩容的条件" class="headerlink" title="发生扩容的条件"></a><strong>发生扩容的条件</strong></h2><p>首先我们了解下**<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90&zhida_source=entity">装载因子</a>(loadFactor)**的概念</p><p>loadFactor:&#x3D;count &#x2F; (2^B) 即 装载因子 &#x3D; map中元素的个数 &#x2F; map中当前桶的个数</p><p>通过计算公式我们可以得知，<strong>装载因子是指当前map中，每个桶中的平均元素个数。</strong></p><p><strong>扩容条件1</strong>：<strong>装载因子 &gt; 6.5</strong> (源码中定义的)</p><p>这个也非常容易理解，正常情况下，如果没有溢出桶，那么一个桶中最多有8个元素，当平均每个桶中的数据超过了6.5个，那就意味着当前容量要不足了，发生扩容。</p><p><strong>扩容条件2</strong>: <strong>溢出桶的数量过多</strong></p><p>当 B &lt; 15 时，如果overflow的bucket数量超过 2^B。</p><p>当 B &gt;&#x3D; 15 时，overflow的bucket数量超过 2^15。</p><p>简单来讲，新加入key的hash值后B位都一样，使得个别桶一直在插入新数据，进而导致它的溢出桶链条越来越长。如此一来，当map在操作数据时，扫描速度就会变得很慢。及时的扩容，可以对这些元素进行重排，使元素在桶的位置更平均一些。</p><p><strong>扩容时的细节</strong></p><ol><li>在我们的hmap结构中有一个oldbuckets吗，扩容刚发生时，会先将老数据存到这个里面。</li><li>每次对map进行删改操作时，会触发从oldbucket中迁移到bucket的操作【非一次性，分多次】</li><li>在扩容没有完全迁移完成之前，每次get或者put遍历数据时，都会先遍历oldbuckets，然后再遍历buckets。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><p><strong>map是线程不安全的</strong></p><p>在同一时间点，两个 <a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=goroutine&zhida_source=entity">goroutine</a> 对同一个map进行读写操作是不安全的。举个栗子：</p><p>某map桶数量为4，即B&#x3D;2。此时 goroutine1来插入key1， goroutine2来读取 key2. 可能会发生如下过程：</p><p>① goroutine2 计算key2的hash值,B&#x3D;2，并确定桶号为1。</p><p>② goroutine1添加key1，触发扩容条件。</p><p>③ B&#x3D;B+1&#x3D;3, buckets数据迁移到oldbuckets。</p><p>④ goroutine2从桶1中遍历，获取数据失败。</p><p>在工作中，当我们涉及到对一个map进行并发读写时，一般采用的做法是采用golang中自带的<a href="https://zhida.zhihu.com/search?content_id=198353368&content_type=Article&match_order=1&q=mutex%E9%94%81&zhida_source=entity">mutex锁</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Resource <span class="hljs-keyword">struct</span> &#123;<br>    sync.RWMutex<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    r := Resource&#123;m: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)&#125;<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine写map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.Lock()<br>            r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)] = j<br>            r.Unlock()<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">//开一个goroutine读map</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ &#123;<br>            r.RLock()<br>            fmt.Println(r.m[fmt.Sprintf(<span class="hljs-string">&quot;resource_%d&quot;</span>, j)])<br>            r.RUnlock()<br>        &#125;<br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对map数据进行操作时不可取地址</li></ul><p>因为随着map元素的增长，map底层重新分配空间会导致之前的地址无效。</p><p>[<a href="https://zhuanlan.zhihu.com/p/495998623#ref_1">1]</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/495998623#ref_1_0">^</a>Map <a href="https://juejin.cn/post/7029679896183963678#heading-1">https://juejin.cn/post/7029679896183963678#heading-1</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.jpg" alt="排序算法"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) &lt;= <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums<br>    &#125;<br>    <span class="hljs-comment">// 冒泡排序核心实现代码</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        flag := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(nums) - i - <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[j] &gt; nums[j+<span class="hljs-number">1</span>] &#123;<br>                nums[j], nums[j+<span class="hljs-number">1</span>] = nums[j+<span class="hljs-number">1</span>], nums[j]<br>                flag = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> !flag &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br>    nums = bubbleSort(nums)<br>    fmt.Println(nums)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.webp" alt="冒泡排序"></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(list []<span class="hljs-type">int</span>, low, high <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    pivot := list[low] <span class="hljs-comment">//导致 low 位置值为空</span><br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        <span class="hljs-comment">//high指针值 &gt;= pivot high指针👈移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &lt;= list[high] &#123;<br>            high--<br>        &#125;<br>        <span class="hljs-comment">//填补low位置空值</span><br>        <span class="hljs-comment">//high指针值 &lt; pivot high值 移到low位置</span><br>        <span class="hljs-comment">//high 位置值空</span><br>        list[low] = list[high]<br>        <span class="hljs-comment">//low指针值 &lt;= pivot low指针👉移</span><br>        <span class="hljs-keyword">for</span> low &lt; high &amp;&amp; pivot &gt;= list[low] &#123;<br>            low++<br>        &#125;<br>        <span class="hljs-comment">//填补high位置空值</span><br>        <span class="hljs-comment">//low指针值 &gt; pivot low值 移到high位置</span><br>        <span class="hljs-comment">//low位置值空</span><br>        list[high] = list[low]<br>    &#125;<br>    <span class="hljs-comment">//pivot 填补 low位置的空值</span><br>    list[low] = pivot<br>    <span class="hljs-keyword">return</span> low<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(list []<span class="hljs-type">int</span>,low,high <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> high &gt; low&#123;<br>        <span class="hljs-comment">//位置划分</span><br>        pivot := partition(list,low,high)<br>        <span class="hljs-comment">//左边部分排序</span><br>        QuickSort(list,low,pivot<span class="hljs-number">-1</span>)<br>        <span class="hljs-comment">//右边排序</span><br>        QuickSort(list,pivot+<span class="hljs-number">1</span>,high)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestQuickSort</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    list := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>,<span class="hljs-number">44</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">33</span>,<span class="hljs-number">1</span>,<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>,<span class="hljs-number">54</span>,<span class="hljs-number">9</span>&#125;<br>    QuickSort(list,<span class="hljs-number">0</span>,<span class="hljs-built_in">len</span>(list)<span class="hljs-number">-1</span>)<br>    t.Log(list)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/quick_sort_partition_animation.gif" alt="快速排序"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入url后发生了什么</title>
    <link href="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器输入url后发生了什么"><a href="#浏览器输入url后发生了什么" class="headerlink" title="浏览器输入url后发生了什么"></a>浏览器输入url后发生了什么</h2><h3 id="1-输入地址"><a href="#1-输入地址" class="headerlink" title="1. 输入地址"></a>1. 输入地址</h3><p>浏览器从历史记录，书签中智能匹配url，甚至从缓存中直接把网页展示出来。</p><h3 id="2-浏览器查找域名对应的IP地址"><a href="#2-浏览器查找域名对应的IP地址" class="headerlink" title="2. 浏览器查找域名对应的IP地址"></a>2. 浏览器查找域名对应的IP地址</h3><ol><li><p>查找本地硬盘的hosts文件，如果有的话直接使用hosts文件中的ip地址。</p></li><li><p>如果hosts文件中没有，则向本地DNS服务器发送请求。本地DNS服务器一般是网络接入供应商提供，比如中国电信，中国移动。</p></li><li><p>本地DNS服务器查缓存，有的话就直接返回。</p></li><li><p>本地DNS服务器缓存没有命中的话，向根服务器查询。</p></li><li><p>根服务器提供下一层级服务器地址。</p></li><li><p>迭代查询直到查询到IP地址。</p></li><li><p>本地DNS服务器向浏览器返回IP地址，并将IP地址记录在自己的缓存中，已备下次使用。</p></li></ol><h3 id="3-浏览器跟web服务器建立TCP连接"><a href="#3-浏览器跟web服务器建立TCP连接" class="headerlink" title="3. 浏览器跟web服务器建立TCP连接"></a>3. 浏览器跟web服务器建立TCP连接</h3><p>通过TCP三次握手，建立连接。</p><h3 id="4-浏览器发送HTTP请求"><a href="#4-浏览器发送HTTP请求" class="headerlink" title="4. 浏览器发送HTTP请求"></a>4. 浏览器发送HTTP请求</h3><p>请求信息包含三个部分：</p><ul><li>请求方法URI协议&#x2F;版本</li><li>请求头(Request Header)</li><li>请求正文</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">GET</span>/sample.jspHTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Accept</span>:image/gif.image/jpeg,*/*<br><span class="hljs-attribute">Accept</span>-Language:zh-cn<br><span class="hljs-attribute">Connection</span>:Keep-Alive<br><span class="hljs-attribute">Host</span>:localhost<br><span class="hljs-attribute">User</span>-Agent:Mozila/<span class="hljs-number">4</span>.<span class="hljs-number">0</span>(compatible;MSIE5.<span class="hljs-number">01</span>;Window NT5.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">Accept</span>-Encoding:gzip,deflate<br><br><span class="hljs-attribute">username</span>=jinqiao&amp;password=<span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>TCP三次握手</p><ol><li><p>第一次握手：</p><p>客户端生成数据包：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">SYN</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">seq</span> <span class="hljs-operator">=</span> J (随机生成一个数J)<br></code></pre></td></tr></table></figure><p>发送出数据包后，客户端进入SYN_SENT状态，等待服务端确认。</p></li><li><p>第二次握手：</p><p>服务端收到数据包，生成返回数据包：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">SYN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = K (随机生成一个数K)<br><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = J + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>发送出数据包后，服务端进入SYN_RCVD状态。</p></li><li><p>第三次握手：</p><p>客户端收到数据包，检查ack是否为J+1，ACK是否为1。若正确，则生成数据包：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = K + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>将数据包发出，客户端进入ESTABLISHED状态。</p><p>服务端收到数据包后，检查ack是否为K+1，ACK是否为1。若正确，服务端进入ESTABLISHED状态。</p></li><li><p>完成三次握手，开始传输数据。</p></li></ol><p><img src="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手"></p><p>为什么需要三次握手</p><p>主要是为了防止服务端一直等待，浪费资源。</p><p>假设没有三次握手，客户端发出的连接请求在网络中滞留了，客户端超时已经释放了连接。服务端接收到请求后，发出确认。确认发出后连接就建立了，服务端就会一直等待客户端发来数据，而客户端实际已经释放了连接，收到确认后不会理睬，这将导致服务端浪费资源。</p><p>TCP四次挥手</p><ol><li><p>第一次挥手：</p><p>客户端发送FIN，用来关闭客户端到服务端的数据传输，客户端进入FIN_WAIT_1状态</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">FIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">seq</span> <span class="hljs-operator">=</span> x<br><span class="hljs-attribute">ack</span> <span class="hljs-operator">=</span> y<br></code></pre></td></tr></table></figure></li><li><p>第二次挥手：</p><p>服务端收到FIN，发送一个ACK给客户端，服务端进入CLOSE_WAIT状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = y<br><span class="hljs-attr">ack</span> = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>客户端收到ACK，进入FIN_WAIT_2状态。</p></li><li><p>第三次挥手：</p><p>服务端处理完剩余数据后，也向客户端发送FIN，服务端进入LAST_ACK状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">FIN</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = y<br><span class="hljs-attr">ack</span> = x + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>第四次挥手：</p><p>客户端收到FIN，发送一个ACK给服务端，客户端进入TIME_WAIT状态。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ACK</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">seq</span> = x + <span class="hljs-number">1</span><br><span class="hljs-attr">ack</span> = y + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>服务端收到ACK，进入CLOSE状态。</p><p><img src="/2025/01/11/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/format,png-20230309230614791.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中的byte类型和rune类型</title>
    <link href="/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/01/11/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84byte%E7%B1%BB%E5%9E%8B%E5%92%8Crune%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>转载：<a href="https://www.cnblogs.com/wjaaron/p/14822799.html">https://www.cnblogs.com/wjaaron/p/14822799.html</a></p><p>Go 语言中定义字符串要用双引号，而不是单引号，单引号中只能包含一个元素，表示一个字符。</p><p>Go语言中字符有两种类型，分别是：</p><p>uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符<br>rune 类型，代表一个 UTF-8 字符<br>了解编码知识的应该知道，ASCII 编码字符是1个字节的，而 UTF-8 是可变长的编码，当要表示中文等非 ASCll 编码的字符时，需要使用 UTF-8 编码来保证不会乱码。关于字符编码相关知识，推荐看这篇廖雪峰的介绍 字符编码</p><p>假如我们要遍历输出一个包含中文的字符串时：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Println(str[i])<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的打印结果是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">104<br>101<br>108<br>108<br>111<br>32<br>228<br>184<br>150<br>231<br>149<br>140<br></code></pre></td></tr></table></figure><p>Go 语言字符串存储的其实是类型为 byte 的只读切片，或者说一个字符串就是一堆字节。在 UTF-8 编码中一个英文字符可以用一个字节存储，一个中文字符需要三个或四个字节存储，而 ASCII 码符号只有 128 个，大于 128 的都不在范围内。上述代码的遍历方式就是以 ASCII 类型来读字符的。</p><p>可以看到输出结果中的前 6 个都是在 ASCII 表中的，但是后 6 个就不在表中了，后面 6 个的每一个字节都不能单独表示一个字符，而是用 3 个在一起才能表示一个字符，明显超出了 ASCII 表的范围，所以当打印具体字符时就会乱码，比如我们现在来打印每一个真实字符，需要使用到占位符 %c：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(str); i++ &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, str[i]) <span class="hljs-comment">// hello ä¸ç</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello ä¸ç<br></code></pre></td></tr></table></figure><p>明显乱码了。解释这么多就是为了说明如果字符串中有非 ASCII 码的字符时，就不能使用 byte 来表示字符，需要使用 rune 类型来表示。</p><p>使用 rune 类型来遍历字符串<br>在 Go 中，有一个遍历方式是 range，它默认就是以 UTF-8 编码形式去读每一个字符。当涉及到的字符串中含有非英文字符时，可以使用 range 来遍历：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;hello 世界&quot;</span><br> <span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> str &#123;<br>  fmt.Println(r)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">104<br>101<br>108<br>108<br>111<br>32<br>19990<br>30028<br></code></pre></td></tr></table></figure><p>此时输出的字节编码就是 UTF-8 编码号，UTF-8 编码是包含 ASCII 编码的，所以前 6 个编号还是一样的，后面两个编号分别代表世，界。</p><p>修改字符串<br>Go 语言中对字符串的修改其实不是对字符串本身的修改，而是复制字符串，同时修改值，即重新分配来内存，需要先将字符串转化成数组，[]byte 或 []rune，然后再转换成 string 型。</p><p>那么我要说的也很明显了，就是要区别使用 []byte 或 []rune。</p><p>对于全是ASCII编码的字符串，使用 []byte 即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> str := <span class="hljs-string">&quot;abc&quot;</span><br> s2 := []<span class="hljs-type">byte</span>(str)<br> s2[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span><br> fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//bbc</span><br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; string()表示强制类型转换，转换为字符串<br>对于包含中文等字符的字符串时，那就要用 []rune 了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    str:=<span class="hljs-string">&quot;白猫&quot;</span><br>    s2:=[]<span class="hljs-type">rune</span>(str)<br>    s2[<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;黑&#x27;</span><br>    fmt.Println(<span class="hljs-type">string</span>(s2)) <span class="hljs-comment">//黑猫</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结<br>在处理字符时，要考虑字符的编码范围，然后根据需要使用 byte 类型或 rune类型。</p><p>byte 类型只能正常输出 ASCII 编码范围的字符；rune 类型可以输出 UTF-8 编码范围的字符。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>golang并发编程</title>
    <link href="/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/12/08/golang%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="goroutine的使用"><a href="#goroutine的使用" class="headerlink" title="goroutine的使用"></a>goroutine的使用</h2><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–goroutine，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个goroutine去执行这个函数就可以了，就是这么简单粗暴。<br>Go语言中使用goroutine非常简单，只需要在调用函数的时候在前面加上go关键字，就可以为一个函数创建一个goroutine。<br>一个goroutine必定对应一个函数，可以创建多个goroutine去执行相同的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> hello() <span class="hljs-comment">// 启动另外一个goroutine去执行hello函数</span><br>    fmt.Println(<span class="hljs-string">&quot;main goroutine done!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h2><p>在Go语言中实现并发就是这样简单，我们还可以启动多个goroutine。让我们再来一个例子： （这里使用了sync.WaitGroup来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">// goroutine结束就登记-1</span><br>    fmt.Println(<span class="hljs-string">&quot;Hello Goroutine!&quot;</span>, i)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 启动一个goroutine就登记+1</span><br>        <span class="hljs-keyword">go</span> hello(i)<br>    &#125;<br>    wg.Wait() <span class="hljs-comment">// 等待所有登记的goroutine都结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个goroutine是并发执行的，而goroutine的调度是随机的。</p><h2 id="注意退出"><a href="#注意退出" class="headerlink" title="注意退出"></a>注意退出</h2><p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大纲</title>
    <link href="/2024/12/05/%E5%A4%A7%E7%BA%B2/"/>
    <url>/2024/12/05/%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol><li>为什么对slice append时，要用原来的变量来接收<br>s &#x3D; append(s, 1)</li></ol><p>因为append是一个函数，函数的传参是值拷贝，传进去的s在函数内部已经是另一个s了，而函数外部原来的s.len并不会被改变，所以要用函数返回的新s来覆盖原来的s</p><p>go内存管理<br>go协程原理<br>go并发编程<br>go网络编程</p><p>gin框架</p><p>context包</p><p>channel底层原理</p><p>实现M:N生产者消费者模型，双方均设置超时5s丢弃机制</p><p>实现高并发阻塞式Map</p><p>sync.Cond</p><p>sync.Once<br>sync.Map原理</p><p>go协程如何退出的</p><p>make和new的区别</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>namespace</p><p>cgroups</p><p>常见命令</p><p>查看日志的相关命令</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h2 id="k8s"><a href="#k8s" class="headerlink" title="k8s"></a>k8s</h2><p>list-watch 底层原理</p><p>helm chart</p><p>pod创建全链路分析</p><p>k8s集群部署实战</p><p>drain</p><p>kube-apiserver 缓存机制</p><p>etcd</p><p>pod都有哪些状态</p><p>分布式训练</p><p>tensorflow如何支持分布式训练</p><p>如何使用docker进行机器学习训练</p><p>如何使用k8s进行机器学习训练</p><p>kubelet是如何把pod拉起来的</p><p>Dockerfile</p><p>scheduler是如何调度pod的</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>socket编程</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>测试文章图片：<br><img src="/2024/10/21/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.jpg" alt="测试"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/20/hello-world/"/>
    <url>/2024/10/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
