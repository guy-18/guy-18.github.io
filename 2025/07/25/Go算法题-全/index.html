

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John">
  <meta name="keywords" content="">
  
    <meta name="description" content="Go算法题-一按出现频率大小递减排序（参考https:&#x2F;&#x2F;codetop.cc&#x2F;home）： 3. 无重复字符的最长子串(1) leetcode 3. 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例 1: 123输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go算法题-全">
<meta property="og:url" content="http://guy-18.github.io/2025/07/25/Go%E7%AE%97%E6%B3%95%E9%A2%98-%E5%85%A8/index.html">
<meta property="og:site_name" content="John的博客">
<meta property="og:description" content="Go算法题-一按出现频率大小递减排序（参考https:&#x2F;&#x2F;codetop.cc&#x2F;home）： 3. 无重复字符的最长子串(1) leetcode 3. 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。 示例 1: 123输入: s &#x3D; &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-07-25T08:25:40.000Z">
<meta property="article:modified_time" content="2025-10-21T14:58:55.230Z">
<meta property="article:author" content="John">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Go算法题-全 - John的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"guy-18.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Go算法题-全"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-25 16:25" pubdate>
          2025年7月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          123 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Go算法题-全</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Go算法题-一"><a href="#Go算法题-一" class="headerlink" title="Go算法题-一"></a>Go算法题-一</h1><p>按出现频率大小递减排序（参考<a target="_blank" rel="noopener" href="https://codetop.cc/home%EF%BC%89%EF%BC%9A">https://codetop.cc/home）：</a></p>
<h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>(1) leetcode 3. 给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code> 由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>解答：</strong></p>
<p> 方法点：</p>
<ol>
<li>使用map记录字符，用来判断是否重复</li>
<li>如果当前字符与前面某字符重复，可以直接跳到重复字符后面，继续比较</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// //外层循环扩展右边界，内层循环扩展左边界</span><br><span class="hljs-comment">// for (int l = 0, r = 0 ; r &lt; n ; r++) &#123;</span><br><span class="hljs-comment">// 	//当前考虑的元素</span><br><span class="hljs-comment">// 	while (l &lt;= r &amp;&amp; check()) &#123;//区间[left,right]不符合题意</span><br><span class="hljs-comment">//         //扩展左边界</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">//     //区间[left,right]符合题意，统计相关信息</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    l := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> r:=<span class="hljs-number">0</span>, r&lt;n; r++ &#123;<br>        <span class="hljs-comment">// 如果重复，一直跳到重复元素的下一位</span><br>        <span class="hljs-keyword">for</span> m[s[r]] != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">delete</span>(m, s[l])<br>            l++<br>        &#125;<br>        m[s[r]] = <span class="hljs-number">1</span><br>        res = max(res, r-l+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>（2）</p>
<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><p>leetcode 146. 请你设计并实现一个满足 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<p><strong>示例：</strong></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> LRUCache(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key &lt;= 10000</code></li>
<li><code>0 &lt;= value &lt;= 105</code></li>
<li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li>
</ul>
<p><strong>解答：</strong></p>
<ol>
<li>使用map来保存cache数据</li>
<li>使用双向链表来保存访问频率，最近访问的放在链表头部。（双向链表方便尾部删除节点）</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    size <span class="hljs-type">int</span><br>    capacity <span class="hljs-type">int</span><br>    cache <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkedNode<br>    head *DLinkedNode<br>    tail *DLinkedNode<br>&#125;<br><br><span class="hljs-keyword">type</span> DLinkedNode <span class="hljs-keyword">struct</span> &#123;<br>    key <span class="hljs-type">int</span><br>    value <span class="hljs-type">int</span><br>    prev *DLinkedNode<br>    next *DLinkedNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initDLinkedNode</span><span class="hljs-params">(key, value <span class="hljs-type">int</span>)</span></span> *DLinkedNode &#123;<br>    <span class="hljs-keyword">return</span> &amp;DLinkedNode&#123;<br>        key: key,<br>        value: value,<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-type">int</span>)</span></span> LRUCache &#123;<br>    l := LRUCache&#123;<br>        cache: <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*DLinkedNode&#123;&#125;,<br>        head: initDLinkedNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        tail: initDLinkedNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>        capacity: capacity,<br>    &#125;<br>    l.head.next = l.tail<br>    l.tail.prev = l.head<br>    <span class="hljs-keyword">return</span> l<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Get(key <span class="hljs-type">int</span>) <span class="hljs-type">int</span> &#123;<br>    node, ok := this.cache[key]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    this.moveToHead(node)<br>    <span class="hljs-keyword">return</span> node.value<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> Put(key <span class="hljs-type">int</span>, value <span class="hljs-type">int</span>)  &#123;<br>    node, ok := this.cache[key]<br>    <span class="hljs-keyword">if</span> !ok &#123;<br>        node := initDLinkedNode(key, value)<br>        this.cache[key] = node<br>        this.addToHead(node)<br>        this.size++<br>        <span class="hljs-keyword">if</span> this.size &gt; this.capacity &#123;<br>            removed := this.removeTail()<br>            <span class="hljs-built_in">delete</span>(this.cache, removed.key)<br>            this.size--<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node.value = value<br>        this.moveToHead(node)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> addToHead(node *DLinkedNode) &#123;<br>    node.prev = this.head<br>    node.next = this.head.next<br>    <span class="hljs-comment">// 以下两行顺序不能反</span><br>    this.head.next.prev = node<br>    this.head.next = node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeNode(node *DLinkedNode) &#123;<br>    node.prev.next = node.next<br>    node.next.prev = node.prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> moveToHead(node *DLinkedNode) &#123;<br>    this.removeNode(node)<br>    this.addToHead(node)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span></span> removeTail() *DLinkedNode &#123;<br>    node := this.tail.prev<br>    this.removeNode(node)<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(capacity);</span><br><span class="hljs-comment"> * param_1 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<p>(3) </p>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p>解答：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 迭代解法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br><br><span class="hljs-comment">// 递归解法，不好理解</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    newHead := reverseList(head.Next)<br>    head.Next.Next = head<br>    head.Next = <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">return</span> newHead<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;Next: head&#125;<br>    <br>    <span class="hljs-comment">// 记录每一段的前驱节点</span><br>    pre := dummy<br><br>    <span class="hljs-comment">// 每次循环处理k个</span><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 找到第k个节点，作为tail</span><br>        tail := pre<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>            tail = tail.Next<br>            <span class="hljs-comment">// 如果还没有到k个，已经到了结尾，则整体反转已完成，返回头节点</span><br>            <span class="hljs-keyword">if</span> tail == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> dummy.Next<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 记录下一段链表的开头节点</span><br>        next := tail.Next<br><br>        <span class="hljs-comment">// 反转当前链表段，获取到新的head和tail</span><br>        head, tail = reverse(head, tail)<br><br>        <span class="hljs-comment">// 将head连接到上一段链表</span><br>        pre.Next = head<br><br>        <span class="hljs-comment">// 将tail连接到下一段链表</span><br>        tail.Next = next<br><br>        <span class="hljs-comment">// 本段的末尾记录为下一段的前驱</span><br>        pre = tail<br><br>        <span class="hljs-comment">// head重置为下一段的开头</span><br>        head = tail.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head, tail *ListNode)</span></span> (*ListNode, *ListNode) &#123;<br>    <span class="hljs-comment">// pre用于记录前驱节点</span><br>    <span class="hljs-keyword">var</span> pre *ListNode<br><br>    <span class="hljs-comment">// 从head节点开始处理</span><br>    curr := head<br><br>    <span class="hljs-comment">// 一直循环到pre指向最后一个节点</span><br>    <span class="hljs-keyword">for</span> pre != tail &#123;<br>        <span class="hljs-comment">// 先记录当前节点的下一个节点</span><br>        nex := curr.Next <br>        <span class="hljs-comment">// 将当前节点指向前驱节点</span><br>        curr.Next = pre<br>        <span class="hljs-comment">// pre后移</span><br>        pre = curr<br>        <span class="hljs-comment">// curr后移</span><br>        curr = nex<br>    &#125;<br>    <span class="hljs-comment">// 反转完成，tail成为新的头，head成为新的尾</span><br>    <span class="hljs-keyword">return</span> tail, head<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> (ans [][]<span class="hljs-type">int</span>) &#123;<br>    <span class="hljs-comment">// 先排序，不然没法做</span><br>    slices.Sort(nums)<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> nums[:<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>]&#123;<br>        <span class="hljs-comment">// 当前元素和上一个元素相同，则跳过</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; x == nums[i<span class="hljs-number">-1</span>] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 当前元素和后两个元素相加已经大于0，则此后所有循环肯定都大于0，直接退出</span><br>        <span class="hljs-keyword">if</span> x+nums[i+<span class="hljs-number">1</span>] + nums[i+<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        <span class="hljs-comment">// 当前元素和最后两个元素相加仍然小于0，则本轮循环中的和均小于0，跳过本轮循环</span><br>        <span class="hljs-keyword">if</span> x + nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-2</span>] + nums[<span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// j从当前元素的后一个元素开始</span><br>        j := i+<span class="hljs-number">1</span><br>        <span class="hljs-comment">// k从最后一个元素开始</span><br>        k := <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span><br>        <br>        <span class="hljs-keyword">for</span> j &lt; k &#123;<br>            s := x + nums[j] + nums[k]<br>            <span class="hljs-comment">// 如果小于0，则增大j</span><br>            <span class="hljs-keyword">if</span> s &lt; <span class="hljs-number">0</span> &#123;<br>                j++<br>            <span class="hljs-comment">// 如果大于0，则减小k</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s &gt; <span class="hljs-number">0</span> &#123;<br>                k--<br>            <span class="hljs-comment">// 等于0，则找到了一个答案</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">append</span>(ans, []<span class="hljs-type">int</span>&#123;x, nums[j], nums[k]&#125;)<br>                <span class="hljs-keyword">for</span> j++; j &lt; k &amp;&amp; nums[j] == nums[j<span class="hljs-number">-1</span>]; j++ &#123;&#125; <span class="hljs-comment">// 跳过重复数字</span><br>                <span class="hljs-keyword">for</span> k--; k &gt; j &amp;&amp; nums[k] == nums[k+<span class="hljs-number">1</span>]; k-- &#123;&#125; <span class="hljs-comment">// 跳过重复数字</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-comment">// sums[i]值的含义是，以nums[i]为结尾的所有连续子数组的最大和</span><br>    sums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-comment">// 初始时，以nums[0]为结尾的子数组就是它本身</span><br>    sums[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// ans用来记录整体最大和</span><br>    ans := sums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 从nums[1]开始遍历</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 关键代码</span><br>        <span class="hljs-comment">// 1. sums[i-1]保存了所有以nums[i-1]为结尾元素的连续子数组的最大和</span><br>        <span class="hljs-comment">// 2. nums[i]要么加入到前面的连续子数组，要么自己单独作为一个子数组</span><br>        sums[i] = max(sums[i<span class="hljs-number">-1</span>] + nums[i], nums[i])<br>        ans = max(ans, sums[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 迭代法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p := dummy<br>    <span class="hljs-keyword">for</span> list1 != <span class="hljs-literal">nil</span> &amp;&amp; list2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>            p.Next = list1<br>            list1 = list1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = list2<br>            list2 = list2.Next<br>        &#125;<br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = list1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        p.Next = list2<br>    &#125;<br>   <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 递归法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list2<br>    &#125;<br>    <span class="hljs-keyword">if</span> list2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>        list1.Next = mergeTwoLists(list1.Next, list2)<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    list2.Next = mergeTwoLists(list2.Next, list1)<br>    <span class="hljs-keyword">return</span> list2<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 动态规划</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br><br>    <span class="hljs-comment">// 用于记录最长回文串长度及起始位置</span><br>    maxLen := <span class="hljs-number">1</span><br>    begin := <span class="hljs-number">0</span><br><br>    <span class="hljs-comment">// 初始化dp数组，并将dp[i][i]置为true（每个元素都可以认为是一个回文串）</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> n &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        dp[i][i] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 外层长度循环，遍历所有长度的子串</span><br>    <span class="hljs-keyword">for</span> l := <span class="hljs-number">2</span>; l &lt; n + <span class="hljs-number">1</span>; l++ &#123;<br>        <span class="hljs-comment">// 内层对起始位置进行循环，遍历所有的起始位置</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> n &#123;<br>            <span class="hljs-comment">// 计算结束位置</span><br>            j := i + l <span class="hljs-number">-1</span><br><br>            <span class="hljs-comment">// 若结束位置不合法，则直接退出本轮循环</span><br>            <span class="hljs-keyword">if</span> j &gt;= n &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br><br>            <span class="hljs-comment">// 核心代码，dp[i][j]是否为回文串，取决于</span><br>            <span class="hljs-comment">// 1. 内层dp[i+1][j-1]是回文串</span><br>            <span class="hljs-comment">// 2. s[i] == s[j]</span><br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                <span class="hljs-keyword">if</span> j - i &lt;= <span class="hljs-number">2</span> &#123;<br>                    dp[i][j] = <span class="hljs-literal">true</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 实时更新最长子串长度及起始位置</span><br>            <span class="hljs-keyword">if</span> dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; maxLen &#123;<br>                maxLen = j - i + <span class="hljs-number">1</span><br>                begin = i<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回最终结果</span><br>    <span class="hljs-keyword">return</span> s[begin:begin+maxLen]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 定义返回值</span><br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-comment">// q用于保存待遍历的元素</span><br>    q := []*TreeNode&#123;root&#125;<br>    <span class="hljs-comment">// q中保存的始终是同一层的元素</span><br>    <span class="hljs-comment">// 每次循环中把q中所有元素都取出，都取出后再填入下一层的元素</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>; i++ &#123;<br>        res = <span class="hljs-built_in">append</span>(res, []<span class="hljs-type">int</span>&#123;&#125;)<br>        <span class="hljs-comment">// 关键点，用临时的p来保存下层元素，待本层元素处理完后，用p替换q</span><br>        p := []*TreeNode&#123;&#125;<br>        <span class="hljs-comment">// 将q中元素全部遍历，过程中将下层子节点加入p</span><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(q); j++ &#123;<br>            node := q[j]<br>            res[i] = <span class="hljs-built_in">append</span>(res[i], node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 用p替换q，进入新一轮循环</span><br>        q = p<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> idx, ok := m[target-v]; ok &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;i, idx&#125;<br>        &#125;<br>        m[v] = i<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    l := <span class="hljs-number">0</span><br>    r := n - <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 总体是二分查找</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        <span class="hljs-comment">// 获取中间位置</span><br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-comment">// 如果命中，则返回</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-comment">// 如果左边是升序</span><br>        <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= nums[mid] &#123;<br>            <span class="hljs-comment">// 并且target在左边</span><br>            <span class="hljs-keyword">if</span> nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid] &#123;<br>                r = mid - <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                l = mid + <span class="hljs-number">1</span><br>            &#125;<br>        <span class="hljs-comment">// 如果右边是升序</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 并且target在右边</span><br>            <span class="hljs-keyword">if</span> nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="hljs-number">-1</span>] &#123;<br>                l = mid + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                r = mid - <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 深度优先搜索</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>, r, c <span class="hljs-type">int</span>)</span></span> &#123;<br>    nr := <span class="hljs-built_in">len</span>(grid)<br>    nc := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 先将遍历到的元素置为0</span><br>    grid[r][c] = <span class="hljs-string">&#x27;0&#x27;</span><br>    <span class="hljs-comment">// 向上下左右都走一步，如果值为1，则往下搜索</span><br>    <span class="hljs-keyword">if</span> r - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r<span class="hljs-number">-1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r<span class="hljs-number">-1</span>, c)<br>    &#125;<br>    <span class="hljs-keyword">if</span> r + <span class="hljs-number">1</span> &lt; nr &amp;&amp; grid[r+<span class="hljs-number">1</span>][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r+<span class="hljs-number">1</span>, c)<br>    &#125;<br>    <span class="hljs-keyword">if</span> c - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[r][c<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r, c<span class="hljs-number">-1</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> c + <span class="hljs-number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>        dfs(grid, r, c+<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(grid [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    nr := <span class="hljs-built_in">len</span>(grid)<br>    <span class="hljs-keyword">if</span> nr == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    nc := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">if</span> nc == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">var</span> numIslands <span class="hljs-type">int</span><br>    <span class="hljs-comment">// 将所有元素遍历一遍，如果遇到1就深度优先搜索</span><br>    <span class="hljs-comment">// 在深度优先搜索中，会将遍历到的元素置为0</span><br>    <span class="hljs-comment">// 最终执行的搜索次数即为岛屿数量</span><br>    <span class="hljs-keyword">for</span> r := <span class="hljs-number">0</span>; r &lt; nr; r++ &#123;<br>        <span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; nc; c++ &#123;<br>            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-string">&#x27;1&#x27;</span> &#123;<br>                numIslands++<br>                dfs(grid, r, c)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> numIslands<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 回溯法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    <span class="hljs-comment">// 对pos这个位置，使用待排列的所有数字尝试一遍</span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pos <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 如果索引到了n，则说明得到了一个全排列，将结果加入到结果集中</span><br>        <span class="hljs-keyword">if</span> pos == n &#123;<br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, nums...))<br>        &#125;<br>        <span class="hljs-comment">// 对pos这个位置尝试所有待使用元素</span><br>        <span class="hljs-keyword">for</span> i := pos; i &lt; n; i++ &#123;<br>            <span class="hljs-comment">// 把第i个位置的元素放到pos位置上</span><br>            nums[pos], nums[i] = nums[i], nums[pos]<br>            <span class="hljs-comment">// 得到pos后面所有字符的结果集</span><br>            backtrack(pos+<span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// 恢复pos和i元素的初始位置，以便下一次循环使用另外的元素</span><br>            nums[pos], nums[i] = nums[i], nums[pos]<br>        &#125;<br>    &#125;<br><br>    backtrack(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    <span class="hljs-comment">// 如果字符是奇数个，则肯定不能完全匹配</span><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 记录右括号对应的左括号</span><br>    pairs := <span class="hljs-keyword">map</span>[<span class="hljs-type">byte</span>]<span class="hljs-type">byte</span>&#123;<br>        <span class="hljs-string">&#x27;)&#x27;</span>: <span class="hljs-string">&#x27;(&#x27;</span>,<br>        <span class="hljs-string">&#x27;]&#x27;</span>: <span class="hljs-string">&#x27;[&#x27;</span>,<br>        <span class="hljs-string">&#x27;&#125;&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>,<br>    &#125;<br><br>    stack := []<span class="hljs-type">byte</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果拿到了一个右括号</span><br>        <span class="hljs-keyword">if</span> v, ok := pairs[s[i]]; ok &#123;<br>            <span class="hljs-comment">// 如果栈为空，或者栈顶元素与当前右括号不匹配，就直接返回false</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> || stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != v &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>            <span class="hljs-comment">// 如果匹配就把栈顶元素出栈</span><br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        <span class="hljs-comment">// 如果拿到的是左括号，就压栈</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, s[i])<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 栈中剩余元素就是没有匹配成功的</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 核心思想：第i天卖出得到的最大利润，买入价格一定是前i-1天中的最低价格</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// 记录“历史”最低价格</span><br>    minPrice := prices[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 记录最大利润</span><br>    maxProfit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, price := <span class="hljs-keyword">range</span> prices &#123;<br>        <span class="hljs-comment">// 更新最大利润</span><br>        maxProfit = max(maxProfit, price - minPrice)<br>        <span class="hljs-comment">// 更新历史最低价格</span><br>        minPrice = min(minPrice, price)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxProfit<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, m <span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 从后向前遍历</span><br>    <span class="hljs-comment">// p1指向nums1待排元素，p2指向nums2待排元素，tail指向要放入的位置</span><br>    <span class="hljs-keyword">for</span> p1, p2, tail := m<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>, m+n<span class="hljs-number">-1</span>; p1 &gt;=<span class="hljs-number">0</span> || p2 &gt;= <span class="hljs-number">0</span>; tail-- &#123;<br>        <span class="hljs-comment">// 当前要处理的元素是什么</span><br>        <span class="hljs-keyword">var</span> cur <span class="hljs-type">int</span><br>        <span class="hljs-comment">// 如果nums1已经遍历完了</span><br>        <span class="hljs-keyword">if</span> p1 == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-comment">// 从nums2中取</span><br>            cur = nums2[p2]<br>            p2--<br>        <span class="hljs-comment">// 如果nums2已经遍历完了</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p2 == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-comment">// 从nums1中取</span><br>            cur = nums1[p1]<br>            p1--<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums1[p1] &gt; nums2[p2] &#123;<br>            cur = nums1[p1]<br>            p1--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = nums2[p2]<br>            p2--<br>        &#125;<br>        nums1[tail] = cur<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zigzagLevelOrder</span><span class="hljs-params">(root *TreeNode)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-comment">// 辅助层序遍历</span><br>    queue := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> level := <span class="hljs-number">0</span>; <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span>; level++ &#123;<br>        vals := []<span class="hljs-type">int</span>&#123;&#125;<br>        <span class="hljs-comment">// q接收本层元素，用于遍历，queue保存下层元素</span><br>        q := queue<br>        queue = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> q &#123;<br>            vals = <span class="hljs-built_in">append</span>(vals, node.Val)<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果本层为奇数层，将得到的遍历结果反转，再加入结果集</span><br>        <span class="hljs-keyword">if</span> level % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            n := <span class="hljs-built_in">len</span>(vals)<br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br>                vals[i], vals[n<span class="hljs-number">-1</span>-i] = vals[n<span class="hljs-number">-1</span>-i], vals[i]<br>            &#125;<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, vals)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 哈希表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    seen := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _, ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        seen[head] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>        head = head.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 快慢指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// 慢指针每次走一步，快指针每次走两步</span><br>    <span class="hljs-comment">// 每次移动快慢指针之间的距离会加1，如果有环的话，快慢指针终会相遇</span><br>    slow, fast := head, head.Next<br>    <span class="hljs-keyword">for</span> slow != fast &#123;<br>        <span class="hljs-keyword">if</span> fast == <span class="hljs-literal">nil</span> || fast.Next == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 找到最近公共祖先 or 找到p/q本身</span><br> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;<br>    <span class="hljs-comment">// 如果已经到达底部，直接返回</span><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前节点是p或者q，返回该节点</span><br>    <span class="hljs-keyword">if</span> root.Val == p.Val || root.Val == q.Val &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    <span class="hljs-comment">// 在左子树中找到最近公共祖先 或 在左子树中找到p/q</span><br>    left := lowestCommonAncestor(root.Left, p, q)<br><br>    <span class="hljs-comment">// 在右子树中找到最近公共祖先 或 在右子树中找到p/q</span><br>    right := lowestCommonAncestor(root.Right, p, q)<br>    <br>    <span class="hljs-comment">// 左子树中找到了p/q，右子树中也找到了p/q</span><br>    <span class="hljs-comment">// 则当前节点为最近公共祖先（只有最近公共祖先满足该条件）</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    <span class="hljs-comment">// 如果只是找到了一个，则返回找到的那个，表示从该节点往下有一个p/q</span><br>    <span class="hljs-comment">// 如果都没找到，返回nil</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 头插法一次遍历</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-type">int</span>, right <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-comment">// 设置dummy节点是此类问题的一般做法</span><br>    dummy := &amp;ListNode&#123;Next: head&#125;<br>    pre := dummy<br><br>    <span class="hljs-comment">// 找到left的前一个节点，作为pre</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++ &#123;<br>        pre = pre.Next<br>    &#125;<br><br>    <span class="hljs-comment">// left节点作为cur</span><br>    cur := pre.Next<br><br>    <span class="hljs-comment">// 从left开始遍历，每次循环把当前节点的后一个节点插入到pre后面（该段链表的头部）</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; right-left; i++ &#123;<br>        next := cur.Next<br>        cur.Next = next.Next<br>        next.Next = pre.Next<br>        pre.Next = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-type">int</span>, amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// dp[i]为组成数量为i的金额所需的最小硬币数</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, amount+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 为dp[i]赋初始值</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++ &#123;<br>        <span class="hljs-comment">// 这里的amount+1并没有实际意义，仅仅是为了方便判断是否有解，任何一个大于amount的数均可</span><br>        <span class="hljs-comment">// 因为组成amount所需的硬币数量在任何情况下都不会大于amount</span><br>        dp[i] = amount + <span class="hljs-number">1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= amount; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(coins); j++ &#123;<br>            <span class="hljs-keyword">if</span> coins[j] &lt;= i &#123;<br>                <span class="hljs-comment">// 组成i-coins[j]的最小硬币数，加上本次的一个硬币</span><br>                dp[i] = min(dp[i], dp[i-coins[j]] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> dp[amount] &gt; amount &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;&#125;<br>    &#125;<br><br>    rows, cols := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    order := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, rows * cols)<br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 记录边界</span><br>    left, right, top, bottom := <span class="hljs-number">0</span>, cols - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, rows - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">// 在边界范围内移动</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &amp;&amp; top &lt;= bottom &#123;<br>        <span class="hljs-comment">// 从左往右移动，从最左端left开始，一直到最右端right</span><br>        <span class="hljs-keyword">for</span> col := left; col &lt;= right; col++ &#123;<br>            order[index] = matrix[top][col]<br>            index++<br>        &#125;<br>        <span class="hljs-comment">// 从上往下移动，从最上面的下一个元素开始，到最下端</span><br>        <span class="hljs-keyword">for</span> row := top + <span class="hljs-number">1</span>; row &lt;= bottom; row++ &#123;<br>            order[index] = matrix[row][right]<br>            index++<br>        &#125;<br>        <span class="hljs-comment">// 因为需要始终满足col &gt; left和row &gt; top，这里要保证数组访问不越界</span><br>        <span class="hljs-keyword">if</span> left &lt; right &amp;&amp; top &lt; bottom &#123;<br>            <span class="hljs-comment">// 从右往左移动</span><br>            <span class="hljs-keyword">for</span> col := right - <span class="hljs-number">1</span>; col &gt; left; col-- &#123;<br>                order[index] = matrix[bottom][col]<br>                index++<br>            &#125;<br>            <span class="hljs-comment">// 从下往上移动</span><br>            <span class="hljs-keyword">for</span> row := bottom; row &gt; top; row-- &#123;<br>                order[index] = matrix[row][left]<br>                index++<br>            &#125;<br>        &#125;<br>        left++<br>        right--<br>        top++<br>        bottom--<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> order<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    d := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">len</span> := <span class="hljs-number">1</span><br>    d[<span class="hljs-built_in">len</span>] = nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> num &gt; d[<span class="hljs-built_in">len</span>] &#123;<br>            <span class="hljs-built_in">len</span>++<br>            d[<span class="hljs-built_in">len</span>] = num<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l := <span class="hljs-number">1</span><br>            r := <span class="hljs-built_in">len</span><br>            pos := <span class="hljs-number">0</span><br>            <span class="hljs-comment">// 找到比num小的最大的数</span><br>            <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>                mid := (l + r) &gt;&gt; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> d[mid] &lt; num &#123;<br>                    pos = mid<br>                    l = mid + <span class="hljs-number">1</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    r = mid - <span class="hljs-number">1</span><br>                &#125;<br>            &#125;<br>            d[pos+<span class="hljs-number">1</span>] = num<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> merge(lists, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lists)<span class="hljs-number">-1</span>)<br>&#125;<br><span class="hljs-comment">// 递归执行，将数组拆成左右两部分，分别合并为一个链表，最终再将两个链表合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(lists []*ListNode, l, r <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> l == r &#123;<br>        <span class="hljs-keyword">return</span> lists[l]<br>    &#125;<br>    <span class="hljs-keyword">if</span> l &gt; r &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (l + r) / <span class="hljs-number">2</span><br>    <span class="hljs-keyword">return</span> mergeTwoLists(merge(lists, l, mid), merge(lists, mid+<span class="hljs-number">1</span>, r))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(a, b *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br><br>    dummy := &amp;ListNode&#123;&#125;<br>    tail := dummy<br>    pa := a<br>    pb := b<br>    <span class="hljs-keyword">for</span> pa != <span class="hljs-literal">nil</span> &amp;&amp; pb != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> pa.Val &lt; pb.Val &#123;<br>            tail.Next = pa<br>            pa = pa.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail.Next = pb<br>            pb = pb.Next<br>        &#125;<br>        tail = tail.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> pa != <span class="hljs-literal">nil</span> &#123;<br>        tail.Next = pa<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        tail.Next = pb<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reorderList</span><span class="hljs-params">(head *ListNode)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    mid := middleNode(head)<br>    l1 := head<br>    l2 := mid.Next<br>    mid.Next = <span class="hljs-literal">nil</span><br><br>    l2 = reverseList(l2)<br><br>    mergeList(l1, l2)<br>&#125;<br><br><span class="hljs-comment">// 快慢指针找中点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middleNode</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br><span class="hljs-comment">// 反转链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> pre, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        next := cur.Next<br>        cur.Next = pre<br>        pre = cur<br>        cur = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre<br>&#125;<br><br><span class="hljs-comment">// 交替合并链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeList</span><span class="hljs-params">(l1, l2 *ListNode)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> &amp;&amp; l2 != <span class="hljs-literal">nil</span> &#123;<br>        l1Next := l1.Next<br>        l2Next := l2.Next<br><br>        l1.Next = l2<br>        l1 = l1Next<br><br>        l2.Next = l1<br>        l2 = l2Next<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addStrings</span><span class="hljs-params">(num1 <span class="hljs-type">string</span>, num2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    add := <span class="hljs-number">0</span><br>    ans := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-built_in">len</span>(num1) - <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(num2) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span> || add != <span class="hljs-number">0</span>; i, j = i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>            x = <span class="hljs-type">int</span>(num1[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> j &gt;= <span class="hljs-number">0</span> &#123;<br>            y = <span class="hljs-type">int</span>(num2[j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        result := x + y + add<br>        <span class="hljs-comment">// result % 10 为当前位</span><br>        ans = strconv.Itoa(result % <span class="hljs-number">10</span>) + ans<br>        <span class="hljs-comment">// 向下一位的进位</span><br>        add = result / <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 哈希表存储</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    vis := <span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> p := headA; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>        vis[p] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> p := headB; p != <span class="hljs-literal">nil</span>; p = p.Next &#123;<br>        <span class="hljs-keyword">if</span> vis[p] &#123;<br>            <span class="hljs-keyword">return</span> p<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 双指针分别从两个链表头部开始遍历，遍历完后转到另一条链表头部遍历</span><br><span class="hljs-comment">// 若存在相交节点，则必定相遇（因为会走过相同距离x1+y+x2）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(headA, headB *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> headA == <span class="hljs-literal">nil</span> || headB == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    pa, pb := headA, headB<br>    <span class="hljs-keyword">for</span> pa != pb &#123;<br>        <span class="hljs-keyword">if</span> pa == <span class="hljs-literal">nil</span> &#123;<br>            pa = headB<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pa = pa.Next<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> pb == <span class="hljs-literal">nil</span> &#123;<br>            pb = headA<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pb = pb.Next<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pa<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 先按照左端点进行排序</span><br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>    &#125;)<br><br>    <span class="hljs-comment">// 用于保存结果</span><br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 遍历排序后的区间</span><br>    <span class="hljs-keyword">for</span> _, interval := <span class="hljs-keyword">range</span> intervals &#123;<br>        n := <span class="hljs-built_in">len</span>(res)<br>        <span class="hljs-comment">// 没有重合：res中最后一个区间的右端点小于当前区间左端点</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; interval[<span class="hljs-number">0</span>] &#123;<br>            res = <span class="hljs-built_in">append</span>(res, interval)<br>        <span class="hljs-comment">// 有重合，就拓展res中最后一个区间的右边界</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = max(res[n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], interval[<span class="hljs-number">1</span>])<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trap</span><span class="hljs-params">(height []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(height)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// leftMax[i]的含义是，从i这个位置往左看，最高的高度</span><br>    leftMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    leftMax[<span class="hljs-number">0</span>] = height[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        leftMax[i] = max(leftMax[i<span class="hljs-number">-1</span>], height[i])<br>    &#125;<br><br>    <span class="hljs-comment">// rightMax[i]的含义是，从i这个位置往右看，最高的高度</span><br>    rightMax := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    rightMax[n<span class="hljs-number">-1</span>] = height[n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        rightMax[i] = max(rightMax[i+<span class="hljs-number">1</span>], height[i])<br>    &#125;<br><br>    res := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i, h := <span class="hljs-keyword">range</span> height &#123;<br>        res += min(leftMax[i], rightMax[i]) - h<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSum := math.MinInt32<br>    <span class="hljs-keyword">var</span> maxGain <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span> <span class="hljs-type">int</span><br>    maxGain = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br><br>        leftGain := max(maxGain(node.Left), <span class="hljs-number">0</span>)<br>        rightGain := max(maxGain(node.Right), <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment">// 将左子树路径-当前节点-右子树路径 连接起来组成新的一条路径</span><br>        <span class="hljs-comment">// 计算这条路径的和</span><br>        newPathPrice := node.Val + leftGain + rightGain<br><br>        <span class="hljs-comment">// 更新答案</span><br>        maxSum = max(maxSum, newPathPrice)<br><br>        <span class="hljs-comment">// 返回节点的最大贡献值。路径只向一个子树上延申</span><br>        <span class="hljs-keyword">return</span> node.Val + max(leftGain, rightGain)<br>    &#125;<br><br>    maxGain(root)<br><br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-type">bool</span>)<br><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> _, ok := seen[head]; ok &#123;<br>            <span class="hljs-keyword">return</span> head<br>        &#125;<br>        seen[head] = <span class="hljs-literal">true</span><br>        head = head.Next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-type">string</span>, text2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(text1), <span class="hljs-built_in">len</span>(text2)<br>    <span class="hljs-comment">// dp[i][j]含义：以text1[i-1]结尾的字符串，和以text2[j-1]结尾的字符串之间的最长公共子序列长度</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, c1 := <span class="hljs-keyword">range</span> text1 &#123;<br>        <span class="hljs-keyword">for</span> j, c2 := <span class="hljs-keyword">range</span> text2 &#123;<br>            <span class="hljs-keyword">if</span> c1 == c2 &#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = dp[i][j] + <span class="hljs-number">1</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>] = max(dp[i][j+<span class="hljs-number">1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> SEG_COUNT = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">var</span> (<br>    ans []<span class="hljs-type">string</span><br>    segments []<span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">restoreIpAddresses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    segments = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, SEG_COUNT)<br>    ans = []<span class="hljs-type">string</span>&#123;&#125;<br>    dfs(s, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(s <span class="hljs-type">string</span>, segId, segStart <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// segId从0开始的，等于SEG_COUNT说明已经找到了4段</span><br>    <span class="hljs-comment">// segStart从0开始的，等于len(s)说明字符串已经遍历完了</span><br>    <span class="hljs-keyword">if</span> segId == SEG_COUNT &#123;<br>        <span class="hljs-keyword">if</span> segStart == <span class="hljs-built_in">len</span>(s) &#123;<br>            <span class="hljs-comment">// 将dfs过程中保存的segments数组转化成真正的ip字符串</span><br>            ipAddr := <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; SEG_COUNT; i++ &#123;<br>                ipAddr += strconv.Itoa(segments[i])<br>                <span class="hljs-keyword">if</span> i != SEG_COUNT - <span class="hljs-number">1</span> &#123;<br>                    ipAddr += <span class="hljs-string">&quot;.&quot;</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将ip字符串加入到结果集中</span><br>            ans = <span class="hljs-built_in">append</span>(ans, ipAddr)<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果还没有找到4段，但字符串已经遍历完了，说明本次尝试无功而返，什么也不做，直接返回</span><br>    <span class="hljs-keyword">if</span> segStart == <span class="hljs-built_in">len</span>(s) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前段，遇到的第一个数字就是0，那么本段也只能为0。保存本段的0，然后开启向下的搜索</span><br>    <span class="hljs-keyword">if</span> s[segStart] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>        segments[segId] = <span class="hljs-number">0</span><br>        dfs(s, segId + <span class="hljs-number">1</span>, segStart + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 一般情况，枚举每一种可能性，并向下递归</span><br>    addr := <span class="hljs-number">0</span> <span class="hljs-comment">// 用来保存本段ip地址数值</span><br>    <span class="hljs-comment">// 从segStart开始尝试，i的总体限制是小于len(s)，但在前期遍历过程中达不到len(s) addr就超过255了</span><br>    <span class="hljs-comment">// 所以这里的for循环并不一定会遍历到len(s)，超过255退出即可，所有可能的结果都会在dfs过程中遍历到</span><br>    <span class="hljs-keyword">for</span> i := segStart; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        addr = addr * <span class="hljs-number">10</span> + <span class="hljs-type">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-comment">// 如果本轮循环得到的addr数值符合要求，那么就找到了本段的一个解，记录之后向下递归寻找之后几段的解</span><br>        <span class="hljs-keyword">if</span> addr &gt; <span class="hljs-number">0</span> &amp;&amp; addr &lt;= <span class="hljs-number">0xFF</span> &#123;<br>            segments[segId] = addr<br>            dfs(s, segId + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 双指针</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-type">int</span>)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br>    first, second := head, dummy<br>    <span class="hljs-comment">// first先往前走n步</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br>    <span class="hljs-comment">// first和second同时往前走</span><br>    <span class="hljs-keyword">for</span> ; first != <span class="hljs-literal">nil</span>; first = first.Next &#123;<br>        second = second.Next<br>    &#125;<br>    second.Next = second.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br><br>    cur := dummy<br>    <span class="hljs-comment">// 每次都是对比当前节点的后两个节点</span><br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 如果后两个节点相等</span><br>        <span class="hljs-keyword">if</span> cur.Next.Val == cur.Next.Next.Val &#123;<br>            <span class="hljs-comment">// 记录相等节点的值</span><br>            x := cur.Next.Val<br>            <span class="hljs-comment">// 不停的跳过值为x的节点，注意这里cur是一直没变的，变化的是cur的下一个节点，</span><br>            <span class="hljs-comment">// 也就是说如果cur的下一个节点值为x，那么它就会被跳过</span><br>            <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &amp;&amp; cur.Next.Val == x &#123;<br>                cur.Next = cur.Next.Next<br>            &#125;<br>        <span class="hljs-comment">// 后两个节点不相等的情况下，cur才往后移动一位</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">// 层序遍历，右子树先入队，每层保留最右侧节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rightSideView</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    q := []*TreeNode&#123;root&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        p := []*TreeNode&#123;&#125;<br>        res = <span class="hljs-built_in">append</span>(res, q[<span class="hljs-number">0</span>].Val)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(q); j++ &#123;<br>            node := q[j]<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Right)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                p = <span class="hljs-built_in">append</span>(p, node.Left)<br>            &#125;<br>        &#125;<br>        q = p<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> inorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    inorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node * TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        inorder(node.Left)<br>        res = <span class="hljs-built_in">append</span>(res, node.Val)<br>        inorder(node.Right)<br>    &#125;<br><br>    inorder(root)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    l := <span class="hljs-number">0</span><br>    r := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>            l = mid + <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            r = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>    inStack, outStack []<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MyQueue &#123;<br>    <span class="hljs-keyword">return</span> MyQueue&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Push(x <span class="hljs-type">int</span>) &#123;<br>    q.inStack = <span class="hljs-built_in">append</span>(q.inStack, x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> in2out() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q.inStack) &gt; <span class="hljs-number">0</span> &#123;<br>        q.outStack = <span class="hljs-built_in">append</span>(q.outStack, q.inStack[<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>])<br>        q.inStack = q.inStack[:<span class="hljs-built_in">len</span>(q.inStack)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Pop() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;<br>        q.in2out()<br>    &#125;<br>    x := q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>    q.outStack = q.outStack[:<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Peek() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span> &#123;<br>        q.in2out()<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.outStack[<span class="hljs-built_in">len</span>(q.outStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(q *MyQueue)</span></span> Empty() <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(q.inStack) == <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">len</span>(q.outStack) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 归并排序两个有序链表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(head1, head2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p, p1, p2 := dummy, head1, head2<br>    <span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1.Val &lt; p2.Val &#123;<br>            p.Next = p1<br>            p1 = p1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.Next = p2<br>            p2 = p2.Next<br>        &#125;<br>        p = p.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> p1 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p1<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> p2 != <span class="hljs-literal">nil</span> &#123;<br>        p.Next = p2<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br><br><span class="hljs-comment">// 拆分一个链表，分别递归排序，将排好序的两个链表合并</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sort</span><span class="hljs-params">(head, tail *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    <br>    <span class="hljs-comment">// 丢弃尾部节点，避免重复</span><br>    <span class="hljs-keyword">if</span> head.Next == tail &#123;<br>        head.Next = <span class="hljs-literal">nil</span><br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != tail &#123;<br>        slow = slow.Next<br>        fast = fast.Next<br>        <span class="hljs-keyword">if</span> fast != tail &#123;<br>            fast = fast.Next<br>        &#125;<br>    &#125;<br><br>    mid := slow<br>    <span class="hljs-comment">// 这里将mid分别作为头和尾递归传递，但作为尾部的mid最终会被丢弃，不会出现mid节点重复的问题</span><br>    <span class="hljs-keyword">return</span> merge(sort(head, mid), sort(mid, tail))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">return</span> sort(head, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 用于保存结果集</span><br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 用于保存每一步的结果</span><br>    tmp := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 回溯法，每个位置上要么放左括号，要么放右括号</span><br>    <span class="hljs-comment">// 放的时候校验下合不合法</span><br>    <span class="hljs-keyword">var</span> backtrack <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leftCount, rightCount <span class="hljs-type">int</span>)</span></span><br>    backtrack = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(leftCount, rightCount <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 长度达到2n，找到一个答案，加入结果集</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp) == <span class="hljs-number">2</span>*n &#123;<br>            res = <span class="hljs-built_in">append</span>(res, strings.Join(tmp, <span class="hljs-string">&quot;&quot;</span>))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 只要左括号数量小于n，当前位置放左括号就是合法的</span><br>        <span class="hljs-keyword">if</span> leftCount &lt; n &#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-string">&quot;(&quot;</span>)<br>            backtrack(leftCount+<span class="hljs-number">1</span>, rightCount)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// 只要右括号数量小于左括号，当前位置放右括号就是合法的</span><br>        <span class="hljs-keyword">if</span> rightCount &lt; leftCount &#123;<br>            tmp = <span class="hljs-built_in">append</span>(tmp, <span class="hljs-string">&quot;)&quot;</span>)<br>            backtrack(leftCount, rightCount+<span class="hljs-number">1</span>)<br>            tmp = tmp[:<span class="hljs-built_in">len</span>(tmp)<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    backtrack(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 唉，背诵题，原理看题解吧</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span>  &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    i := n - <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>] &#123;<br>        i--<br>    &#125;<br>    <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        j := n - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[j] &#123;<br>            j--<br>        &#125;<br>        nums[i], nums[j] = nums[j], nums[i]<br>    &#125;<br>    reverse(nums[i+<span class="hljs-number">1</span>:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a); i &lt; n/<span class="hljs-number">2</span>; i++ &#123;<br>        a[i], a[n<span class="hljs-number">-1</span>-i] = a[n<span class="hljs-number">-1</span>-i], a[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/compare-version-numbers/">165. 比较版本号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compareVersion</span><span class="hljs-params">(version1 <span class="hljs-type">string</span>, version2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    v1 := strings.Split(version1, <span class="hljs-string">&quot;.&quot;</span>)<br>    v2 := strings.Split(version2, <span class="hljs-string">&quot;.&quot;</span>)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(v1) || i &lt; <span class="hljs-built_in">len</span>(v2); i++ &#123;<br>        x, y := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(v1) &#123;<br>            x, _ = strconv.Atoi(v1[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(v2) &#123;<br>            y, _ = strconv.Atoi(v2[i])<br>        &#125;<br>        <span class="hljs-keyword">if</span> x &gt; y &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> x &lt; y &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    l, r := <span class="hljs-number">0</span>, x<br>    ans := <span class="hljs-number">-1</span><br>    <span class="hljs-keyword">for</span> l &lt;= r &#123;<br>        mid := (l + r) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> mid * mid &lt;= x &#123;<br>            ans = mid<br>            l = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/string-to-integer-atoi/">8. 字符串转换整数 (atoi)</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;math&quot;</span><br>	<span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>	<span class="hljs-comment">// 去除前导空格</span><br>	s = strings.TrimLeft(s, <span class="hljs-string">&quot; &quot;</span>)<br>	<br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>	&#125;<br>	<br>	<span class="hljs-comment">// 处理符号</span><br>	sign := <span class="hljs-number">1</span><br>	<span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>		sign = <span class="hljs-number">-1</span><br>		s = s[<span class="hljs-number">1</span>:]<br>	&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> &#123;<br>		s = s[<span class="hljs-number">1</span>:]<br>	&#125;<br>	<br>	<span class="hljs-keyword">var</span> result <span class="hljs-type">int64</span> = <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> s &#123;<br>		<span class="hljs-comment">// 遇到非数字字符则停止</span><br>		<span class="hljs-keyword">if</span> ch &lt; <span class="hljs-string">&#x27;0&#x27;</span> || ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		<br>		digit := <span class="hljs-type">int64</span>(ch - <span class="hljs-string">&#x27;0&#x27;</span>)<br>		result = result*<span class="hljs-number">10</span> + digit<br>		<br>		<span class="hljs-comment">// 检查溢出</span><br>		<span class="hljs-keyword">if</span> sign == <span class="hljs-number">1</span> &amp;&amp; result &gt; math.MaxInt32 &#123;<br>			<span class="hljs-keyword">return</span> math.MaxInt32<br>		&#125;<br>		<span class="hljs-keyword">if</span> sign == <span class="hljs-number">-1</span> &amp;&amp; -result &lt; math.MinInt32 &#123;<br>			<span class="hljs-keyword">return</span> math.MinInt32<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 应用符号</span><br>	final := <span class="hljs-type">int64</span>(sign) * result<br>	<br>	<span class="hljs-comment">// 确保结果在32位整数范围内</span><br>	<span class="hljs-keyword">if</span> final &gt; math.MaxInt32 &#123;<br>		<span class="hljs-keyword">return</span> math.MaxInt32<br>	&#125;<br>	<span class="hljs-keyword">if</span> final &lt; math.MinInt32 &#123;<br>		<span class="hljs-keyword">return</span> math.MinInt32<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(final)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;<br>    dummy := &amp;ListNode&#123;&#125;<br>    p := dummy<br>    digit := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> l1 != <span class="hljs-literal">nil</span> || l2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">var</span> v1, v2 <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> l1 != <span class="hljs-literal">nil</span> &#123;<br>            v1 = l1.Val<br>            l1 = l1.Next<br>        &#125;<br>        <span class="hljs-keyword">if</span> l2 != <span class="hljs-literal">nil</span> &#123;<br>            v2 = l2.Val<br>            l2 = l2.Next<br>        &#125;<br><br>        sum := v1 + v2 + digit<br>        <br>        val := sum % <span class="hljs-number">10</span><br><br>        node := &amp;ListNode&#123;Val: val&#125;<br>        p.Next = node<br>        p = p.Next<br><br>        digit = sum / <span class="hljs-number">10</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> digit != <span class="hljs-number">0</span> &#123;<br>        p.Next = &amp;ListNode&#123;Val: digit&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 用于保存最终结果</span><br>    res := <span class="hljs-number">0</span><br>    <br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-comment">// 为了初始时方便，提前压入-1</span><br>    stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br>        <span class="hljs-comment">// 如果是左括号，就压入栈中</span><br>        <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, i)<br>        <span class="hljs-comment">// 如果是右括号，就将栈顶元素出栈（除了栈底元素，栈中肯定全部都是左括号。栈底元素是遍历过的最后的没有被匹配的右括号）</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            <span class="hljs-comment">// 如果出栈后栈空了，就说明栈底的右括号被出栈了，那么当前的右括号就成了新的不能被匹配的右括号，压入栈中成为新的栈底</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> &#123;<br>                stack = <span class="hljs-built_in">append</span>(stack, i)<br>            <span class="hljs-comment">// 实时更新最长的匹配长度</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res = max(res, i - stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">3</span>; i &lt; n + <span class="hljs-number">1</span>; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-type">int</span>, inorder []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(preorder) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    root := &amp;TreeNode&#123;preorder[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br><br>    <span class="hljs-comment">// 找到中序遍历中的根节点</span><br>    i := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> ; i &lt; <span class="hljs-built_in">len</span>(inorder); i++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[i] == preorder[<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 中序遍历根节点左边的节点为左子树，右边的节点为右子树</span><br>    root.Left = buildTree(preorder[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>], inorder[:i])<br>    root.Right = buildTree(preorder[<span class="hljs-built_in">len</span>(inorder[:i])+<span class="hljs-number">1</span>:], inorder[i+<span class="hljs-number">1</span>:])<br><br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    set := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cur <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 如果长度已经超过了nums长度，说明已经得到了一个结果</span><br>        <span class="hljs-keyword">if</span> cur == <span class="hljs-built_in">len</span>(nums) &#123;<br>            <span class="hljs-comment">// 这里要注意，不要把set直接append到结果集中，因为后面还要对set进行修改，引用传递，会受影响</span><br>            <span class="hljs-comment">// 创建一个新的数组，加入结果集中</span><br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, set...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 选择当前元素</span><br>        set = <span class="hljs-built_in">append</span>(set, nums[cur])<br>        dfs(cur+<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment">// 不选择当前元素</span><br>        set = set[:<span class="hljs-built_in">len</span>(set)<span class="hljs-number">-1</span>]<br>        dfs(cur+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 去除两端空格</span><br>    s = strings.Trim(s, <span class="hljs-string">&quot; &quot;</span>)<br><br>    <span class="hljs-comment">// 双指针</span><br>    i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    j := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    res := []<span class="hljs-type">string</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 从后向前遍历</span><br>    <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 搜索首个空格</span><br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            i -= <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-comment">// 记录单词</span><br>        res = <span class="hljs-built_in">append</span>(res, s[i+<span class="hljs-number">1</span>:j+<span class="hljs-number">1</span>])<br>        <span class="hljs-comment">// 跳过单词间空格</span><br>        <span class="hljs-keyword">for</span> i &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span> &#123;<br>            i -= <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-comment">// j指向下个单词的尾字符</span><br>        j = i<br>    &#125;<br><br>    <span class="hljs-comment">// 拼接返回</span><br>    <span class="hljs-keyword">return</span> strings.Join(res, <span class="hljs-string">&quot; &quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 思路：使用一个辅助栈，每次压栈时同步往辅助栈中压入当前最小值，出栈时也是同步出栈。</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-type">int</span><br>    minStack []<span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        stack: []<span class="hljs-type">int</span>&#123;&#125;,<br>        minStack: []<span class="hljs-type">int</span>&#123;math.MaxInt64&#125;,<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    this.stack = <span class="hljs-built_in">append</span>(this.stack, val)<br>    top := this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>    this.minStack = <span class="hljs-built_in">append</span>(this.minStack, min(val, top))<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop()  &#123;<br>    this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>    this.minStack = this.minStack[:<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> this.minStack[<span class="hljs-built_in">len</span>(this.minStack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 使用单个栈的解法，通过向栈中压入差值实现</span><br><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-type">int</span><br>    minValue <span class="hljs-type">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MinStack &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<br>        stack: []<span class="hljs-type">int</span>&#123;&#125;,<br>        minValue: <span class="hljs-number">-1</span>,<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Push(val <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        this.stack = <span class="hljs-built_in">append</span>(this.stack, <span class="hljs-number">0</span>)<br>        this.minValue = val<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        diff := val - this.minValue<br>        this.stack = <span class="hljs-built_in">append</span>(this.stack, diff)<br>        <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> &#123;<br>            this.minValue = val<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Pop()  &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    diff := this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>    this.stack = this.stack[:<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br><br>    <span class="hljs-comment">// 如果diff小于0，则当前最小值就是栈顶的原始元素</span><br>    <span class="hljs-comment">// 并且，当前最小值 - diff就是上一次的最小值（参考push中的逻辑）</span><br>    <span class="hljs-comment">// 这里相当于在出栈时恢复上一次的最小值，是关键的一步</span><br>    <span class="hljs-keyword">if</span> diff &lt; <span class="hljs-number">0</span> &#123;<br>        this.minValue = this.minValue - diff<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> Top() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> this.minValue<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>] + this.minValue<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span></span> GetMin() <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.stack) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> this.minValue<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Push(val);</span><br><span class="hljs-comment"> * obj.Pop();</span><br><span class="hljs-comment"> * param_3 := obj.Top();</span><br><span class="hljs-comment"> * param_4 := obj.GetMin();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<h2 id="129-求根节点到叶节点数字之和"><a href="#129-求根节点到叶节点数字之和" class="headerlink" title="129. 求根节点到叶节点数字之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sumNumbers</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">return</span> dfs(root, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root *TreeNode, prevSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    sum := prevSum * <span class="hljs-number">10</span> + root.Val<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> sum<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(root.Left, sum) + dfs(root.Right, sum)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> check(root.Left, root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(p, q *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &amp;&amp; q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> || q == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> p.Val == q.Val &amp;&amp; check(p.Left, q.Right) &amp;&amp; check(p.Right, q.Left)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(maxDepth(root.Left), maxDepth(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// lowerBound 返回最小的满足 nums[i] &gt;= target 的下标 i</span><br><span class="hljs-comment">// 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)</span><br><span class="hljs-comment">// 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowerBound</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span> <span class="hljs-comment">// 闭区间 [left, right]</span><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123; <span class="hljs-comment">// 区间不为空</span><br>        <span class="hljs-comment">// 循环不变量：</span><br>        <span class="hljs-comment">// nums[left-1] &lt; target</span><br>        <span class="hljs-comment">// nums[right+1] &gt;= target</span><br>        mid := left + (right-left)/<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &gt;= target &#123;<br>            right = mid - <span class="hljs-number">1</span> <span class="hljs-comment">// 范围缩小到 [left, mid-1]</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = mid + <span class="hljs-number">1</span> <span class="hljs-comment">// 范围缩小到 [mid+1, right]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 循环结束后 left = right+1</span><br>    <span class="hljs-comment">// 此时 nums[left-1] &lt; target 而 nums[left] = nums[right+1] &gt;= target</span><br>    <span class="hljs-comment">// 所以 left 就是第一个 &gt;= target 的元素下标</span><br>    <span class="hljs-keyword">return</span> left<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    start := lowerBound(nums, target)<br>    <span class="hljs-keyword">if</span> start == <span class="hljs-built_in">len</span>(nums) || nums[start] != target &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125; <span class="hljs-comment">// nums 中没有 target</span><br>    &#125;<br>    <span class="hljs-comment">// 如果 start 存在，那么 end 必定存在</span><br>    end := lowerBound(nums, target+<span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> []<span class="hljs-type">int</span>&#123;start, end&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []<span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    res := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> preorder <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span><br>    preorder = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, root.Val)<br>        preorder(root.Left)<br>        preorder(root.Right)<br>    &#125;<br>    preorder(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combinationSum</span><span class="hljs-params">(candidates []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    comb := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(target, idx <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-comment">// 当前索引超过了数组总长度</span><br>        <span class="hljs-keyword">if</span> idx == <span class="hljs-built_in">len</span>(candidates) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// target减到了0，说明找到了一个答案</span><br>        <span class="hljs-keyword">if</span> target == <span class="hljs-number">0</span> &#123;<br>            res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, comb...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-comment">// 考虑选择当前元素</span><br>        <span class="hljs-keyword">if</span> target - candidates[idx] &gt;= <span class="hljs-number">0</span> &#123;<br>            comb = <span class="hljs-built_in">append</span>(comb, candidates[idx])<br>            dfs(target-candidates[idx], idx)<br>            comb = comb[:<span class="hljs-built_in">len</span>(comb)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <span class="hljs-comment">// 不考虑当前元素</span><br>        dfs(target, idx+<span class="hljs-number">1</span>)<br>    &#125;<br>    dfs(target, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">decodeString</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    stack := []<span class="hljs-type">string</span>&#123;&#125;<br>    p := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> p &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        cur := s[p]<br>        <span class="hljs-comment">// 如果遍历到数字，就取出所有的后续数字，得到整数字符串后，将其压入栈中</span><br>        <span class="hljs-keyword">if</span> cur &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>            digits := getDigits(s, &amp;p)<br>            stack = <span class="hljs-built_in">append</span>(stack, digits)<br>        <span class="hljs-comment">// 如果遇到字符或左括号，直接压栈</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || cur &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; cur &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) || cur == <span class="hljs-string">&#x27;[&#x27;</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, <span class="hljs-type">string</span>(cur))<br>            p++<br>        <span class="hljs-comment">// 如果遇到右括号</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 持续出栈字符，直到遇到左括号，此时sub中保存了所有的出栈字符</span><br>            sub := []<span class="hljs-type">string</span>&#123;&#125;<br>            <span class="hljs-keyword">for</span> stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] != <span class="hljs-string">&quot;[&quot;</span> &#123;<br>                sub = <span class="hljs-built_in">append</span>(sub, stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>                stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            &#125;<br>            <span class="hljs-comment">// 将sub中的字符反转，得到正常的字符顺序</span><br>            <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(sub)/<span class="hljs-number">2</span>; i++ &#123;<br>                sub[i], sub[<span class="hljs-built_in">len</span>(sub)<span class="hljs-number">-1</span>-i] = sub[<span class="hljs-built_in">len</span>(sub)<span class="hljs-number">-1</span>-i], sub[i]<br>            &#125;<br><br>            <span class="hljs-comment">// 将左括号出栈</span><br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br><br>            <span class="hljs-comment">// 此时栈顶保存的是整数，将此整数出栈，并进行重复处理</span><br>            repTime, _ := strconv.Atoi(stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>])<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            t := strings.Repeat(getString(sub), repTime)<br>            <span class="hljs-comment">// 重点，将重复后的字符串重新压入栈中</span><br>            stack = <span class="hljs-built_in">append</span>(stack, t)<br><br>            <span class="hljs-comment">// 继续判断下一个字符</span><br>            p++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> getString(stack)<br>&#125;<br><br><span class="hljs-comment">// 取出所有的后续数字，组成一个整数字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getDigits</span><span class="hljs-params">(s <span class="hljs-type">string</span>, p *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> ; s[*p] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[*p] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; *p++ &#123;<br>        res += <span class="hljs-type">string</span>(s[*p])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getString</span><span class="hljs-params">(v []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    res := <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> v &#123;<br>        res += s<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> abs(height(root.Left) - height(root.Right)) &lt;= <span class="hljs-number">1</span> &amp;&amp; isBalanced(root.Left) &amp;&amp; isBalanced(root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">height</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> max(height(root.Left), height(root.Right)) + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> * x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    rows := <span class="hljs-built_in">len</span>(grid)<br>    cols := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    <br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, rows)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dp); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, cols)<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; rows; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; cols; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][j]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; rows; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; cols; j++ &#123;<br>            dp[i][j] = min(dp[i][j<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][j]) + grid[i][j]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[rows<span class="hljs-number">-1</span>][cols<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>



<h2 id="470-用-Rand7-实现-Rand10"><a href="#470-用-Rand7-实现-Rand10" class="headerlink" title="470. 用 Rand7() 实现 Rand10()"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-rand10-using-rand7/">470. 用 Rand7() 实现 Rand10()</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        row := rand7()<br>        col := rand7()<br>        idx := (row<span class="hljs-number">-1</span>)*<span class="hljs-number">7</span> + col<br>        <span class="hljs-keyword">if</span> idx &lt;= <span class="hljs-number">40</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + (idx<span class="hljs-number">-1</span>)%<span class="hljs-number">10</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    m := <span class="hljs-built_in">len</span>(matrix)<br>    n := <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    x := <span class="hljs-number">0</span><br>    y := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> matrix[x][y] == target &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">// 如果当前元素大，就往小了走，往小了走就是往左移动</span><br>        <span class="hljs-keyword">if</span> matrix[x][y] &gt; target &#123;<br>            y--<br>        <span class="hljs-comment">// 如果当前元素小，就往大了走，往大了走就是往下走</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            x++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(root *TreeNode, lower, upper <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">var</span> depth <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span><br>    depth = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        &#125;<br>        l := depth(root.Left)<br>        r := depth(root.Right)<br><br>        res = max(res, l + r + <span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">return</span> max(l, r) + <span class="hljs-number">1</span><br>    &#125;<br><br>    depth(root)<br><br>    <span class="hljs-keyword">return</span> res - <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(matrix [][]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    maxSide := <span class="hljs-number">0</span><br><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(matrix[i]))<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            dp[i][j] = <span class="hljs-type">int</span>(matrix[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>)<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                maxSide = <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(matrix); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[i]); j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[i][j] == <span class="hljs-number">1</span> &#123;<br>                dp[i][j] = min(min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]), dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> dp[i][j] &gt; maxSide &#123;<br>                    maxSide = dp[i][j]<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSide * maxSide<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    numSet := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        numSet[num] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    maxLength := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> num := <span class="hljs-keyword">range</span> numSet &#123;<br>        <span class="hljs-keyword">if</span> !numSet[num<span class="hljs-number">-1</span>] &#123;<br>            curNum := num<br>            curLength := <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> numSet[curNum+<span class="hljs-number">1</span>] &#123;<br>                curNum++<br>                curLength++<br>            &#125;<br>            <span class="hljs-keyword">if</span> curLength &gt; maxLength &#123;<br>                maxLength = curLength<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLength<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 贪心法，只能用于计算最大利润</span><br><span class="hljs-comment">// 思想：所有的利润都要有，所有的亏损都不要。即：只要后一天比前一天价格高，这部分差价就是利润</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(prices); i++ &#123;<br>        res += max(<span class="hljs-number">0</span>, prices[i]-prices[i<span class="hljs-number">-1</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// // 递归，本质是利用栈</span><br><span class="hljs-comment">// func isPalindrome(head *ListNode) bool &#123;</span><br><span class="hljs-comment">//     // 递归函数外指针，指向链表头部</span><br><span class="hljs-comment">//     p := head</span><br><br><span class="hljs-comment">//     var check func(*ListNode) bool</span><br><span class="hljs-comment">//     check = func(node *ListNode) bool &#123;</span><br><span class="hljs-comment">//         if node != nil &#123;</span><br><span class="hljs-comment">//             // 一开始就进入递归，实际效果上会把当前节点压入函数栈中，并且会一直压到最后一个节点</span><br><span class="hljs-comment">//             // 当开始出栈时，实际就是从最后一个节点往前遍历了</span><br><span class="hljs-comment">//             if !check(node.Next) &#123;</span><br><span class="hljs-comment">//                 return false</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//             // 判断递归外指针与当前节点的值</span><br><span class="hljs-comment">//             if node.Val != p.Val &#123;</span><br><span class="hljs-comment">//                 return false</span><br><span class="hljs-comment">//             &#125;</span><br><span class="hljs-comment">//             // 外指针向后移动一位</span><br><span class="hljs-comment">//             p = p.Next</span><br><span class="hljs-comment">//         &#125;</span><br><span class="hljs-comment">//         return true</span><br><span class="hljs-comment">//     &#125;</span><br><br><span class="hljs-comment">//     return check(head)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 快慢指针找中点 + 反转链表 + 遍历对比</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">var</span> prev, cur *ListNode = <span class="hljs-literal">nil</span>, head<br>    <span class="hljs-keyword">for</span> cur != <span class="hljs-literal">nil</span> &#123;<br>        nextTmp := cur.Next<br>        cur.Next = prev<br>        prev = cur<br>        cur = nextTmp<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">endOfFirstHalf</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    fast := head<br>    slow := head<br>    <span class="hljs-keyword">for</span> fast.Next != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 找到前半部分链表的尾节点并反转后半部分链表</span><br>    firstHalfEnd := endOfFirstHalf(head)<br>    secondHalfStart := reverseList(firstHalfEnd.Next)<br><br>    <span class="hljs-comment">// 判断是否回文</span><br>    p1 := head<br>    p2 := secondHalfStart<br>    result := <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> result &amp;&amp; p2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> p1.Val != p2.Val &#123;<br>            result = <span class="hljs-literal">false</span><br>        &#125;<br>        p1 = p1.Next<br>        p2 = p2.Next<br>    &#125;<br><br>    <span class="hljs-comment">// 还原链表并返回结果</span><br>    firstHalfEnd.Next = reverseList(secondHalfStart)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 利用性质 + 每次二分丢弃一半选项</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findPeakElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-comment">// 辅助函数，输入下标 i，返回 nums[i] 的值</span><br>    <span class="hljs-comment">// 方便处理 nums[-1] 以及 nums[n] 的边界情况</span><br>    get := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> || i == n &#123;<br>            <span class="hljs-keyword">return</span> math.MinInt64<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[i]<br>    &#125;<br><br>    left := <span class="hljs-number">0</span><br>    right := n - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        mid := (left + right) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> get(mid<span class="hljs-number">-1</span>) &lt; get(mid) &amp;&amp; get(mid) &gt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125;<br>        <span class="hljs-keyword">if</span> get(mid) &lt; get(mid+<span class="hljs-number">1</span>) &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(grid); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]); j++ &#123;<br>            res = max(dfs(grid, i, j), res)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dfs</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>, i, j <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i == <span class="hljs-built_in">len</span>(grid) || j == <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) || grid[i][j] != <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    grid[i][j] = <span class="hljs-number">0</span><br>    area := <span class="hljs-number">1</span><br>    di := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;<br>    dj := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>    <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">len</span>(di); k++ &#123;<br>        area += dfs(grid, i+di[k], j+dj[k])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> area<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">int</span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    nodes := []<span class="hljs-type">int</span>&#123;&#125;<br>    res := [][]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        nodes = <span class="hljs-built_in">append</span>(nodes, node.Val)<br>        sum += node.Val<br>        <span class="hljs-keyword">if</span> sum == targetSum &#123;<br>            <span class="hljs-keyword">if</span> node.Left == <span class="hljs-literal">nil</span> &amp;&amp; node.Right == <span class="hljs-literal">nil</span> &#123;<br>                res = <span class="hljs-built_in">append</span>(res, <span class="hljs-built_in">append</span>([]<span class="hljs-type">int</span>&#123;&#125;, nodes...))<br>            &#125;<br>        &#125;<br>        dfs(node.Left)<br>        dfs(node.Right)<br>        sum -= node.Val<br>        nodes = nodes[:<span class="hljs-built_in">len</span>(nodes)<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    dfs(root)<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(m <span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 广度优先搜索 + 二叉树节点编号性质</span><br><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span> &#123;<br>    node *TreeNode<br>    index <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    q := []pair&#123;&#123;root, <span class="hljs-number">1</span>&#125;&#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        res = max(res, q[<span class="hljs-built_in">len</span>(q)<span class="hljs-number">-1</span>].index - q[<span class="hljs-number">0</span>].index + <span class="hljs-number">1</span>)<br>        tmp := []pair&#123;&#125;<br>        <span class="hljs-keyword">for</span> _, p := <span class="hljs-keyword">range</span> q &#123;<br>            <span class="hljs-keyword">if</span> p.node.Left != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, pair&#123;p.node.Left, p.index * <span class="hljs-number">2</span>&#125;)<br>            &#125;<br>            <span class="hljs-keyword">if</span> p.node.Right != <span class="hljs-literal">nil</span> &#123;<br>                tmp = <span class="hljs-built_in">append</span>(tmp, pair&#123;p.node.Right, p.index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125;)<br>            &#125;<br>        &#125;<br>        q = tmp<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := nums[<span class="hljs-number">0</span>]<br>    mx := nums[<span class="hljs-number">0</span>]<br>    mn := nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// 这里mx，mn的计算互不干扰，均使用上一次的结果计算</span><br>        mx, mn = max(nums[i], max(mx * nums[i], mn * nums[i])), min(nums[i], min(mx * nums[i], mn * nums[i]))<br>        res = max(res, mx)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &amp;&amp; root.Right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> targetSum == root.Val<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum(root.Left, targetSum - root.Val) || hasPathSum(root.Right, targetSum - root.Val)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rob</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 如果只有一间房，则偷取该间房</span><br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 如果有两间房，则偷取金额大的那一间</span><br>    dp[<span class="hljs-number">1</span>] = max(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果偷取第i间房，则到达i位置时的总金额为，前i-2间房偷到的数额加上第i间房</span><br>        <span class="hljs-comment">// 如果不偷第i间房，则到达i位置时的总金额为，前i-1间房偷到的总数额</span><br>        dp[i] = max(dp[i<span class="hljs-number">-2</span>] + nums[i], dp[i<span class="hljs-number">-1</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 记录最终结果</span><br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 记录从开头到当前位置的和</span><br>    pre := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// key：前缀和，value：个数</span><br>    m := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        pre += nums[i]<br>        <span class="hljs-keyword">if</span> _, ok := m[pre-k]; ok &#123;<br>            count += m[pre-k]<br>        &#125;<br>        m[pre] += <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 摩尔投票法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    count := <span class="hljs-number">0</span><br>    candidate := nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> &#123;<br>            candidate = num<br>        &#125;<br>        <span class="hljs-keyword">if</span> num == candidate &#123;<br>            count += <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count -= <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> candidate<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    res := <span class="hljs-number">0</span><br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    preSign := <span class="hljs-string">&#x27;+&#x27;</span><br>    num := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i, ch := <span class="hljs-keyword">range</span> s &#123;<br>        isDigit := <span class="hljs-string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span><br>        <span class="hljs-keyword">if</span> isDigit &#123;<br>            num = num*<span class="hljs-number">10</span> + <span class="hljs-type">int</span>(ch-<span class="hljs-string">&#x27;0&#x27;</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span> !isDigit &amp;&amp; ch != <span class="hljs-string">&#x27; &#x27;</span> || i == <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">switch</span> preSign &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    stack = <span class="hljs-built_in">append</span>(stack, num)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    stack = <span class="hljs-built_in">append</span>(stack, -num)<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] *= num<br>                <span class="hljs-keyword">default</span>:<br>                    stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] /= num<br>            &#125;<br>            preSign = ch<br>            num = <span class="hljs-number">0</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> stack &#123;<br>        res += v<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span></span> *ListNode &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    cur := head<br>    <span class="hljs-keyword">for</span> cur.Next != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> cur.Val == cur.Next.Val &#123;<br>            cur.Next = cur.Next.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = cur.Next<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">718. 最长重复子数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLength</span><span class="hljs-params">(nums1 []<span class="hljs-type">int</span>, nums2 []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums1)<br>    m := <span class="hljs-built_in">len</span>(nums2)<br><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-comment">// dp[i][j]含义：nums1[:i+1]和nums2[:j+1]的最长公共后缀</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>        <span class="hljs-keyword">if</span> nums1[i] == nums2[<span class="hljs-number">0</span>] &#123;<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; m; j++ &#123;<br>        <span class="hljs-keyword">if</span> nums1[<span class="hljs-number">0</span>] == nums2[j] &#123;<br>            dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span><br>            res = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; m; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums1[i] == nums2[j] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span><br>                res = max(res, dp[i][j])<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span>  &#123;<br>    k = k % <span class="hljs-built_in">len</span>(nums)<br>    reverse(nums)<br>    reverse(nums[:k])<br>    reverse(nums[k:])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(a []<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i, n := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(a); i &lt; n / <span class="hljs-number">2</span>; i ++ &#123;<br>        a[i], a[n<span class="hljs-number">-1</span>-i] = a[n<span class="hljs-number">-1</span>-i], a[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(matrix [][]<span class="hljs-type">int</span>)</span></span>  &#123;<br>    row := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(matrix))<br>    col := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))<br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> matrix &#123;<br>        <span class="hljs-keyword">for</span> j, v := <span class="hljs-keyword">range</span> r &#123;<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span> &#123;<br>                row[i] = <span class="hljs-literal">true</span><br>                col[j] = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> matrix &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> r &#123;<br>            <span class="hljs-keyword">if</span> row[i] || col[j] &#123;<br>                r[j] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a Node.</span><br><span class="hljs-comment"> * type Node struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *Node</span><br><span class="hljs-comment"> *     Random *Node</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> cachedNode <span class="hljs-keyword">map</span>[*Node]*Node<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deepCopy</span><span class="hljs-params">(node *Node)</span></span> *Node &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n, has := cachedNode[node]; has &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    newNode := &amp;Node&#123;Val: node.Val&#125;<br>    cachedNode[node] = newNode<br>    newNode.Next = deepCopy(node.Next)<br>    newNode.Random = deepCopy(node.Random)<br>    <span class="hljs-keyword">return</span> newNode<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span></span> *Node &#123;<br>    cachedNode = <span class="hljs-keyword">map</span>[*Node]*Node&#123;&#125;<br>    <span class="hljs-keyword">return</span> deepCopy(head)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> *TreeNode &#123;<br>    <span class="hljs-keyword">return</span> helper(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, left, right <span class="hljs-type">int</span>)</span></span> * TreeNode &#123;<br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := (left + right) / <span class="hljs-number">2</span><br>    root := &amp;TreeNode&#123;Val: nums[mid]&#125;<br>    root.Left = helper(nums, left, mid<span class="hljs-number">-1</span>)<br>    root.Right = helper(nums, mid+<span class="hljs-number">1</span>, right)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span>  &#123;<br>    list := preorderTraversal(root)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(list); i++ &#123;<br>        prev, curr := list[i<span class="hljs-number">-1</span>], list[i]<br>        prev.Left, prev.Right = <span class="hljs-literal">nil</span>, curr<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(root *TreeNode)</span></span> []*TreeNode &#123;<br>    list := []*TreeNode&#123;&#125;<br>    <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>        list = <span class="hljs-built_in">append</span>(list, root)<br>        list = <span class="hljs-built_in">append</span>(list, preorderTraversal(root.Left)...)<br>        list = <span class="hljs-built_in">append</span>(list, preorderTraversal(root.Right)...)<br>    &#125;<br>    <span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(root *TreeNode, targetSum <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    ans := <span class="hljs-number">0</span><br>    preSum := <span class="hljs-keyword">map</span>[<span class="hljs-type">int64</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>&#125;<br>    <br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*TreeNode, <span class="hljs-type">int64</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode, curr <span class="hljs-type">int64</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        curr += <span class="hljs-type">int64</span>(node.Val)<br>        ans += preSum[curr-<span class="hljs-type">int64</span>(targetSum)]<br>        preSum[curr]++<br>        dfs(node.Left, curr)<br>        dfs(node.Right, curr)<br>        preSum[curr]--<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    dfs(root, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(grid [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-comment">// 总行数</span><br>    R := <span class="hljs-built_in">len</span>(grid)<br>    <span class="hljs-comment">// 总列数</span><br>    C := <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 上下左右四个方向</span><br>    dr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;<br>    dc := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br><br>    <span class="hljs-comment">// 用于辅助层次遍历</span><br>    queue := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 用于记录到达每个点位对应的深度</span><br>    depth := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br><br>    <span class="hljs-comment">// 记录首层点位，深度均为0</span><br>    <span class="hljs-keyword">for</span> r := <span class="hljs-number">0</span>; r &lt; R; r++ &#123;<br>        <span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; C; c++ &#123;<br>            <span class="hljs-keyword">if</span> grid[r][c] == <span class="hljs-number">2</span> &#123;<br>                code := r * C + c<br>                queue = <span class="hljs-built_in">append</span>(queue, code)<br>                depth[code] = <span class="hljs-number">0</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 进行层序遍历</span><br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        code := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        r := code / C<br>        c := code % C<br>        <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++ &#123;<br>            nr := r + dr[k]<br>            nc := c + dc[k]<br>            <span class="hljs-keyword">if</span> nr &gt;= <span class="hljs-number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &gt;= <span class="hljs-number">0</span> &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="hljs-number">1</span> &#123;<br>                grid[nr][nc] = <span class="hljs-number">2</span><br>                ncode := nr * C + nc<br>                queue = <span class="hljs-built_in">append</span>(queue, ncode)<br>                depth[ncode] = depth[code] + <span class="hljs-number">1</span><br>                <span class="hljs-comment">// 每次进入该if条件，则意味着到达了一个新鲜橘子，深度加1</span><br>                ans = depth[ncode]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否还有新鲜橘子</span><br>    <span class="hljs-keyword">for</span> _, row := <span class="hljs-keyword">range</span> grid &#123;<br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> v == <span class="hljs-number">1</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-type">int</span>, prerequisites [][]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// 记录所有节点的边，edges[i]含义为第i个节点所指向的所有节点</span><br>    edges := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-comment">// 记录每个节点的入度，即有多少个节点指向它</span><br>    indeg := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, numCourses)<br>    <span class="hljs-comment">// 记录拓扑排序，如果所有节点存在拓扑排序，则课程能正常修完</span><br>    result := []<span class="hljs-type">int</span>&#123;&#125;<br><br>    <span class="hljs-comment">// 保存所有节点的边和入度</span><br>    <span class="hljs-keyword">for</span> _, info := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        edges[info[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(edges[info[<span class="hljs-number">1</span>]], info[<span class="hljs-number">0</span>])<br>        indeg[info[<span class="hljs-number">0</span>]]++<br>    &#125;<br><br>    <span class="hljs-comment">// 先将入度为0的节点入队</span><br>    q := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>        <span class="hljs-keyword">if</span> indeg[i] == <span class="hljs-number">0</span> &#123;<br>            q = <span class="hljs-built_in">append</span>(q, i)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 广度优先搜索</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span> &#123;<br>        u := q[<span class="hljs-number">0</span>]<br>        q = q[<span class="hljs-number">1</span>:]<br>        result = <span class="hljs-built_in">append</span>(result, u)<br>        <span class="hljs-comment">// 将u入队后，检查u指向的所有节点，将其入度减1</span><br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> edges[u] &#123;<br>            indeg[v]--<br>            <span class="hljs-keyword">if</span> indeg[v] == <span class="hljs-number">0</span> &#123;<br>                q = <span class="hljs-built_in">append</span>(q, v)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(result) == numCourses<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>    children [<span class="hljs-number">26</span>]*Trie<br>    isEnd <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> Trie &#123;<br>    <span class="hljs-keyword">return</span> Trie&#123;&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Insert(word <span class="hljs-type">string</span>)  &#123;<br>    node := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> word &#123;<br>        ch -= <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[ch] == <span class="hljs-literal">nil</span> &#123;<br>            node.children[ch] = &amp;Trie&#123;&#125;<br>        &#125;<br>        node = node.children[ch]<br>    &#125;<br>    node.isEnd = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> SearchPrefix(prefix <span class="hljs-type">string</span>) *Trie &#123;<br>    node := this<br>    <span class="hljs-keyword">for</span> _, ch := <span class="hljs-keyword">range</span> prefix &#123;<br>        ch -= <span class="hljs-string">&#x27;a&#x27;</span><br>        <span class="hljs-keyword">if</span> node.children[ch] == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        node = node.children[ch]<br>    &#125;<br>    <span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> Search(word <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    node := this.SearchPrefix(word)<br>    <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nil</span> &amp;&amp; node.isEnd<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span></span> StartsWith(prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> this.SearchPrefix(prefix) != <span class="hljs-literal">nil</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.Insert(word);</span><br><span class="hljs-comment"> * param_2 := obj.Search(word);</span><br><span class="hljs-comment"> * param_3 := obj.StartsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> pair <span class="hljs-keyword">struct</span>&#123;<br>    x <span class="hljs-type">int</span><br>    y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> directions = []pair&#123;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-type">byte</span>, word <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    R := <span class="hljs-built_in">len</span>(board)<br>    C := <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    visit := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, R)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> visit &#123;<br>        visit[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, C)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> check <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span><br>    check = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j, k <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">if</span> board[i][j] != word[k] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(word) - <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        visit[i][j] = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            visit[i][j] = <span class="hljs-literal">false</span><br>        &#125;()<br><br>        <span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> directions &#123;<br>            newI := i + dir.x<br>            newJ := j + dir.y<br>            <span class="hljs-keyword">if</span> newI &gt;= <span class="hljs-number">0</span> &amp;&amp; newI &lt; R &amp;&amp; newJ &gt;= <span class="hljs-number">0</span> &amp;&amp; newJ &lt; C &amp;&amp; !visit[newI][newJ] &#123;<br>                <span class="hljs-keyword">if</span> check(newI, newJ, k+<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i, row := <span class="hljs-keyword">range</span> board &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> row &#123;<br>            <span class="hljs-keyword">if</span> check(i, j, <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">partition</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    f := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">bool</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f &#123;<br>        f[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> f[i] &#123;<br>            f[i][j] = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            f[i][j] = s[i] == s[j] &amp;&amp; f[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br><br>    ans := [][]<span class="hljs-type">string</span>&#123;&#125;<br><br>    splits := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">var</span> dfs <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br>    dfs = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> i == n &#123;<br>            ans = <span class="hljs-built_in">append</span>(ans, <span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>(<span class="hljs-literal">nil</span>), splits...))<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> j := i; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> f[i][j] &#123;<br>                splits = <span class="hljs-built_in">append</span>(splits, s[i:j+<span class="hljs-number">1</span>])<br>                dfs(j+<span class="hljs-number">1</span>)<br>                <span class="hljs-comment">// 放弃当前拆分方案，回退到原状</span><br>                splits = splits[:<span class="hljs-built_in">len</span>(splits)<span class="hljs-number">-1</span>]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    dfs(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> solutions [][]<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> [][]<span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 保存最终结果</span><br>    solutions = [][]<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录每一行的皇后放置在哪一列</span><br>    queens := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        queens[i] = <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-comment">// 记录哪些列已经放置了皇后</span><br>    columns := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-comment">// 记录哪些对角已经放置了皇后</span><br>    diagonals1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    diagonals2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br><br>    backtrack(queens, n, <span class="hljs-number">0</span>, columns, diagonals1, diagonals2)<br><br>    <span class="hljs-keyword">return</span> solutions<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, n, row <span class="hljs-type">int</span>, columns, diagonals1, diagonals2 <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 如果row == n 说明已经产生了一个正确答案</span><br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        board := generateBoard(queens, n)<br>        solutions = <span class="hljs-built_in">append</span>(solutions, board)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 针对当前第row行，枚举每个列的位置，判断时候能放置皇后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// 如果该列已经放置了皇后，继续下一列</span><br>        <span class="hljs-keyword">if</span> columns[i] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 如果对角已经放置了皇后，继续下一列</span><br>        diag1 := row - i<br>        <span class="hljs-keyword">if</span> diagonals1[diag1] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        diag2 := row + i<br>        <span class="hljs-keyword">if</span> diagonals2[diag2] &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-comment">// 记录第row行的皇后放置位置</span><br>        queens[row] = i<br>        <span class="hljs-comment">// 标记第i列已经放置皇后</span><br>        columns[i] = <span class="hljs-literal">true</span><br>        <span class="hljs-comment">// 标记对应的对角已经放置了皇后</span><br>        diagonals1[diag1] = <span class="hljs-literal">true</span><br>        diagonals2[diag2] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-comment">// 在第row行放置了一个位置之后，继续进行下一行判断</span><br>        backtrack(queens, n, row+<span class="hljs-number">1</span>, columns, diagonals1, diagonals2)<br><br>        <span class="hljs-comment">// 恢复原本状态，继续寻找第row行的下一个解</span><br>        queens[row] = <span class="hljs-number">-1</span><br>        <span class="hljs-built_in">delete</span>(columns, i)<br>        <span class="hljs-built_in">delete</span>(diagonals1, diag1)<br>        <span class="hljs-built_in">delete</span>(diagonals2, diag2)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateBoard</span><span class="hljs-params">(queens []<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>    board := []<span class="hljs-type">string</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        row := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>            row[j] = <span class="hljs-string">&#x27;.&#x27;</span><br>        &#125;<br>        row[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span><br>        board = <span class="hljs-built_in">append</span>(board, <span class="hljs-type">string</span>(row))<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> board<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 核心思想：如果右半边升序，则最小值一定在左半边</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    low := <span class="hljs-number">0</span><br>    high := <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> low &lt; high &#123;<br>        mid := (low + high) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; nums[high] &#123;<br>            high = mid<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums[low]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(temperatures []<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(temperatures)<br>    ans := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    stack := []<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        t := temperatures[i]<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &amp;&amp; t &gt; temperatures[stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]] &#123;<br>            idx := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>            ans[idx] = i - idx<br>        &#125;<br>        stack = <span class="hljs-built_in">append</span>(stack, i)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topKFrequent</span><span class="hljs-params">(nums []<span class="hljs-type">int</span>, k <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>    occur := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>        occur[num]++<br>    &#125;<br><br>    h := &amp;IHeap&#123;&#125;<br>    heap.Init(h)<br><br>    <span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> occur &#123;<br>        heap.Push(h, [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;key, value&#125;)<br>        <span class="hljs-keyword">if</span> h.Len() &gt; k &#123;<br>            heap.Pop(h)<br>        &#125;<br>    &#125;<br>    ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, k)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        ret[k-i<span class="hljs-number">-1</span>] = heap.Pop(h).([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>)[<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-keyword">type</span> IHeap [][<span class="hljs-number">2</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Len() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> h[i][<span class="hljs-number">1</span>] &lt; h[j][<span class="hljs-number">1</span>]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h IHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;h[i], h[j] = h[j], h[i]&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Push(x <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.([<span class="hljs-number">2</span>]<span class="hljs-type">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *IHeap)</span></span> Pop() <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>: n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MedianFinder <span class="hljs-keyword">struct</span> &#123;<br>    maxHeap *MaxHeap <span class="hljs-comment">// 存储较小的一半数字</span><br>    minHeap *MinHeap <span class="hljs-comment">// 存储较大的一半数字</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span></span> MedianFinder &#123;<br>    mf := MedianFinder&#123;<br>        maxHeap: &amp;MaxHeap&#123;&#125;,<br>        minHeap: &amp;MinHeap&#123;&#125;,<br>    &#125;<br>    heap.Init(mf.maxHeap)<br>    heap.Init(mf.minHeap)<br>    <span class="hljs-keyword">return</span> mf<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> AddNum(num <span class="hljs-type">int</span>)  &#123;<br>    <span class="hljs-comment">// 总是先加入最大堆</span><br>    heap.Push(this.maxHeap, num)<br><br>    <span class="hljs-comment">// 将最大堆的最大值移到最小堆</span><br>    heap.Push(this.minHeap, heap.Pop(this.maxHeap))<br><br>    <span class="hljs-comment">// 如果最大堆的大小小于最小堆，平衡两个堆</span><br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() &lt; this.minHeap.Len() &#123;<br>        heap.Push(this.maxHeap, heap.Pop(this.minHeap))<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span></span> FindMedian() <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">// 或者根据需求返回其他默认值</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> this.maxHeap.Len() &gt; this.minHeap.Len() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>((*this.maxHeap)[<span class="hljs-number">0</span>])<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">float64</span>((*this.maxHeap)[<span class="hljs-number">0</span>]) + <span class="hljs-type">float64</span>((*this.minHeap)[<span class="hljs-number">0</span>])) / <span class="hljs-number">2</span><br>&#125;<br><br><span class="hljs-comment">// 最大堆（存储较小的一半数字）</span><br><span class="hljs-keyword">type</span> MaxHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &gt; h[j]&#125; <span class="hljs-comment">// 注意这里是 &gt;，实现最大堆</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MaxHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Push(x any) &#123;*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MaxHeap)</span></span> Pop() any &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// 最小堆（存储较大的一半数字）</span><br><span class="hljs-keyword">type</span> MinHeap []<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Len() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h)&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> h[i] &lt; h[j]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h MinHeap)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123; h[i], h[j] = h[j], h[i]&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MinHeap)</span></span> Push(x any) &#123;*h = <span class="hljs-built_in">append</span>(*h, x.(<span class="hljs-type">int</span>))&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *MinHeap)</span></span> Pop() any &#123;<br>    old := *h<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    *h = old[<span class="hljs-number">0</span>:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.AddNum(num);</span><br><span class="hljs-comment"> * param_2 := obj.FindMedian();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516. 最长回文子序列</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>    &#125;<br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        dp[i][i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(s <span class="hljs-type">string</span>, wordDict []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    wordMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> wordDict &#123;<br>        wordMap[word] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    n := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-type">bool</span>, n+<span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    <span class="hljs-comment">// dp[i]含义：以s[i]为结尾的字符串能否由word组成</span><br>    <span class="hljs-comment">// dp[i]如何得到：dp[i] = dp[j] &amp; s[j:i]是否在map中，0 &lt;= j &lt;= i</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> dp[j] &amp;&amp; wordMap[s[j:i]] &#123;<br>                dp[i] = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Go算法题-全</div>
      <div>http://guy-18.github.io/2025/07/25/Go算法题-全/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年7月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/25/list-watch%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%E5%90%8E%E7%9A%84%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6/" title="list-watch在网络中断后的恢复机制">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">list-watch在网络中断后的恢复机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/07/24/golang%E5%8D%8F%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98/" title="golang协程练习题">
                        <span class="hidden-mobile">golang协程练习题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
